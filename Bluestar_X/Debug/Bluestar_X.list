
Bluestar_X.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   000001ac  08040000  08040000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00018b9c  080401b0  080401b0  000101b0  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00002250  08058d50  08058d50  00028d50  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM          00000008  0805afa0  0805afa0  0002afa0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .init_array   00000008  0805afa8  0805afa8  0002afa8  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .fini_array   00000004  0805afb0  0805afb0  0002afb0  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .data         00004084  20000000  0805afb4  00030000  2**3
                  CONTENTS, ALLOC, LOAD, DATA
  7 .ccmram       00000000  10000000  10000000  00034084  2**0
                  CONTENTS
  8 .bss          0000c034  20004084  20004084  00034084  2**2
                  ALLOC
  9 ._user_heap_stack 00000600  200100b8  200100b8  00034084  2**0
                  ALLOC
 10 .ARM.attributes 00000030  00000000  00000000  00034084  2**0
                  CONTENTS, READONLY
 11 .debug_info   0007fc1b  00000000  00000000  000340b4  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 12 .debug_abbrev 0000c9d2  00000000  00000000  000b3ccf  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_loc    0001ff58  00000000  00000000  000c06a1  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_aranges 00002308  00000000  00000000  000e0600  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_ranges 00002668  00000000  00000000  000e2908  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_macro  0003a5b2  00000000  00000000  000e4f70  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_line   000530a0  00000000  00000000  0011f522  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_str    0010ef7c  00000000  00000000  001725c2  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .comment      00000053  00000000  00000000  0028153e  2**0
                  CONTENTS, READONLY
 20 .debug_frame  000079f8  00000000  00000000  00281594  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

080401b0 <__do_global_dtors_aux>:
 80401b0:	b510      	push	{r4, lr}
 80401b2:	4c05      	ldr	r4, [pc, #20]	; (80401c8 <__do_global_dtors_aux+0x18>)
 80401b4:	7823      	ldrb	r3, [r4, #0]
 80401b6:	b933      	cbnz	r3, 80401c6 <__do_global_dtors_aux+0x16>
 80401b8:	4b04      	ldr	r3, [pc, #16]	; (80401cc <__do_global_dtors_aux+0x1c>)
 80401ba:	b113      	cbz	r3, 80401c2 <__do_global_dtors_aux+0x12>
 80401bc:	4804      	ldr	r0, [pc, #16]	; (80401d0 <__do_global_dtors_aux+0x20>)
 80401be:	f3af 8000 	nop.w
 80401c2:	2301      	movs	r3, #1
 80401c4:	7023      	strb	r3, [r4, #0]
 80401c6:	bd10      	pop	{r4, pc}
 80401c8:	20004084 	.word	0x20004084
 80401cc:	00000000 	.word	0x00000000
 80401d0:	08058d34 	.word	0x08058d34

080401d4 <frame_dummy>:
 80401d4:	b508      	push	{r3, lr}
 80401d6:	4b03      	ldr	r3, [pc, #12]	; (80401e4 <frame_dummy+0x10>)
 80401d8:	b11b      	cbz	r3, 80401e2 <frame_dummy+0xe>
 80401da:	4903      	ldr	r1, [pc, #12]	; (80401e8 <frame_dummy+0x14>)
 80401dc:	4803      	ldr	r0, [pc, #12]	; (80401ec <frame_dummy+0x18>)
 80401de:	f3af 8000 	nop.w
 80401e2:	bd08      	pop	{r3, pc}
 80401e4:	00000000 	.word	0x00000000
 80401e8:	20004088 	.word	0x20004088
 80401ec:	08058d34 	.word	0x08058d34

080401f0 <strcmp>:
 80401f0:	f810 2b01 	ldrb.w	r2, [r0], #1
 80401f4:	f811 3b01 	ldrb.w	r3, [r1], #1
 80401f8:	2a01      	cmp	r2, #1
 80401fa:	bf28      	it	cs
 80401fc:	429a      	cmpcs	r2, r3
 80401fe:	d0f7      	beq.n	80401f0 <strcmp>
 8040200:	1ad0      	subs	r0, r2, r3
 8040202:	4770      	bx	lr

08040204 <strlen>:
 8040204:	4603      	mov	r3, r0
 8040206:	f813 2b01 	ldrb.w	r2, [r3], #1
 804020a:	2a00      	cmp	r2, #0
 804020c:	d1fb      	bne.n	8040206 <strlen+0x2>
 804020e:	1a18      	subs	r0, r3, r0
 8040210:	3801      	subs	r0, #1
 8040212:	4770      	bx	lr
	...

08040220 <memchr>:
 8040220:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 8040224:	2a10      	cmp	r2, #16
 8040226:	db2b      	blt.n	8040280 <memchr+0x60>
 8040228:	f010 0f07 	tst.w	r0, #7
 804022c:	d008      	beq.n	8040240 <memchr+0x20>
 804022e:	f810 3b01 	ldrb.w	r3, [r0], #1
 8040232:	3a01      	subs	r2, #1
 8040234:	428b      	cmp	r3, r1
 8040236:	d02d      	beq.n	8040294 <memchr+0x74>
 8040238:	f010 0f07 	tst.w	r0, #7
 804023c:	b342      	cbz	r2, 8040290 <memchr+0x70>
 804023e:	d1f6      	bne.n	804022e <memchr+0xe>
 8040240:	b4f0      	push	{r4, r5, r6, r7}
 8040242:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
 8040246:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
 804024a:	f022 0407 	bic.w	r4, r2, #7
 804024e:	f07f 0700 	mvns.w	r7, #0
 8040252:	2300      	movs	r3, #0
 8040254:	e8f0 5602 	ldrd	r5, r6, [r0], #8
 8040258:	3c08      	subs	r4, #8
 804025a:	ea85 0501 	eor.w	r5, r5, r1
 804025e:	ea86 0601 	eor.w	r6, r6, r1
 8040262:	fa85 f547 	uadd8	r5, r5, r7
 8040266:	faa3 f587 	sel	r5, r3, r7
 804026a:	fa86 f647 	uadd8	r6, r6, r7
 804026e:	faa5 f687 	sel	r6, r5, r7
 8040272:	b98e      	cbnz	r6, 8040298 <memchr+0x78>
 8040274:	d1ee      	bne.n	8040254 <memchr+0x34>
 8040276:	bcf0      	pop	{r4, r5, r6, r7}
 8040278:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 804027c:	f002 0207 	and.w	r2, r2, #7
 8040280:	b132      	cbz	r2, 8040290 <memchr+0x70>
 8040282:	f810 3b01 	ldrb.w	r3, [r0], #1
 8040286:	3a01      	subs	r2, #1
 8040288:	ea83 0301 	eor.w	r3, r3, r1
 804028c:	b113      	cbz	r3, 8040294 <memchr+0x74>
 804028e:	d1f8      	bne.n	8040282 <memchr+0x62>
 8040290:	2000      	movs	r0, #0
 8040292:	4770      	bx	lr
 8040294:	3801      	subs	r0, #1
 8040296:	4770      	bx	lr
 8040298:	2d00      	cmp	r5, #0
 804029a:	bf06      	itte	eq
 804029c:	4635      	moveq	r5, r6
 804029e:	3803      	subeq	r0, #3
 80402a0:	3807      	subne	r0, #7
 80402a2:	f015 0f01 	tst.w	r5, #1
 80402a6:	d107      	bne.n	80402b8 <memchr+0x98>
 80402a8:	3001      	adds	r0, #1
 80402aa:	f415 7f80 	tst.w	r5, #256	; 0x100
 80402ae:	bf02      	ittt	eq
 80402b0:	3001      	addeq	r0, #1
 80402b2:	f415 3fc0 	tsteq.w	r5, #98304	; 0x18000
 80402b6:	3001      	addeq	r0, #1
 80402b8:	bcf0      	pop	{r4, r5, r6, r7}
 80402ba:	3801      	subs	r0, #1
 80402bc:	4770      	bx	lr
 80402be:	bf00      	nop

080402c0 <__aeabi_drsub>:
 80402c0:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
 80402c4:	e002      	b.n	80402cc <__adddf3>
 80402c6:	bf00      	nop

080402c8 <__aeabi_dsub>:
 80402c8:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

080402cc <__adddf3>:
 80402cc:	b530      	push	{r4, r5, lr}
 80402ce:	ea4f 0441 	mov.w	r4, r1, lsl #1
 80402d2:	ea4f 0543 	mov.w	r5, r3, lsl #1
 80402d6:	ea94 0f05 	teq	r4, r5
 80402da:	bf08      	it	eq
 80402dc:	ea90 0f02 	teqeq	r0, r2
 80402e0:	bf1f      	itttt	ne
 80402e2:	ea54 0c00 	orrsne.w	ip, r4, r0
 80402e6:	ea55 0c02 	orrsne.w	ip, r5, r2
 80402ea:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
 80402ee:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 80402f2:	f000 80e2 	beq.w	80404ba <__adddf3+0x1ee>
 80402f6:	ea4f 5454 	mov.w	r4, r4, lsr #21
 80402fa:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
 80402fe:	bfb8      	it	lt
 8040300:	426d      	neglt	r5, r5
 8040302:	dd0c      	ble.n	804031e <__adddf3+0x52>
 8040304:	442c      	add	r4, r5
 8040306:	ea80 0202 	eor.w	r2, r0, r2
 804030a:	ea81 0303 	eor.w	r3, r1, r3
 804030e:	ea82 0000 	eor.w	r0, r2, r0
 8040312:	ea83 0101 	eor.w	r1, r3, r1
 8040316:	ea80 0202 	eor.w	r2, r0, r2
 804031a:	ea81 0303 	eor.w	r3, r1, r3
 804031e:	2d36      	cmp	r5, #54	; 0x36
 8040320:	bf88      	it	hi
 8040322:	bd30      	pophi	{r4, r5, pc}
 8040324:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 8040328:	ea4f 3101 	mov.w	r1, r1, lsl #12
 804032c:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
 8040330:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
 8040334:	d002      	beq.n	804033c <__adddf3+0x70>
 8040336:	4240      	negs	r0, r0
 8040338:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 804033c:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
 8040340:	ea4f 3303 	mov.w	r3, r3, lsl #12
 8040344:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
 8040348:	d002      	beq.n	8040350 <__adddf3+0x84>
 804034a:	4252      	negs	r2, r2
 804034c:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 8040350:	ea94 0f05 	teq	r4, r5
 8040354:	f000 80a7 	beq.w	80404a6 <__adddf3+0x1da>
 8040358:	f1a4 0401 	sub.w	r4, r4, #1
 804035c:	f1d5 0e20 	rsbs	lr, r5, #32
 8040360:	db0d      	blt.n	804037e <__adddf3+0xb2>
 8040362:	fa02 fc0e 	lsl.w	ip, r2, lr
 8040366:	fa22 f205 	lsr.w	r2, r2, r5
 804036a:	1880      	adds	r0, r0, r2
 804036c:	f141 0100 	adc.w	r1, r1, #0
 8040370:	fa03 f20e 	lsl.w	r2, r3, lr
 8040374:	1880      	adds	r0, r0, r2
 8040376:	fa43 f305 	asr.w	r3, r3, r5
 804037a:	4159      	adcs	r1, r3
 804037c:	e00e      	b.n	804039c <__adddf3+0xd0>
 804037e:	f1a5 0520 	sub.w	r5, r5, #32
 8040382:	f10e 0e20 	add.w	lr, lr, #32
 8040386:	2a01      	cmp	r2, #1
 8040388:	fa03 fc0e 	lsl.w	ip, r3, lr
 804038c:	bf28      	it	cs
 804038e:	f04c 0c02 	orrcs.w	ip, ip, #2
 8040392:	fa43 f305 	asr.w	r3, r3, r5
 8040396:	18c0      	adds	r0, r0, r3
 8040398:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
 804039c:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 80403a0:	d507      	bpl.n	80403b2 <__adddf3+0xe6>
 80403a2:	f04f 0e00 	mov.w	lr, #0
 80403a6:	f1dc 0c00 	rsbs	ip, ip, #0
 80403aa:	eb7e 0000 	sbcs.w	r0, lr, r0
 80403ae:	eb6e 0101 	sbc.w	r1, lr, r1
 80403b2:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
 80403b6:	d31b      	bcc.n	80403f0 <__adddf3+0x124>
 80403b8:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
 80403bc:	d30c      	bcc.n	80403d8 <__adddf3+0x10c>
 80403be:	0849      	lsrs	r1, r1, #1
 80403c0:	ea5f 0030 	movs.w	r0, r0, rrx
 80403c4:	ea4f 0c3c 	mov.w	ip, ip, rrx
 80403c8:	f104 0401 	add.w	r4, r4, #1
 80403cc:	ea4f 5244 	mov.w	r2, r4, lsl #21
 80403d0:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
 80403d4:	f080 809a 	bcs.w	804050c <__adddf3+0x240>
 80403d8:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 80403dc:	bf08      	it	eq
 80403de:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 80403e2:	f150 0000 	adcs.w	r0, r0, #0
 80403e6:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 80403ea:	ea41 0105 	orr.w	r1, r1, r5
 80403ee:	bd30      	pop	{r4, r5, pc}
 80403f0:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
 80403f4:	4140      	adcs	r0, r0
 80403f6:	eb41 0101 	adc.w	r1, r1, r1
 80403fa:	3c01      	subs	r4, #1
 80403fc:	bf28      	it	cs
 80403fe:	f5b1 1f80 	cmpcs.w	r1, #1048576	; 0x100000
 8040402:	d2e9      	bcs.n	80403d8 <__adddf3+0x10c>
 8040404:	f091 0f00 	teq	r1, #0
 8040408:	bf04      	itt	eq
 804040a:	4601      	moveq	r1, r0
 804040c:	2000      	moveq	r0, #0
 804040e:	fab1 f381 	clz	r3, r1
 8040412:	bf08      	it	eq
 8040414:	3320      	addeq	r3, #32
 8040416:	f1a3 030b 	sub.w	r3, r3, #11
 804041a:	f1b3 0220 	subs.w	r2, r3, #32
 804041e:	da0c      	bge.n	804043a <__adddf3+0x16e>
 8040420:	320c      	adds	r2, #12
 8040422:	dd08      	ble.n	8040436 <__adddf3+0x16a>
 8040424:	f102 0c14 	add.w	ip, r2, #20
 8040428:	f1c2 020c 	rsb	r2, r2, #12
 804042c:	fa01 f00c 	lsl.w	r0, r1, ip
 8040430:	fa21 f102 	lsr.w	r1, r1, r2
 8040434:	e00c      	b.n	8040450 <__adddf3+0x184>
 8040436:	f102 0214 	add.w	r2, r2, #20
 804043a:	bfd8      	it	le
 804043c:	f1c2 0c20 	rsble	ip, r2, #32
 8040440:	fa01 f102 	lsl.w	r1, r1, r2
 8040444:	fa20 fc0c 	lsr.w	ip, r0, ip
 8040448:	bfdc      	itt	le
 804044a:	ea41 010c 	orrle.w	r1, r1, ip
 804044e:	4090      	lslle	r0, r2
 8040450:	1ae4      	subs	r4, r4, r3
 8040452:	bfa2      	ittt	ge
 8040454:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
 8040458:	4329      	orrge	r1, r5
 804045a:	bd30      	popge	{r4, r5, pc}
 804045c:	ea6f 0404 	mvn.w	r4, r4
 8040460:	3c1f      	subs	r4, #31
 8040462:	da1c      	bge.n	804049e <__adddf3+0x1d2>
 8040464:	340c      	adds	r4, #12
 8040466:	dc0e      	bgt.n	8040486 <__adddf3+0x1ba>
 8040468:	f104 0414 	add.w	r4, r4, #20
 804046c:	f1c4 0220 	rsb	r2, r4, #32
 8040470:	fa20 f004 	lsr.w	r0, r0, r4
 8040474:	fa01 f302 	lsl.w	r3, r1, r2
 8040478:	ea40 0003 	orr.w	r0, r0, r3
 804047c:	fa21 f304 	lsr.w	r3, r1, r4
 8040480:	ea45 0103 	orr.w	r1, r5, r3
 8040484:	bd30      	pop	{r4, r5, pc}
 8040486:	f1c4 040c 	rsb	r4, r4, #12
 804048a:	f1c4 0220 	rsb	r2, r4, #32
 804048e:	fa20 f002 	lsr.w	r0, r0, r2
 8040492:	fa01 f304 	lsl.w	r3, r1, r4
 8040496:	ea40 0003 	orr.w	r0, r0, r3
 804049a:	4629      	mov	r1, r5
 804049c:	bd30      	pop	{r4, r5, pc}
 804049e:	fa21 f004 	lsr.w	r0, r1, r4
 80404a2:	4629      	mov	r1, r5
 80404a4:	bd30      	pop	{r4, r5, pc}
 80404a6:	f094 0f00 	teq	r4, #0
 80404aa:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
 80404ae:	bf06      	itte	eq
 80404b0:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
 80404b4:	3401      	addeq	r4, #1
 80404b6:	3d01      	subne	r5, #1
 80404b8:	e74e      	b.n	8040358 <__adddf3+0x8c>
 80404ba:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 80404be:	bf18      	it	ne
 80404c0:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 80404c4:	d029      	beq.n	804051a <__adddf3+0x24e>
 80404c6:	ea94 0f05 	teq	r4, r5
 80404ca:	bf08      	it	eq
 80404cc:	ea90 0f02 	teqeq	r0, r2
 80404d0:	d005      	beq.n	80404de <__adddf3+0x212>
 80404d2:	ea54 0c00 	orrs.w	ip, r4, r0
 80404d6:	bf04      	itt	eq
 80404d8:	4619      	moveq	r1, r3
 80404da:	4610      	moveq	r0, r2
 80404dc:	bd30      	pop	{r4, r5, pc}
 80404de:	ea91 0f03 	teq	r1, r3
 80404e2:	bf1e      	ittt	ne
 80404e4:	2100      	movne	r1, #0
 80404e6:	2000      	movne	r0, #0
 80404e8:	bd30      	popne	{r4, r5, pc}
 80404ea:	ea5f 5c54 	movs.w	ip, r4, lsr #21
 80404ee:	d105      	bne.n	80404fc <__adddf3+0x230>
 80404f0:	0040      	lsls	r0, r0, #1
 80404f2:	4149      	adcs	r1, r1
 80404f4:	bf28      	it	cs
 80404f6:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
 80404fa:	bd30      	pop	{r4, r5, pc}
 80404fc:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
 8040500:	bf3c      	itt	cc
 8040502:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
 8040506:	bd30      	popcc	{r4, r5, pc}
 8040508:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 804050c:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
 8040510:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 8040514:	f04f 0000 	mov.w	r0, #0
 8040518:	bd30      	pop	{r4, r5, pc}
 804051a:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 804051e:	bf1a      	itte	ne
 8040520:	4619      	movne	r1, r3
 8040522:	4610      	movne	r0, r2
 8040524:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
 8040528:	bf1c      	itt	ne
 804052a:	460b      	movne	r3, r1
 804052c:	4602      	movne	r2, r0
 804052e:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 8040532:	bf06      	itte	eq
 8040534:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
 8040538:	ea91 0f03 	teqeq	r1, r3
 804053c:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
 8040540:	bd30      	pop	{r4, r5, pc}
 8040542:	bf00      	nop

08040544 <__aeabi_ui2d>:
 8040544:	f090 0f00 	teq	r0, #0
 8040548:	bf04      	itt	eq
 804054a:	2100      	moveq	r1, #0
 804054c:	4770      	bxeq	lr
 804054e:	b530      	push	{r4, r5, lr}
 8040550:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8040554:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8040558:	f04f 0500 	mov.w	r5, #0
 804055c:	f04f 0100 	mov.w	r1, #0
 8040560:	e750      	b.n	8040404 <__adddf3+0x138>
 8040562:	bf00      	nop

08040564 <__aeabi_i2d>:
 8040564:	f090 0f00 	teq	r0, #0
 8040568:	bf04      	itt	eq
 804056a:	2100      	moveq	r1, #0
 804056c:	4770      	bxeq	lr
 804056e:	b530      	push	{r4, r5, lr}
 8040570:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8040574:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8040578:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
 804057c:	bf48      	it	mi
 804057e:	4240      	negmi	r0, r0
 8040580:	f04f 0100 	mov.w	r1, #0
 8040584:	e73e      	b.n	8040404 <__adddf3+0x138>
 8040586:	bf00      	nop

08040588 <__aeabi_f2d>:
 8040588:	0042      	lsls	r2, r0, #1
 804058a:	ea4f 01e2 	mov.w	r1, r2, asr #3
 804058e:	ea4f 0131 	mov.w	r1, r1, rrx
 8040592:	ea4f 7002 	mov.w	r0, r2, lsl #28
 8040596:	bf1f      	itttt	ne
 8040598:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
 804059c:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 80405a0:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
 80405a4:	4770      	bxne	lr
 80405a6:	f032 427f 	bics.w	r2, r2, #4278190080	; 0xff000000
 80405aa:	bf08      	it	eq
 80405ac:	4770      	bxeq	lr
 80405ae:	f093 4f7f 	teq	r3, #4278190080	; 0xff000000
 80405b2:	bf04      	itt	eq
 80405b4:	f441 2100 	orreq.w	r1, r1, #524288	; 0x80000
 80405b8:	4770      	bxeq	lr
 80405ba:	b530      	push	{r4, r5, lr}
 80405bc:	f44f 7460 	mov.w	r4, #896	; 0x380
 80405c0:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 80405c4:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 80405c8:	e71c      	b.n	8040404 <__adddf3+0x138>
 80405ca:	bf00      	nop

080405cc <__aeabi_ul2d>:
 80405cc:	ea50 0201 	orrs.w	r2, r0, r1
 80405d0:	bf08      	it	eq
 80405d2:	4770      	bxeq	lr
 80405d4:	b530      	push	{r4, r5, lr}
 80405d6:	f04f 0500 	mov.w	r5, #0
 80405da:	e00a      	b.n	80405f2 <__aeabi_l2d+0x16>

080405dc <__aeabi_l2d>:
 80405dc:	ea50 0201 	orrs.w	r2, r0, r1
 80405e0:	bf08      	it	eq
 80405e2:	4770      	bxeq	lr
 80405e4:	b530      	push	{r4, r5, lr}
 80405e6:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
 80405ea:	d502      	bpl.n	80405f2 <__aeabi_l2d+0x16>
 80405ec:	4240      	negs	r0, r0
 80405ee:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 80405f2:	f44f 6480 	mov.w	r4, #1024	; 0x400
 80405f6:	f104 0432 	add.w	r4, r4, #50	; 0x32
 80405fa:	ea5f 5c91 	movs.w	ip, r1, lsr #22
 80405fe:	f43f aed8 	beq.w	80403b2 <__adddf3+0xe6>
 8040602:	f04f 0203 	mov.w	r2, #3
 8040606:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 804060a:	bf18      	it	ne
 804060c:	3203      	addne	r2, #3
 804060e:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 8040612:	bf18      	it	ne
 8040614:	3203      	addne	r2, #3
 8040616:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
 804061a:	f1c2 0320 	rsb	r3, r2, #32
 804061e:	fa00 fc03 	lsl.w	ip, r0, r3
 8040622:	fa20 f002 	lsr.w	r0, r0, r2
 8040626:	fa01 fe03 	lsl.w	lr, r1, r3
 804062a:	ea40 000e 	orr.w	r0, r0, lr
 804062e:	fa21 f102 	lsr.w	r1, r1, r2
 8040632:	4414      	add	r4, r2
 8040634:	e6bd      	b.n	80403b2 <__adddf3+0xe6>
 8040636:	bf00      	nop

08040638 <__aeabi_dmul>:
 8040638:	b570      	push	{r4, r5, r6, lr}
 804063a:	f04f 0cff 	mov.w	ip, #255	; 0xff
 804063e:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 8040642:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 8040646:	bf1d      	ittte	ne
 8040648:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 804064c:	ea94 0f0c 	teqne	r4, ip
 8040650:	ea95 0f0c 	teqne	r5, ip
 8040654:	f000 f8de 	bleq	8040814 <__aeabi_dmul+0x1dc>
 8040658:	442c      	add	r4, r5
 804065a:	ea81 0603 	eor.w	r6, r1, r3
 804065e:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
 8040662:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
 8040666:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
 804066a:	bf18      	it	ne
 804066c:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
 8040670:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8040674:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8040678:	d038      	beq.n	80406ec <__aeabi_dmul+0xb4>
 804067a:	fba0 ce02 	umull	ip, lr, r0, r2
 804067e:	f04f 0500 	mov.w	r5, #0
 8040682:	fbe1 e502 	umlal	lr, r5, r1, r2
 8040686:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
 804068a:	fbe0 e503 	umlal	lr, r5, r0, r3
 804068e:	f04f 0600 	mov.w	r6, #0
 8040692:	fbe1 5603 	umlal	r5, r6, r1, r3
 8040696:	f09c 0f00 	teq	ip, #0
 804069a:	bf18      	it	ne
 804069c:	f04e 0e01 	orrne.w	lr, lr, #1
 80406a0:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
 80406a4:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
 80406a8:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
 80406ac:	d204      	bcs.n	80406b8 <__aeabi_dmul+0x80>
 80406ae:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
 80406b2:	416d      	adcs	r5, r5
 80406b4:	eb46 0606 	adc.w	r6, r6, r6
 80406b8:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
 80406bc:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
 80406c0:	ea4f 20c5 	mov.w	r0, r5, lsl #11
 80406c4:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
 80406c8:	ea4f 2ece 	mov.w	lr, lr, lsl #11
 80406cc:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 80406d0:	bf88      	it	hi
 80406d2:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 80406d6:	d81e      	bhi.n	8040716 <__aeabi_dmul+0xde>
 80406d8:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
 80406dc:	bf08      	it	eq
 80406de:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
 80406e2:	f150 0000 	adcs.w	r0, r0, #0
 80406e6:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 80406ea:	bd70      	pop	{r4, r5, r6, pc}
 80406ec:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
 80406f0:	ea46 0101 	orr.w	r1, r6, r1
 80406f4:	ea40 0002 	orr.w	r0, r0, r2
 80406f8:	ea81 0103 	eor.w	r1, r1, r3
 80406fc:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
 8040700:	bfc2      	ittt	gt
 8040702:	ebd4 050c 	rsbsgt	r5, r4, ip
 8040706:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 804070a:	bd70      	popgt	{r4, r5, r6, pc}
 804070c:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8040710:	f04f 0e00 	mov.w	lr, #0
 8040714:	3c01      	subs	r4, #1
 8040716:	f300 80ab 	bgt.w	8040870 <__aeabi_dmul+0x238>
 804071a:	f114 0f36 	cmn.w	r4, #54	; 0x36
 804071e:	bfde      	ittt	le
 8040720:	2000      	movle	r0, #0
 8040722:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
 8040726:	bd70      	pople	{r4, r5, r6, pc}
 8040728:	f1c4 0400 	rsb	r4, r4, #0
 804072c:	3c20      	subs	r4, #32
 804072e:	da35      	bge.n	804079c <__aeabi_dmul+0x164>
 8040730:	340c      	adds	r4, #12
 8040732:	dc1b      	bgt.n	804076c <__aeabi_dmul+0x134>
 8040734:	f104 0414 	add.w	r4, r4, #20
 8040738:	f1c4 0520 	rsb	r5, r4, #32
 804073c:	fa00 f305 	lsl.w	r3, r0, r5
 8040740:	fa20 f004 	lsr.w	r0, r0, r4
 8040744:	fa01 f205 	lsl.w	r2, r1, r5
 8040748:	ea40 0002 	orr.w	r0, r0, r2
 804074c:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
 8040750:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 8040754:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 8040758:	fa21 f604 	lsr.w	r6, r1, r4
 804075c:	eb42 0106 	adc.w	r1, r2, r6
 8040760:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 8040764:	bf08      	it	eq
 8040766:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 804076a:	bd70      	pop	{r4, r5, r6, pc}
 804076c:	f1c4 040c 	rsb	r4, r4, #12
 8040770:	f1c4 0520 	rsb	r5, r4, #32
 8040774:	fa00 f304 	lsl.w	r3, r0, r4
 8040778:	fa20 f005 	lsr.w	r0, r0, r5
 804077c:	fa01 f204 	lsl.w	r2, r1, r4
 8040780:	ea40 0002 	orr.w	r0, r0, r2
 8040784:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8040788:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 804078c:	f141 0100 	adc.w	r1, r1, #0
 8040790:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 8040794:	bf08      	it	eq
 8040796:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 804079a:	bd70      	pop	{r4, r5, r6, pc}
 804079c:	f1c4 0520 	rsb	r5, r4, #32
 80407a0:	fa00 f205 	lsl.w	r2, r0, r5
 80407a4:	ea4e 0e02 	orr.w	lr, lr, r2
 80407a8:	fa20 f304 	lsr.w	r3, r0, r4
 80407ac:	fa01 f205 	lsl.w	r2, r1, r5
 80407b0:	ea43 0302 	orr.w	r3, r3, r2
 80407b4:	fa21 f004 	lsr.w	r0, r1, r4
 80407b8:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 80407bc:	fa21 f204 	lsr.w	r2, r1, r4
 80407c0:	ea20 0002 	bic.w	r0, r0, r2
 80407c4:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
 80407c8:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 80407cc:	bf08      	it	eq
 80407ce:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 80407d2:	bd70      	pop	{r4, r5, r6, pc}
 80407d4:	f094 0f00 	teq	r4, #0
 80407d8:	d10f      	bne.n	80407fa <__aeabi_dmul+0x1c2>
 80407da:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
 80407de:	0040      	lsls	r0, r0, #1
 80407e0:	eb41 0101 	adc.w	r1, r1, r1
 80407e4:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 80407e8:	bf08      	it	eq
 80407ea:	3c01      	subeq	r4, #1
 80407ec:	d0f7      	beq.n	80407de <__aeabi_dmul+0x1a6>
 80407ee:	ea41 0106 	orr.w	r1, r1, r6
 80407f2:	f095 0f00 	teq	r5, #0
 80407f6:	bf18      	it	ne
 80407f8:	4770      	bxne	lr
 80407fa:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
 80407fe:	0052      	lsls	r2, r2, #1
 8040800:	eb43 0303 	adc.w	r3, r3, r3
 8040804:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
 8040808:	bf08      	it	eq
 804080a:	3d01      	subeq	r5, #1
 804080c:	d0f7      	beq.n	80407fe <__aeabi_dmul+0x1c6>
 804080e:	ea43 0306 	orr.w	r3, r3, r6
 8040812:	4770      	bx	lr
 8040814:	ea94 0f0c 	teq	r4, ip
 8040818:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 804081c:	bf18      	it	ne
 804081e:	ea95 0f0c 	teqne	r5, ip
 8040822:	d00c      	beq.n	804083e <__aeabi_dmul+0x206>
 8040824:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8040828:	bf18      	it	ne
 804082a:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 804082e:	d1d1      	bne.n	80407d4 <__aeabi_dmul+0x19c>
 8040830:	ea81 0103 	eor.w	r1, r1, r3
 8040834:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8040838:	f04f 0000 	mov.w	r0, #0
 804083c:	bd70      	pop	{r4, r5, r6, pc}
 804083e:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8040842:	bf06      	itte	eq
 8040844:	4610      	moveq	r0, r2
 8040846:	4619      	moveq	r1, r3
 8040848:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 804084c:	d019      	beq.n	8040882 <__aeabi_dmul+0x24a>
 804084e:	ea94 0f0c 	teq	r4, ip
 8040852:	d102      	bne.n	804085a <__aeabi_dmul+0x222>
 8040854:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
 8040858:	d113      	bne.n	8040882 <__aeabi_dmul+0x24a>
 804085a:	ea95 0f0c 	teq	r5, ip
 804085e:	d105      	bne.n	804086c <__aeabi_dmul+0x234>
 8040860:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
 8040864:	bf1c      	itt	ne
 8040866:	4610      	movne	r0, r2
 8040868:	4619      	movne	r1, r3
 804086a:	d10a      	bne.n	8040882 <__aeabi_dmul+0x24a>
 804086c:	ea81 0103 	eor.w	r1, r1, r3
 8040870:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8040874:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 8040878:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 804087c:	f04f 0000 	mov.w	r0, #0
 8040880:	bd70      	pop	{r4, r5, r6, pc}
 8040882:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 8040886:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
 804088a:	bd70      	pop	{r4, r5, r6, pc}

0804088c <__aeabi_ddiv>:
 804088c:	b570      	push	{r4, r5, r6, lr}
 804088e:	f04f 0cff 	mov.w	ip, #255	; 0xff
 8040892:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 8040896:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 804089a:	bf1d      	ittte	ne
 804089c:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 80408a0:	ea94 0f0c 	teqne	r4, ip
 80408a4:	ea95 0f0c 	teqne	r5, ip
 80408a8:	f000 f8a7 	bleq	80409fa <__aeabi_ddiv+0x16e>
 80408ac:	eba4 0405 	sub.w	r4, r4, r5
 80408b0:	ea81 0e03 	eor.w	lr, r1, r3
 80408b4:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 80408b8:	ea4f 3101 	mov.w	r1, r1, lsl #12
 80408bc:	f000 8088 	beq.w	80409d0 <__aeabi_ddiv+0x144>
 80408c0:	ea4f 3303 	mov.w	r3, r3, lsl #12
 80408c4:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
 80408c8:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
 80408cc:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 80408d0:	ea4f 2202 	mov.w	r2, r2, lsl #8
 80408d4:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
 80408d8:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
 80408dc:	ea4f 2600 	mov.w	r6, r0, lsl #8
 80408e0:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
 80408e4:	429d      	cmp	r5, r3
 80408e6:	bf08      	it	eq
 80408e8:	4296      	cmpeq	r6, r2
 80408ea:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
 80408ee:	f504 7440 	add.w	r4, r4, #768	; 0x300
 80408f2:	d202      	bcs.n	80408fa <__aeabi_ddiv+0x6e>
 80408f4:	085b      	lsrs	r3, r3, #1
 80408f6:	ea4f 0232 	mov.w	r2, r2, rrx
 80408fa:	1ab6      	subs	r6, r6, r2
 80408fc:	eb65 0503 	sbc.w	r5, r5, r3
 8040900:	085b      	lsrs	r3, r3, #1
 8040902:	ea4f 0232 	mov.w	r2, r2, rrx
 8040906:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 804090a:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
 804090e:	ebb6 0e02 	subs.w	lr, r6, r2
 8040912:	eb75 0e03 	sbcs.w	lr, r5, r3
 8040916:	bf22      	ittt	cs
 8040918:	1ab6      	subcs	r6, r6, r2
 804091a:	4675      	movcs	r5, lr
 804091c:	ea40 000c 	orrcs.w	r0, r0, ip
 8040920:	085b      	lsrs	r3, r3, #1
 8040922:	ea4f 0232 	mov.w	r2, r2, rrx
 8040926:	ebb6 0e02 	subs.w	lr, r6, r2
 804092a:	eb75 0e03 	sbcs.w	lr, r5, r3
 804092e:	bf22      	ittt	cs
 8040930:	1ab6      	subcs	r6, r6, r2
 8040932:	4675      	movcs	r5, lr
 8040934:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 8040938:	085b      	lsrs	r3, r3, #1
 804093a:	ea4f 0232 	mov.w	r2, r2, rrx
 804093e:	ebb6 0e02 	subs.w	lr, r6, r2
 8040942:	eb75 0e03 	sbcs.w	lr, r5, r3
 8040946:	bf22      	ittt	cs
 8040948:	1ab6      	subcs	r6, r6, r2
 804094a:	4675      	movcs	r5, lr
 804094c:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 8040950:	085b      	lsrs	r3, r3, #1
 8040952:	ea4f 0232 	mov.w	r2, r2, rrx
 8040956:	ebb6 0e02 	subs.w	lr, r6, r2
 804095a:	eb75 0e03 	sbcs.w	lr, r5, r3
 804095e:	bf22      	ittt	cs
 8040960:	1ab6      	subcs	r6, r6, r2
 8040962:	4675      	movcs	r5, lr
 8040964:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 8040968:	ea55 0e06 	orrs.w	lr, r5, r6
 804096c:	d018      	beq.n	80409a0 <__aeabi_ddiv+0x114>
 804096e:	ea4f 1505 	mov.w	r5, r5, lsl #4
 8040972:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
 8040976:	ea4f 1606 	mov.w	r6, r6, lsl #4
 804097a:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 804097e:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
 8040982:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 8040986:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
 804098a:	d1c0      	bne.n	804090e <__aeabi_ddiv+0x82>
 804098c:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 8040990:	d10b      	bne.n	80409aa <__aeabi_ddiv+0x11e>
 8040992:	ea41 0100 	orr.w	r1, r1, r0
 8040996:	f04f 0000 	mov.w	r0, #0
 804099a:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
 804099e:	e7b6      	b.n	804090e <__aeabi_ddiv+0x82>
 80409a0:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 80409a4:	bf04      	itt	eq
 80409a6:	4301      	orreq	r1, r0
 80409a8:	2000      	moveq	r0, #0
 80409aa:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 80409ae:	bf88      	it	hi
 80409b0:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 80409b4:	f63f aeaf 	bhi.w	8040716 <__aeabi_dmul+0xde>
 80409b8:	ebb5 0c03 	subs.w	ip, r5, r3
 80409bc:	bf04      	itt	eq
 80409be:	ebb6 0c02 	subseq.w	ip, r6, r2
 80409c2:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 80409c6:	f150 0000 	adcs.w	r0, r0, #0
 80409ca:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 80409ce:	bd70      	pop	{r4, r5, r6, pc}
 80409d0:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
 80409d4:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
 80409d8:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
 80409dc:	bfc2      	ittt	gt
 80409de:	ebd4 050c 	rsbsgt	r5, r4, ip
 80409e2:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 80409e6:	bd70      	popgt	{r4, r5, r6, pc}
 80409e8:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 80409ec:	f04f 0e00 	mov.w	lr, #0
 80409f0:	3c01      	subs	r4, #1
 80409f2:	e690      	b.n	8040716 <__aeabi_dmul+0xde>
 80409f4:	ea45 0e06 	orr.w	lr, r5, r6
 80409f8:	e68d      	b.n	8040716 <__aeabi_dmul+0xde>
 80409fa:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 80409fe:	ea94 0f0c 	teq	r4, ip
 8040a02:	bf08      	it	eq
 8040a04:	ea95 0f0c 	teqeq	r5, ip
 8040a08:	f43f af3b 	beq.w	8040882 <__aeabi_dmul+0x24a>
 8040a0c:	ea94 0f0c 	teq	r4, ip
 8040a10:	d10a      	bne.n	8040a28 <__aeabi_ddiv+0x19c>
 8040a12:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 8040a16:	f47f af34 	bne.w	8040882 <__aeabi_dmul+0x24a>
 8040a1a:	ea95 0f0c 	teq	r5, ip
 8040a1e:	f47f af25 	bne.w	804086c <__aeabi_dmul+0x234>
 8040a22:	4610      	mov	r0, r2
 8040a24:	4619      	mov	r1, r3
 8040a26:	e72c      	b.n	8040882 <__aeabi_dmul+0x24a>
 8040a28:	ea95 0f0c 	teq	r5, ip
 8040a2c:	d106      	bne.n	8040a3c <__aeabi_ddiv+0x1b0>
 8040a2e:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 8040a32:	f43f aefd 	beq.w	8040830 <__aeabi_dmul+0x1f8>
 8040a36:	4610      	mov	r0, r2
 8040a38:	4619      	mov	r1, r3
 8040a3a:	e722      	b.n	8040882 <__aeabi_dmul+0x24a>
 8040a3c:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8040a40:	bf18      	it	ne
 8040a42:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 8040a46:	f47f aec5 	bne.w	80407d4 <__aeabi_dmul+0x19c>
 8040a4a:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
 8040a4e:	f47f af0d 	bne.w	804086c <__aeabi_dmul+0x234>
 8040a52:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
 8040a56:	f47f aeeb 	bne.w	8040830 <__aeabi_dmul+0x1f8>
 8040a5a:	e712      	b.n	8040882 <__aeabi_dmul+0x24a>

08040a5c <__gedf2>:
 8040a5c:	f04f 3cff 	mov.w	ip, #4294967295
 8040a60:	e006      	b.n	8040a70 <__cmpdf2+0x4>
 8040a62:	bf00      	nop

08040a64 <__ledf2>:
 8040a64:	f04f 0c01 	mov.w	ip, #1
 8040a68:	e002      	b.n	8040a70 <__cmpdf2+0x4>
 8040a6a:	bf00      	nop

08040a6c <__cmpdf2>:
 8040a6c:	f04f 0c01 	mov.w	ip, #1
 8040a70:	f84d cd04 	str.w	ip, [sp, #-4]!
 8040a74:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 8040a78:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8040a7c:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 8040a80:	bf18      	it	ne
 8040a82:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
 8040a86:	d01b      	beq.n	8040ac0 <__cmpdf2+0x54>
 8040a88:	b001      	add	sp, #4
 8040a8a:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
 8040a8e:	bf0c      	ite	eq
 8040a90:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
 8040a94:	ea91 0f03 	teqne	r1, r3
 8040a98:	bf02      	ittt	eq
 8040a9a:	ea90 0f02 	teqeq	r0, r2
 8040a9e:	2000      	moveq	r0, #0
 8040aa0:	4770      	bxeq	lr
 8040aa2:	f110 0f00 	cmn.w	r0, #0
 8040aa6:	ea91 0f03 	teq	r1, r3
 8040aaa:	bf58      	it	pl
 8040aac:	4299      	cmppl	r1, r3
 8040aae:	bf08      	it	eq
 8040ab0:	4290      	cmpeq	r0, r2
 8040ab2:	bf2c      	ite	cs
 8040ab4:	17d8      	asrcs	r0, r3, #31
 8040ab6:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
 8040aba:	f040 0001 	orr.w	r0, r0, #1
 8040abe:	4770      	bx	lr
 8040ac0:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 8040ac4:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8040ac8:	d102      	bne.n	8040ad0 <__cmpdf2+0x64>
 8040aca:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
 8040ace:	d107      	bne.n	8040ae0 <__cmpdf2+0x74>
 8040ad0:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 8040ad4:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8040ad8:	d1d6      	bne.n	8040a88 <__cmpdf2+0x1c>
 8040ada:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
 8040ade:	d0d3      	beq.n	8040a88 <__cmpdf2+0x1c>
 8040ae0:	f85d 0b04 	ldr.w	r0, [sp], #4
 8040ae4:	4770      	bx	lr
 8040ae6:	bf00      	nop

08040ae8 <__aeabi_cdrcmple>:
 8040ae8:	4684      	mov	ip, r0
 8040aea:	4610      	mov	r0, r2
 8040aec:	4662      	mov	r2, ip
 8040aee:	468c      	mov	ip, r1
 8040af0:	4619      	mov	r1, r3
 8040af2:	4663      	mov	r3, ip
 8040af4:	e000      	b.n	8040af8 <__aeabi_cdcmpeq>
 8040af6:	bf00      	nop

08040af8 <__aeabi_cdcmpeq>:
 8040af8:	b501      	push	{r0, lr}
 8040afa:	f7ff ffb7 	bl	8040a6c <__cmpdf2>
 8040afe:	2800      	cmp	r0, #0
 8040b00:	bf48      	it	mi
 8040b02:	f110 0f00 	cmnmi.w	r0, #0
 8040b06:	bd01      	pop	{r0, pc}

08040b08 <__aeabi_dcmpeq>:
 8040b08:	f84d ed08 	str.w	lr, [sp, #-8]!
 8040b0c:	f7ff fff4 	bl	8040af8 <__aeabi_cdcmpeq>
 8040b10:	bf0c      	ite	eq
 8040b12:	2001      	moveq	r0, #1
 8040b14:	2000      	movne	r0, #0
 8040b16:	f85d fb08 	ldr.w	pc, [sp], #8
 8040b1a:	bf00      	nop

08040b1c <__aeabi_dcmplt>:
 8040b1c:	f84d ed08 	str.w	lr, [sp, #-8]!
 8040b20:	f7ff ffea 	bl	8040af8 <__aeabi_cdcmpeq>
 8040b24:	bf34      	ite	cc
 8040b26:	2001      	movcc	r0, #1
 8040b28:	2000      	movcs	r0, #0
 8040b2a:	f85d fb08 	ldr.w	pc, [sp], #8
 8040b2e:	bf00      	nop

08040b30 <__aeabi_dcmple>:
 8040b30:	f84d ed08 	str.w	lr, [sp, #-8]!
 8040b34:	f7ff ffe0 	bl	8040af8 <__aeabi_cdcmpeq>
 8040b38:	bf94      	ite	ls
 8040b3a:	2001      	movls	r0, #1
 8040b3c:	2000      	movhi	r0, #0
 8040b3e:	f85d fb08 	ldr.w	pc, [sp], #8
 8040b42:	bf00      	nop

08040b44 <__aeabi_dcmpge>:
 8040b44:	f84d ed08 	str.w	lr, [sp, #-8]!
 8040b48:	f7ff ffce 	bl	8040ae8 <__aeabi_cdrcmple>
 8040b4c:	bf94      	ite	ls
 8040b4e:	2001      	movls	r0, #1
 8040b50:	2000      	movhi	r0, #0
 8040b52:	f85d fb08 	ldr.w	pc, [sp], #8
 8040b56:	bf00      	nop

08040b58 <__aeabi_dcmpgt>:
 8040b58:	f84d ed08 	str.w	lr, [sp, #-8]!
 8040b5c:	f7ff ffc4 	bl	8040ae8 <__aeabi_cdrcmple>
 8040b60:	bf34      	ite	cc
 8040b62:	2001      	movcc	r0, #1
 8040b64:	2000      	movcs	r0, #0
 8040b66:	f85d fb08 	ldr.w	pc, [sp], #8
 8040b6a:	bf00      	nop

08040b6c <__aeabi_dcmpun>:
 8040b6c:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 8040b70:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8040b74:	d102      	bne.n	8040b7c <__aeabi_dcmpun+0x10>
 8040b76:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
 8040b7a:	d10a      	bne.n	8040b92 <__aeabi_dcmpun+0x26>
 8040b7c:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 8040b80:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8040b84:	d102      	bne.n	8040b8c <__aeabi_dcmpun+0x20>
 8040b86:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
 8040b8a:	d102      	bne.n	8040b92 <__aeabi_dcmpun+0x26>
 8040b8c:	f04f 0000 	mov.w	r0, #0
 8040b90:	4770      	bx	lr
 8040b92:	f04f 0001 	mov.w	r0, #1
 8040b96:	4770      	bx	lr

08040b98 <__aeabi_d2iz>:
 8040b98:	ea4f 0241 	mov.w	r2, r1, lsl #1
 8040b9c:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
 8040ba0:	d215      	bcs.n	8040bce <__aeabi_d2iz+0x36>
 8040ba2:	d511      	bpl.n	8040bc8 <__aeabi_d2iz+0x30>
 8040ba4:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
 8040ba8:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
 8040bac:	d912      	bls.n	8040bd4 <__aeabi_d2iz+0x3c>
 8040bae:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 8040bb2:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8040bb6:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
 8040bba:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 8040bbe:	fa23 f002 	lsr.w	r0, r3, r2
 8040bc2:	bf18      	it	ne
 8040bc4:	4240      	negne	r0, r0
 8040bc6:	4770      	bx	lr
 8040bc8:	f04f 0000 	mov.w	r0, #0
 8040bcc:	4770      	bx	lr
 8040bce:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
 8040bd2:	d105      	bne.n	8040be0 <__aeabi_d2iz+0x48>
 8040bd4:	f011 4000 	ands.w	r0, r1, #2147483648	; 0x80000000
 8040bd8:	bf08      	it	eq
 8040bda:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
 8040bde:	4770      	bx	lr
 8040be0:	f04f 0000 	mov.w	r0, #0
 8040be4:	4770      	bx	lr
 8040be6:	bf00      	nop

08040be8 <__aeabi_d2uiz>:
 8040be8:	004a      	lsls	r2, r1, #1
 8040bea:	d211      	bcs.n	8040c10 <__aeabi_d2uiz+0x28>
 8040bec:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
 8040bf0:	d211      	bcs.n	8040c16 <__aeabi_d2uiz+0x2e>
 8040bf2:	d50d      	bpl.n	8040c10 <__aeabi_d2uiz+0x28>
 8040bf4:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
 8040bf8:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
 8040bfc:	d40e      	bmi.n	8040c1c <__aeabi_d2uiz+0x34>
 8040bfe:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 8040c02:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8040c06:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
 8040c0a:	fa23 f002 	lsr.w	r0, r3, r2
 8040c0e:	4770      	bx	lr
 8040c10:	f04f 0000 	mov.w	r0, #0
 8040c14:	4770      	bx	lr
 8040c16:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
 8040c1a:	d102      	bne.n	8040c22 <__aeabi_d2uiz+0x3a>
 8040c1c:	f04f 30ff 	mov.w	r0, #4294967295
 8040c20:	4770      	bx	lr
 8040c22:	f04f 0000 	mov.w	r0, #0
 8040c26:	4770      	bx	lr

08040c28 <__aeabi_d2f>:
 8040c28:	ea4f 0241 	mov.w	r2, r1, lsl #1
 8040c2c:	f1b2 43e0 	subs.w	r3, r2, #1879048192	; 0x70000000
 8040c30:	bf24      	itt	cs
 8040c32:	f5b3 1c00 	subscs.w	ip, r3, #2097152	; 0x200000
 8040c36:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	; 0x1fc00000
 8040c3a:	d90d      	bls.n	8040c58 <__aeabi_d2f+0x30>
 8040c3c:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
 8040c40:	ea4f 02c0 	mov.w	r2, r0, lsl #3
 8040c44:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
 8040c48:	f1b2 4f00 	cmp.w	r2, #2147483648	; 0x80000000
 8040c4c:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
 8040c50:	bf08      	it	eq
 8040c52:	f020 0001 	biceq.w	r0, r0, #1
 8040c56:	4770      	bx	lr
 8040c58:	f011 4f80 	tst.w	r1, #1073741824	; 0x40000000
 8040c5c:	d121      	bne.n	8040ca2 <__aeabi_d2f+0x7a>
 8040c5e:	f113 7238 	adds.w	r2, r3, #48234496	; 0x2e00000
 8040c62:	bfbc      	itt	lt
 8040c64:	f001 4000 	andlt.w	r0, r1, #2147483648	; 0x80000000
 8040c68:	4770      	bxlt	lr
 8040c6a:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8040c6e:	ea4f 5252 	mov.w	r2, r2, lsr #21
 8040c72:	f1c2 0218 	rsb	r2, r2, #24
 8040c76:	f1c2 0c20 	rsb	ip, r2, #32
 8040c7a:	fa10 f30c 	lsls.w	r3, r0, ip
 8040c7e:	fa20 f002 	lsr.w	r0, r0, r2
 8040c82:	bf18      	it	ne
 8040c84:	f040 0001 	orrne.w	r0, r0, #1
 8040c88:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 8040c8c:	ea4f 23d3 	mov.w	r3, r3, lsr #11
 8040c90:	fa03 fc0c 	lsl.w	ip, r3, ip
 8040c94:	ea40 000c 	orr.w	r0, r0, ip
 8040c98:	fa23 f302 	lsr.w	r3, r3, r2
 8040c9c:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8040ca0:	e7cc      	b.n	8040c3c <__aeabi_d2f+0x14>
 8040ca2:	ea7f 5362 	mvns.w	r3, r2, asr #21
 8040ca6:	d107      	bne.n	8040cb8 <__aeabi_d2f+0x90>
 8040ca8:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
 8040cac:	bf1e      	ittt	ne
 8040cae:	f04f 40fe 	movne.w	r0, #2130706432	; 0x7f000000
 8040cb2:	f440 0040 	orrne.w	r0, r0, #12582912	; 0xc00000
 8040cb6:	4770      	bxne	lr
 8040cb8:	f001 4000 	and.w	r0, r1, #2147483648	; 0x80000000
 8040cbc:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
 8040cc0:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8040cc4:	4770      	bx	lr
 8040cc6:	bf00      	nop

08040cc8 <__aeabi_uldivmod>:
 8040cc8:	b953      	cbnz	r3, 8040ce0 <__aeabi_uldivmod+0x18>
 8040cca:	b94a      	cbnz	r2, 8040ce0 <__aeabi_uldivmod+0x18>
 8040ccc:	2900      	cmp	r1, #0
 8040cce:	bf08      	it	eq
 8040cd0:	2800      	cmpeq	r0, #0
 8040cd2:	bf1c      	itt	ne
 8040cd4:	f04f 31ff 	movne.w	r1, #4294967295
 8040cd8:	f04f 30ff 	movne.w	r0, #4294967295
 8040cdc:	f000 b9a4 	b.w	8041028 <__aeabi_idiv0>
 8040ce0:	f1ad 0c08 	sub.w	ip, sp, #8
 8040ce4:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 8040ce8:	f000 f83c 	bl	8040d64 <__udivmoddi4>
 8040cec:	f8dd e004 	ldr.w	lr, [sp, #4]
 8040cf0:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8040cf4:	b004      	add	sp, #16
 8040cf6:	4770      	bx	lr

08040cf8 <__aeabi_d2lz>:
 8040cf8:	b538      	push	{r3, r4, r5, lr}
 8040cfa:	2200      	movs	r2, #0
 8040cfc:	2300      	movs	r3, #0
 8040cfe:	4604      	mov	r4, r0
 8040d00:	460d      	mov	r5, r1
 8040d02:	f7ff ff0b 	bl	8040b1c <__aeabi_dcmplt>
 8040d06:	b928      	cbnz	r0, 8040d14 <__aeabi_d2lz+0x1c>
 8040d08:	4620      	mov	r0, r4
 8040d0a:	4629      	mov	r1, r5
 8040d0c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 8040d10:	f000 b80a 	b.w	8040d28 <__aeabi_d2ulz>
 8040d14:	4620      	mov	r0, r4
 8040d16:	f105 4100 	add.w	r1, r5, #2147483648	; 0x80000000
 8040d1a:	f000 f805 	bl	8040d28 <__aeabi_d2ulz>
 8040d1e:	4240      	negs	r0, r0
 8040d20:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8040d24:	bd38      	pop	{r3, r4, r5, pc}
 8040d26:	bf00      	nop

08040d28 <__aeabi_d2ulz>:
 8040d28:	b5d0      	push	{r4, r6, r7, lr}
 8040d2a:	4b0c      	ldr	r3, [pc, #48]	; (8040d5c <__aeabi_d2ulz+0x34>)
 8040d2c:	2200      	movs	r2, #0
 8040d2e:	4606      	mov	r6, r0
 8040d30:	460f      	mov	r7, r1
 8040d32:	f7ff fc81 	bl	8040638 <__aeabi_dmul>
 8040d36:	f7ff ff57 	bl	8040be8 <__aeabi_d2uiz>
 8040d3a:	4604      	mov	r4, r0
 8040d3c:	f7ff fc02 	bl	8040544 <__aeabi_ui2d>
 8040d40:	4b07      	ldr	r3, [pc, #28]	; (8040d60 <__aeabi_d2ulz+0x38>)
 8040d42:	2200      	movs	r2, #0
 8040d44:	f7ff fc78 	bl	8040638 <__aeabi_dmul>
 8040d48:	4602      	mov	r2, r0
 8040d4a:	460b      	mov	r3, r1
 8040d4c:	4630      	mov	r0, r6
 8040d4e:	4639      	mov	r1, r7
 8040d50:	f7ff faba 	bl	80402c8 <__aeabi_dsub>
 8040d54:	f7ff ff48 	bl	8040be8 <__aeabi_d2uiz>
 8040d58:	4621      	mov	r1, r4
 8040d5a:	bdd0      	pop	{r4, r6, r7, pc}
 8040d5c:	3df00000 	.word	0x3df00000
 8040d60:	41f00000 	.word	0x41f00000

08040d64 <__udivmoddi4>:
 8040d64:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8040d68:	9d08      	ldr	r5, [sp, #32]
 8040d6a:	4604      	mov	r4, r0
 8040d6c:	468c      	mov	ip, r1
 8040d6e:	2b00      	cmp	r3, #0
 8040d70:	f040 8083 	bne.w	8040e7a <__udivmoddi4+0x116>
 8040d74:	428a      	cmp	r2, r1
 8040d76:	4617      	mov	r7, r2
 8040d78:	d947      	bls.n	8040e0a <__udivmoddi4+0xa6>
 8040d7a:	fab2 f282 	clz	r2, r2
 8040d7e:	b142      	cbz	r2, 8040d92 <__udivmoddi4+0x2e>
 8040d80:	f1c2 0020 	rsb	r0, r2, #32
 8040d84:	fa24 f000 	lsr.w	r0, r4, r0
 8040d88:	4091      	lsls	r1, r2
 8040d8a:	4097      	lsls	r7, r2
 8040d8c:	ea40 0c01 	orr.w	ip, r0, r1
 8040d90:	4094      	lsls	r4, r2
 8040d92:	ea4f 4817 	mov.w	r8, r7, lsr #16
 8040d96:	0c23      	lsrs	r3, r4, #16
 8040d98:	fbbc f6f8 	udiv	r6, ip, r8
 8040d9c:	fa1f fe87 	uxth.w	lr, r7
 8040da0:	fb08 c116 	mls	r1, r8, r6, ip
 8040da4:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 8040da8:	fb06 f10e 	mul.w	r1, r6, lr
 8040dac:	4299      	cmp	r1, r3
 8040dae:	d909      	bls.n	8040dc4 <__udivmoddi4+0x60>
 8040db0:	18fb      	adds	r3, r7, r3
 8040db2:	f106 30ff 	add.w	r0, r6, #4294967295
 8040db6:	f080 8119 	bcs.w	8040fec <__udivmoddi4+0x288>
 8040dba:	4299      	cmp	r1, r3
 8040dbc:	f240 8116 	bls.w	8040fec <__udivmoddi4+0x288>
 8040dc0:	3e02      	subs	r6, #2
 8040dc2:	443b      	add	r3, r7
 8040dc4:	1a5b      	subs	r3, r3, r1
 8040dc6:	b2a4      	uxth	r4, r4
 8040dc8:	fbb3 f0f8 	udiv	r0, r3, r8
 8040dcc:	fb08 3310 	mls	r3, r8, r0, r3
 8040dd0:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
 8040dd4:	fb00 fe0e 	mul.w	lr, r0, lr
 8040dd8:	45a6      	cmp	lr, r4
 8040dda:	d909      	bls.n	8040df0 <__udivmoddi4+0x8c>
 8040ddc:	193c      	adds	r4, r7, r4
 8040dde:	f100 33ff 	add.w	r3, r0, #4294967295
 8040de2:	f080 8105 	bcs.w	8040ff0 <__udivmoddi4+0x28c>
 8040de6:	45a6      	cmp	lr, r4
 8040de8:	f240 8102 	bls.w	8040ff0 <__udivmoddi4+0x28c>
 8040dec:	3802      	subs	r0, #2
 8040dee:	443c      	add	r4, r7
 8040df0:	ea40 4006 	orr.w	r0, r0, r6, lsl #16
 8040df4:	eba4 040e 	sub.w	r4, r4, lr
 8040df8:	2600      	movs	r6, #0
 8040dfa:	b11d      	cbz	r5, 8040e04 <__udivmoddi4+0xa0>
 8040dfc:	40d4      	lsrs	r4, r2
 8040dfe:	2300      	movs	r3, #0
 8040e00:	e9c5 4300 	strd	r4, r3, [r5]
 8040e04:	4631      	mov	r1, r6
 8040e06:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8040e0a:	b902      	cbnz	r2, 8040e0e <__udivmoddi4+0xaa>
 8040e0c:	deff      	udf	#255	; 0xff
 8040e0e:	fab2 f282 	clz	r2, r2
 8040e12:	2a00      	cmp	r2, #0
 8040e14:	d150      	bne.n	8040eb8 <__udivmoddi4+0x154>
 8040e16:	1bcb      	subs	r3, r1, r7
 8040e18:	ea4f 4e17 	mov.w	lr, r7, lsr #16
 8040e1c:	fa1f f887 	uxth.w	r8, r7
 8040e20:	2601      	movs	r6, #1
 8040e22:	fbb3 fcfe 	udiv	ip, r3, lr
 8040e26:	0c21      	lsrs	r1, r4, #16
 8040e28:	fb0e 331c 	mls	r3, lr, ip, r3
 8040e2c:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
 8040e30:	fb08 f30c 	mul.w	r3, r8, ip
 8040e34:	428b      	cmp	r3, r1
 8040e36:	d907      	bls.n	8040e48 <__udivmoddi4+0xe4>
 8040e38:	1879      	adds	r1, r7, r1
 8040e3a:	f10c 30ff 	add.w	r0, ip, #4294967295
 8040e3e:	d202      	bcs.n	8040e46 <__udivmoddi4+0xe2>
 8040e40:	428b      	cmp	r3, r1
 8040e42:	f200 80e9 	bhi.w	8041018 <__udivmoddi4+0x2b4>
 8040e46:	4684      	mov	ip, r0
 8040e48:	1ac9      	subs	r1, r1, r3
 8040e4a:	b2a3      	uxth	r3, r4
 8040e4c:	fbb1 f0fe 	udiv	r0, r1, lr
 8040e50:	fb0e 1110 	mls	r1, lr, r0, r1
 8040e54:	ea43 4401 	orr.w	r4, r3, r1, lsl #16
 8040e58:	fb08 f800 	mul.w	r8, r8, r0
 8040e5c:	45a0      	cmp	r8, r4
 8040e5e:	d907      	bls.n	8040e70 <__udivmoddi4+0x10c>
 8040e60:	193c      	adds	r4, r7, r4
 8040e62:	f100 33ff 	add.w	r3, r0, #4294967295
 8040e66:	d202      	bcs.n	8040e6e <__udivmoddi4+0x10a>
 8040e68:	45a0      	cmp	r8, r4
 8040e6a:	f200 80d9 	bhi.w	8041020 <__udivmoddi4+0x2bc>
 8040e6e:	4618      	mov	r0, r3
 8040e70:	eba4 0408 	sub.w	r4, r4, r8
 8040e74:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
 8040e78:	e7bf      	b.n	8040dfa <__udivmoddi4+0x96>
 8040e7a:	428b      	cmp	r3, r1
 8040e7c:	d909      	bls.n	8040e92 <__udivmoddi4+0x12e>
 8040e7e:	2d00      	cmp	r5, #0
 8040e80:	f000 80b1 	beq.w	8040fe6 <__udivmoddi4+0x282>
 8040e84:	2600      	movs	r6, #0
 8040e86:	e9c5 0100 	strd	r0, r1, [r5]
 8040e8a:	4630      	mov	r0, r6
 8040e8c:	4631      	mov	r1, r6
 8040e8e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8040e92:	fab3 f683 	clz	r6, r3
 8040e96:	2e00      	cmp	r6, #0
 8040e98:	d14a      	bne.n	8040f30 <__udivmoddi4+0x1cc>
 8040e9a:	428b      	cmp	r3, r1
 8040e9c:	d302      	bcc.n	8040ea4 <__udivmoddi4+0x140>
 8040e9e:	4282      	cmp	r2, r0
 8040ea0:	f200 80b8 	bhi.w	8041014 <__udivmoddi4+0x2b0>
 8040ea4:	1a84      	subs	r4, r0, r2
 8040ea6:	eb61 0103 	sbc.w	r1, r1, r3
 8040eaa:	2001      	movs	r0, #1
 8040eac:	468c      	mov	ip, r1
 8040eae:	2d00      	cmp	r5, #0
 8040eb0:	d0a8      	beq.n	8040e04 <__udivmoddi4+0xa0>
 8040eb2:	e9c5 4c00 	strd	r4, ip, [r5]
 8040eb6:	e7a5      	b.n	8040e04 <__udivmoddi4+0xa0>
 8040eb8:	f1c2 0320 	rsb	r3, r2, #32
 8040ebc:	fa20 f603 	lsr.w	r6, r0, r3
 8040ec0:	4097      	lsls	r7, r2
 8040ec2:	fa01 f002 	lsl.w	r0, r1, r2
 8040ec6:	ea4f 4e17 	mov.w	lr, r7, lsr #16
 8040eca:	40d9      	lsrs	r1, r3
 8040ecc:	4330      	orrs	r0, r6
 8040ece:	0c03      	lsrs	r3, r0, #16
 8040ed0:	fbb1 f6fe 	udiv	r6, r1, lr
 8040ed4:	fa1f f887 	uxth.w	r8, r7
 8040ed8:	fb0e 1116 	mls	r1, lr, r6, r1
 8040edc:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 8040ee0:	fb06 f108 	mul.w	r1, r6, r8
 8040ee4:	4299      	cmp	r1, r3
 8040ee6:	fa04 f402 	lsl.w	r4, r4, r2
 8040eea:	d909      	bls.n	8040f00 <__udivmoddi4+0x19c>
 8040eec:	18fb      	adds	r3, r7, r3
 8040eee:	f106 3cff 	add.w	ip, r6, #4294967295
 8040ef2:	f080 808d 	bcs.w	8041010 <__udivmoddi4+0x2ac>
 8040ef6:	4299      	cmp	r1, r3
 8040ef8:	f240 808a 	bls.w	8041010 <__udivmoddi4+0x2ac>
 8040efc:	3e02      	subs	r6, #2
 8040efe:	443b      	add	r3, r7
 8040f00:	1a5b      	subs	r3, r3, r1
 8040f02:	b281      	uxth	r1, r0
 8040f04:	fbb3 f0fe 	udiv	r0, r3, lr
 8040f08:	fb0e 3310 	mls	r3, lr, r0, r3
 8040f0c:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
 8040f10:	fb00 f308 	mul.w	r3, r0, r8
 8040f14:	428b      	cmp	r3, r1
 8040f16:	d907      	bls.n	8040f28 <__udivmoddi4+0x1c4>
 8040f18:	1879      	adds	r1, r7, r1
 8040f1a:	f100 3cff 	add.w	ip, r0, #4294967295
 8040f1e:	d273      	bcs.n	8041008 <__udivmoddi4+0x2a4>
 8040f20:	428b      	cmp	r3, r1
 8040f22:	d971      	bls.n	8041008 <__udivmoddi4+0x2a4>
 8040f24:	3802      	subs	r0, #2
 8040f26:	4439      	add	r1, r7
 8040f28:	1acb      	subs	r3, r1, r3
 8040f2a:	ea40 4606 	orr.w	r6, r0, r6, lsl #16
 8040f2e:	e778      	b.n	8040e22 <__udivmoddi4+0xbe>
 8040f30:	f1c6 0c20 	rsb	ip, r6, #32
 8040f34:	fa03 f406 	lsl.w	r4, r3, r6
 8040f38:	fa22 f30c 	lsr.w	r3, r2, ip
 8040f3c:	431c      	orrs	r4, r3
 8040f3e:	fa20 f70c 	lsr.w	r7, r0, ip
 8040f42:	fa01 f306 	lsl.w	r3, r1, r6
 8040f46:	ea4f 4e14 	mov.w	lr, r4, lsr #16
 8040f4a:	fa21 f10c 	lsr.w	r1, r1, ip
 8040f4e:	431f      	orrs	r7, r3
 8040f50:	0c3b      	lsrs	r3, r7, #16
 8040f52:	fbb1 f9fe 	udiv	r9, r1, lr
 8040f56:	fa1f f884 	uxth.w	r8, r4
 8040f5a:	fb0e 1119 	mls	r1, lr, r9, r1
 8040f5e:	ea43 4101 	orr.w	r1, r3, r1, lsl #16
 8040f62:	fb09 fa08 	mul.w	sl, r9, r8
 8040f66:	458a      	cmp	sl, r1
 8040f68:	fa02 f206 	lsl.w	r2, r2, r6
 8040f6c:	fa00 f306 	lsl.w	r3, r0, r6
 8040f70:	d908      	bls.n	8040f84 <__udivmoddi4+0x220>
 8040f72:	1861      	adds	r1, r4, r1
 8040f74:	f109 30ff 	add.w	r0, r9, #4294967295
 8040f78:	d248      	bcs.n	804100c <__udivmoddi4+0x2a8>
 8040f7a:	458a      	cmp	sl, r1
 8040f7c:	d946      	bls.n	804100c <__udivmoddi4+0x2a8>
 8040f7e:	f1a9 0902 	sub.w	r9, r9, #2
 8040f82:	4421      	add	r1, r4
 8040f84:	eba1 010a 	sub.w	r1, r1, sl
 8040f88:	b2bf      	uxth	r7, r7
 8040f8a:	fbb1 f0fe 	udiv	r0, r1, lr
 8040f8e:	fb0e 1110 	mls	r1, lr, r0, r1
 8040f92:	ea47 4701 	orr.w	r7, r7, r1, lsl #16
 8040f96:	fb00 f808 	mul.w	r8, r0, r8
 8040f9a:	45b8      	cmp	r8, r7
 8040f9c:	d907      	bls.n	8040fae <__udivmoddi4+0x24a>
 8040f9e:	19e7      	adds	r7, r4, r7
 8040fa0:	f100 31ff 	add.w	r1, r0, #4294967295
 8040fa4:	d22e      	bcs.n	8041004 <__udivmoddi4+0x2a0>
 8040fa6:	45b8      	cmp	r8, r7
 8040fa8:	d92c      	bls.n	8041004 <__udivmoddi4+0x2a0>
 8040faa:	3802      	subs	r0, #2
 8040fac:	4427      	add	r7, r4
 8040fae:	ea40 4009 	orr.w	r0, r0, r9, lsl #16
 8040fb2:	eba7 0708 	sub.w	r7, r7, r8
 8040fb6:	fba0 8902 	umull	r8, r9, r0, r2
 8040fba:	454f      	cmp	r7, r9
 8040fbc:	46c6      	mov	lr, r8
 8040fbe:	4649      	mov	r1, r9
 8040fc0:	d31a      	bcc.n	8040ff8 <__udivmoddi4+0x294>
 8040fc2:	d017      	beq.n	8040ff4 <__udivmoddi4+0x290>
 8040fc4:	b15d      	cbz	r5, 8040fde <__udivmoddi4+0x27a>
 8040fc6:	ebb3 020e 	subs.w	r2, r3, lr
 8040fca:	eb67 0701 	sbc.w	r7, r7, r1
 8040fce:	fa07 fc0c 	lsl.w	ip, r7, ip
 8040fd2:	40f2      	lsrs	r2, r6
 8040fd4:	ea4c 0202 	orr.w	r2, ip, r2
 8040fd8:	40f7      	lsrs	r7, r6
 8040fda:	e9c5 2700 	strd	r2, r7, [r5]
 8040fde:	2600      	movs	r6, #0
 8040fe0:	4631      	mov	r1, r6
 8040fe2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8040fe6:	462e      	mov	r6, r5
 8040fe8:	4628      	mov	r0, r5
 8040fea:	e70b      	b.n	8040e04 <__udivmoddi4+0xa0>
 8040fec:	4606      	mov	r6, r0
 8040fee:	e6e9      	b.n	8040dc4 <__udivmoddi4+0x60>
 8040ff0:	4618      	mov	r0, r3
 8040ff2:	e6fd      	b.n	8040df0 <__udivmoddi4+0x8c>
 8040ff4:	4543      	cmp	r3, r8
 8040ff6:	d2e5      	bcs.n	8040fc4 <__udivmoddi4+0x260>
 8040ff8:	ebb8 0e02 	subs.w	lr, r8, r2
 8040ffc:	eb69 0104 	sbc.w	r1, r9, r4
 8041000:	3801      	subs	r0, #1
 8041002:	e7df      	b.n	8040fc4 <__udivmoddi4+0x260>
 8041004:	4608      	mov	r0, r1
 8041006:	e7d2      	b.n	8040fae <__udivmoddi4+0x24a>
 8041008:	4660      	mov	r0, ip
 804100a:	e78d      	b.n	8040f28 <__udivmoddi4+0x1c4>
 804100c:	4681      	mov	r9, r0
 804100e:	e7b9      	b.n	8040f84 <__udivmoddi4+0x220>
 8041010:	4666      	mov	r6, ip
 8041012:	e775      	b.n	8040f00 <__udivmoddi4+0x19c>
 8041014:	4630      	mov	r0, r6
 8041016:	e74a      	b.n	8040eae <__udivmoddi4+0x14a>
 8041018:	f1ac 0c02 	sub.w	ip, ip, #2
 804101c:	4439      	add	r1, r7
 804101e:	e713      	b.n	8040e48 <__udivmoddi4+0xe4>
 8041020:	3802      	subs	r0, #2
 8041022:	443c      	add	r4, r7
 8041024:	e724      	b.n	8040e70 <__udivmoddi4+0x10c>
 8041026:	bf00      	nop

08041028 <__aeabi_idiv0>:
 8041028:	4770      	bx	lr
 804102a:	bf00      	nop

0804102c <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 804102c:	b510      	push	{r4, lr}
 804102e:	4604      	mov	r4, r0
  /* Configure the SysTick to have interrupt in 1ms time basis*/
  if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / uwTickFreq)) > 0U)
 8041030:	4b0e      	ldr	r3, [pc, #56]	; (804106c <HAL_InitTick+0x40>)
 8041032:	7818      	ldrb	r0, [r3, #0]
 8041034:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8041038:	fbb3 f3f0 	udiv	r3, r3, r0
 804103c:	4a0c      	ldr	r2, [pc, #48]	; (8041070 <HAL_InitTick+0x44>)
 804103e:	6810      	ldr	r0, [r2, #0]
 8041040:	fbb0 f0f3 	udiv	r0, r0, r3
 8041044:	f000 fca8 	bl	8041998 <HAL_SYSTICK_Config>
 8041048:	b968      	cbnz	r0, 8041066 <HAL_InitTick+0x3a>
  {
    return HAL_ERROR;
  }

  /* Configure the SysTick IRQ priority */
  if (TickPriority < (1UL << __NVIC_PRIO_BITS))
 804104a:	2c0f      	cmp	r4, #15
 804104c:	d901      	bls.n	8041052 <HAL_InitTick+0x26>
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
    uwTickPrio = TickPriority;
  }
  else
  {
    return HAL_ERROR;
 804104e:	2001      	movs	r0, #1
 8041050:	e00a      	b.n	8041068 <HAL_InitTick+0x3c>
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
 8041052:	2200      	movs	r2, #0
 8041054:	4621      	mov	r1, r4
 8041056:	f04f 30ff 	mov.w	r0, #4294967295
 804105a:	f000 fc49 	bl	80418f0 <HAL_NVIC_SetPriority>
    uwTickPrio = TickPriority;
 804105e:	4b03      	ldr	r3, [pc, #12]	; (804106c <HAL_InitTick+0x40>)
 8041060:	605c      	str	r4, [r3, #4]
  }

  /* Return function status */
  return HAL_OK;
 8041062:	2000      	movs	r0, #0
 8041064:	e000      	b.n	8041068 <HAL_InitTick+0x3c>
    return HAL_ERROR;
 8041066:	2001      	movs	r0, #1
}
 8041068:	bd10      	pop	{r4, pc}
 804106a:	bf00      	nop
 804106c:	20000000 	.word	0x20000000
 8041070:	20003678 	.word	0x20003678

08041074 <HAL_Init>:
{
 8041074:	b508      	push	{r3, lr}
  __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();
 8041076:	4b0b      	ldr	r3, [pc, #44]	; (80410a4 <HAL_Init+0x30>)
 8041078:	681a      	ldr	r2, [r3, #0]
 804107a:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 804107e:	601a      	str	r2, [r3, #0]
  __HAL_FLASH_DATA_CACHE_ENABLE();
 8041080:	681a      	ldr	r2, [r3, #0]
 8041082:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 8041086:	601a      	str	r2, [r3, #0]
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 8041088:	681a      	ldr	r2, [r3, #0]
 804108a:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 804108e:	601a      	str	r2, [r3, #0]
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 8041090:	2003      	movs	r0, #3
 8041092:	f000 fc1b 	bl	80418cc <HAL_NVIC_SetPriorityGrouping>
  HAL_InitTick(TICK_INT_PRIORITY);
 8041096:	2000      	movs	r0, #0
 8041098:	f7ff ffc8 	bl	804102c <HAL_InitTick>
  HAL_MspInit();
 804109c:	f00f f9c4 	bl	8050428 <HAL_MspInit>
}
 80410a0:	2000      	movs	r0, #0
 80410a2:	bd08      	pop	{r3, pc}
 80410a4:	40023c00 	.word	0x40023c00

080410a8 <HAL_IncTick>:
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick += uwTickFreq;
 80410a8:	4a03      	ldr	r2, [pc, #12]	; (80410b8 <HAL_IncTick+0x10>)
 80410aa:	6811      	ldr	r1, [r2, #0]
 80410ac:	4b03      	ldr	r3, [pc, #12]	; (80410bc <HAL_IncTick+0x14>)
 80410ae:	781b      	ldrb	r3, [r3, #0]
 80410b0:	440b      	add	r3, r1
 80410b2:	6013      	str	r3, [r2, #0]
}
 80410b4:	4770      	bx	lr
 80410b6:	bf00      	nop
 80410b8:	200051cc 	.word	0x200051cc
 80410bc:	20000000 	.word	0x20000000

080410c0 <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
 80410c0:	4b01      	ldr	r3, [pc, #4]	; (80410c8 <HAL_GetTick+0x8>)
 80410c2:	6818      	ldr	r0, [r3, #0]
}
 80410c4:	4770      	bx	lr
 80410c6:	bf00      	nop
 80410c8:	200051cc 	.word	0x200051cc

080410cc <HAL_Delay>:
  *       implementations in user file.
  * @param Delay specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
 80410cc:	b538      	push	{r3, r4, r5, lr}
 80410ce:	4604      	mov	r4, r0
  uint32_t tickstart = HAL_GetTick();
 80410d0:	f7ff fff6 	bl	80410c0 <HAL_GetTick>
 80410d4:	4605      	mov	r5, r0
  uint32_t wait = Delay;

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
 80410d6:	f1b4 3fff 	cmp.w	r4, #4294967295
 80410da:	d002      	beq.n	80410e2 <HAL_Delay+0x16>
  {
    wait += (uint32_t)(uwTickFreq);
 80410dc:	4b04      	ldr	r3, [pc, #16]	; (80410f0 <HAL_Delay+0x24>)
 80410de:	781b      	ldrb	r3, [r3, #0]
 80410e0:	441c      	add	r4, r3
  }

  while((HAL_GetTick() - tickstart) < wait)
 80410e2:	f7ff ffed 	bl	80410c0 <HAL_GetTick>
 80410e6:	1b40      	subs	r0, r0, r5
 80410e8:	42a0      	cmp	r0, r4
 80410ea:	d3fa      	bcc.n	80410e2 <HAL_Delay+0x16>
  {
  }
}
 80410ec:	bd38      	pop	{r3, r4, r5, pc}
 80410ee:	bf00      	nop
 80410f0:	20000000 	.word	0x20000000

080410f4 <ADC_Init>:
  /* (Depending on STM32F4 product, there may be up to 3 ADCs and 1 common */
  /* control register)                                                    */
  tmpADC_Common = ADC_COMMON_REGISTER(hadc);
  
  /* Set the ADC clock prescaler */
  tmpADC_Common->CCR &= ~(ADC_CCR_ADCPRE);
 80410f4:	4b4a      	ldr	r3, [pc, #296]	; (8041220 <ADC_Init+0x12c>)
 80410f6:	685a      	ldr	r2, [r3, #4]
 80410f8:	f422 3240 	bic.w	r2, r2, #196608	; 0x30000
 80410fc:	605a      	str	r2, [r3, #4]
  tmpADC_Common->CCR |=  hadc->Init.ClockPrescaler;
 80410fe:	685a      	ldr	r2, [r3, #4]
 8041100:	6841      	ldr	r1, [r0, #4]
 8041102:	430a      	orrs	r2, r1
 8041104:	605a      	str	r2, [r3, #4]
  
  /* Set ADC scan mode */
  hadc->Instance->CR1 &= ~(ADC_CR1_SCAN);
 8041106:	6802      	ldr	r2, [r0, #0]
 8041108:	6853      	ldr	r3, [r2, #4]
 804110a:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 804110e:	6053      	str	r3, [r2, #4]
  hadc->Instance->CR1 |=  ADC_CR1_SCANCONV(hadc->Init.ScanConvMode);
 8041110:	6802      	ldr	r2, [r0, #0]
 8041112:	6853      	ldr	r3, [r2, #4]
 8041114:	6901      	ldr	r1, [r0, #16]
 8041116:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 804111a:	6053      	str	r3, [r2, #4]
  
  /* Set ADC resolution */
  hadc->Instance->CR1 &= ~(ADC_CR1_RES);
 804111c:	6802      	ldr	r2, [r0, #0]
 804111e:	6853      	ldr	r3, [r2, #4]
 8041120:	f023 7340 	bic.w	r3, r3, #50331648	; 0x3000000
 8041124:	6053      	str	r3, [r2, #4]
  hadc->Instance->CR1 |=  hadc->Init.Resolution;
 8041126:	6802      	ldr	r2, [r0, #0]
 8041128:	6853      	ldr	r3, [r2, #4]
 804112a:	6881      	ldr	r1, [r0, #8]
 804112c:	430b      	orrs	r3, r1
 804112e:	6053      	str	r3, [r2, #4]
  
  /* Set ADC data alignment */
  hadc->Instance->CR2 &= ~(ADC_CR2_ALIGN);
 8041130:	6802      	ldr	r2, [r0, #0]
 8041132:	6893      	ldr	r3, [r2, #8]
 8041134:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8041138:	6093      	str	r3, [r2, #8]
  hadc->Instance->CR2 |= hadc->Init.DataAlign;
 804113a:	6802      	ldr	r2, [r0, #0]
 804113c:	6893      	ldr	r3, [r2, #8]
 804113e:	68c1      	ldr	r1, [r0, #12]
 8041140:	430b      	orrs	r3, r1
 8041142:	6093      	str	r3, [r2, #8]
  /* Enable external trigger if trigger selection is different of software  */
  /* start.                                                                 */
  /* Note: This configuration keeps the hardware feature of parameter       */
  /*       ExternalTrigConvEdge "trigger edge none" equivalent to           */
  /*       software start.                                                  */
  if(hadc->Init.ExternalTrigConv != ADC_SOFTWARE_START)
 8041144:	6a82      	ldr	r2, [r0, #40]	; 0x28
 8041146:	4b37      	ldr	r3, [pc, #220]	; (8041224 <ADC_Init+0x130>)
 8041148:	429a      	cmp	r2, r3
 804114a:	d057      	beq.n	80411fc <ADC_Init+0x108>
  {
    /* Select external trigger to start conversion */
    hadc->Instance->CR2 &= ~(ADC_CR2_EXTSEL);
 804114c:	6802      	ldr	r2, [r0, #0]
 804114e:	6893      	ldr	r3, [r2, #8]
 8041150:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
 8041154:	6093      	str	r3, [r2, #8]
    hadc->Instance->CR2 |= hadc->Init.ExternalTrigConv;
 8041156:	6802      	ldr	r2, [r0, #0]
 8041158:	6893      	ldr	r3, [r2, #8]
 804115a:	6a81      	ldr	r1, [r0, #40]	; 0x28
 804115c:	430b      	orrs	r3, r1
 804115e:	6093      	str	r3, [r2, #8]
    
    /* Select external trigger polarity */
    hadc->Instance->CR2 &= ~(ADC_CR2_EXTEN);
 8041160:	6802      	ldr	r2, [r0, #0]
 8041162:	6893      	ldr	r3, [r2, #8]
 8041164:	f023 5340 	bic.w	r3, r3, #805306368	; 0x30000000
 8041168:	6093      	str	r3, [r2, #8]
    hadc->Instance->CR2 |= hadc->Init.ExternalTrigConvEdge;
 804116a:	6802      	ldr	r2, [r0, #0]
 804116c:	6893      	ldr	r3, [r2, #8]
 804116e:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
 8041170:	430b      	orrs	r3, r1
 8041172:	6093      	str	r3, [r2, #8]
    hadc->Instance->CR2 &= ~(ADC_CR2_EXTSEL);
    hadc->Instance->CR2 &= ~(ADC_CR2_EXTEN);
  }
  
  /* Enable or disable ADC continuous conversion mode */
  hadc->Instance->CR2 &= ~(ADC_CR2_CONT);
 8041174:	6802      	ldr	r2, [r0, #0]
 8041176:	6893      	ldr	r3, [r2, #8]
 8041178:	f023 0302 	bic.w	r3, r3, #2
 804117c:	6093      	str	r3, [r2, #8]
  hadc->Instance->CR2 |= ADC_CR2_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode);
 804117e:	6802      	ldr	r2, [r0, #0]
 8041180:	6893      	ldr	r3, [r2, #8]
 8041182:	7e01      	ldrb	r1, [r0, #24]
 8041184:	ea43 0341 	orr.w	r3, r3, r1, lsl #1
 8041188:	6093      	str	r3, [r2, #8]
  
  if(hadc->Init.DiscontinuousConvMode != DISABLE)
 804118a:	f890 3020 	ldrb.w	r3, [r0, #32]
 804118e:	2b00      	cmp	r3, #0
 8041190:	d03f      	beq.n	8041212 <ADC_Init+0x11e>
  {
    assert_param(IS_ADC_REGULAR_DISC_NUMBER(hadc->Init.NbrOfDiscConversion));
  
    /* Enable the selected ADC regular discontinuous mode */
    hadc->Instance->CR1 |= (uint32_t)ADC_CR1_DISCEN;
 8041192:	6802      	ldr	r2, [r0, #0]
 8041194:	6853      	ldr	r3, [r2, #4]
 8041196:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 804119a:	6053      	str	r3, [r2, #4]
    
    /* Set the number of channels to be converted in discontinuous mode */
    hadc->Instance->CR1 &= ~(ADC_CR1_DISCNUM);
 804119c:	6802      	ldr	r2, [r0, #0]
 804119e:	6853      	ldr	r3, [r2, #4]
 80411a0:	f423 4360 	bic.w	r3, r3, #57344	; 0xe000
 80411a4:	6053      	str	r3, [r2, #4]
    hadc->Instance->CR1 |=  ADC_CR1_DISCONTINUOUS(hadc->Init.NbrOfDiscConversion);
 80411a6:	6801      	ldr	r1, [r0, #0]
 80411a8:	684b      	ldr	r3, [r1, #4]
 80411aa:	6a42      	ldr	r2, [r0, #36]	; 0x24
 80411ac:	3a01      	subs	r2, #1
 80411ae:	ea43 3342 	orr.w	r3, r3, r2, lsl #13
 80411b2:	604b      	str	r3, [r1, #4]
    /* Disable the selected ADC regular discontinuous mode */
    hadc->Instance->CR1 &= ~(ADC_CR1_DISCEN);
  }
  
  /* Set ADC number of conversion */
  hadc->Instance->SQR1 &= ~(ADC_SQR1_L);
 80411b4:	6802      	ldr	r2, [r0, #0]
 80411b6:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
 80411b8:	f423 0370 	bic.w	r3, r3, #15728640	; 0xf00000
 80411bc:	62d3      	str	r3, [r2, #44]	; 0x2c
  hadc->Instance->SQR1 |=  ADC_SQR1(hadc->Init.NbrOfConversion);
 80411be:	6801      	ldr	r1, [r0, #0]
 80411c0:	6acb      	ldr	r3, [r1, #44]	; 0x2c
 80411c2:	69c2      	ldr	r2, [r0, #28]
 80411c4:	3a01      	subs	r2, #1
 80411c6:	ea43 5302 	orr.w	r3, r3, r2, lsl #20
 80411ca:	62cb      	str	r3, [r1, #44]	; 0x2c
  
  /* Enable or disable ADC DMA continuous request */
  hadc->Instance->CR2 &= ~(ADC_CR2_DDS);
 80411cc:	6802      	ldr	r2, [r0, #0]
 80411ce:	6893      	ldr	r3, [r2, #8]
 80411d0:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 80411d4:	6093      	str	r3, [r2, #8]
  hadc->Instance->CR2 |= ADC_CR2_DMAContReq((uint32_t)hadc->Init.DMAContinuousRequests);
 80411d6:	6802      	ldr	r2, [r0, #0]
 80411d8:	6893      	ldr	r3, [r2, #8]
 80411da:	f890 1030 	ldrb.w	r1, [r0, #48]	; 0x30
 80411de:	ea43 2341 	orr.w	r3, r3, r1, lsl #9
 80411e2:	6093      	str	r3, [r2, #8]
  
  /* Enable or disable ADC end of conversion selection */
  hadc->Instance->CR2 &= ~(ADC_CR2_EOCS);
 80411e4:	6802      	ldr	r2, [r0, #0]
 80411e6:	6893      	ldr	r3, [r2, #8]
 80411e8:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 80411ec:	6093      	str	r3, [r2, #8]
  hadc->Instance->CR2 |= ADC_CR2_EOCSelection(hadc->Init.EOCSelection);
 80411ee:	6802      	ldr	r2, [r0, #0]
 80411f0:	6893      	ldr	r3, [r2, #8]
 80411f2:	6941      	ldr	r1, [r0, #20]
 80411f4:	ea43 2381 	orr.w	r3, r3, r1, lsl #10
 80411f8:	6093      	str	r3, [r2, #8]
}
 80411fa:	4770      	bx	lr
    hadc->Instance->CR2 &= ~(ADC_CR2_EXTSEL);
 80411fc:	6802      	ldr	r2, [r0, #0]
 80411fe:	6893      	ldr	r3, [r2, #8]
 8041200:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
 8041204:	6093      	str	r3, [r2, #8]
    hadc->Instance->CR2 &= ~(ADC_CR2_EXTEN);
 8041206:	6802      	ldr	r2, [r0, #0]
 8041208:	6893      	ldr	r3, [r2, #8]
 804120a:	f023 5340 	bic.w	r3, r3, #805306368	; 0x30000000
 804120e:	6093      	str	r3, [r2, #8]
 8041210:	e7b0      	b.n	8041174 <ADC_Init+0x80>
    hadc->Instance->CR1 &= ~(ADC_CR1_DISCEN);
 8041212:	6802      	ldr	r2, [r0, #0]
 8041214:	6853      	ldr	r3, [r2, #4]
 8041216:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 804121a:	6053      	str	r3, [r2, #4]
 804121c:	e7ca      	b.n	80411b4 <ADC_Init+0xc0>
 804121e:	bf00      	nop
 8041220:	40012300 	.word	0x40012300
 8041224:	0f000001 	.word	0x0f000001

08041228 <HAL_ADC_Init>:
  if(hadc == NULL)
 8041228:	b338      	cbz	r0, 804127a <HAL_ADC_Init+0x52>
{
 804122a:	b510      	push	{r4, lr}
 804122c:	4604      	mov	r4, r0
  if(hadc->State == HAL_ADC_STATE_RESET)
 804122e:	6c03      	ldr	r3, [r0, #64]	; 0x40
 8041230:	b143      	cbz	r3, 8041244 <HAL_ADC_Init+0x1c>
  if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL))
 8041232:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8041234:	f013 0f10 	tst.w	r3, #16
 8041238:	d00b      	beq.n	8041252 <HAL_ADC_Init+0x2a>
    tmp_hal_status = HAL_ERROR;
 804123a:	2001      	movs	r0, #1
  __HAL_UNLOCK(hadc);
 804123c:	2300      	movs	r3, #0
 804123e:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c
}
 8041242:	bd10      	pop	{r4, pc}
    HAL_ADC_MspInit(hadc);
 8041244:	f00a fa86 	bl	804b754 <HAL_ADC_MspInit>
    ADC_CLEAR_ERRORCODE(hadc);
 8041248:	2300      	movs	r3, #0
 804124a:	6463      	str	r3, [r4, #68]	; 0x44
    hadc->Lock = HAL_UNLOCKED;
 804124c:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c
 8041250:	e7ef      	b.n	8041232 <HAL_ADC_Init+0xa>
    ADC_STATE_CLR_SET(hadc->State,
 8041252:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8041254:	f423 5388 	bic.w	r3, r3, #4352	; 0x1100
 8041258:	f023 0302 	bic.w	r3, r3, #2
 804125c:	f043 0302 	orr.w	r3, r3, #2
 8041260:	6423      	str	r3, [r4, #64]	; 0x40
    ADC_Init(hadc);
 8041262:	4620      	mov	r0, r4
 8041264:	f7ff ff46 	bl	80410f4 <ADC_Init>
    ADC_CLEAR_ERRORCODE(hadc);
 8041268:	2000      	movs	r0, #0
 804126a:	6460      	str	r0, [r4, #68]	; 0x44
    ADC_STATE_CLR_SET(hadc->State,
 804126c:	6c23      	ldr	r3, [r4, #64]	; 0x40
 804126e:	f023 0303 	bic.w	r3, r3, #3
 8041272:	f043 0301 	orr.w	r3, r3, #1
 8041276:	6423      	str	r3, [r4, #64]	; 0x40
 8041278:	e7e0      	b.n	804123c <HAL_ADC_Init+0x14>
    return HAL_ERROR;
 804127a:	2001      	movs	r0, #1
}
 804127c:	4770      	bx	lr
	...

08041280 <HAL_ADC_Start_IT>:
{
 8041280:	b082      	sub	sp, #8
  __IO uint32_t counter = 0U;
 8041282:	2300      	movs	r3, #0
 8041284:	9301      	str	r3, [sp, #4]
  __HAL_LOCK(hadc);
 8041286:	f890 303c 	ldrb.w	r3, [r0, #60]	; 0x3c
 804128a:	2b01      	cmp	r3, #1
 804128c:	f000 8085 	beq.w	804139a <HAL_ADC_Start_IT+0x11a>
 8041290:	2301      	movs	r3, #1
 8041292:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
  if((hadc->Instance->CR2 & ADC_CR2_ADON) != ADC_CR2_ADON)
 8041296:	6803      	ldr	r3, [r0, #0]
 8041298:	689a      	ldr	r2, [r3, #8]
 804129a:	f012 0f01 	tst.w	r2, #1
 804129e:	d113      	bne.n	80412c8 <HAL_ADC_Start_IT+0x48>
    __HAL_ADC_ENABLE(hadc);
 80412a0:	689a      	ldr	r2, [r3, #8]
 80412a2:	f042 0201 	orr.w	r2, r2, #1
 80412a6:	609a      	str	r2, [r3, #8]
    counter = (ADC_STAB_DELAY_US * (SystemCoreClock / 1000000U));
 80412a8:	4b40      	ldr	r3, [pc, #256]	; (80413ac <HAL_ADC_Start_IT+0x12c>)
 80412aa:	681b      	ldr	r3, [r3, #0]
 80412ac:	4a40      	ldr	r2, [pc, #256]	; (80413b0 <HAL_ADC_Start_IT+0x130>)
 80412ae:	fba2 2303 	umull	r2, r3, r2, r3
 80412b2:	0c9b      	lsrs	r3, r3, #18
 80412b4:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 80412b8:	9301      	str	r3, [sp, #4]
    while(counter != 0U)
 80412ba:	e002      	b.n	80412c2 <HAL_ADC_Start_IT+0x42>
      counter--;
 80412bc:	9b01      	ldr	r3, [sp, #4]
 80412be:	3b01      	subs	r3, #1
 80412c0:	9301      	str	r3, [sp, #4]
    while(counter != 0U)
 80412c2:	9b01      	ldr	r3, [sp, #4]
 80412c4:	2b00      	cmp	r3, #0
 80412c6:	d1f9      	bne.n	80412bc <HAL_ADC_Start_IT+0x3c>
  if(HAL_IS_BIT_SET(hadc->Instance->CR2, ADC_CR2_ADON))
 80412c8:	6802      	ldr	r2, [r0, #0]
 80412ca:	6893      	ldr	r3, [r2, #8]
 80412cc:	f013 0f01 	tst.w	r3, #1
 80412d0:	d065      	beq.n	804139e <HAL_ADC_Start_IT+0x11e>
    ADC_STATE_CLR_SET(hadc->State,
 80412d2:	6c03      	ldr	r3, [r0, #64]	; 0x40
 80412d4:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 80412d8:	f023 0301 	bic.w	r3, r3, #1
 80412dc:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80412e0:	6403      	str	r3, [r0, #64]	; 0x40
    if (READ_BIT(hadc->Instance->CR1, ADC_CR1_JAUTO) != RESET)
 80412e2:	6853      	ldr	r3, [r2, #4]
 80412e4:	f413 6f80 	tst.w	r3, #1024	; 0x400
 80412e8:	d005      	beq.n	80412f6 <HAL_ADC_Start_IT+0x76>
      ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_INJ_EOC, HAL_ADC_STATE_INJ_BUSY);  
 80412ea:	6c03      	ldr	r3, [r0, #64]	; 0x40
 80412ec:	f423 5340 	bic.w	r3, r3, #12288	; 0x3000
 80412f0:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 80412f4:	6403      	str	r3, [r0, #64]	; 0x40
    if (HAL_IS_BIT_SET(hadc->State, HAL_ADC_STATE_INJ_BUSY))
 80412f6:	6c03      	ldr	r3, [r0, #64]	; 0x40
 80412f8:	f413 5f80 	tst.w	r3, #4096	; 0x1000
 80412fc:	d022      	beq.n	8041344 <HAL_ADC_Start_IT+0xc4>
      CLEAR_BIT(hadc->ErrorCode, (HAL_ADC_ERROR_OVR | HAL_ADC_ERROR_DMA));         
 80412fe:	6c43      	ldr	r3, [r0, #68]	; 0x44
 8041300:	f023 0306 	bic.w	r3, r3, #6
 8041304:	6443      	str	r3, [r0, #68]	; 0x44
    __HAL_UNLOCK(hadc);
 8041306:	2300      	movs	r3, #0
 8041308:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
    __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_EOC | ADC_FLAG_OVR);
 804130c:	f06f 0322 	mvn.w	r3, #34	; 0x22
 8041310:	6013      	str	r3, [r2, #0]
    __HAL_ADC_ENABLE_IT(hadc, (ADC_IT_EOC | ADC_IT_OVR));
 8041312:	6802      	ldr	r2, [r0, #0]
 8041314:	6853      	ldr	r3, [r2, #4]
 8041316:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
 804131a:	f043 0320 	orr.w	r3, r3, #32
 804131e:	6053      	str	r3, [r2, #4]
    if(HAL_IS_BIT_CLR(tmpADC_Common->CCR, ADC_CCR_MULTI))
 8041320:	4b24      	ldr	r3, [pc, #144]	; (80413b4 <HAL_ADC_Start_IT+0x134>)
 8041322:	685b      	ldr	r3, [r3, #4]
 8041324:	f013 0f1f 	tst.w	r3, #31
 8041328:	d127      	bne.n	804137a <HAL_ADC_Start_IT+0xfa>
      if((hadc->Instance == ADC1) || ((hadc->Instance == ADC2) && ((ADC->CCR & ADC_CCR_MULTI_Msk) < ADC_CCR_MULTI_0)) \
 804132a:	6803      	ldr	r3, [r0, #0]
 804132c:	4a22      	ldr	r2, [pc, #136]	; (80413b8 <HAL_ADC_Start_IT+0x138>)
 804132e:	4293      	cmp	r3, r2
 8041330:	d011      	beq.n	8041356 <HAL_ADC_Start_IT+0xd6>
 8041332:	f502 7280 	add.w	r2, r2, #256	; 0x100
 8041336:	4293      	cmp	r3, r2
 8041338:	d007      	beq.n	804134a <HAL_ADC_Start_IT+0xca>
                                  || ((hadc->Instance == ADC3) && ((ADC->CCR & ADC_CCR_MULTI_Msk) < ADC_CCR_MULTI_4)))
 804133a:	4a20      	ldr	r2, [pc, #128]	; (80413bc <HAL_ADC_Start_IT+0x13c>)
 804133c:	4293      	cmp	r3, r2
 804133e:	d014      	beq.n	804136a <HAL_ADC_Start_IT+0xea>
  return HAL_OK;
 8041340:	2000      	movs	r0, #0
 8041342:	e02d      	b.n	80413a0 <HAL_ADC_Start_IT+0x120>
      ADC_CLEAR_ERRORCODE(hadc);
 8041344:	2300      	movs	r3, #0
 8041346:	6443      	str	r3, [r0, #68]	; 0x44
 8041348:	e7dd      	b.n	8041306 <HAL_ADC_Start_IT+0x86>
      if((hadc->Instance == ADC1) || ((hadc->Instance == ADC2) && ((ADC->CCR & ADC_CCR_MULTI_Msk) < ADC_CCR_MULTI_0)) \
 804134a:	f502 7200 	add.w	r2, r2, #512	; 0x200
 804134e:	6852      	ldr	r2, [r2, #4]
 8041350:	f012 0f1f 	tst.w	r2, #31
 8041354:	d1f1      	bne.n	804133a <HAL_ADC_Start_IT+0xba>
        if((hadc->Instance->CR2 & ADC_CR2_EXTEN) == RESET) 
 8041356:	689a      	ldr	r2, [r3, #8]
 8041358:	f012 5f40 	tst.w	r2, #805306368	; 0x30000000
 804135c:	d122      	bne.n	80413a4 <HAL_ADC_Start_IT+0x124>
          hadc->Instance->CR2 |= (uint32_t)ADC_CR2_SWSTART;
 804135e:	689a      	ldr	r2, [r3, #8]
 8041360:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
 8041364:	609a      	str	r2, [r3, #8]
  return HAL_OK;
 8041366:	2000      	movs	r0, #0
 8041368:	e01a      	b.n	80413a0 <HAL_ADC_Start_IT+0x120>
                                  || ((hadc->Instance == ADC3) && ((ADC->CCR & ADC_CCR_MULTI_Msk) < ADC_CCR_MULTI_4)))
 804136a:	f502 7280 	add.w	r2, r2, #256	; 0x100
 804136e:	6852      	ldr	r2, [r2, #4]
 8041370:	f012 0f10 	tst.w	r2, #16
 8041374:	d0ef      	beq.n	8041356 <HAL_ADC_Start_IT+0xd6>
  return HAL_OK;
 8041376:	2000      	movs	r0, #0
 8041378:	e012      	b.n	80413a0 <HAL_ADC_Start_IT+0x120>
      if((hadc->Instance == ADC1) && ((hadc->Instance->CR2 & ADC_CR2_EXTEN) == RESET))
 804137a:	6803      	ldr	r3, [r0, #0]
 804137c:	4a0e      	ldr	r2, [pc, #56]	; (80413b8 <HAL_ADC_Start_IT+0x138>)
 804137e:	4293      	cmp	r3, r2
 8041380:	d001      	beq.n	8041386 <HAL_ADC_Start_IT+0x106>
  return HAL_OK;
 8041382:	2000      	movs	r0, #0
 8041384:	e00c      	b.n	80413a0 <HAL_ADC_Start_IT+0x120>
      if((hadc->Instance == ADC1) && ((hadc->Instance->CR2 & ADC_CR2_EXTEN) == RESET))
 8041386:	689a      	ldr	r2, [r3, #8]
 8041388:	f012 5f40 	tst.w	r2, #805306368	; 0x30000000
 804138c:	d10c      	bne.n	80413a8 <HAL_ADC_Start_IT+0x128>
          hadc->Instance->CR2 |= (uint32_t)ADC_CR2_SWSTART;
 804138e:	689a      	ldr	r2, [r3, #8]
 8041390:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
 8041394:	609a      	str	r2, [r3, #8]
  return HAL_OK;
 8041396:	2000      	movs	r0, #0
 8041398:	e002      	b.n	80413a0 <HAL_ADC_Start_IT+0x120>
  __HAL_LOCK(hadc);
 804139a:	2002      	movs	r0, #2
 804139c:	e000      	b.n	80413a0 <HAL_ADC_Start_IT+0x120>
  return HAL_OK;
 804139e:	2000      	movs	r0, #0
}
 80413a0:	b002      	add	sp, #8
 80413a2:	4770      	bx	lr
  return HAL_OK;
 80413a4:	2000      	movs	r0, #0
 80413a6:	e7fb      	b.n	80413a0 <HAL_ADC_Start_IT+0x120>
 80413a8:	2000      	movs	r0, #0
 80413aa:	e7f9      	b.n	80413a0 <HAL_ADC_Start_IT+0x120>
 80413ac:	20003678 	.word	0x20003678
 80413b0:	431bde83 	.word	0x431bde83
 80413b4:	40012300 	.word	0x40012300
 80413b8:	40012000 	.word	0x40012000
 80413bc:	40012200 	.word	0x40012200

080413c0 <HAL_ADC_Start_DMA>:
{
 80413c0:	b530      	push	{r4, r5, lr}
 80413c2:	b083      	sub	sp, #12
 80413c4:	4613      	mov	r3, r2
  __IO uint32_t counter = 0U;
 80413c6:	2200      	movs	r2, #0
 80413c8:	9201      	str	r2, [sp, #4]
  __HAL_LOCK(hadc);
 80413ca:	f890 203c 	ldrb.w	r2, [r0, #60]	; 0x3c
 80413ce:	2a01      	cmp	r2, #1
 80413d0:	f000 809a 	beq.w	8041508 <HAL_ADC_Start_DMA+0x148>
 80413d4:	4605      	mov	r5, r0
 80413d6:	2201      	movs	r2, #1
 80413d8:	f880 203c 	strb.w	r2, [r0, #60]	; 0x3c
  if((hadc->Instance->CR2 & ADC_CR2_ADON) != ADC_CR2_ADON)
 80413dc:	6802      	ldr	r2, [r0, #0]
 80413de:	6890      	ldr	r0, [r2, #8]
 80413e0:	f010 0f01 	tst.w	r0, #1
 80413e4:	d113      	bne.n	804140e <HAL_ADC_Start_DMA+0x4e>
    __HAL_ADC_ENABLE(hadc);
 80413e6:	6890      	ldr	r0, [r2, #8]
 80413e8:	f040 0001 	orr.w	r0, r0, #1
 80413ec:	6090      	str	r0, [r2, #8]
    counter = (ADC_STAB_DELAY_US * (SystemCoreClock / 1000000U));
 80413ee:	4a4b      	ldr	r2, [pc, #300]	; (804151c <HAL_ADC_Start_DMA+0x15c>)
 80413f0:	6810      	ldr	r0, [r2, #0]
 80413f2:	4a4b      	ldr	r2, [pc, #300]	; (8041520 <HAL_ADC_Start_DMA+0x160>)
 80413f4:	fba2 2000 	umull	r2, r0, r2, r0
 80413f8:	0c80      	lsrs	r0, r0, #18
 80413fa:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 80413fe:	9001      	str	r0, [sp, #4]
    while(counter != 0U)
 8041400:	e002      	b.n	8041408 <HAL_ADC_Start_DMA+0x48>
      counter--;
 8041402:	9c01      	ldr	r4, [sp, #4]
 8041404:	3c01      	subs	r4, #1
 8041406:	9401      	str	r4, [sp, #4]
    while(counter != 0U)
 8041408:	9801      	ldr	r0, [sp, #4]
 804140a:	2800      	cmp	r0, #0
 804140c:	d1f9      	bne.n	8041402 <HAL_ADC_Start_DMA+0x42>
  if(HAL_IS_BIT_SET(hadc->Instance->CR2, ADC_CR2_ADON))
 804140e:	682a      	ldr	r2, [r5, #0]
 8041410:	6890      	ldr	r0, [r2, #8]
 8041412:	f010 0f01 	tst.w	r0, #1
 8041416:	d079      	beq.n	804150c <HAL_ADC_Start_DMA+0x14c>
    ADC_STATE_CLR_SET(hadc->State,
 8041418:	6c28      	ldr	r0, [r5, #64]	; 0x40
 804141a:	f420 60e0 	bic.w	r0, r0, #1792	; 0x700
 804141e:	f020 0001 	bic.w	r0, r0, #1
 8041422:	f440 7080 	orr.w	r0, r0, #256	; 0x100
 8041426:	6428      	str	r0, [r5, #64]	; 0x40
    if (READ_BIT(hadc->Instance->CR1, ADC_CR1_JAUTO) != RESET)
 8041428:	6852      	ldr	r2, [r2, #4]
 804142a:	f412 6f80 	tst.w	r2, #1024	; 0x400
 804142e:	d005      	beq.n	804143c <HAL_ADC_Start_DMA+0x7c>
      ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_INJ_EOC, HAL_ADC_STATE_INJ_BUSY);  
 8041430:	6c2a      	ldr	r2, [r5, #64]	; 0x40
 8041432:	f422 5240 	bic.w	r2, r2, #12288	; 0x3000
 8041436:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 804143a:	642a      	str	r2, [r5, #64]	; 0x40
    if (HAL_IS_BIT_SET(hadc->State, HAL_ADC_STATE_INJ_BUSY))
 804143c:	6c2a      	ldr	r2, [r5, #64]	; 0x40
 804143e:	f412 5f80 	tst.w	r2, #4096	; 0x1000
 8041442:	d036      	beq.n	80414b2 <HAL_ADC_Start_DMA+0xf2>
      CLEAR_BIT(hadc->ErrorCode, (HAL_ADC_ERROR_OVR | HAL_ADC_ERROR_DMA));         
 8041444:	6c6a      	ldr	r2, [r5, #68]	; 0x44
 8041446:	f022 0206 	bic.w	r2, r2, #6
 804144a:	646a      	str	r2, [r5, #68]	; 0x44
    __HAL_UNLOCK(hadc);   
 804144c:	2200      	movs	r2, #0
 804144e:	f885 203c 	strb.w	r2, [r5, #60]	; 0x3c
    hadc->DMA_Handle->XferCpltCallback = ADC_DMAConvCplt;
 8041452:	6baa      	ldr	r2, [r5, #56]	; 0x38
 8041454:	4833      	ldr	r0, [pc, #204]	; (8041524 <HAL_ADC_Start_DMA+0x164>)
 8041456:	63d0      	str	r0, [r2, #60]	; 0x3c
    hadc->DMA_Handle->XferHalfCpltCallback = ADC_DMAHalfConvCplt;
 8041458:	6baa      	ldr	r2, [r5, #56]	; 0x38
 804145a:	4833      	ldr	r0, [pc, #204]	; (8041528 <HAL_ADC_Start_DMA+0x168>)
 804145c:	6410      	str	r0, [r2, #64]	; 0x40
    hadc->DMA_Handle->XferErrorCallback = ADC_DMAError;
 804145e:	6baa      	ldr	r2, [r5, #56]	; 0x38
 8041460:	4832      	ldr	r0, [pc, #200]	; (804152c <HAL_ADC_Start_DMA+0x16c>)
 8041462:	64d0      	str	r0, [r2, #76]	; 0x4c
    __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_EOC | ADC_FLAG_OVR);
 8041464:	682a      	ldr	r2, [r5, #0]
 8041466:	f06f 0022 	mvn.w	r0, #34	; 0x22
 804146a:	6010      	str	r0, [r2, #0]
    __HAL_ADC_ENABLE_IT(hadc, ADC_IT_OVR);
 804146c:	6828      	ldr	r0, [r5, #0]
 804146e:	6842      	ldr	r2, [r0, #4]
 8041470:	f042 6280 	orr.w	r2, r2, #67108864	; 0x4000000
 8041474:	6042      	str	r2, [r0, #4]
    hadc->Instance->CR2 |= ADC_CR2_DMA;
 8041476:	6828      	ldr	r0, [r5, #0]
 8041478:	6882      	ldr	r2, [r0, #8]
 804147a:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 804147e:	6082      	str	r2, [r0, #8]
    HAL_DMA_Start_IT(hadc->DMA_Handle, (uint32_t)&hadc->Instance->DR, (uint32_t)pData, Length);
 8041480:	6828      	ldr	r0, [r5, #0]
 8041482:	460a      	mov	r2, r1
 8041484:	f100 014c 	add.w	r1, r0, #76	; 0x4c
 8041488:	6ba8      	ldr	r0, [r5, #56]	; 0x38
 804148a:	f000 fb81 	bl	8041b90 <HAL_DMA_Start_IT>
    if(HAL_IS_BIT_CLR(tmpADC_Common->CCR, ADC_CCR_MULTI))
 804148e:	4b28      	ldr	r3, [pc, #160]	; (8041530 <HAL_ADC_Start_DMA+0x170>)
 8041490:	685b      	ldr	r3, [r3, #4]
 8041492:	f013 0f1f 	tst.w	r3, #31
 8041496:	d127      	bne.n	80414e8 <HAL_ADC_Start_DMA+0x128>
      if((hadc->Instance == ADC1) || ((hadc->Instance == ADC2) && ((ADC->CCR & ADC_CCR_MULTI_Msk) < ADC_CCR_MULTI_0)) \
 8041498:	682b      	ldr	r3, [r5, #0]
 804149a:	4a26      	ldr	r2, [pc, #152]	; (8041534 <HAL_ADC_Start_DMA+0x174>)
 804149c:	4293      	cmp	r3, r2
 804149e:	d011      	beq.n	80414c4 <HAL_ADC_Start_DMA+0x104>
 80414a0:	f502 7280 	add.w	r2, r2, #256	; 0x100
 80414a4:	4293      	cmp	r3, r2
 80414a6:	d007      	beq.n	80414b8 <HAL_ADC_Start_DMA+0xf8>
                                  || ((hadc->Instance == ADC3) && ((ADC->CCR & ADC_CCR_MULTI_Msk) < ADC_CCR_MULTI_4)))
 80414a8:	4a23      	ldr	r2, [pc, #140]	; (8041538 <HAL_ADC_Start_DMA+0x178>)
 80414aa:	4293      	cmp	r3, r2
 80414ac:	d014      	beq.n	80414d8 <HAL_ADC_Start_DMA+0x118>
  return HAL_OK;
 80414ae:	2000      	movs	r0, #0
 80414b0:	e02d      	b.n	804150e <HAL_ADC_Start_DMA+0x14e>
      ADC_CLEAR_ERRORCODE(hadc);
 80414b2:	2200      	movs	r2, #0
 80414b4:	646a      	str	r2, [r5, #68]	; 0x44
 80414b6:	e7c9      	b.n	804144c <HAL_ADC_Start_DMA+0x8c>
      if((hadc->Instance == ADC1) || ((hadc->Instance == ADC2) && ((ADC->CCR & ADC_CCR_MULTI_Msk) < ADC_CCR_MULTI_0)) \
 80414b8:	f502 7200 	add.w	r2, r2, #512	; 0x200
 80414bc:	6852      	ldr	r2, [r2, #4]
 80414be:	f012 0f1f 	tst.w	r2, #31
 80414c2:	d1f1      	bne.n	80414a8 <HAL_ADC_Start_DMA+0xe8>
        if((hadc->Instance->CR2 & ADC_CR2_EXTEN) == RESET) 
 80414c4:	689a      	ldr	r2, [r3, #8]
 80414c6:	f012 5f40 	tst.w	r2, #805306368	; 0x30000000
 80414ca:	d122      	bne.n	8041512 <HAL_ADC_Start_DMA+0x152>
          hadc->Instance->CR2 |= (uint32_t)ADC_CR2_SWSTART;
 80414cc:	689a      	ldr	r2, [r3, #8]
 80414ce:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
 80414d2:	609a      	str	r2, [r3, #8]
  return HAL_OK;
 80414d4:	2000      	movs	r0, #0
 80414d6:	e01a      	b.n	804150e <HAL_ADC_Start_DMA+0x14e>
                                  || ((hadc->Instance == ADC3) && ((ADC->CCR & ADC_CCR_MULTI_Msk) < ADC_CCR_MULTI_4)))
 80414d8:	f502 7280 	add.w	r2, r2, #256	; 0x100
 80414dc:	6852      	ldr	r2, [r2, #4]
 80414de:	f012 0f10 	tst.w	r2, #16
 80414e2:	d0ef      	beq.n	80414c4 <HAL_ADC_Start_DMA+0x104>
  return HAL_OK;
 80414e4:	2000      	movs	r0, #0
 80414e6:	e012      	b.n	804150e <HAL_ADC_Start_DMA+0x14e>
      if((hadc->Instance == ADC1) && ((hadc->Instance->CR2 & ADC_CR2_EXTEN) == RESET))
 80414e8:	682b      	ldr	r3, [r5, #0]
 80414ea:	4a12      	ldr	r2, [pc, #72]	; (8041534 <HAL_ADC_Start_DMA+0x174>)
 80414ec:	4293      	cmp	r3, r2
 80414ee:	d001      	beq.n	80414f4 <HAL_ADC_Start_DMA+0x134>
  return HAL_OK;
 80414f0:	2000      	movs	r0, #0
 80414f2:	e00c      	b.n	804150e <HAL_ADC_Start_DMA+0x14e>
      if((hadc->Instance == ADC1) && ((hadc->Instance->CR2 & ADC_CR2_EXTEN) == RESET))
 80414f4:	689a      	ldr	r2, [r3, #8]
 80414f6:	f012 5f40 	tst.w	r2, #805306368	; 0x30000000
 80414fa:	d10c      	bne.n	8041516 <HAL_ADC_Start_DMA+0x156>
          hadc->Instance->CR2 |= (uint32_t)ADC_CR2_SWSTART;
 80414fc:	689a      	ldr	r2, [r3, #8]
 80414fe:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
 8041502:	609a      	str	r2, [r3, #8]
  return HAL_OK;
 8041504:	2000      	movs	r0, #0
 8041506:	e002      	b.n	804150e <HAL_ADC_Start_DMA+0x14e>
  __HAL_LOCK(hadc);
 8041508:	2002      	movs	r0, #2
 804150a:	e000      	b.n	804150e <HAL_ADC_Start_DMA+0x14e>
  return HAL_OK;
 804150c:	2000      	movs	r0, #0
}
 804150e:	b003      	add	sp, #12
 8041510:	bd30      	pop	{r4, r5, pc}
  return HAL_OK;
 8041512:	2000      	movs	r0, #0
 8041514:	e7fb      	b.n	804150e <HAL_ADC_Start_DMA+0x14e>
 8041516:	2000      	movs	r0, #0
 8041518:	e7f9      	b.n	804150e <HAL_ADC_Start_DMA+0x14e>
 804151a:	bf00      	nop
 804151c:	20003678 	.word	0x20003678
 8041520:	431bde83 	.word	0x431bde83
 8041524:	080416b1 	.word	0x080416b1
 8041528:	0804153f 	.word	0x0804153f
 804152c:	0804169b 	.word	0x0804169b
 8041530:	40012300 	.word	0x40012300
 8041534:	40012000 	.word	0x40012000
 8041538:	40012200 	.word	0x40012200

0804153c <HAL_ADC_ConvHalfCpltCallback>:
}
 804153c:	4770      	bx	lr

0804153e <ADC_DMAHalfConvCplt>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *                the configuration information for the specified DMA module.
  * @retval None
  */
static void ADC_DMAHalfConvCplt(DMA_HandleTypeDef *hdma)   
{
 804153e:	b508      	push	{r3, lr}
  ADC_HandleTypeDef* hadc = ( ADC_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   /* Half conversion callback */
#if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
  hadc->ConvHalfCpltCallback(hadc);
#else
  HAL_ADC_ConvHalfCpltCallback(hadc);
 8041540:	6b80      	ldr	r0, [r0, #56]	; 0x38
 8041542:	f7ff fffb 	bl	804153c <HAL_ADC_ConvHalfCpltCallback>
#endif /* USE_HAL_ADC_REGISTER_CALLBACKS */
}
 8041546:	bd08      	pop	{r3, pc}

08041548 <HAL_ADC_LevelOutOfWindowCallback>:
}
 8041548:	4770      	bx	lr

0804154a <HAL_ADC_ErrorCallback>:
}
 804154a:	4770      	bx	lr

0804154c <HAL_ADC_IRQHandler>:
{
 804154c:	b538      	push	{r3, r4, r5, lr}
 804154e:	4604      	mov	r4, r0
  tmp1 = __HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOC);
 8041550:	6802      	ldr	r2, [r0, #0]
 8041552:	6811      	ldr	r1, [r2, #0]
  tmp2 = __HAL_ADC_GET_IT_SOURCE(hadc, ADC_IT_EOC);
 8041554:	6853      	ldr	r3, [r2, #4]
  if(tmp1 && tmp2)
 8041556:	f011 0f02 	tst.w	r1, #2
 804155a:	d02f      	beq.n	80415bc <HAL_ADC_IRQHandler+0x70>
 804155c:	f003 0320 	and.w	r3, r3, #32
 8041560:	b363      	cbz	r3, 80415bc <HAL_ADC_IRQHandler+0x70>
    if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL))
 8041562:	6c03      	ldr	r3, [r0, #64]	; 0x40
 8041564:	f013 0f10 	tst.w	r3, #16
 8041568:	d103      	bne.n	8041572 <HAL_ADC_IRQHandler+0x26>
      SET_BIT(hadc->State, HAL_ADC_STATE_REG_EOC); 
 804156a:	6c03      	ldr	r3, [r0, #64]	; 0x40
 804156c:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8041570:	6403      	str	r3, [r0, #64]	; 0x40
    if(ADC_IS_SOFTWARE_START_REGULAR(hadc)                   &&
 8041572:	6893      	ldr	r3, [r2, #8]
 8041574:	f013 5f40 	tst.w	r3, #805306368	; 0x30000000
 8041578:	d119      	bne.n	80415ae <HAL_ADC_IRQHandler+0x62>
       (hadc->Init.ContinuousConvMode == DISABLE)            &&
 804157a:	7e23      	ldrb	r3, [r4, #24]
    if(ADC_IS_SOFTWARE_START_REGULAR(hadc)                   &&
 804157c:	b9bb      	cbnz	r3, 80415ae <HAL_ADC_IRQHandler+0x62>
       (HAL_IS_BIT_CLR(hadc->Instance->SQR1, ADC_SQR1_L) || 
 804157e:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
       (hadc->Init.ContinuousConvMode == DISABLE)            &&
 8041580:	f413 0f70 	tst.w	r3, #15728640	; 0xf00000
 8041584:	d003      	beq.n	804158e <HAL_ADC_IRQHandler+0x42>
        HAL_IS_BIT_CLR(hadc->Instance->CR2, ADC_CR2_EOCS)  )   )
 8041586:	6893      	ldr	r3, [r2, #8]
       (HAL_IS_BIT_CLR(hadc->Instance->SQR1, ADC_SQR1_L) || 
 8041588:	f413 6f80 	tst.w	r3, #1024	; 0x400
 804158c:	d10f      	bne.n	80415ae <HAL_ADC_IRQHandler+0x62>
      __HAL_ADC_DISABLE_IT(hadc, ADC_IT_EOC);
 804158e:	6853      	ldr	r3, [r2, #4]
 8041590:	f023 0320 	bic.w	r3, r3, #32
 8041594:	6053      	str	r3, [r2, #4]
      CLEAR_BIT(hadc->State, HAL_ADC_STATE_REG_BUSY);
 8041596:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8041598:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 804159c:	6423      	str	r3, [r4, #64]	; 0x40
      if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_INJ_BUSY))
 804159e:	6c23      	ldr	r3, [r4, #64]	; 0x40
 80415a0:	f413 5f80 	tst.w	r3, #4096	; 0x1000
 80415a4:	d103      	bne.n	80415ae <HAL_ADC_IRQHandler+0x62>
        SET_BIT(hadc->State, HAL_ADC_STATE_READY);
 80415a6:	6c23      	ldr	r3, [r4, #64]	; 0x40
 80415a8:	f043 0301 	orr.w	r3, r3, #1
 80415ac:	6423      	str	r3, [r4, #64]	; 0x40
    HAL_ADC_ConvCpltCallback(hadc);
 80415ae:	4620      	mov	r0, r4
 80415b0:	f00f fac8 	bl	8050b44 <HAL_ADC_ConvCpltCallback>
    __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_STRT | ADC_FLAG_EOC);
 80415b4:	6823      	ldr	r3, [r4, #0]
 80415b6:	f06f 0212 	mvn.w	r2, #18
 80415ba:	601a      	str	r2, [r3, #0]
  tmp1 = __HAL_ADC_GET_FLAG(hadc, ADC_FLAG_JEOC);
 80415bc:	6823      	ldr	r3, [r4, #0]
 80415be:	6819      	ldr	r1, [r3, #0]
  tmp2 = __HAL_ADC_GET_IT_SOURCE(hadc, ADC_IT_JEOC);                               
 80415c0:	685a      	ldr	r2, [r3, #4]
 80415c2:	f002 0280 	and.w	r2, r2, #128	; 0x80
  if(tmp1 && tmp2)
 80415c6:	f011 0f04 	tst.w	r1, #4
 80415ca:	d036      	beq.n	804163a <HAL_ADC_IRQHandler+0xee>
 80415cc:	2a00      	cmp	r2, #0
 80415ce:	d034      	beq.n	804163a <HAL_ADC_IRQHandler+0xee>
    if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL))
 80415d0:	6c22      	ldr	r2, [r4, #64]	; 0x40
 80415d2:	f012 0f10 	tst.w	r2, #16
 80415d6:	d103      	bne.n	80415e0 <HAL_ADC_IRQHandler+0x94>
      SET_BIT(hadc->State, HAL_ADC_STATE_INJ_EOC);
 80415d8:	6c22      	ldr	r2, [r4, #64]	; 0x40
 80415da:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 80415de:	6422      	str	r2, [r4, #64]	; 0x40
    if(ADC_IS_SOFTWARE_START_INJECTED(hadc)                    &&
 80415e0:	689a      	ldr	r2, [r3, #8]
 80415e2:	f412 1f40 	tst.w	r2, #3145728	; 0x300000
 80415e6:	d121      	bne.n	804162c <HAL_ADC_IRQHandler+0xe0>
       (HAL_IS_BIT_CLR(hadc->Instance->JSQR, ADC_JSQR_JL)  ||
 80415e8:	6b9a      	ldr	r2, [r3, #56]	; 0x38
    if(ADC_IS_SOFTWARE_START_INJECTED(hadc)                    &&
 80415ea:	f412 1f40 	tst.w	r2, #3145728	; 0x300000
 80415ee:	d003      	beq.n	80415f8 <HAL_ADC_IRQHandler+0xac>
        HAL_IS_BIT_CLR(hadc->Instance->CR2, ADC_CR2_EOCS)    ) &&
 80415f0:	689a      	ldr	r2, [r3, #8]
       (HAL_IS_BIT_CLR(hadc->Instance->JSQR, ADC_JSQR_JL)  ||
 80415f2:	f412 6f80 	tst.w	r2, #1024	; 0x400
 80415f6:	d119      	bne.n	804162c <HAL_ADC_IRQHandler+0xe0>
       (HAL_IS_BIT_CLR(hadc->Instance->CR1, ADC_CR1_JAUTO) &&
 80415f8:	685a      	ldr	r2, [r3, #4]
        HAL_IS_BIT_CLR(hadc->Instance->CR2, ADC_CR2_EOCS)    ) &&
 80415fa:	f412 6f80 	tst.w	r2, #1024	; 0x400
 80415fe:	d115      	bne.n	804162c <HAL_ADC_IRQHandler+0xe0>
        (ADC_IS_SOFTWARE_START_REGULAR(hadc)       &&
 8041600:	689a      	ldr	r2, [r3, #8]
       (HAL_IS_BIT_CLR(hadc->Instance->CR1, ADC_CR1_JAUTO) &&
 8041602:	f012 5f40 	tst.w	r2, #805306368	; 0x30000000
 8041606:	d111      	bne.n	804162c <HAL_ADC_IRQHandler+0xe0>
        (hadc->Init.ContinuousConvMode == DISABLE)   )       )   )
 8041608:	7e22      	ldrb	r2, [r4, #24]
        (ADC_IS_SOFTWARE_START_REGULAR(hadc)       &&
 804160a:	b97a      	cbnz	r2, 804162c <HAL_ADC_IRQHandler+0xe0>
      __HAL_ADC_DISABLE_IT(hadc, ADC_IT_JEOC);
 804160c:	685a      	ldr	r2, [r3, #4]
 804160e:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 8041612:	605a      	str	r2, [r3, #4]
      CLEAR_BIT(hadc->State, HAL_ADC_STATE_INJ_BUSY);   
 8041614:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8041616:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 804161a:	6423      	str	r3, [r4, #64]	; 0x40
      if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_REG_BUSY))
 804161c:	6c23      	ldr	r3, [r4, #64]	; 0x40
 804161e:	f413 7f80 	tst.w	r3, #256	; 0x100
 8041622:	d103      	bne.n	804162c <HAL_ADC_IRQHandler+0xe0>
        SET_BIT(hadc->State, HAL_ADC_STATE_READY);
 8041624:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8041626:	f043 0301 	orr.w	r3, r3, #1
 804162a:	6423      	str	r3, [r4, #64]	; 0x40
      HAL_ADCEx_InjectedConvCpltCallback(hadc);
 804162c:	4620      	mov	r0, r4
 804162e:	f000 f94b 	bl	80418c8 <HAL_ADCEx_InjectedConvCpltCallback>
    __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_JSTRT | ADC_FLAG_JEOC));
 8041632:	6823      	ldr	r3, [r4, #0]
 8041634:	f06f 020c 	mvn.w	r2, #12
 8041638:	601a      	str	r2, [r3, #0]
  tmp1 = __HAL_ADC_GET_FLAG(hadc, ADC_FLAG_AWD);
 804163a:	6822      	ldr	r2, [r4, #0]
 804163c:	6811      	ldr	r1, [r2, #0]
  tmp2 = __HAL_ADC_GET_IT_SOURCE(hadc, ADC_IT_AWD);                          
 804163e:	6853      	ldr	r3, [r2, #4]
 8041640:	f003 0340 	and.w	r3, r3, #64	; 0x40
  if(tmp1 && tmp2)
 8041644:	f011 0f01 	tst.w	r1, #1
 8041648:	d004      	beq.n	8041654 <HAL_ADC_IRQHandler+0x108>
 804164a:	b11b      	cbz	r3, 8041654 <HAL_ADC_IRQHandler+0x108>
    if(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_AWD))
 804164c:	6813      	ldr	r3, [r2, #0]
 804164e:	f013 0f01 	tst.w	r3, #1
 8041652:	d109      	bne.n	8041668 <HAL_ADC_IRQHandler+0x11c>
  tmp1 = __HAL_ADC_GET_FLAG(hadc, ADC_FLAG_OVR);
 8041654:	6822      	ldr	r2, [r4, #0]
 8041656:	6811      	ldr	r1, [r2, #0]
  tmp2 = __HAL_ADC_GET_IT_SOURCE(hadc, ADC_IT_OVR);
 8041658:	6853      	ldr	r3, [r2, #4]
 804165a:	f003 6380 	and.w	r3, r3, #67108864	; 0x4000000
  if(tmp1 && tmp2)
 804165e:	f011 0f20 	tst.w	r1, #32
 8041662:	d000      	beq.n	8041666 <HAL_ADC_IRQHandler+0x11a>
 8041664:	b963      	cbnz	r3, 8041680 <HAL_ADC_IRQHandler+0x134>
}
 8041666:	bd38      	pop	{r3, r4, r5, pc}
      SET_BIT(hadc->State, HAL_ADC_STATE_AWD1);
 8041668:	6c23      	ldr	r3, [r4, #64]	; 0x40
 804166a:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 804166e:	6423      	str	r3, [r4, #64]	; 0x40
      HAL_ADC_LevelOutOfWindowCallback(hadc);
 8041670:	4620      	mov	r0, r4
 8041672:	f7ff ff69 	bl	8041548 <HAL_ADC_LevelOutOfWindowCallback>
      __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_AWD);
 8041676:	6823      	ldr	r3, [r4, #0]
 8041678:	f06f 0201 	mvn.w	r2, #1
 804167c:	601a      	str	r2, [r3, #0]
 804167e:	e7e9      	b.n	8041654 <HAL_ADC_IRQHandler+0x108>
    SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_OVR);
 8041680:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8041682:	f043 0302 	orr.w	r3, r3, #2
 8041686:	6463      	str	r3, [r4, #68]	; 0x44
    __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_OVR);
 8041688:	f06f 0520 	mvn.w	r5, #32
 804168c:	6015      	str	r5, [r2, #0]
      HAL_ADC_ErrorCallback(hadc);
 804168e:	4620      	mov	r0, r4
 8041690:	f7ff ff5b 	bl	804154a <HAL_ADC_ErrorCallback>
    __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_OVR);
 8041694:	6823      	ldr	r3, [r4, #0]
 8041696:	601d      	str	r5, [r3, #0]
}
 8041698:	e7e5      	b.n	8041666 <HAL_ADC_IRQHandler+0x11a>

0804169a <ADC_DMAError>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *                the configuration information for the specified DMA module.
  * @retval None
  */
static void ADC_DMAError(DMA_HandleTypeDef *hdma)   
{
 804169a:	b508      	push	{r3, lr}
  ADC_HandleTypeDef* hadc = ( ADC_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
 804169c:	6b80      	ldr	r0, [r0, #56]	; 0x38
  hadc->State= HAL_ADC_STATE_ERROR_DMA;
 804169e:	2340      	movs	r3, #64	; 0x40
 80416a0:	6403      	str	r3, [r0, #64]	; 0x40
  /* Set ADC error code to DMA error */
  hadc->ErrorCode |= HAL_ADC_ERROR_DMA;
 80416a2:	6c43      	ldr	r3, [r0, #68]	; 0x44
 80416a4:	f043 0304 	orr.w	r3, r3, #4
 80416a8:	6443      	str	r3, [r0, #68]	; 0x44
   /* Error callback */
#if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
  hadc->ErrorCallback(hadc);
#else
  HAL_ADC_ErrorCallback(hadc);
 80416aa:	f7ff ff4e 	bl	804154a <HAL_ADC_ErrorCallback>
#endif /* USE_HAL_ADC_REGISTER_CALLBACKS */
}
 80416ae:	bd08      	pop	{r3, pc}

080416b0 <ADC_DMAConvCplt>:
{
 80416b0:	b508      	push	{r3, lr}
 80416b2:	4603      	mov	r3, r0
  ADC_HandleTypeDef* hadc = ( ADC_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
 80416b4:	6b80      	ldr	r0, [r0, #56]	; 0x38
  if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL | HAL_ADC_STATE_ERROR_DMA))
 80416b6:	6c02      	ldr	r2, [r0, #64]	; 0x40
 80416b8:	f012 0f50 	tst.w	r2, #80	; 0x50
 80416bc:	d125      	bne.n	804170a <ADC_DMAConvCplt+0x5a>
    SET_BIT(hadc->State, HAL_ADC_STATE_REG_EOC);
 80416be:	6c03      	ldr	r3, [r0, #64]	; 0x40
 80416c0:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 80416c4:	6403      	str	r3, [r0, #64]	; 0x40
    if(ADC_IS_SOFTWARE_START_REGULAR(hadc)                   &&
 80416c6:	6803      	ldr	r3, [r0, #0]
 80416c8:	689a      	ldr	r2, [r3, #8]
 80416ca:	f012 5f40 	tst.w	r2, #805306368	; 0x30000000
 80416ce:	d119      	bne.n	8041704 <ADC_DMAConvCplt+0x54>
       (hadc->Init.ContinuousConvMode == DISABLE)            &&
 80416d0:	7e02      	ldrb	r2, [r0, #24]
    if(ADC_IS_SOFTWARE_START_REGULAR(hadc)                   &&
 80416d2:	b9ba      	cbnz	r2, 8041704 <ADC_DMAConvCplt+0x54>
       (HAL_IS_BIT_CLR(hadc->Instance->SQR1, ADC_SQR1_L) || 
 80416d4:	6ada      	ldr	r2, [r3, #44]	; 0x2c
       (hadc->Init.ContinuousConvMode == DISABLE)            &&
 80416d6:	f412 0f70 	tst.w	r2, #15728640	; 0xf00000
 80416da:	d003      	beq.n	80416e4 <ADC_DMAConvCplt+0x34>
        HAL_IS_BIT_CLR(hadc->Instance->CR2, ADC_CR2_EOCS)  )   )
 80416dc:	689a      	ldr	r2, [r3, #8]
       (HAL_IS_BIT_CLR(hadc->Instance->SQR1, ADC_SQR1_L) || 
 80416de:	f412 6f80 	tst.w	r2, #1024	; 0x400
 80416e2:	d10f      	bne.n	8041704 <ADC_DMAConvCplt+0x54>
      __HAL_ADC_DISABLE_IT(hadc, ADC_IT_EOC);
 80416e4:	685a      	ldr	r2, [r3, #4]
 80416e6:	f022 0220 	bic.w	r2, r2, #32
 80416ea:	605a      	str	r2, [r3, #4]
      CLEAR_BIT(hadc->State, HAL_ADC_STATE_REG_BUSY);   
 80416ec:	6c03      	ldr	r3, [r0, #64]	; 0x40
 80416ee:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 80416f2:	6403      	str	r3, [r0, #64]	; 0x40
      if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_INJ_BUSY))
 80416f4:	6c03      	ldr	r3, [r0, #64]	; 0x40
 80416f6:	f413 5f80 	tst.w	r3, #4096	; 0x1000
 80416fa:	d103      	bne.n	8041704 <ADC_DMAConvCplt+0x54>
        SET_BIT(hadc->State, HAL_ADC_STATE_READY);
 80416fc:	6c03      	ldr	r3, [r0, #64]	; 0x40
 80416fe:	f043 0301 	orr.w	r3, r3, #1
 8041702:	6403      	str	r3, [r0, #64]	; 0x40
    HAL_ADC_ConvCpltCallback(hadc);
 8041704:	f00f fa1e 	bl	8050b44 <HAL_ADC_ConvCpltCallback>
}
 8041708:	bd08      	pop	{r3, pc}
    if ((hadc->State & HAL_ADC_STATE_ERROR_INTERNAL) != 0UL)
 804170a:	6c02      	ldr	r2, [r0, #64]	; 0x40
 804170c:	f012 0f10 	tst.w	r2, #16
 8041710:	d104      	bne.n	804171c <ADC_DMAConvCplt+0x6c>
      hadc->DMA_Handle->XferErrorCallback(hdma);
 8041712:	6b82      	ldr	r2, [r0, #56]	; 0x38
 8041714:	6cd2      	ldr	r2, [r2, #76]	; 0x4c
 8041716:	4618      	mov	r0, r3
 8041718:	4790      	blx	r2
}
 804171a:	e7f5      	b.n	8041708 <ADC_DMAConvCplt+0x58>
      HAL_ADC_ErrorCallback(hadc);
 804171c:	f7ff ff15 	bl	804154a <HAL_ADC_ErrorCallback>
 8041720:	e7f2      	b.n	8041708 <ADC_DMAConvCplt+0x58>
	...

08041724 <HAL_ADC_ConfigChannel>:
{
 8041724:	b430      	push	{r4, r5}
 8041726:	b082      	sub	sp, #8
  __IO uint32_t counter = 0U;
 8041728:	2300      	movs	r3, #0
 804172a:	9301      	str	r3, [sp, #4]
  __HAL_LOCK(hadc);
 804172c:	f890 303c 	ldrb.w	r3, [r0, #60]	; 0x3c
 8041730:	2b01      	cmp	r3, #1
 8041732:	f000 80bd 	beq.w	80418b0 <HAL_ADC_ConfigChannel+0x18c>
 8041736:	2301      	movs	r3, #1
 8041738:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
  if (sConfig->Channel > ADC_CHANNEL_9)
 804173c:	680b      	ldr	r3, [r1, #0]
 804173e:	2b09      	cmp	r3, #9
 8041740:	d93e      	bls.n	80417c0 <HAL_ADC_ConfigChannel+0x9c>
    hadc->Instance->SMPR1 &= ~ADC_SMPR1(ADC_SMPR1_SMP10, sConfig->Channel);
 8041742:	6805      	ldr	r5, [r0, #0]
 8041744:	68ea      	ldr	r2, [r5, #12]
 8041746:	b29b      	uxth	r3, r3
 8041748:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 804174c:	3b1e      	subs	r3, #30
 804174e:	2407      	movs	r4, #7
 8041750:	fa04 f303 	lsl.w	r3, r4, r3
 8041754:	ea22 0303 	bic.w	r3, r2, r3
 8041758:	60eb      	str	r3, [r5, #12]
    hadc->Instance->SMPR1 |= ADC_SMPR1(sConfig->SamplingTime, sConfig->Channel);
 804175a:	6805      	ldr	r5, [r0, #0]
 804175c:	68ea      	ldr	r2, [r5, #12]
 804175e:	688c      	ldr	r4, [r1, #8]
 8041760:	880b      	ldrh	r3, [r1, #0]
 8041762:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8041766:	3b1e      	subs	r3, #30
 8041768:	fa04 f303 	lsl.w	r3, r4, r3
 804176c:	4313      	orrs	r3, r2
 804176e:	60eb      	str	r3, [r5, #12]
  if (sConfig->Rank < 7U)
 8041770:	684b      	ldr	r3, [r1, #4]
 8041772:	2b06      	cmp	r3, #6
 8041774:	d83a      	bhi.n	80417ec <HAL_ADC_ConfigChannel+0xc8>
    hadc->Instance->SQR3 &= ~ADC_SQR3_RK(ADC_SQR3_SQ1, sConfig->Rank);
 8041776:	6805      	ldr	r5, [r0, #0]
 8041778:	6b6a      	ldr	r2, [r5, #52]	; 0x34
 804177a:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 804177e:	3b05      	subs	r3, #5
 8041780:	241f      	movs	r4, #31
 8041782:	fa04 f303 	lsl.w	r3, r4, r3
 8041786:	ea22 0303 	bic.w	r3, r2, r3
 804178a:	636b      	str	r3, [r5, #52]	; 0x34
    hadc->Instance->SQR3 |= ADC_SQR3_RK(sConfig->Channel, sConfig->Rank);
 804178c:	6805      	ldr	r5, [r0, #0]
 804178e:	6b6a      	ldr	r2, [r5, #52]	; 0x34
 8041790:	684b      	ldr	r3, [r1, #4]
 8041792:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8041796:	3b05      	subs	r3, #5
 8041798:	880c      	ldrh	r4, [r1, #0]
 804179a:	fa04 f303 	lsl.w	r3, r4, r3
 804179e:	4313      	orrs	r3, r2
 80417a0:	636b      	str	r3, [r5, #52]	; 0x34
  if ((hadc->Instance == ADC1) && (sConfig->Channel == ADC_CHANNEL_VBAT))
 80417a2:	6802      	ldr	r2, [r0, #0]
 80417a4:	4b43      	ldr	r3, [pc, #268]	; (80418b4 <HAL_ADC_ConfigChannel+0x190>)
 80417a6:	429a      	cmp	r2, r3
 80417a8:	d050      	beq.n	804184c <HAL_ADC_ConfigChannel+0x128>
  if ((hadc->Instance == ADC1) && ((sConfig->Channel == ADC_CHANNEL_TEMPSENSOR) || (sConfig->Channel == ADC_CHANNEL_VREFINT)))
 80417aa:	6802      	ldr	r2, [r0, #0]
 80417ac:	4b41      	ldr	r3, [pc, #260]	; (80418b4 <HAL_ADC_ConfigChannel+0x190>)
 80417ae:	429a      	cmp	r2, r3
 80417b0:	d059      	beq.n	8041866 <HAL_ADC_ConfigChannel+0x142>
  __HAL_UNLOCK(hadc);
 80417b2:	2300      	movs	r3, #0
 80417b4:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
  return HAL_OK;
 80417b8:	4618      	mov	r0, r3
}
 80417ba:	b002      	add	sp, #8
 80417bc:	bc30      	pop	{r4, r5}
 80417be:	4770      	bx	lr
    hadc->Instance->SMPR2 &= ~ADC_SMPR2(ADC_SMPR2_SMP0, sConfig->Channel);
 80417c0:	6805      	ldr	r5, [r0, #0]
 80417c2:	692a      	ldr	r2, [r5, #16]
 80417c4:	b29b      	uxth	r3, r3
 80417c6:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 80417ca:	2407      	movs	r4, #7
 80417cc:	fa04 f303 	lsl.w	r3, r4, r3
 80417d0:	ea22 0303 	bic.w	r3, r2, r3
 80417d4:	612b      	str	r3, [r5, #16]
    hadc->Instance->SMPR2 |= ADC_SMPR2(sConfig->SamplingTime, sConfig->Channel);
 80417d6:	6805      	ldr	r5, [r0, #0]
 80417d8:	692a      	ldr	r2, [r5, #16]
 80417da:	688c      	ldr	r4, [r1, #8]
 80417dc:	880b      	ldrh	r3, [r1, #0]
 80417de:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 80417e2:	fa04 f303 	lsl.w	r3, r4, r3
 80417e6:	4313      	orrs	r3, r2
 80417e8:	612b      	str	r3, [r5, #16]
 80417ea:	e7c1      	b.n	8041770 <HAL_ADC_ConfigChannel+0x4c>
  else if (sConfig->Rank < 13U)
 80417ec:	2b0c      	cmp	r3, #12
 80417ee:	d816      	bhi.n	804181e <HAL_ADC_ConfigChannel+0xfa>
    hadc->Instance->SQR2 &= ~ADC_SQR2_RK(ADC_SQR2_SQ7, sConfig->Rank);
 80417f0:	6805      	ldr	r5, [r0, #0]
 80417f2:	6b2a      	ldr	r2, [r5, #48]	; 0x30
 80417f4:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 80417f8:	3b23      	subs	r3, #35	; 0x23
 80417fa:	241f      	movs	r4, #31
 80417fc:	fa04 f303 	lsl.w	r3, r4, r3
 8041800:	ea22 0303 	bic.w	r3, r2, r3
 8041804:	632b      	str	r3, [r5, #48]	; 0x30
    hadc->Instance->SQR2 |= ADC_SQR2_RK(sConfig->Channel, sConfig->Rank);
 8041806:	6805      	ldr	r5, [r0, #0]
 8041808:	6b2a      	ldr	r2, [r5, #48]	; 0x30
 804180a:	684b      	ldr	r3, [r1, #4]
 804180c:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8041810:	3b23      	subs	r3, #35	; 0x23
 8041812:	880c      	ldrh	r4, [r1, #0]
 8041814:	fa04 f303 	lsl.w	r3, r4, r3
 8041818:	4313      	orrs	r3, r2
 804181a:	632b      	str	r3, [r5, #48]	; 0x30
 804181c:	e7c1      	b.n	80417a2 <HAL_ADC_ConfigChannel+0x7e>
    hadc->Instance->SQR1 &= ~ADC_SQR1_RK(ADC_SQR1_SQ13, sConfig->Rank);
 804181e:	6805      	ldr	r5, [r0, #0]
 8041820:	6aea      	ldr	r2, [r5, #44]	; 0x2c
 8041822:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8041826:	3b41      	subs	r3, #65	; 0x41
 8041828:	241f      	movs	r4, #31
 804182a:	fa04 f303 	lsl.w	r3, r4, r3
 804182e:	ea22 0303 	bic.w	r3, r2, r3
 8041832:	62eb      	str	r3, [r5, #44]	; 0x2c
    hadc->Instance->SQR1 |= ADC_SQR1_RK(sConfig->Channel, sConfig->Rank);
 8041834:	6805      	ldr	r5, [r0, #0]
 8041836:	6aea      	ldr	r2, [r5, #44]	; 0x2c
 8041838:	684b      	ldr	r3, [r1, #4]
 804183a:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 804183e:	3b41      	subs	r3, #65	; 0x41
 8041840:	880c      	ldrh	r4, [r1, #0]
 8041842:	fa04 f303 	lsl.w	r3, r4, r3
 8041846:	4313      	orrs	r3, r2
 8041848:	62eb      	str	r3, [r5, #44]	; 0x2c
 804184a:	e7aa      	b.n	80417a2 <HAL_ADC_ConfigChannel+0x7e>
  if ((hadc->Instance == ADC1) && (sConfig->Channel == ADC_CHANNEL_VBAT))
 804184c:	680b      	ldr	r3, [r1, #0]
 804184e:	2b12      	cmp	r3, #18
 8041850:	d1ab      	bne.n	80417aa <HAL_ADC_ConfigChannel+0x86>
      tmpADC_Common->CCR &= ~ADC_CCR_TSVREFE;
 8041852:	4b19      	ldr	r3, [pc, #100]	; (80418b8 <HAL_ADC_ConfigChannel+0x194>)
 8041854:	685a      	ldr	r2, [r3, #4]
 8041856:	f422 0200 	bic.w	r2, r2, #8388608	; 0x800000
 804185a:	605a      	str	r2, [r3, #4]
    tmpADC_Common->CCR |= ADC_CCR_VBATE;
 804185c:	685a      	ldr	r2, [r3, #4]
 804185e:	f442 0280 	orr.w	r2, r2, #4194304	; 0x400000
 8041862:	605a      	str	r2, [r3, #4]
 8041864:	e7a1      	b.n	80417aa <HAL_ADC_ConfigChannel+0x86>
  if ((hadc->Instance == ADC1) && ((sConfig->Channel == ADC_CHANNEL_TEMPSENSOR) || (sConfig->Channel == ADC_CHANNEL_VREFINT)))
 8041866:	680b      	ldr	r3, [r1, #0]
 8041868:	4a14      	ldr	r2, [pc, #80]	; (80418bc <HAL_ADC_ConfigChannel+0x198>)
 804186a:	4293      	cmp	r3, r2
 804186c:	d001      	beq.n	8041872 <HAL_ADC_ConfigChannel+0x14e>
 804186e:	2b11      	cmp	r3, #17
 8041870:	d19f      	bne.n	80417b2 <HAL_ADC_ConfigChannel+0x8e>
      tmpADC_Common->CCR &= ~ADC_CCR_VBATE;
 8041872:	4b11      	ldr	r3, [pc, #68]	; (80418b8 <HAL_ADC_ConfigChannel+0x194>)
 8041874:	685a      	ldr	r2, [r3, #4]
 8041876:	f422 0280 	bic.w	r2, r2, #4194304	; 0x400000
 804187a:	605a      	str	r2, [r3, #4]
    tmpADC_Common->CCR |= ADC_CCR_TSVREFE;
 804187c:	685a      	ldr	r2, [r3, #4]
 804187e:	f442 0200 	orr.w	r2, r2, #8388608	; 0x800000
 8041882:	605a      	str	r2, [r3, #4]
    if((sConfig->Channel == ADC_CHANNEL_TEMPSENSOR))
 8041884:	680a      	ldr	r2, [r1, #0]
 8041886:	4b0d      	ldr	r3, [pc, #52]	; (80418bc <HAL_ADC_ConfigChannel+0x198>)
 8041888:	429a      	cmp	r2, r3
 804188a:	d192      	bne.n	80417b2 <HAL_ADC_ConfigChannel+0x8e>
      counter = (ADC_TEMPSENSOR_DELAY_US * (SystemCoreClock / 1000000U));
 804188c:	4b0c      	ldr	r3, [pc, #48]	; (80418c0 <HAL_ADC_ConfigChannel+0x19c>)
 804188e:	681b      	ldr	r3, [r3, #0]
 8041890:	4a0c      	ldr	r2, [pc, #48]	; (80418c4 <HAL_ADC_ConfigChannel+0x1a0>)
 8041892:	fba2 2303 	umull	r2, r3, r2, r3
 8041896:	0c9b      	lsrs	r3, r3, #18
 8041898:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 804189c:	005b      	lsls	r3, r3, #1
 804189e:	9301      	str	r3, [sp, #4]
      while(counter != 0U)
 80418a0:	e002      	b.n	80418a8 <HAL_ADC_ConfigChannel+0x184>
        counter--;
 80418a2:	9b01      	ldr	r3, [sp, #4]
 80418a4:	3b01      	subs	r3, #1
 80418a6:	9301      	str	r3, [sp, #4]
      while(counter != 0U)
 80418a8:	9b01      	ldr	r3, [sp, #4]
 80418aa:	2b00      	cmp	r3, #0
 80418ac:	d1f9      	bne.n	80418a2 <HAL_ADC_ConfigChannel+0x17e>
 80418ae:	e780      	b.n	80417b2 <HAL_ADC_ConfigChannel+0x8e>
  __HAL_LOCK(hadc);
 80418b0:	2002      	movs	r0, #2
 80418b2:	e782      	b.n	80417ba <HAL_ADC_ConfigChannel+0x96>
 80418b4:	40012000 	.word	0x40012000
 80418b8:	40012300 	.word	0x40012300
 80418bc:	10000012 	.word	0x10000012
 80418c0:	20003678 	.word	0x20003678
 80418c4:	431bde83 	.word	0x431bde83

080418c8 <HAL_ADCEx_InjectedConvCpltCallback>:
  /* Prevent unused argument(s) compilation warning */
  UNUSED(hadc);
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_ADC_InjectedConvCpltCallback could be implemented in the user file
   */
}
 80418c8:	4770      	bx	lr
	...

080418cc <HAL_NVIC_SetPriorityGrouping>:
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 80418cc:	4a07      	ldr	r2, [pc, #28]	; (80418ec <HAL_NVIC_SetPriorityGrouping+0x20>)
 80418ce:	68d3      	ldr	r3, [r2, #12]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 80418d0:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 80418d4:	041b      	lsls	r3, r3, #16
 80418d6:	0c1b      	lsrs	r3, r3, #16
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 80418d8:	0200      	lsls	r0, r0, #8
 80418da:	f400 60e0 	and.w	r0, r0, #1792	; 0x700
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 80418de:	4303      	orrs	r3, r0
  reg_value  =  (reg_value                                   |
 80418e0:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 80418e4:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
  SCB->AIRCR =  reg_value;
 80418e8:	60d3      	str	r3, [r2, #12]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
  
  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
}
 80418ea:	4770      	bx	lr
 80418ec:	e000ed00 	.word	0xe000ed00

080418f0 <HAL_NVIC_SetPriority>:
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.          
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
 80418f0:	b430      	push	{r4, r5}
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 80418f2:	4b17      	ldr	r3, [pc, #92]	; (8041950 <HAL_NVIC_SetPriority+0x60>)
 80418f4:	68db      	ldr	r3, [r3, #12]
 80418f6:	f3c3 2302 	ubfx	r3, r3, #8, #3
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 80418fa:	f1c3 0407 	rsb	r4, r3, #7
 80418fe:	2c04      	cmp	r4, #4
 8041900:	bf28      	it	cs
 8041902:	2404      	movcs	r4, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8041904:	1d1d      	adds	r5, r3, #4
 8041906:	2d06      	cmp	r5, #6
 8041908:	d918      	bls.n	804193c <HAL_NVIC_SetPriority+0x4c>
 804190a:	3b03      	subs	r3, #3

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 804190c:	f04f 35ff 	mov.w	r5, #4294967295
 8041910:	fa05 f404 	lsl.w	r4, r5, r4
 8041914:	ea21 0104 	bic.w	r1, r1, r4
 8041918:	4099      	lsls	r1, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 804191a:	fa05 f303 	lsl.w	r3, r5, r3
 804191e:	ea22 0303 	bic.w	r3, r2, r3
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8041922:	4319      	orrs	r1, r3
  if ((int32_t)(IRQn) >= 0)
 8041924:	2800      	cmp	r0, #0
 8041926:	db0b      	blt.n	8041940 <HAL_NVIC_SetPriority+0x50>
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8041928:	0109      	lsls	r1, r1, #4
 804192a:	b2c9      	uxtb	r1, r1
 804192c:	f100 4060 	add.w	r0, r0, #3758096384	; 0xe0000000
 8041930:	f500 4061 	add.w	r0, r0, #57600	; 0xe100
 8041934:	f880 1300 	strb.w	r1, [r0, #768]	; 0x300
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
  
  prioritygroup = NVIC_GetPriorityGrouping();
  
  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
}
 8041938:	bc30      	pop	{r4, r5}
 804193a:	4770      	bx	lr
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 804193c:	2300      	movs	r3, #0
 804193e:	e7e5      	b.n	804190c <HAL_NVIC_SetPriority+0x1c>
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8041940:	f000 000f 	and.w	r0, r0, #15
 8041944:	0109      	lsls	r1, r1, #4
 8041946:	b2c9      	uxtb	r1, r1
 8041948:	4b02      	ldr	r3, [pc, #8]	; (8041954 <HAL_NVIC_SetPriority+0x64>)
 804194a:	5419      	strb	r1, [r3, r0]
 804194c:	e7f4      	b.n	8041938 <HAL_NVIC_SetPriority+0x48>
 804194e:	bf00      	nop
 8041950:	e000ed00 	.word	0xe000ed00
 8041954:	e000ed14 	.word	0xe000ed14

08041958 <HAL_NVIC_EnableIRQ>:
  if ((int32_t)(IRQn) >= 0)
 8041958:	2800      	cmp	r0, #0
 804195a:	db07      	blt.n	804196c <HAL_NVIC_EnableIRQ+0x14>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 804195c:	f000 021f 	and.w	r2, r0, #31
 8041960:	0940      	lsrs	r0, r0, #5
 8041962:	2301      	movs	r3, #1
 8041964:	4093      	lsls	r3, r2
 8041966:	4a02      	ldr	r2, [pc, #8]	; (8041970 <HAL_NVIC_EnableIRQ+0x18>)
 8041968:	f842 3020 	str.w	r3, [r2, r0, lsl #2]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
}
 804196c:	4770      	bx	lr
 804196e:	bf00      	nop
 8041970:	e000e100 	.word	0xe000e100

08041974 <HAL_NVIC_SystemReset>:
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 8041974:	f3bf 8f4f 	dsb	sy
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 8041978:	4905      	ldr	r1, [pc, #20]	; (8041990 <HAL_NVIC_SystemReset+0x1c>)
 804197a:	68ca      	ldr	r2, [r1, #12]
 804197c:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 8041980:	4b04      	ldr	r3, [pc, #16]	; (8041994 <HAL_NVIC_SystemReset+0x20>)
 8041982:	4313      	orrs	r3, r2
 8041984:	60cb      	str	r3, [r1, #12]
 8041986:	f3bf 8f4f 	dsb	sy
                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
  __DSB();                                                          /* Ensure completion of memory access */

  for(;;)                                                           /* wait until reset */
  {
    __NOP();
 804198a:	bf00      	nop
  for(;;)                                                           /* wait until reset */
 804198c:	e7fd      	b.n	804198a <HAL_NVIC_SystemReset+0x16>
 804198e:	bf00      	nop
 8041990:	e000ed00 	.word	0xe000ed00
 8041994:	05fa0004 	.word	0x05fa0004

08041998 <HAL_SYSTICK_Config>:
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 8041998:	3801      	subs	r0, #1
 804199a:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
 804199e:	d20a      	bcs.n	80419b6 <HAL_SYSTICK_Config+0x1e>
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 80419a0:	4b06      	ldr	r3, [pc, #24]	; (80419bc <HAL_SYSTICK_Config+0x24>)
 80419a2:	6058      	str	r0, [r3, #4]
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80419a4:	4a06      	ldr	r2, [pc, #24]	; (80419c0 <HAL_SYSTICK_Config+0x28>)
 80419a6:	21f0      	movs	r1, #240	; 0xf0
 80419a8:	f882 1023 	strb.w	r1, [r2, #35]	; 0x23
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 80419ac:	2000      	movs	r0, #0
 80419ae:	6098      	str	r0, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 80419b0:	2207      	movs	r2, #7
 80419b2:	601a      	str	r2, [r3, #0]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
 80419b4:	4770      	bx	lr
    return (1UL);                                                   /* Reload value impossible */
 80419b6:	2001      	movs	r0, #1
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
   return SysTick_Config(TicksNumb);
}
 80419b8:	4770      	bx	lr
 80419ba:	bf00      	nop
 80419bc:	e000e010 	.word	0xe000e010
 80419c0:	e000ed00 	.word	0xe000ed00

080419c4 <DMA_SetConfig>:
  * @param  DstAddress The destination memory Buffer address
  * @param  DataLength The length of data to be transferred from source to destination
  * @retval HAL status
  */
static void DMA_SetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{
 80419c4:	b430      	push	{r4, r5}
  /* Clear DBM bit */
  hdma->Instance->CR &= (uint32_t)(~DMA_SxCR_DBM);
 80419c6:	6805      	ldr	r5, [r0, #0]
 80419c8:	682c      	ldr	r4, [r5, #0]
 80419ca:	f424 2480 	bic.w	r4, r4, #262144	; 0x40000
 80419ce:	602c      	str	r4, [r5, #0]

  /* Configure DMA Stream data length */
  hdma->Instance->NDTR = DataLength;
 80419d0:	6804      	ldr	r4, [r0, #0]
 80419d2:	6063      	str	r3, [r4, #4]

  /* Memory to Peripheral */
  if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
 80419d4:	6883      	ldr	r3, [r0, #8]
 80419d6:	2b40      	cmp	r3, #64	; 0x40
 80419d8:	d005      	beq.n	80419e6 <DMA_SetConfig+0x22>
  }
  /* Peripheral to Memory */
  else
  {
    /* Configure DMA Stream source address */
    hdma->Instance->PAR = SrcAddress;
 80419da:	6803      	ldr	r3, [r0, #0]
 80419dc:	6099      	str	r1, [r3, #8]

    /* Configure DMA Stream destination address */
    hdma->Instance->M0AR = DstAddress;
 80419de:	6803      	ldr	r3, [r0, #0]
 80419e0:	60da      	str	r2, [r3, #12]
  }
}
 80419e2:	bc30      	pop	{r4, r5}
 80419e4:	4770      	bx	lr
    hdma->Instance->PAR = DstAddress;
 80419e6:	6803      	ldr	r3, [r0, #0]
 80419e8:	609a      	str	r2, [r3, #8]
    hdma->Instance->M0AR = SrcAddress;
 80419ea:	6803      	ldr	r3, [r0, #0]
 80419ec:	60d9      	str	r1, [r3, #12]
 80419ee:	e7f8      	b.n	80419e2 <DMA_SetConfig+0x1e>

080419f0 <DMA_CalcBaseAndBitshift>:
  * @param  hdma       pointer to a DMA_HandleTypeDef structure that contains
  *                     the configuration information for the specified DMA Stream. 
  * @retval Stream base address
  */
static uint32_t DMA_CalcBaseAndBitshift(DMA_HandleTypeDef *hdma)
{
 80419f0:	b410      	push	{r4}
  uint32_t stream_number = (((uint32_t)hdma->Instance & 0xFFU) - 16U) / 24U;
 80419f2:	6803      	ldr	r3, [r0, #0]
 80419f4:	b2d9      	uxtb	r1, r3
 80419f6:	3910      	subs	r1, #16
 80419f8:	4a0c      	ldr	r2, [pc, #48]	; (8041a2c <DMA_CalcBaseAndBitshift+0x3c>)
 80419fa:	fba2 4201 	umull	r4, r2, r2, r1
 80419fe:	0912      	lsrs	r2, r2, #4
  
  /* lookup table for necessary bitshift of flags within status registers */
  static const uint8_t flagBitshiftOffset[8U] = {0U, 6U, 16U, 22U, 0U, 6U, 16U, 22U};
  hdma->StreamIndex = flagBitshiftOffset[stream_number];
 8041a00:	4c0b      	ldr	r4, [pc, #44]	; (8041a30 <DMA_CalcBaseAndBitshift+0x40>)
 8041a02:	5ca2      	ldrb	r2, [r4, r2]
 8041a04:	65c2      	str	r2, [r0, #92]	; 0x5c
  
  if (stream_number > 3U)
 8041a06:	295f      	cmp	r1, #95	; 0x5f
 8041a08:	d909      	bls.n	8041a1e <DMA_CalcBaseAndBitshift+0x2e>
  {
    /* return pointer to HISR and HIFCR */
    hdma->StreamBaseAddress = (((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU)) + 4U);
 8041a0a:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
 8041a0e:	f023 0303 	bic.w	r3, r3, #3
 8041a12:	3304      	adds	r3, #4
 8041a14:	6583      	str	r3, [r0, #88]	; 0x58
    /* return pointer to LISR and LIFCR */
    hdma->StreamBaseAddress = ((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU));
  }
  
  return hdma->StreamBaseAddress;
}
 8041a16:	6d80      	ldr	r0, [r0, #88]	; 0x58
 8041a18:	f85d 4b04 	ldr.w	r4, [sp], #4
 8041a1c:	4770      	bx	lr
    hdma->StreamBaseAddress = ((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU));
 8041a1e:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
 8041a22:	f023 0303 	bic.w	r3, r3, #3
 8041a26:	6583      	str	r3, [r0, #88]	; 0x58
 8041a28:	e7f5      	b.n	8041a16 <DMA_CalcBaseAndBitshift+0x26>
 8041a2a:	bf00      	nop
 8041a2c:	aaaaaaab 	.word	0xaaaaaaab
 8041a30:	08058d50 	.word	0x08058d50

08041a34 <DMA_CheckFifoParam>:
  * @retval HAL status
  */
static HAL_StatusTypeDef DMA_CheckFifoParam(DMA_HandleTypeDef *hdma)
{
  HAL_StatusTypeDef status = HAL_OK;
  uint32_t tmp = hdma->Init.FIFOThreshold;
 8041a34:	6a83      	ldr	r3, [r0, #40]	; 0x28
  
  /* Memory Data size equal to Byte */
  if(hdma->Init.MemDataAlignment == DMA_MDATAALIGN_BYTE)
 8041a36:	6982      	ldr	r2, [r0, #24]
 8041a38:	b992      	cbnz	r2, 8041a60 <DMA_CheckFifoParam+0x2c>
  {
    switch (tmp)
 8041a3a:	2b01      	cmp	r3, #1
 8041a3c:	d00a      	beq.n	8041a54 <DMA_CheckFifoParam+0x20>
 8041a3e:	2b02      	cmp	r3, #2
 8041a40:	d002      	beq.n	8041a48 <DMA_CheckFifoParam+0x14>
 8041a42:	b10b      	cbz	r3, 8041a48 <DMA_CheckFifoParam+0x14>
 8041a44:	2000      	movs	r0, #0
 8041a46:	4770      	bx	lr
    {
    case DMA_FIFO_THRESHOLD_1QUARTERFULL:
    case DMA_FIFO_THRESHOLD_3QUARTERSFULL:
      if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
 8041a48:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 8041a4a:	f013 7f80 	tst.w	r3, #16777216	; 0x1000000
 8041a4e:	d128      	bne.n	8041aa2 <DMA_CheckFifoParam+0x6e>
  HAL_StatusTypeDef status = HAL_OK;
 8041a50:	2000      	movs	r0, #0
 8041a52:	4770      	bx	lr
      {
        status = HAL_ERROR;
      }
      break;
    case DMA_FIFO_THRESHOLD_HALFFULL:
      if (hdma->Init.MemBurst == DMA_MBURST_INC16)
 8041a54:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 8041a56:	f1b3 7fc0 	cmp.w	r3, #25165824	; 0x1800000
 8041a5a:	d024      	beq.n	8041aa6 <DMA_CheckFifoParam+0x72>
  HAL_StatusTypeDef status = HAL_OK;
 8041a5c:	2000      	movs	r0, #0
 8041a5e:	4770      	bx	lr
      break;
    }
  }
  
  /* Memory Data size equal to Half-Word */
  else if (hdma->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)
 8041a60:	f5b2 5f00 	cmp.w	r2, #8192	; 0x2000
 8041a64:	d009      	beq.n	8041a7a <DMA_CheckFifoParam+0x46>
  }
  
  /* Memory Data size equal to Word */
  else
  {
    switch (tmp)
 8041a66:	2b02      	cmp	r3, #2
 8041a68:	d925      	bls.n	8041ab6 <DMA_CheckFifoParam+0x82>
 8041a6a:	2b03      	cmp	r3, #3
 8041a6c:	d125      	bne.n	8041aba <DMA_CheckFifoParam+0x86>
    case DMA_FIFO_THRESHOLD_HALFFULL:
    case DMA_FIFO_THRESHOLD_3QUARTERSFULL:
      status = HAL_ERROR;
      break;
    case DMA_FIFO_THRESHOLD_FULL:
      if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
 8041a6e:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 8041a70:	f013 7f80 	tst.w	r3, #16777216	; 0x1000000
 8041a74:	d123      	bne.n	8041abe <DMA_CheckFifoParam+0x8a>
  HAL_StatusTypeDef status = HAL_OK;
 8041a76:	2000      	movs	r0, #0
 8041a78:	4770      	bx	lr
    switch (tmp)
 8041a7a:	2b03      	cmp	r3, #3
 8041a7c:	d803      	bhi.n	8041a86 <DMA_CheckFifoParam+0x52>
 8041a7e:	e8df f003 	tbb	[pc, r3]
 8041a82:	0414      	.short	0x0414
 8041a84:	0a14      	.short	0x0a14
  else if (hdma->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)
 8041a86:	2000      	movs	r0, #0
 8041a88:	4770      	bx	lr
      if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
 8041a8a:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 8041a8c:	f013 7f80 	tst.w	r3, #16777216	; 0x1000000
 8041a90:	d10d      	bne.n	8041aae <DMA_CheckFifoParam+0x7a>
  HAL_StatusTypeDef status = HAL_OK;
 8041a92:	2000      	movs	r0, #0
 8041a94:	4770      	bx	lr
      if (hdma->Init.MemBurst == DMA_MBURST_INC16)
 8041a96:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 8041a98:	f1b3 7fc0 	cmp.w	r3, #25165824	; 0x1800000
 8041a9c:	d009      	beq.n	8041ab2 <DMA_CheckFifoParam+0x7e>
  HAL_StatusTypeDef status = HAL_OK;
 8041a9e:	2000      	movs	r0, #0
 8041aa0:	4770      	bx	lr
        status = HAL_ERROR;
 8041aa2:	2001      	movs	r0, #1
 8041aa4:	4770      	bx	lr
        status = HAL_ERROR;
 8041aa6:	2001      	movs	r0, #1
 8041aa8:	4770      	bx	lr
      status = HAL_ERROR;
 8041aaa:	2001      	movs	r0, #1
 8041aac:	4770      	bx	lr
        status = HAL_ERROR;
 8041aae:	2001      	movs	r0, #1
 8041ab0:	4770      	bx	lr
        status = HAL_ERROR;
 8041ab2:	2001      	movs	r0, #1
 8041ab4:	4770      	bx	lr
      status = HAL_ERROR;
 8041ab6:	2001      	movs	r0, #1
 8041ab8:	4770      	bx	lr
    switch (tmp)
 8041aba:	2000      	movs	r0, #0
 8041abc:	4770      	bx	lr
      {
        status = HAL_ERROR;
 8041abe:	2001      	movs	r0, #1
      break;
    }
  } 
  
  return status; 
}
 8041ac0:	4770      	bx	lr
	...

08041ac4 <HAL_DMA_Init>:
{
 8041ac4:	b570      	push	{r4, r5, r6, lr}
 8041ac6:	4604      	mov	r4, r0
  uint32_t tickstart = HAL_GetTick();
 8041ac8:	f7ff fafa 	bl	80410c0 <HAL_GetTick>
  if(hdma == NULL)
 8041acc:	2c00      	cmp	r4, #0
 8041ace:	d05b      	beq.n	8041b88 <HAL_DMA_Init+0xc4>
 8041ad0:	4605      	mov	r5, r0
  __HAL_UNLOCK(hdma);
 8041ad2:	2300      	movs	r3, #0
 8041ad4:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
  hdma->State = HAL_DMA_STATE_BUSY;
 8041ad8:	2302      	movs	r3, #2
 8041ada:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
  __HAL_DMA_DISABLE(hdma);
 8041ade:	6822      	ldr	r2, [r4, #0]
 8041ae0:	6813      	ldr	r3, [r2, #0]
 8041ae2:	f023 0301 	bic.w	r3, r3, #1
 8041ae6:	6013      	str	r3, [r2, #0]
  while((hdma->Instance->CR & DMA_SxCR_EN) != RESET)
 8041ae8:	6823      	ldr	r3, [r4, #0]
 8041aea:	681a      	ldr	r2, [r3, #0]
 8041aec:	f012 0f01 	tst.w	r2, #1
 8041af0:	d00a      	beq.n	8041b08 <HAL_DMA_Init+0x44>
    if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA_ABORT)
 8041af2:	f7ff fae5 	bl	80410c0 <HAL_GetTick>
 8041af6:	1b43      	subs	r3, r0, r5
 8041af8:	2b05      	cmp	r3, #5
 8041afa:	d9f5      	bls.n	8041ae8 <HAL_DMA_Init+0x24>
      hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
 8041afc:	2320      	movs	r3, #32
 8041afe:	6563      	str	r3, [r4, #84]	; 0x54
      hdma->State = HAL_DMA_STATE_TIMEOUT;
 8041b00:	2003      	movs	r0, #3
 8041b02:	f884 0035 	strb.w	r0, [r4, #53]	; 0x35
}
 8041b06:	bd70      	pop	{r4, r5, r6, pc}
  tmp = hdma->Instance->CR;
 8041b08:	681a      	ldr	r2, [r3, #0]
  tmp &= ((uint32_t)~(DMA_SxCR_CHSEL | DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
 8041b0a:	4820      	ldr	r0, [pc, #128]	; (8041b8c <HAL_DMA_Init+0xc8>)
 8041b0c:	4010      	ands	r0, r2
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
 8041b0e:	6861      	ldr	r1, [r4, #4]
 8041b10:	68a2      	ldr	r2, [r4, #8]
 8041b12:	430a      	orrs	r2, r1
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 8041b14:	68e1      	ldr	r1, [r4, #12]
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
 8041b16:	430a      	orrs	r2, r1
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 8041b18:	6921      	ldr	r1, [r4, #16]
 8041b1a:	430a      	orrs	r2, r1
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 8041b1c:	6961      	ldr	r1, [r4, #20]
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 8041b1e:	430a      	orrs	r2, r1
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 8041b20:	69a1      	ldr	r1, [r4, #24]
 8041b22:	430a      	orrs	r2, r1
          hdma->Init.Mode                | hdma->Init.Priority;
 8041b24:	69e1      	ldr	r1, [r4, #28]
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 8041b26:	430a      	orrs	r2, r1
          hdma->Init.Mode                | hdma->Init.Priority;
 8041b28:	6a21      	ldr	r1, [r4, #32]
 8041b2a:	430a      	orrs	r2, r1
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
 8041b2c:	4302      	orrs	r2, r0
  if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
 8041b2e:	6a61      	ldr	r1, [r4, #36]	; 0x24
 8041b30:	2904      	cmp	r1, #4
 8041b32:	d01e      	beq.n	8041b72 <HAL_DMA_Init+0xae>
  hdma->Instance->CR = tmp;  
 8041b34:	601a      	str	r2, [r3, #0]
  tmp = hdma->Instance->FCR;
 8041b36:	6826      	ldr	r6, [r4, #0]
 8041b38:	6975      	ldr	r5, [r6, #20]
  tmp &= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH);
 8041b3a:	f025 0507 	bic.w	r5, r5, #7
  tmp |= hdma->Init.FIFOMode;
 8041b3e:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8041b40:	431d      	orrs	r5, r3
  if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
 8041b42:	2b04      	cmp	r3, #4
 8041b44:	d107      	bne.n	8041b56 <HAL_DMA_Init+0x92>
    tmp |= hdma->Init.FIFOThreshold;
 8041b46:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8041b48:	431d      	orrs	r5, r3
    if (hdma->Init.MemBurst != DMA_MBURST_SINGLE)
 8041b4a:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8041b4c:	b11b      	cbz	r3, 8041b56 <HAL_DMA_Init+0x92>
      if (DMA_CheckFifoParam(hdma) != HAL_OK)
 8041b4e:	4620      	mov	r0, r4
 8041b50:	f7ff ff70 	bl	8041a34 <DMA_CheckFifoParam>
 8041b54:	b990      	cbnz	r0, 8041b7c <HAL_DMA_Init+0xb8>
  hdma->Instance->FCR = tmp;
 8041b56:	6175      	str	r5, [r6, #20]
  regs = (DMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
 8041b58:	4620      	mov	r0, r4
 8041b5a:	f7ff ff49 	bl	80419f0 <DMA_CalcBaseAndBitshift>
  regs->IFCR = 0x3FU << hdma->StreamIndex;
 8041b5e:	6de2      	ldr	r2, [r4, #92]	; 0x5c
 8041b60:	233f      	movs	r3, #63	; 0x3f
 8041b62:	4093      	lsls	r3, r2
 8041b64:	6083      	str	r3, [r0, #8]
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 8041b66:	2000      	movs	r0, #0
 8041b68:	6560      	str	r0, [r4, #84]	; 0x54
  hdma->State = HAL_DMA_STATE_READY;
 8041b6a:	2301      	movs	r3, #1
 8041b6c:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
  return HAL_OK;
 8041b70:	e7c9      	b.n	8041b06 <HAL_DMA_Init+0x42>
    tmp |=  hdma->Init.MemBurst | hdma->Init.PeriphBurst;
 8041b72:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
 8041b74:	6b20      	ldr	r0, [r4, #48]	; 0x30
 8041b76:	4301      	orrs	r1, r0
 8041b78:	430a      	orrs	r2, r1
 8041b7a:	e7db      	b.n	8041b34 <HAL_DMA_Init+0x70>
        hdma->ErrorCode = HAL_DMA_ERROR_PARAM;
 8041b7c:	2340      	movs	r3, #64	; 0x40
 8041b7e:	6563      	str	r3, [r4, #84]	; 0x54
        hdma->State = HAL_DMA_STATE_READY;
 8041b80:	2001      	movs	r0, #1
 8041b82:	f884 0035 	strb.w	r0, [r4, #53]	; 0x35
        return HAL_ERROR; 
 8041b86:	e7be      	b.n	8041b06 <HAL_DMA_Init+0x42>
    return HAL_ERROR;
 8041b88:	2001      	movs	r0, #1
 8041b8a:	e7bc      	b.n	8041b06 <HAL_DMA_Init+0x42>
 8041b8c:	f010803f 	.word	0xf010803f

08041b90 <HAL_DMA_Start_IT>:
{
 8041b90:	b538      	push	{r3, r4, r5, lr}
 8041b92:	4604      	mov	r4, r0
  DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
 8041b94:	6d85      	ldr	r5, [r0, #88]	; 0x58
  __HAL_LOCK(hdma);
 8041b96:	f890 0034 	ldrb.w	r0, [r0, #52]	; 0x34
 8041b9a:	2801      	cmp	r0, #1
 8041b9c:	d030      	beq.n	8041c00 <HAL_DMA_Start_IT+0x70>
 8041b9e:	2001      	movs	r0, #1
 8041ba0:	f884 0034 	strb.w	r0, [r4, #52]	; 0x34
  if(HAL_DMA_STATE_READY == hdma->State)
 8041ba4:	f894 0035 	ldrb.w	r0, [r4, #53]	; 0x35
 8041ba8:	b2c0      	uxtb	r0, r0
 8041baa:	2801      	cmp	r0, #1
 8041bac:	d004      	beq.n	8041bb8 <HAL_DMA_Start_IT+0x28>
    __HAL_UNLOCK(hdma);	  
 8041bae:	2300      	movs	r3, #0
 8041bb0:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
    status = HAL_BUSY;
 8041bb4:	2002      	movs	r0, #2
}
 8041bb6:	bd38      	pop	{r3, r4, r5, pc}
    hdma->State = HAL_DMA_STATE_BUSY;
 8041bb8:	2002      	movs	r0, #2
 8041bba:	f884 0035 	strb.w	r0, [r4, #53]	; 0x35
    hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 8041bbe:	2000      	movs	r0, #0
 8041bc0:	6560      	str	r0, [r4, #84]	; 0x54
    DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength);
 8041bc2:	4620      	mov	r0, r4
 8041bc4:	f7ff fefe 	bl	80419c4 <DMA_SetConfig>
    regs->IFCR = 0x3FU << hdma->StreamIndex;
 8041bc8:	6de2      	ldr	r2, [r4, #92]	; 0x5c
 8041bca:	233f      	movs	r3, #63	; 0x3f
 8041bcc:	4093      	lsls	r3, r2
 8041bce:	60ab      	str	r3, [r5, #8]
    hdma->Instance->CR  |= DMA_IT_TC | DMA_IT_TE | DMA_IT_DME;
 8041bd0:	6822      	ldr	r2, [r4, #0]
 8041bd2:	6813      	ldr	r3, [r2, #0]
 8041bd4:	f043 0316 	orr.w	r3, r3, #22
 8041bd8:	6013      	str	r3, [r2, #0]
    hdma->Instance->FCR |= DMA_IT_FE;
 8041bda:	6822      	ldr	r2, [r4, #0]
 8041bdc:	6953      	ldr	r3, [r2, #20]
 8041bde:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8041be2:	6153      	str	r3, [r2, #20]
    if(hdma->XferHalfCpltCallback != NULL)
 8041be4:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8041be6:	b123      	cbz	r3, 8041bf2 <HAL_DMA_Start_IT+0x62>
      hdma->Instance->CR  |= DMA_IT_HT;
 8041be8:	6822      	ldr	r2, [r4, #0]
 8041bea:	6813      	ldr	r3, [r2, #0]
 8041bec:	f043 0308 	orr.w	r3, r3, #8
 8041bf0:	6013      	str	r3, [r2, #0]
    __HAL_DMA_ENABLE(hdma);
 8041bf2:	6822      	ldr	r2, [r4, #0]
 8041bf4:	6813      	ldr	r3, [r2, #0]
 8041bf6:	f043 0301 	orr.w	r3, r3, #1
 8041bfa:	6013      	str	r3, [r2, #0]
  HAL_StatusTypeDef status = HAL_OK;
 8041bfc:	2000      	movs	r0, #0
 8041bfe:	e7da      	b.n	8041bb6 <HAL_DMA_Start_IT+0x26>
  __HAL_LOCK(hdma);
 8041c00:	2002      	movs	r0, #2
 8041c02:	e7d8      	b.n	8041bb6 <HAL_DMA_Start_IT+0x26>

08041c04 <HAL_DMA_Abort_IT>:
  if(hdma->State != HAL_DMA_STATE_BUSY)
 8041c04:	f890 3035 	ldrb.w	r3, [r0, #53]	; 0x35
 8041c08:	b2db      	uxtb	r3, r3
 8041c0a:	2b02      	cmp	r3, #2
 8041c0c:	d003      	beq.n	8041c16 <HAL_DMA_Abort_IT+0x12>
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 8041c0e:	2380      	movs	r3, #128	; 0x80
 8041c10:	6543      	str	r3, [r0, #84]	; 0x54
    return HAL_ERROR;
 8041c12:	2001      	movs	r0, #1
 8041c14:	4770      	bx	lr
    hdma->State = HAL_DMA_STATE_ABORT;
 8041c16:	2305      	movs	r3, #5
 8041c18:	f880 3035 	strb.w	r3, [r0, #53]	; 0x35
    __HAL_DMA_DISABLE(hdma);
 8041c1c:	6802      	ldr	r2, [r0, #0]
 8041c1e:	6813      	ldr	r3, [r2, #0]
 8041c20:	f023 0301 	bic.w	r3, r3, #1
 8041c24:	6013      	str	r3, [r2, #0]
  return HAL_OK;
 8041c26:	2000      	movs	r0, #0
}
 8041c28:	4770      	bx	lr
	...

08041c2c <HAL_DMA_IRQHandler>:
{
 8041c2c:	b5f0      	push	{r4, r5, r6, r7, lr}
 8041c2e:	b083      	sub	sp, #12
 8041c30:	4604      	mov	r4, r0
  __IO uint32_t count = 0U;
 8041c32:	2300      	movs	r3, #0
 8041c34:	9301      	str	r3, [sp, #4]
  uint32_t timeout = SystemCoreClock / 9600U;
 8041c36:	4b72      	ldr	r3, [pc, #456]	; (8041e00 <HAL_DMA_IRQHandler+0x1d4>)
 8041c38:	681d      	ldr	r5, [r3, #0]
 8041c3a:	4b72      	ldr	r3, [pc, #456]	; (8041e04 <HAL_DMA_IRQHandler+0x1d8>)
 8041c3c:	fba3 3505 	umull	r3, r5, r3, r5
 8041c40:	0aad      	lsrs	r5, r5, #10
  DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
 8041c42:	6d87      	ldr	r7, [r0, #88]	; 0x58
  tmpisr = regs->ISR;
 8041c44:	683e      	ldr	r6, [r7, #0]
  if ((tmpisr & (DMA_FLAG_TEIF0_4 << hdma->StreamIndex)) != RESET)
 8041c46:	6dc2      	ldr	r2, [r0, #92]	; 0x5c
 8041c48:	2308      	movs	r3, #8
 8041c4a:	4093      	lsls	r3, r2
 8041c4c:	4233      	tst	r3, r6
 8041c4e:	d010      	beq.n	8041c72 <HAL_DMA_IRQHandler+0x46>
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TE) != RESET)
 8041c50:	6803      	ldr	r3, [r0, #0]
 8041c52:	681a      	ldr	r2, [r3, #0]
 8041c54:	f012 0f04 	tst.w	r2, #4
 8041c58:	d00b      	beq.n	8041c72 <HAL_DMA_IRQHandler+0x46>
      hdma->Instance->CR  &= ~(DMA_IT_TE);
 8041c5a:	681a      	ldr	r2, [r3, #0]
 8041c5c:	f022 0204 	bic.w	r2, r2, #4
 8041c60:	601a      	str	r2, [r3, #0]
      regs->IFCR = DMA_FLAG_TEIF0_4 << hdma->StreamIndex;
 8041c62:	6dc2      	ldr	r2, [r0, #92]	; 0x5c
 8041c64:	2308      	movs	r3, #8
 8041c66:	4093      	lsls	r3, r2
 8041c68:	60bb      	str	r3, [r7, #8]
      hdma->ErrorCode |= HAL_DMA_ERROR_TE;
 8041c6a:	6d43      	ldr	r3, [r0, #84]	; 0x54
 8041c6c:	f043 0301 	orr.w	r3, r3, #1
 8041c70:	6543      	str	r3, [r0, #84]	; 0x54
  if ((tmpisr & (DMA_FLAG_FEIF0_4 << hdma->StreamIndex)) != RESET)
 8041c72:	6de2      	ldr	r2, [r4, #92]	; 0x5c
 8041c74:	2301      	movs	r3, #1
 8041c76:	4093      	lsls	r3, r2
 8041c78:	4233      	tst	r3, r6
 8041c7a:	d009      	beq.n	8041c90 <HAL_DMA_IRQHandler+0x64>
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_FE) != RESET)
 8041c7c:	6822      	ldr	r2, [r4, #0]
 8041c7e:	6952      	ldr	r2, [r2, #20]
 8041c80:	f012 0f80 	tst.w	r2, #128	; 0x80
 8041c84:	d004      	beq.n	8041c90 <HAL_DMA_IRQHandler+0x64>
      regs->IFCR = DMA_FLAG_FEIF0_4 << hdma->StreamIndex;
 8041c86:	60bb      	str	r3, [r7, #8]
      hdma->ErrorCode |= HAL_DMA_ERROR_FE;
 8041c88:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8041c8a:	f043 0302 	orr.w	r3, r3, #2
 8041c8e:	6563      	str	r3, [r4, #84]	; 0x54
  if ((tmpisr & (DMA_FLAG_DMEIF0_4 << hdma->StreamIndex)) != RESET)
 8041c90:	6de2      	ldr	r2, [r4, #92]	; 0x5c
 8041c92:	2304      	movs	r3, #4
 8041c94:	4093      	lsls	r3, r2
 8041c96:	4233      	tst	r3, r6
 8041c98:	d009      	beq.n	8041cae <HAL_DMA_IRQHandler+0x82>
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_DME) != RESET)
 8041c9a:	6822      	ldr	r2, [r4, #0]
 8041c9c:	6812      	ldr	r2, [r2, #0]
 8041c9e:	f012 0f02 	tst.w	r2, #2
 8041ca2:	d004      	beq.n	8041cae <HAL_DMA_IRQHandler+0x82>
      regs->IFCR = DMA_FLAG_DMEIF0_4 << hdma->StreamIndex;
 8041ca4:	60bb      	str	r3, [r7, #8]
      hdma->ErrorCode |= HAL_DMA_ERROR_DME;
 8041ca6:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8041ca8:	f043 0304 	orr.w	r3, r3, #4
 8041cac:	6563      	str	r3, [r4, #84]	; 0x54
  if ((tmpisr & (DMA_FLAG_HTIF0_4 << hdma->StreamIndex)) != RESET)
 8041cae:	6de2      	ldr	r2, [r4, #92]	; 0x5c
 8041cb0:	2310      	movs	r3, #16
 8041cb2:	4093      	lsls	r3, r2
 8041cb4:	4233      	tst	r3, r6
 8041cb6:	d024      	beq.n	8041d02 <HAL_DMA_IRQHandler+0xd6>
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_HT) != RESET)
 8041cb8:	6822      	ldr	r2, [r4, #0]
 8041cba:	6812      	ldr	r2, [r2, #0]
 8041cbc:	f012 0f08 	tst.w	r2, #8
 8041cc0:	d01f      	beq.n	8041d02 <HAL_DMA_IRQHandler+0xd6>
      regs->IFCR = DMA_FLAG_HTIF0_4 << hdma->StreamIndex;
 8041cc2:	60bb      	str	r3, [r7, #8]
      if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != RESET)
 8041cc4:	6823      	ldr	r3, [r4, #0]
 8041cc6:	681a      	ldr	r2, [r3, #0]
 8041cc8:	f412 2f80 	tst.w	r2, #262144	; 0x40000
 8041ccc:	d00d      	beq.n	8041cea <HAL_DMA_IRQHandler+0xbe>
        if((hdma->Instance->CR & DMA_SxCR_CT) == RESET)
 8041cce:	681b      	ldr	r3, [r3, #0]
 8041cd0:	f413 2f00 	tst.w	r3, #524288	; 0x80000
 8041cd4:	d104      	bne.n	8041ce0 <HAL_DMA_IRQHandler+0xb4>
          if(hdma->XferHalfCpltCallback != NULL)
 8041cd6:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8041cd8:	b19b      	cbz	r3, 8041d02 <HAL_DMA_IRQHandler+0xd6>
            hdma->XferHalfCpltCallback(hdma);
 8041cda:	4620      	mov	r0, r4
 8041cdc:	4798      	blx	r3
 8041cde:	e010      	b.n	8041d02 <HAL_DMA_IRQHandler+0xd6>
          if(hdma->XferM1HalfCpltCallback != NULL)
 8041ce0:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8041ce2:	b173      	cbz	r3, 8041d02 <HAL_DMA_IRQHandler+0xd6>
            hdma->XferM1HalfCpltCallback(hdma);
 8041ce4:	4620      	mov	r0, r4
 8041ce6:	4798      	blx	r3
 8041ce8:	e00b      	b.n	8041d02 <HAL_DMA_IRQHandler+0xd6>
        if((hdma->Instance->CR & DMA_SxCR_CIRC) == RESET)
 8041cea:	681a      	ldr	r2, [r3, #0]
 8041cec:	f412 7f80 	tst.w	r2, #256	; 0x100
 8041cf0:	d103      	bne.n	8041cfa <HAL_DMA_IRQHandler+0xce>
          hdma->Instance->CR  &= ~(DMA_IT_HT);
 8041cf2:	681a      	ldr	r2, [r3, #0]
 8041cf4:	f022 0208 	bic.w	r2, r2, #8
 8041cf8:	601a      	str	r2, [r3, #0]
        if(hdma->XferHalfCpltCallback != NULL)
 8041cfa:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8041cfc:	b10b      	cbz	r3, 8041d02 <HAL_DMA_IRQHandler+0xd6>
          hdma->XferHalfCpltCallback(hdma);
 8041cfe:	4620      	mov	r0, r4
 8041d00:	4798      	blx	r3
  if ((tmpisr & (DMA_FLAG_TCIF0_4 << hdma->StreamIndex)) != RESET)
 8041d02:	6de2      	ldr	r2, [r4, #92]	; 0x5c
 8041d04:	2320      	movs	r3, #32
 8041d06:	4093      	lsls	r3, r2
 8041d08:	4233      	tst	r3, r6
 8041d0a:	d055      	beq.n	8041db8 <HAL_DMA_IRQHandler+0x18c>
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TC) != RESET)
 8041d0c:	6822      	ldr	r2, [r4, #0]
 8041d0e:	6812      	ldr	r2, [r2, #0]
 8041d10:	f012 0f10 	tst.w	r2, #16
 8041d14:	d050      	beq.n	8041db8 <HAL_DMA_IRQHandler+0x18c>
      regs->IFCR = DMA_FLAG_TCIF0_4 << hdma->StreamIndex;
 8041d16:	60bb      	str	r3, [r7, #8]
      if(HAL_DMA_STATE_ABORT == hdma->State)
 8041d18:	f894 3035 	ldrb.w	r3, [r4, #53]	; 0x35
 8041d1c:	b2db      	uxtb	r3, r3
 8041d1e:	2b05      	cmp	r3, #5
 8041d20:	d00e      	beq.n	8041d40 <HAL_DMA_IRQHandler+0x114>
      if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != RESET)
 8041d22:	6823      	ldr	r3, [r4, #0]
 8041d24:	681a      	ldr	r2, [r3, #0]
 8041d26:	f412 2f80 	tst.w	r2, #262144	; 0x40000
 8041d2a:	d033      	beq.n	8041d94 <HAL_DMA_IRQHandler+0x168>
        if((hdma->Instance->CR & DMA_SxCR_CT) == RESET)
 8041d2c:	681b      	ldr	r3, [r3, #0]
 8041d2e:	f413 2f00 	tst.w	r3, #524288	; 0x80000
 8041d32:	d12a      	bne.n	8041d8a <HAL_DMA_IRQHandler+0x15e>
          if(hdma->XferM1CpltCallback != NULL)
 8041d34:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8041d36:	2b00      	cmp	r3, #0
 8041d38:	d03e      	beq.n	8041db8 <HAL_DMA_IRQHandler+0x18c>
            hdma->XferM1CpltCallback(hdma);
 8041d3a:	4620      	mov	r0, r4
 8041d3c:	4798      	blx	r3
 8041d3e:	e03b      	b.n	8041db8 <HAL_DMA_IRQHandler+0x18c>
        hdma->Instance->CR  &= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME);
 8041d40:	6822      	ldr	r2, [r4, #0]
 8041d42:	6813      	ldr	r3, [r2, #0]
 8041d44:	f023 0316 	bic.w	r3, r3, #22
 8041d48:	6013      	str	r3, [r2, #0]
        hdma->Instance->FCR &= ~(DMA_IT_FE);
 8041d4a:	6822      	ldr	r2, [r4, #0]
 8041d4c:	6953      	ldr	r3, [r2, #20]
 8041d4e:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8041d52:	6153      	str	r3, [r2, #20]
        if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
 8041d54:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8041d56:	b1a3      	cbz	r3, 8041d82 <HAL_DMA_IRQHandler+0x156>
          hdma->Instance->CR  &= ~(DMA_IT_HT);
 8041d58:	6822      	ldr	r2, [r4, #0]
 8041d5a:	6813      	ldr	r3, [r2, #0]
 8041d5c:	f023 0308 	bic.w	r3, r3, #8
 8041d60:	6013      	str	r3, [r2, #0]
        regs->IFCR = 0x3FU << hdma->StreamIndex;
 8041d62:	6de2      	ldr	r2, [r4, #92]	; 0x5c
 8041d64:	233f      	movs	r3, #63	; 0x3f
 8041d66:	4093      	lsls	r3, r2
 8041d68:	60bb      	str	r3, [r7, #8]
        __HAL_UNLOCK(hdma);
 8041d6a:	2300      	movs	r3, #0
 8041d6c:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
        hdma->State = HAL_DMA_STATE_READY;
 8041d70:	2301      	movs	r3, #1
 8041d72:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
        if(hdma->XferAbortCallback != NULL)
 8041d76:	6d23      	ldr	r3, [r4, #80]	; 0x50
 8041d78:	2b00      	cmp	r3, #0
 8041d7a:	d03f      	beq.n	8041dfc <HAL_DMA_IRQHandler+0x1d0>
          hdma->XferAbortCallback(hdma);
 8041d7c:	4620      	mov	r0, r4
 8041d7e:	4798      	blx	r3
        return;
 8041d80:	e03c      	b.n	8041dfc <HAL_DMA_IRQHandler+0x1d0>
        if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
 8041d82:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8041d84:	2b00      	cmp	r3, #0
 8041d86:	d1e7      	bne.n	8041d58 <HAL_DMA_IRQHandler+0x12c>
 8041d88:	e7eb      	b.n	8041d62 <HAL_DMA_IRQHandler+0x136>
          if(hdma->XferCpltCallback != NULL)
 8041d8a:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8041d8c:	b1a3      	cbz	r3, 8041db8 <HAL_DMA_IRQHandler+0x18c>
            hdma->XferCpltCallback(hdma);
 8041d8e:	4620      	mov	r0, r4
 8041d90:	4798      	blx	r3
 8041d92:	e011      	b.n	8041db8 <HAL_DMA_IRQHandler+0x18c>
        if((hdma->Instance->CR & DMA_SxCR_CIRC) == RESET)
 8041d94:	681a      	ldr	r2, [r3, #0]
 8041d96:	f412 7f80 	tst.w	r2, #256	; 0x100
 8041d9a:	d109      	bne.n	8041db0 <HAL_DMA_IRQHandler+0x184>
          hdma->Instance->CR  &= ~(DMA_IT_TC);
 8041d9c:	681a      	ldr	r2, [r3, #0]
 8041d9e:	f022 0210 	bic.w	r2, r2, #16
 8041da2:	601a      	str	r2, [r3, #0]
          __HAL_UNLOCK(hdma);
 8041da4:	2300      	movs	r3, #0
 8041da6:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
          hdma->State = HAL_DMA_STATE_READY;
 8041daa:	2301      	movs	r3, #1
 8041dac:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
        if(hdma->XferCpltCallback != NULL)
 8041db0:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8041db2:	b10b      	cbz	r3, 8041db8 <HAL_DMA_IRQHandler+0x18c>
          hdma->XferCpltCallback(hdma);
 8041db4:	4620      	mov	r0, r4
 8041db6:	4798      	blx	r3
  if(hdma->ErrorCode != HAL_DMA_ERROR_NONE)
 8041db8:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8041dba:	b1fb      	cbz	r3, 8041dfc <HAL_DMA_IRQHandler+0x1d0>
    if((hdma->ErrorCode & HAL_DMA_ERROR_TE) != RESET)
 8041dbc:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8041dbe:	f013 0f01 	tst.w	r3, #1
 8041dc2:	d017      	beq.n	8041df4 <HAL_DMA_IRQHandler+0x1c8>
      hdma->State = HAL_DMA_STATE_ABORT;
 8041dc4:	2305      	movs	r3, #5
 8041dc6:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
      __HAL_DMA_DISABLE(hdma);
 8041dca:	6822      	ldr	r2, [r4, #0]
 8041dcc:	6813      	ldr	r3, [r2, #0]
 8041dce:	f023 0301 	bic.w	r3, r3, #1
 8041dd2:	6013      	str	r3, [r2, #0]
        if (++count > timeout)
 8041dd4:	9b01      	ldr	r3, [sp, #4]
 8041dd6:	3301      	adds	r3, #1
 8041dd8:	9301      	str	r3, [sp, #4]
 8041dda:	42ab      	cmp	r3, r5
 8041ddc:	d804      	bhi.n	8041de8 <HAL_DMA_IRQHandler+0x1bc>
      while((hdma->Instance->CR & DMA_SxCR_EN) != RESET);
 8041dde:	6823      	ldr	r3, [r4, #0]
 8041de0:	681b      	ldr	r3, [r3, #0]
 8041de2:	f013 0f01 	tst.w	r3, #1
 8041de6:	d1f5      	bne.n	8041dd4 <HAL_DMA_IRQHandler+0x1a8>
      __HAL_UNLOCK(hdma);
 8041de8:	2300      	movs	r3, #0
 8041dea:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
      hdma->State = HAL_DMA_STATE_READY;
 8041dee:	2301      	movs	r3, #1
 8041df0:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
    if(hdma->XferErrorCallback != NULL)
 8041df4:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 8041df6:	b10b      	cbz	r3, 8041dfc <HAL_DMA_IRQHandler+0x1d0>
      hdma->XferErrorCallback(hdma);
 8041df8:	4620      	mov	r0, r4
 8041dfa:	4798      	blx	r3
}
 8041dfc:	b003      	add	sp, #12
 8041dfe:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8041e00:	20003678 	.word	0x20003678
 8041e04:	1b4e81b5 	.word	0x1b4e81b5

08041e08 <HAL_DMA_GetState>:
  return hdma->State;
 8041e08:	f890 0035 	ldrb.w	r0, [r0, #53]	; 0x35
}
 8041e0c:	4770      	bx	lr
	...

08041e10 <ETH_MACAddressConfig>:

  /* Check the parameters */
  assert_param(IS_ETH_MAC_ADDRESS0123(MacAddr));
  
  /* Calculate the selected MAC address high register */
  tmpreg1 = ((uint32_t)Addr[5U] << 8U) | (uint32_t)Addr[4U];
 8041e10:	7950      	ldrb	r0, [r2, #5]
 8041e12:	7913      	ldrb	r3, [r2, #4]
 8041e14:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
  /* Load the selected MAC address high register */
  (*(__IO uint32_t *)((uint32_t)(ETH_MAC_ADDR_HBASE + MacAddr))) = tmpreg1;
 8041e18:	4807      	ldr	r0, [pc, #28]	; (8041e38 <ETH_MACAddressConfig+0x28>)
 8041e1a:	500b      	str	r3, [r1, r0]
  /* Calculate the selected MAC address low register */
  tmpreg1 = ((uint32_t)Addr[3U] << 24U) | ((uint32_t)Addr[2U] << 16U) | ((uint32_t)Addr[1U] << 8U) | Addr[0U];
 8041e1c:	78d0      	ldrb	r0, [r2, #3]
 8041e1e:	7893      	ldrb	r3, [r2, #2]
 8041e20:	041b      	lsls	r3, r3, #16
 8041e22:	ea43 6300 	orr.w	r3, r3, r0, lsl #24
 8041e26:	7850      	ldrb	r0, [r2, #1]
 8041e28:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
 8041e2c:	7812      	ldrb	r2, [r2, #0]
 8041e2e:	4313      	orrs	r3, r2
  
  /* Load the selected MAC address low register */
  (*(__IO uint32_t *)((uint32_t)(ETH_MAC_ADDR_LBASE + MacAddr))) = tmpreg1;
 8041e30:	4a02      	ldr	r2, [pc, #8]	; (8041e3c <ETH_MACAddressConfig+0x2c>)
 8041e32:	508b      	str	r3, [r1, r2]
}
 8041e34:	4770      	bx	lr
 8041e36:	bf00      	nop
 8041e38:	40028040 	.word	0x40028040
 8041e3c:	40028044 	.word	0x40028044

08041e40 <ETH_DMATransmissionEnable>:
  * @retval None
  */
static void ETH_DMATransmissionEnable(ETH_HandleTypeDef *heth)
{
  /* Enable the DMA transmission */
  (heth->Instance)->DMAOMR |= ETH_DMAOMR_ST;  
 8041e40:	6801      	ldr	r1, [r0, #0]
 8041e42:	f241 0218 	movw	r2, #4120	; 0x1018
 8041e46:	588b      	ldr	r3, [r1, r2]
 8041e48:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8041e4c:	508b      	str	r3, [r1, r2]
}
 8041e4e:	4770      	bx	lr

08041e50 <ETH_DMAReceptionEnable>:
  * @retval None
  */
static void ETH_DMAReceptionEnable(ETH_HandleTypeDef *heth)
{  
  /* Enable the DMA reception */
  (heth->Instance)->DMAOMR |= ETH_DMAOMR_SR;  
 8041e50:	6801      	ldr	r1, [r0, #0]
 8041e52:	f241 0218 	movw	r2, #4120	; 0x1018
 8041e56:	588b      	ldr	r3, [r1, r2]
 8041e58:	f043 0302 	orr.w	r3, r3, #2
 8041e5c:	508b      	str	r3, [r1, r2]
}
 8041e5e:	4770      	bx	lr

08041e60 <ETH_Delay>:
  * @brief  This function provides delay (in milliseconds) based on CPU cycles method.
  * @param  mdelay specifies the delay time length, in milliseconds.
  * @retval None
  */
static void ETH_Delay(uint32_t mdelay)
{
 8041e60:	b082      	sub	sp, #8
  __IO uint32_t Delay = mdelay * (SystemCoreClock / 8U / 1000U);
 8041e62:	4b08      	ldr	r3, [pc, #32]	; (8041e84 <ETH_Delay+0x24>)
 8041e64:	681b      	ldr	r3, [r3, #0]
 8041e66:	4a08      	ldr	r2, [pc, #32]	; (8041e88 <ETH_Delay+0x28>)
 8041e68:	fba2 2303 	umull	r2, r3, r2, r3
 8041e6c:	0a5b      	lsrs	r3, r3, #9
 8041e6e:	fb00 f303 	mul.w	r3, r0, r3
 8041e72:	9301      	str	r3, [sp, #4]
  do 
  {
    __NOP();
 8041e74:	bf00      	nop
  } 
  while (Delay --);
 8041e76:	9b01      	ldr	r3, [sp, #4]
 8041e78:	1e5a      	subs	r2, r3, #1
 8041e7a:	9201      	str	r2, [sp, #4]
 8041e7c:	2b00      	cmp	r3, #0
 8041e7e:	d1f9      	bne.n	8041e74 <ETH_Delay+0x14>
}
 8041e80:	b002      	add	sp, #8
 8041e82:	4770      	bx	lr
 8041e84:	20003678 	.word	0x20003678
 8041e88:	10624dd3 	.word	0x10624dd3

08041e8c <ETH_MACTransmissionEnable>:
{ 
 8041e8c:	b510      	push	{r4, lr}
 8041e8e:	b082      	sub	sp, #8
 8041e90:	4604      	mov	r4, r0
  __IO uint32_t tmpreg1 = 0U;
 8041e92:	2300      	movs	r3, #0
 8041e94:	9301      	str	r3, [sp, #4]
  (heth->Instance)->MACCR |= ETH_MACCR_TE;
 8041e96:	6802      	ldr	r2, [r0, #0]
 8041e98:	6813      	ldr	r3, [r2, #0]
 8041e9a:	f043 0308 	orr.w	r3, r3, #8
 8041e9e:	6013      	str	r3, [r2, #0]
  tmpreg1 = (heth->Instance)->MACCR;
 8041ea0:	6803      	ldr	r3, [r0, #0]
 8041ea2:	681b      	ldr	r3, [r3, #0]
 8041ea4:	9301      	str	r3, [sp, #4]
  ETH_Delay(ETH_REG_WRITE_DELAY);
 8041ea6:	2001      	movs	r0, #1
 8041ea8:	f7ff ffda 	bl	8041e60 <ETH_Delay>
  (heth->Instance)->MACCR = tmpreg1;
 8041eac:	6823      	ldr	r3, [r4, #0]
 8041eae:	9a01      	ldr	r2, [sp, #4]
 8041eb0:	601a      	str	r2, [r3, #0]
}
 8041eb2:	b002      	add	sp, #8
 8041eb4:	bd10      	pop	{r4, pc}

08041eb6 <ETH_MACReceptionEnable>:
{ 
 8041eb6:	b510      	push	{r4, lr}
 8041eb8:	b082      	sub	sp, #8
 8041eba:	4604      	mov	r4, r0
  __IO uint32_t tmpreg1 = 0U;
 8041ebc:	2300      	movs	r3, #0
 8041ebe:	9301      	str	r3, [sp, #4]
  (heth->Instance)->MACCR |= ETH_MACCR_RE;
 8041ec0:	6802      	ldr	r2, [r0, #0]
 8041ec2:	6813      	ldr	r3, [r2, #0]
 8041ec4:	f043 0304 	orr.w	r3, r3, #4
 8041ec8:	6013      	str	r3, [r2, #0]
  tmpreg1 = (heth->Instance)->MACCR;
 8041eca:	6803      	ldr	r3, [r0, #0]
 8041ecc:	681b      	ldr	r3, [r3, #0]
 8041ece:	9301      	str	r3, [sp, #4]
  ETH_Delay(ETH_REG_WRITE_DELAY);
 8041ed0:	2001      	movs	r0, #1
 8041ed2:	f7ff ffc5 	bl	8041e60 <ETH_Delay>
  (heth->Instance)->MACCR = tmpreg1;
 8041ed6:	6823      	ldr	r3, [r4, #0]
 8041ed8:	9a01      	ldr	r2, [sp, #4]
 8041eda:	601a      	str	r2, [r3, #0]
}
 8041edc:	b002      	add	sp, #8
 8041ede:	bd10      	pop	{r4, pc}

08041ee0 <ETH_FlushTransmitFIFO>:
{
 8041ee0:	b530      	push	{r4, r5, lr}
 8041ee2:	b083      	sub	sp, #12
 8041ee4:	4604      	mov	r4, r0
  __IO uint32_t tmpreg1 = 0U;
 8041ee6:	2300      	movs	r3, #0
 8041ee8:	9301      	str	r3, [sp, #4]
  (heth->Instance)->DMAOMR |= ETH_DMAOMR_FTF;
 8041eea:	6802      	ldr	r2, [r0, #0]
 8041eec:	f241 0518 	movw	r5, #4120	; 0x1018
 8041ef0:	5953      	ldr	r3, [r2, r5]
 8041ef2:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8041ef6:	5153      	str	r3, [r2, r5]
  tmpreg1 = (heth->Instance)->DMAOMR;
 8041ef8:	6803      	ldr	r3, [r0, #0]
 8041efa:	595b      	ldr	r3, [r3, r5]
 8041efc:	9301      	str	r3, [sp, #4]
  ETH_Delay(ETH_REG_WRITE_DELAY);
 8041efe:	2001      	movs	r0, #1
 8041f00:	f7ff ffae 	bl	8041e60 <ETH_Delay>
  (heth->Instance)->DMAOMR = tmpreg1;
 8041f04:	6823      	ldr	r3, [r4, #0]
 8041f06:	9a01      	ldr	r2, [sp, #4]
 8041f08:	515a      	str	r2, [r3, r5]
}
 8041f0a:	b003      	add	sp, #12
 8041f0c:	bd30      	pop	{r4, r5, pc}
	...

08041f10 <ETH_MACDMAConfig>:
{
 8041f10:	b570      	push	{r4, r5, r6, lr}
 8041f12:	b09e      	sub	sp, #120	; 0x78
 8041f14:	4604      	mov	r4, r0
  if (err != ETH_SUCCESS) /* Auto-negotiation failed */
 8041f16:	b129      	cbz	r1, 8041f24 <ETH_MACDMAConfig+0x14>
    (heth->Init).DuplexMode = ETH_MODE_FULLDUPLEX;
 8041f18:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8041f1c:	60c3      	str	r3, [r0, #12]
    (heth->Init).Speed = ETH_SPEED_100M;
 8041f1e:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 8041f22:	6083      	str	r3, [r0, #8]
  if(heth->Init.ChecksumMode == ETH_CHECKSUM_BY_HARDWARE)
 8041f24:	69e3      	ldr	r3, [r4, #28]
 8041f26:	2b00      	cmp	r3, #0
 8041f28:	d16a      	bne.n	8042000 <ETH_MACDMAConfig+0xf0>
    macinit.ChecksumOffload = ETH_CHECKSUMOFFLAOD_ENABLE;
 8041f2a:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8041f2e:	9307      	str	r3, [sp, #28]
  tmpreg1 = (heth->Instance)->MACCR;
 8041f30:	6821      	ldr	r1, [r4, #0]
 8041f32:	680b      	ldr	r3, [r1, #0]
  tmpreg1 &= ETH_MACCR_CLEAR_MASK;
 8041f34:	4a39      	ldr	r2, [pc, #228]	; (804201c <ETH_MACDMAConfig+0x10c>)
 8041f36:	401a      	ands	r2, r3
                       (heth->Init).Speed | 
 8041f38:	68a3      	ldr	r3, [r4, #8]
                       (heth->Init).DuplexMode | 
 8041f3a:	68e0      	ldr	r0, [r4, #12]
                       macinit.LoopbackMode |
 8041f3c:	4303      	orrs	r3, r0
                       macinit.ChecksumOffload |    
 8041f3e:	9807      	ldr	r0, [sp, #28]
                       (heth->Init).DuplexMode | 
 8041f40:	4303      	orrs	r3, r0
                       macinit.ChecksumOffload |    
 8041f42:	f443 7300 	orr.w	r3, r3, #512	; 0x200
  tmpreg1 |= (uint32_t)(macinit.Watchdog | 
 8041f46:	4313      	orrs	r3, r2
  (heth->Instance)->MACCR = (uint32_t)tmpreg1;
 8041f48:	600b      	str	r3, [r1, #0]
  tmpreg1 = (heth->Instance)->MACCR;
 8041f4a:	6823      	ldr	r3, [r4, #0]
 8041f4c:	681d      	ldr	r5, [r3, #0]
  HAL_Delay(ETH_REG_WRITE_DELAY);
 8041f4e:	2001      	movs	r0, #1
 8041f50:	f7ff f8bc 	bl	80410cc <HAL_Delay>
  (heth->Instance)->MACCR = tmpreg1; 
 8041f54:	6823      	ldr	r3, [r4, #0]
 8041f56:	601d      	str	r5, [r3, #0]
  (heth->Instance)->MACFFR = (uint32_t)(macinit.ReceiveAll | 
 8041f58:	6823      	ldr	r3, [r4, #0]
 8041f5a:	2240      	movs	r2, #64	; 0x40
 8041f5c:	605a      	str	r2, [r3, #4]
   tmpreg1 = (heth->Instance)->MACFFR;
 8041f5e:	6823      	ldr	r3, [r4, #0]
 8041f60:	685d      	ldr	r5, [r3, #4]
   HAL_Delay(ETH_REG_WRITE_DELAY);
 8041f62:	2001      	movs	r0, #1
 8041f64:	f7ff f8b2 	bl	80410cc <HAL_Delay>
   (heth->Instance)->MACFFR = tmpreg1;
 8041f68:	6823      	ldr	r3, [r4, #0]
 8041f6a:	605d      	str	r5, [r3, #4]
   (heth->Instance)->MACHTHR = (uint32_t)macinit.HashTableHigh;
 8041f6c:	6823      	ldr	r3, [r4, #0]
 8041f6e:	2500      	movs	r5, #0
 8041f70:	609d      	str	r5, [r3, #8]
   (heth->Instance)->MACHTLR = (uint32_t)macinit.HashTableLow;
 8041f72:	6823      	ldr	r3, [r4, #0]
 8041f74:	60dd      	str	r5, [r3, #12]
   tmpreg1 = (heth->Instance)->MACFCR;
 8041f76:	6822      	ldr	r2, [r4, #0]
 8041f78:	6993      	ldr	r3, [r2, #24]
   tmpreg1 &= ETH_MACFCR_CLEAR_MASK;
 8041f7a:	f023 03be 	bic.w	r3, r3, #190	; 0xbe
 8041f7e:	041b      	lsls	r3, r3, #16
 8041f80:	0c1b      	lsrs	r3, r3, #16
   tmpreg1 |= (uint32_t)((macinit.PauseTime << 16U) | 
 8041f82:	f043 0380 	orr.w	r3, r3, #128	; 0x80
   (heth->Instance)->MACFCR = (uint32_t)tmpreg1;
 8041f86:	6193      	str	r3, [r2, #24]
   tmpreg1 = (heth->Instance)->MACFCR;
 8041f88:	6823      	ldr	r3, [r4, #0]
 8041f8a:	699e      	ldr	r6, [r3, #24]
   HAL_Delay(ETH_REG_WRITE_DELAY);
 8041f8c:	2001      	movs	r0, #1
 8041f8e:	f7ff f89d 	bl	80410cc <HAL_Delay>
   (heth->Instance)->MACFCR = tmpreg1;
 8041f92:	6823      	ldr	r3, [r4, #0]
 8041f94:	619e      	str	r6, [r3, #24]
   (heth->Instance)->MACVLANTR = (uint32_t)(macinit.VLANTagComparison | 
 8041f96:	6823      	ldr	r3, [r4, #0]
 8041f98:	61dd      	str	r5, [r3, #28]
    tmpreg1 = (heth->Instance)->MACVLANTR;
 8041f9a:	6823      	ldr	r3, [r4, #0]
 8041f9c:	69dd      	ldr	r5, [r3, #28]
    HAL_Delay(ETH_REG_WRITE_DELAY);
 8041f9e:	2001      	movs	r0, #1
 8041fa0:	f7ff f894 	bl	80410cc <HAL_Delay>
    (heth->Instance)->MACVLANTR = tmpreg1;
 8041fa4:	6823      	ldr	r3, [r4, #0]
 8041fa6:	61dd      	str	r5, [r3, #28]
    tmpreg1 = (heth->Instance)->DMAOMR;
 8041fa8:	6822      	ldr	r2, [r4, #0]
 8041faa:	f241 0518 	movw	r5, #4120	; 0x1018
 8041fae:	5951      	ldr	r1, [r2, r5]
    tmpreg1 &= ETH_DMAOMR_CLEAR_MASK;
 8041fb0:	4b1b      	ldr	r3, [pc, #108]	; (8042020 <ETH_MACDMAConfig+0x110>)
 8041fb2:	400b      	ands	r3, r1
    tmpreg1 |= (uint32_t)(dmainit.DropTCPIPChecksumErrorFrame | 
 8041fb4:	f043 7308 	orr.w	r3, r3, #35651584	; 0x2200000
 8041fb8:	f043 0304 	orr.w	r3, r3, #4
    (heth->Instance)->DMAOMR = (uint32_t)tmpreg1;
 8041fbc:	5153      	str	r3, [r2, r5]
    tmpreg1 = (heth->Instance)->DMAOMR;
 8041fbe:	6823      	ldr	r3, [r4, #0]
 8041fc0:	595e      	ldr	r6, [r3, r5]
    HAL_Delay(ETH_REG_WRITE_DELAY);
 8041fc2:	2001      	movs	r0, #1
 8041fc4:	f7ff f882 	bl	80410cc <HAL_Delay>
    (heth->Instance)->DMAOMR = tmpreg1;
 8041fc8:	6823      	ldr	r3, [r4, #0]
 8041fca:	515e      	str	r6, [r3, r5]
    (heth->Instance)->DMABMR = (uint32_t)(dmainit.AddressAlignedBeats | 
 8041fcc:	6823      	ldr	r3, [r4, #0]
 8041fce:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8041fd2:	4a14      	ldr	r2, [pc, #80]	; (8042024 <ETH_MACDMAConfig+0x114>)
 8041fd4:	601a      	str	r2, [r3, #0]
     tmpreg1 = (heth->Instance)->DMABMR;
 8041fd6:	6823      	ldr	r3, [r4, #0]
 8041fd8:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8041fdc:	681d      	ldr	r5, [r3, #0]
     HAL_Delay(ETH_REG_WRITE_DELAY);
 8041fde:	2001      	movs	r0, #1
 8041fe0:	f7ff f874 	bl	80410cc <HAL_Delay>
     (heth->Instance)->DMABMR = tmpreg1;
 8041fe4:	6823      	ldr	r3, [r4, #0]
 8041fe6:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8041fea:	601d      	str	r5, [r3, #0]
     if((heth->Init).RxMode == ETH_RXINTERRUPT_MODE)
 8041fec:	69a3      	ldr	r3, [r4, #24]
 8041fee:	2b01      	cmp	r3, #1
 8041ff0:	d009      	beq.n	8042006 <ETH_MACDMAConfig+0xf6>
     ETH_MACAddressConfig(heth, ETH_MAC_ADDRESS0, heth->Init.MACAddr);
 8041ff2:	6962      	ldr	r2, [r4, #20]
 8041ff4:	2100      	movs	r1, #0
 8041ff6:	4620      	mov	r0, r4
 8041ff8:	f7ff ff0a 	bl	8041e10 <ETH_MACAddressConfig>
}
 8041ffc:	b01e      	add	sp, #120	; 0x78
 8041ffe:	bd70      	pop	{r4, r5, r6, pc}
    macinit.ChecksumOffload = ETH_CHECKSUMOFFLAOD_DISABLE;
 8042000:	2300      	movs	r3, #0
 8042002:	9307      	str	r3, [sp, #28]
 8042004:	e794      	b.n	8041f30 <ETH_MACDMAConfig+0x20>
       __HAL_ETH_DMA_ENABLE_IT((heth), ETH_DMA_IT_NIS | ETH_DMA_IT_R);
 8042006:	6821      	ldr	r1, [r4, #0]
 8042008:	f241 021c 	movw	r2, #4124	; 0x101c
 804200c:	588b      	ldr	r3, [r1, r2]
 804200e:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8042012:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8042016:	508b      	str	r3, [r1, r2]
 8042018:	e7eb      	b.n	8041ff2 <ETH_MACDMAConfig+0xe2>
 804201a:	bf00      	nop
 804201c:	ff20810f 	.word	0xff20810f
 8042020:	f8de3f23 	.word	0xf8de3f23
 8042024:	02c12080 	.word	0x02c12080

08042028 <HAL_ETH_DMATxDescListInit>:
{
 8042028:	b4f0      	push	{r4, r5, r6, r7}
  __HAL_LOCK(heth);
 804202a:	f890 4045 	ldrb.w	r4, [r0, #69]	; 0x45
 804202e:	2c01      	cmp	r4, #1
 8042030:	d032      	beq.n	8042098 <HAL_ETH_DMATxDescListInit+0x70>
 8042032:	2401      	movs	r4, #1
 8042034:	f880 4045 	strb.w	r4, [r0, #69]	; 0x45
  heth->State = HAL_ETH_STATE_BUSY;
 8042038:	2402      	movs	r4, #2
 804203a:	f880 4044 	strb.w	r4, [r0, #68]	; 0x44
  heth->TxDesc = DMATxDescTab;
 804203e:	62c1      	str	r1, [r0, #44]	; 0x2c
  for(i=0U; i < TxBuffCount; i++)
 8042040:	2400      	movs	r4, #0
 8042042:	e001      	b.n	8042048 <HAL_ETH_DMATxDescListInit+0x20>
      dmatxdesc->Buffer2NextDescAddr = (uint32_t) DMATxDescTab;  
 8042044:	60f1      	str	r1, [r6, #12]
  for(i=0U; i < TxBuffCount; i++)
 8042046:	3401      	adds	r4, #1
 8042048:	429c      	cmp	r4, r3
 804204a:	d218      	bcs.n	804207e <HAL_ETH_DMATxDescListInit+0x56>
    dmatxdesc = DMATxDescTab + i;
 804204c:	0167      	lsls	r7, r4, #5
 804204e:	eb01 1644 	add.w	r6, r1, r4, lsl #5
    dmatxdesc->Status = ETH_DMATXDESC_TCH;  
 8042052:	f44f 1580 	mov.w	r5, #1048576	; 0x100000
 8042056:	51cd      	str	r5, [r1, r7]
    dmatxdesc->Buffer1Addr = (uint32_t)(&TxBuff[i*ETH_TX_BUF_SIZE]);
 8042058:	f240 55f4 	movw	r5, #1524	; 0x5f4
 804205c:	fb05 2504 	mla	r5, r5, r4, r2
 8042060:	60b5      	str	r5, [r6, #8]
    if ((heth->Init).ChecksumMode == ETH_CHECKSUM_BY_HARDWARE)
 8042062:	69c5      	ldr	r5, [r0, #28]
 8042064:	b91d      	cbnz	r5, 804206e <HAL_ETH_DMATxDescListInit+0x46>
      dmatxdesc->Status |= ETH_DMATXDESC_CHECKSUMTCPUDPICMPFULL;
 8042066:	59cd      	ldr	r5, [r1, r7]
 8042068:	f445 0540 	orr.w	r5, r5, #12582912	; 0xc00000
 804206c:	51cd      	str	r5, [r1, r7]
    if(i < (TxBuffCount-1U))
 804206e:	1e5d      	subs	r5, r3, #1
 8042070:	42a5      	cmp	r5, r4
 8042072:	d9e7      	bls.n	8042044 <HAL_ETH_DMATxDescListInit+0x1c>
      dmatxdesc->Buffer2NextDescAddr = (uint32_t)(DMATxDescTab+i+1U);
 8042074:	1c65      	adds	r5, r4, #1
 8042076:	eb01 1545 	add.w	r5, r1, r5, lsl #5
 804207a:	60f5      	str	r5, [r6, #12]
 804207c:	e7e3      	b.n	8042046 <HAL_ETH_DMATxDescListInit+0x1e>
  (heth->Instance)->DMATDLAR = (uint32_t) DMATxDescTab;
 804207e:	6802      	ldr	r2, [r0, #0]
 8042080:	f241 0310 	movw	r3, #4112	; 0x1010
 8042084:	50d1      	str	r1, [r2, r3]
  heth->State= HAL_ETH_STATE_READY;
 8042086:	2301      	movs	r3, #1
 8042088:	f880 3044 	strb.w	r3, [r0, #68]	; 0x44
  __HAL_UNLOCK(heth);
 804208c:	2300      	movs	r3, #0
 804208e:	f880 3045 	strb.w	r3, [r0, #69]	; 0x45
  return HAL_OK;
 8042092:	4618      	mov	r0, r3
}
 8042094:	bcf0      	pop	{r4, r5, r6, r7}
 8042096:	4770      	bx	lr
  __HAL_LOCK(heth);
 8042098:	2002      	movs	r0, #2
 804209a:	e7fb      	b.n	8042094 <HAL_ETH_DMATxDescListInit+0x6c>

0804209c <HAL_ETH_DMARxDescListInit>:
{
 804209c:	b4f0      	push	{r4, r5, r6, r7}
  __HAL_LOCK(heth);
 804209e:	f890 4045 	ldrb.w	r4, [r0, #69]	; 0x45
 80420a2:	2c01      	cmp	r4, #1
 80420a4:	d02f      	beq.n	8042106 <HAL_ETH_DMARxDescListInit+0x6a>
 80420a6:	2401      	movs	r4, #1
 80420a8:	f880 4045 	strb.w	r4, [r0, #69]	; 0x45
  heth->State = HAL_ETH_STATE_BUSY;
 80420ac:	2402      	movs	r4, #2
 80420ae:	f880 4044 	strb.w	r4, [r0, #68]	; 0x44
  heth->RxDesc = DMARxDescTab; 
 80420b2:	6281      	str	r1, [r0, #40]	; 0x28
  for(i=0U; i < RxBuffCount; i++)
 80420b4:	2400      	movs	r4, #0
 80420b6:	e001      	b.n	80420bc <HAL_ETH_DMARxDescListInit+0x20>
      DMARxDesc->Buffer2NextDescAddr = (uint32_t)(DMARxDescTab); 
 80420b8:	60e9      	str	r1, [r5, #12]
  for(i=0U; i < RxBuffCount; i++)
 80420ba:	3401      	adds	r4, #1
 80420bc:	429c      	cmp	r4, r3
 80420be:	d215      	bcs.n	80420ec <HAL_ETH_DMARxDescListInit+0x50>
    DMARxDesc = DMARxDescTab+i;
 80420c0:	0166      	lsls	r6, r4, #5
 80420c2:	eb01 1544 	add.w	r5, r1, r4, lsl #5
    DMARxDesc->Status = ETH_DMARXDESC_OWN;
 80420c6:	f04f 4700 	mov.w	r7, #2147483648	; 0x80000000
 80420ca:	518f      	str	r7, [r1, r6]
    DMARxDesc->ControlBufferSize = ETH_DMARXDESC_RCH | ETH_RX_BUF_SIZE;  
 80420cc:	f244 56f4 	movw	r6, #17908	; 0x45f4
 80420d0:	606e      	str	r6, [r5, #4]
    DMARxDesc->Buffer1Addr = (uint32_t)(&RxBuff[i*ETH_RX_BUF_SIZE]);
 80420d2:	f240 56f4 	movw	r6, #1524	; 0x5f4
 80420d6:	fb06 2604 	mla	r6, r6, r4, r2
 80420da:	60ae      	str	r6, [r5, #8]
    if(i < (RxBuffCount-1U))
 80420dc:	1e5e      	subs	r6, r3, #1
 80420de:	42a6      	cmp	r6, r4
 80420e0:	d9ea      	bls.n	80420b8 <HAL_ETH_DMARxDescListInit+0x1c>
      DMARxDesc->Buffer2NextDescAddr = (uint32_t)(DMARxDescTab+i+1U); 
 80420e2:	1c66      	adds	r6, r4, #1
 80420e4:	eb01 1646 	add.w	r6, r1, r6, lsl #5
 80420e8:	60ee      	str	r6, [r5, #12]
 80420ea:	e7e6      	b.n	80420ba <HAL_ETH_DMARxDescListInit+0x1e>
  (heth->Instance)->DMARDLAR = (uint32_t) DMARxDescTab;
 80420ec:	6802      	ldr	r2, [r0, #0]
 80420ee:	f241 030c 	movw	r3, #4108	; 0x100c
 80420f2:	50d1      	str	r1, [r2, r3]
  heth->State= HAL_ETH_STATE_READY;
 80420f4:	2301      	movs	r3, #1
 80420f6:	f880 3044 	strb.w	r3, [r0, #68]	; 0x44
  __HAL_UNLOCK(heth);
 80420fa:	2300      	movs	r3, #0
 80420fc:	f880 3045 	strb.w	r3, [r0, #69]	; 0x45
  return HAL_OK;
 8042100:	4618      	mov	r0, r3
}
 8042102:	bcf0      	pop	{r4, r5, r6, r7}
 8042104:	4770      	bx	lr
  __HAL_LOCK(heth);
 8042106:	2002      	movs	r0, #2
 8042108:	e7fb      	b.n	8042102 <HAL_ETH_DMARxDescListInit+0x66>
	...

0804210c <HAL_ETH_TransmitFrame>:
  __HAL_LOCK(heth);
 804210c:	f890 3045 	ldrb.w	r3, [r0, #69]	; 0x45
 8042110:	2b01      	cmp	r3, #1
 8042112:	f000 8085 	beq.w	8042220 <HAL_ETH_TransmitFrame+0x114>
 8042116:	2301      	movs	r3, #1
 8042118:	f880 3045 	strb.w	r3, [r0, #69]	; 0x45
  heth->State = HAL_ETH_STATE_BUSY;
 804211c:	2302      	movs	r3, #2
 804211e:	f880 3044 	strb.w	r3, [r0, #68]	; 0x44
  if (FrameLength == 0U) 
 8042122:	b1b1      	cbz	r1, 8042152 <HAL_ETH_TransmitFrame+0x46>
  if(((heth->TxDesc)->Status & ETH_DMATXDESC_OWN) != (uint32_t)RESET)
 8042124:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 8042126:	681a      	ldr	r2, [r3, #0]
 8042128:	2a00      	cmp	r2, #0
 804212a:	db1a      	blt.n	8042162 <HAL_ETH_TransmitFrame+0x56>
{
 804212c:	b430      	push	{r4, r5}
  if (FrameLength > ETH_TX_BUF_SIZE)
 804212e:	f240 52f4 	movw	r2, #1524	; 0x5f4
 8042132:	4291      	cmp	r1, r2
 8042134:	d91d      	bls.n	8042172 <HAL_ETH_TransmitFrame+0x66>
    bufcount = FrameLength/ETH_TX_BUF_SIZE;
 8042136:	4c3b      	ldr	r4, [pc, #236]	; (8042224 <HAL_ETH_TransmitFrame+0x118>)
 8042138:	fba4 2401 	umull	r2, r4, r4, r1
 804213c:	0aa4      	lsrs	r4, r4, #10
    if (FrameLength % ETH_TX_BUF_SIZE) 
 804213e:	f240 52f4 	movw	r2, #1524	; 0x5f4
 8042142:	fb02 1214 	mls	r2, r2, r4, r1
 8042146:	b102      	cbz	r2, 804214a <HAL_ETH_TransmitFrame+0x3e>
      bufcount++;
 8042148:	3401      	adds	r4, #1
  if (bufcount == 1U)
 804214a:	2c01      	cmp	r4, #1
 804214c:	d011      	beq.n	8042172 <HAL_ETH_TransmitFrame+0x66>
    for (i=0U; i< bufcount; i++)
 804214e:	2300      	movs	r3, #0
 8042150:	e048      	b.n	80421e4 <HAL_ETH_TransmitFrame+0xd8>
    heth->State = HAL_ETH_STATE_READY;
 8042152:	2301      	movs	r3, #1
 8042154:	f880 3044 	strb.w	r3, [r0, #68]	; 0x44
    __HAL_UNLOCK(heth);
 8042158:	2200      	movs	r2, #0
 804215a:	f880 2045 	strb.w	r2, [r0, #69]	; 0x45
    return  HAL_ERROR;                                    
 804215e:	4618      	mov	r0, r3
 8042160:	4770      	bx	lr
    heth->State = HAL_ETH_STATE_BUSY_TX;
 8042162:	2312      	movs	r3, #18
 8042164:	f880 3044 	strb.w	r3, [r0, #68]	; 0x44
    __HAL_UNLOCK(heth);
 8042168:	2300      	movs	r3, #0
 804216a:	f880 3045 	strb.w	r3, [r0, #69]	; 0x45
    return HAL_ERROR;
 804216e:	2001      	movs	r0, #1
 8042170:	4770      	bx	lr
    heth->TxDesc->Status |=ETH_DMATXDESC_FS|ETH_DMATXDESC_LS;
 8042172:	681a      	ldr	r2, [r3, #0]
 8042174:	f042 5240 	orr.w	r2, r2, #805306368	; 0x30000000
 8042178:	601a      	str	r2, [r3, #0]
    heth->TxDesc->ControlBufferSize = (FrameLength & ETH_DMATXDESC_TBS1);
 804217a:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 804217c:	f3c1 010c 	ubfx	r1, r1, #0, #13
 8042180:	6059      	str	r1, [r3, #4]
    heth->TxDesc->Status |= ETH_DMATXDESC_OWN;
 8042182:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
 8042184:	6813      	ldr	r3, [r2, #0]
 8042186:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 804218a:	6013      	str	r3, [r2, #0]
    heth->TxDesc= (ETH_DMADescTypeDef *)(heth->TxDesc->Buffer2NextDescAddr);
 804218c:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 804218e:	68db      	ldr	r3, [r3, #12]
 8042190:	62c3      	str	r3, [r0, #44]	; 0x2c
  if (((heth->Instance)->DMASR & ETH_DMASR_TBUS) != (uint32_t)RESET)
 8042192:	6803      	ldr	r3, [r0, #0]
 8042194:	f241 0214 	movw	r2, #4116	; 0x1014
 8042198:	589a      	ldr	r2, [r3, r2]
 804219a:	f012 0f04 	tst.w	r2, #4
 804219e:	d008      	beq.n	80421b2 <HAL_ETH_TransmitFrame+0xa6>
    (heth->Instance)->DMASR = ETH_DMASR_TBUS;
 80421a0:	f241 0214 	movw	r2, #4116	; 0x1014
 80421a4:	2104      	movs	r1, #4
 80421a6:	5099      	str	r1, [r3, r2]
    (heth->Instance)->DMATPDR = 0U;
 80421a8:	6802      	ldr	r2, [r0, #0]
 80421aa:	f241 0304 	movw	r3, #4100	; 0x1004
 80421ae:	2100      	movs	r1, #0
 80421b0:	50d1      	str	r1, [r2, r3]
  heth->State = HAL_ETH_STATE_READY;
 80421b2:	2301      	movs	r3, #1
 80421b4:	f880 3044 	strb.w	r3, [r0, #68]	; 0x44
  __HAL_UNLOCK(heth);
 80421b8:	2300      	movs	r3, #0
 80421ba:	f880 3045 	strb.w	r3, [r0, #69]	; 0x45
  return HAL_OK;
 80421be:	4618      	mov	r0, r3
}
 80421c0:	bc30      	pop	{r4, r5}
 80421c2:	4770      	bx	lr
      heth->TxDesc->ControlBufferSize = (ETH_TX_BUF_SIZE & ETH_DMATXDESC_TBS1);
 80421c4:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
 80421c6:	f240 55f4 	movw	r5, #1524	; 0x5f4
 80421ca:	6055      	str	r5, [r2, #4]
      if (i == (bufcount-1U))
 80421cc:	1e62      	subs	r2, r4, #1
 80421ce:	429a      	cmp	r2, r3
 80421d0:	d017      	beq.n	8042202 <HAL_ETH_TransmitFrame+0xf6>
      heth->TxDesc->Status |= ETH_DMATXDESC_OWN;
 80421d2:	6ac5      	ldr	r5, [r0, #44]	; 0x2c
 80421d4:	682a      	ldr	r2, [r5, #0]
 80421d6:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
 80421da:	602a      	str	r2, [r5, #0]
      heth->TxDesc = (ETH_DMADescTypeDef *)(heth->TxDesc->Buffer2NextDescAddr);
 80421dc:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
 80421de:	68d2      	ldr	r2, [r2, #12]
 80421e0:	62c2      	str	r2, [r0, #44]	; 0x2c
    for (i=0U; i< bufcount; i++)
 80421e2:	3301      	adds	r3, #1
 80421e4:	429c      	cmp	r4, r3
 80421e6:	d9d4      	bls.n	8042192 <HAL_ETH_TransmitFrame+0x86>
      heth->TxDesc->Status &= ~(ETH_DMATXDESC_FS | ETH_DMATXDESC_LS);
 80421e8:	6ac5      	ldr	r5, [r0, #44]	; 0x2c
 80421ea:	682a      	ldr	r2, [r5, #0]
 80421ec:	f022 5240 	bic.w	r2, r2, #805306368	; 0x30000000
 80421f0:	602a      	str	r2, [r5, #0]
      if (i == 0U) 
 80421f2:	2b00      	cmp	r3, #0
 80421f4:	d1e6      	bne.n	80421c4 <HAL_ETH_TransmitFrame+0xb8>
        heth->TxDesc->Status |= ETH_DMATXDESC_FS;  
 80421f6:	6ac5      	ldr	r5, [r0, #44]	; 0x2c
 80421f8:	682a      	ldr	r2, [r5, #0]
 80421fa:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 80421fe:	602a      	str	r2, [r5, #0]
 8042200:	e7e0      	b.n	80421c4 <HAL_ETH_TransmitFrame+0xb8>
        heth->TxDesc->Status |= ETH_DMATXDESC_LS;
 8042202:	6ac5      	ldr	r5, [r0, #44]	; 0x2c
 8042204:	682a      	ldr	r2, [r5, #0]
 8042206:	f042 5200 	orr.w	r2, r2, #536870912	; 0x20000000
 804220a:	602a      	str	r2, [r5, #0]
        size = FrameLength - (bufcount-1U)*ETH_TX_BUF_SIZE;
 804220c:	4a06      	ldr	r2, [pc, #24]	; (8042228 <HAL_ETH_TransmitFrame+0x11c>)
 804220e:	fb02 1204 	mla	r2, r2, r4, r1
 8042212:	f202 52f4 	addw	r2, r2, #1524	; 0x5f4
        heth->TxDesc->ControlBufferSize = (size & ETH_DMATXDESC_TBS1);
 8042216:	6ac5      	ldr	r5, [r0, #44]	; 0x2c
 8042218:	f3c2 020c 	ubfx	r2, r2, #0, #13
 804221c:	606a      	str	r2, [r5, #4]
 804221e:	e7d8      	b.n	80421d2 <HAL_ETH_TransmitFrame+0xc6>
  __HAL_LOCK(heth);
 8042220:	2002      	movs	r0, #2
}
 8042222:	4770      	bx	lr
 8042224:	ac02b00b 	.word	0xac02b00b
 8042228:	fffffa0c 	.word	0xfffffa0c

0804222c <HAL_ETH_GetReceivedFrame>:
  __HAL_LOCK(heth);
 804222c:	f890 3045 	ldrb.w	r3, [r0, #69]	; 0x45
 8042230:	2b01      	cmp	r3, #1
 8042232:	d040      	beq.n	80422b6 <HAL_ETH_GetReceivedFrame+0x8a>
 8042234:	2301      	movs	r3, #1
 8042236:	f880 3045 	strb.w	r3, [r0, #69]	; 0x45
  heth->State = HAL_ETH_STATE_BUSY;
 804223a:	2302      	movs	r3, #2
 804223c:	f880 3044 	strb.w	r3, [r0, #68]	; 0x44
  if(((heth->RxDesc->Status & ETH_DMARXDESC_OWN) == (uint32_t)RESET))
 8042240:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8042242:	681a      	ldr	r2, [r3, #0]
 8042244:	2a00      	cmp	r2, #0
 8042246:	db0e      	blt.n	8042266 <HAL_ETH_GetReceivedFrame+0x3a>
    if(((heth->RxDesc->Status & ETH_DMARXDESC_LS) != (uint32_t)RESET)) 
 8042248:	681a      	ldr	r2, [r3, #0]
 804224a:	f412 7f80 	tst.w	r2, #256	; 0x100
 804224e:	d112      	bne.n	8042276 <HAL_ETH_GetReceivedFrame+0x4a>
    else if((heth->RxDesc->Status & ETH_DMARXDESC_FS) != (uint32_t)RESET)
 8042250:	681a      	ldr	r2, [r3, #0]
 8042252:	f412 7f00 	tst.w	r2, #512	; 0x200
 8042256:	d028      	beq.n	80422aa <HAL_ETH_GetReceivedFrame+0x7e>
      (heth->RxFrameInfos).FSRxDesc = heth->RxDesc;
 8042258:	6303      	str	r3, [r0, #48]	; 0x30
      (heth->RxFrameInfos).LSRxDesc = NULL;
 804225a:	2200      	movs	r2, #0
 804225c:	6342      	str	r2, [r0, #52]	; 0x34
      (heth->RxFrameInfos).SegCount = 1U;
 804225e:	2201      	movs	r2, #1
 8042260:	6382      	str	r2, [r0, #56]	; 0x38
      heth->RxDesc = (ETH_DMADescTypeDef*) (heth->RxDesc->Buffer2NextDescAddr);
 8042262:	68db      	ldr	r3, [r3, #12]
 8042264:	6283      	str	r3, [r0, #40]	; 0x28
  heth->State = HAL_ETH_STATE_READY;
 8042266:	2301      	movs	r3, #1
 8042268:	f880 3044 	strb.w	r3, [r0, #68]	; 0x44
  __HAL_UNLOCK(heth);
 804226c:	2200      	movs	r2, #0
 804226e:	f880 2045 	strb.w	r2, [r0, #69]	; 0x45
  return HAL_ERROR;
 8042272:	4618      	mov	r0, r3
 8042274:	4770      	bx	lr
      (heth->RxFrameInfos).SegCount++;
 8042276:	6b82      	ldr	r2, [r0, #56]	; 0x38
 8042278:	3201      	adds	r2, #1
 804227a:	6382      	str	r2, [r0, #56]	; 0x38
      if ((heth->RxFrameInfos).SegCount == 1U)
 804227c:	2a01      	cmp	r2, #1
 804227e:	d012      	beq.n	80422a6 <HAL_ETH_GetReceivedFrame+0x7a>
      heth->RxFrameInfos.LSRxDesc = heth->RxDesc;
 8042280:	6343      	str	r3, [r0, #52]	; 0x34
      framelength = (((heth->RxDesc)->Status & ETH_DMARXDESC_FL) >> ETH_DMARXDESC_FRAMELENGTHSHIFT) - 4U;
 8042282:	681a      	ldr	r2, [r3, #0]
 8042284:	f3c2 420d 	ubfx	r2, r2, #16, #14
 8042288:	3a04      	subs	r2, #4
      heth->RxFrameInfos.length = framelength;
 804228a:	63c2      	str	r2, [r0, #60]	; 0x3c
      heth->RxFrameInfos.buffer = ((heth->RxFrameInfos).FSRxDesc)->Buffer1Addr;
 804228c:	6b02      	ldr	r2, [r0, #48]	; 0x30
 804228e:	6892      	ldr	r2, [r2, #8]
 8042290:	6402      	str	r2, [r0, #64]	; 0x40
      heth->RxDesc = (ETH_DMADescTypeDef*) ((heth->RxDesc)->Buffer2NextDescAddr);
 8042292:	68db      	ldr	r3, [r3, #12]
 8042294:	6283      	str	r3, [r0, #40]	; 0x28
      heth->State = HAL_ETH_STATE_READY;
 8042296:	2301      	movs	r3, #1
 8042298:	f880 3044 	strb.w	r3, [r0, #68]	; 0x44
      __HAL_UNLOCK(heth);
 804229c:	2300      	movs	r3, #0
 804229e:	f880 3045 	strb.w	r3, [r0, #69]	; 0x45
      return HAL_OK;
 80422a2:	4618      	mov	r0, r3
 80422a4:	4770      	bx	lr
        (heth->RxFrameInfos).FSRxDesc =heth->RxDesc;
 80422a6:	6303      	str	r3, [r0, #48]	; 0x30
 80422a8:	e7ea      	b.n	8042280 <HAL_ETH_GetReceivedFrame+0x54>
      (heth->RxFrameInfos).SegCount++;
 80422aa:	6b82      	ldr	r2, [r0, #56]	; 0x38
 80422ac:	3201      	adds	r2, #1
 80422ae:	6382      	str	r2, [r0, #56]	; 0x38
      heth->RxDesc = (ETH_DMADescTypeDef*) (heth->RxDesc->Buffer2NextDescAddr);
 80422b0:	68db      	ldr	r3, [r3, #12]
 80422b2:	6283      	str	r3, [r0, #40]	; 0x28
 80422b4:	e7d7      	b.n	8042266 <HAL_ETH_GetReceivedFrame+0x3a>
  __HAL_LOCK(heth);
 80422b6:	2002      	movs	r0, #2
}
 80422b8:	4770      	bx	lr

080422ba <HAL_ETH_ReadPHYRegister>:
{
 80422ba:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if(heth->State == HAL_ETH_STATE_BUSY_RD)
 80422bc:	f890 3044 	ldrb.w	r3, [r0, #68]	; 0x44
 80422c0:	b2db      	uxtb	r3, r3
 80422c2:	2b82      	cmp	r3, #130	; 0x82
 80422c4:	d033      	beq.n	804232e <HAL_ETH_ReadPHYRegister+0x74>
 80422c6:	4605      	mov	r5, r0
 80422c8:	4616      	mov	r6, r2
  heth->State = HAL_ETH_STATE_BUSY_RD;
 80422ca:	2382      	movs	r3, #130	; 0x82
 80422cc:	f880 3044 	strb.w	r3, [r0, #68]	; 0x44
  tmpreg1 = heth->Instance->MACMIIAR;
 80422d0:	6800      	ldr	r0, [r0, #0]
 80422d2:	6902      	ldr	r2, [r0, #16]
  tmpreg1 &= ~ETH_MACMIIAR_CR_MASK;
 80422d4:	f002 021c 	and.w	r2, r2, #28
  tmpreg1 |=(((uint32_t)heth->Init.PhyAddress << 11U) & ETH_MACMIIAR_PA); /* Set the PHY device address   */
 80422d8:	8a2b      	ldrh	r3, [r5, #16]
 80422da:	02db      	lsls	r3, r3, #11
 80422dc:	b29b      	uxth	r3, r3
 80422de:	4313      	orrs	r3, r2
  tmpreg1 |=(((uint32_t)PHYReg<<6U) & ETH_MACMIIAR_MR);                   /* Set the PHY register address */
 80422e0:	018c      	lsls	r4, r1, #6
 80422e2:	f404 64f8 	and.w	r4, r4, #1984	; 0x7c0
  tmpreg1 &= ~ETH_MACMIIAR_MW;                                            /* Set the read mode            */
 80422e6:	431c      	orrs	r4, r3
  tmpreg1 |= ETH_MACMIIAR_MB;                                             /* Set the MII Busy bit         */
 80422e8:	f044 0401 	orr.w	r4, r4, #1
  heth->Instance->MACMIIAR = tmpreg1;
 80422ec:	6104      	str	r4, [r0, #16]
  tickstart = HAL_GetTick();
 80422ee:	f7fe fee7 	bl	80410c0 <HAL_GetTick>
 80422f2:	4607      	mov	r7, r0
  while((tmpreg1 & ETH_MACMIIAR_MB) == ETH_MACMIIAR_MB)
 80422f4:	f014 0f01 	tst.w	r4, #1
 80422f8:	d010      	beq.n	804231c <HAL_ETH_ReadPHYRegister+0x62>
    if((HAL_GetTick() - tickstart ) > PHY_READ_TO)
 80422fa:	f7fe fee1 	bl	80410c0 <HAL_GetTick>
 80422fe:	1bc3      	subs	r3, r0, r7
 8042300:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8042304:	d202      	bcs.n	804230c <HAL_ETH_ReadPHYRegister+0x52>
    tmpreg1 = heth->Instance->MACMIIAR;
 8042306:	682b      	ldr	r3, [r5, #0]
 8042308:	691c      	ldr	r4, [r3, #16]
 804230a:	e7f3      	b.n	80422f4 <HAL_ETH_ReadPHYRegister+0x3a>
      heth->State= HAL_ETH_STATE_READY;
 804230c:	2301      	movs	r3, #1
 804230e:	f885 3044 	strb.w	r3, [r5, #68]	; 0x44
      __HAL_UNLOCK(heth);
 8042312:	2300      	movs	r3, #0
 8042314:	f885 3045 	strb.w	r3, [r5, #69]	; 0x45
      return HAL_TIMEOUT;
 8042318:	2003      	movs	r0, #3
 804231a:	e007      	b.n	804232c <HAL_ETH_ReadPHYRegister+0x72>
  *RegValue = (uint16_t)(heth->Instance->MACMIIDR);
 804231c:	682b      	ldr	r3, [r5, #0]
 804231e:	695b      	ldr	r3, [r3, #20]
 8042320:	b29b      	uxth	r3, r3
 8042322:	6033      	str	r3, [r6, #0]
  heth->State = HAL_ETH_STATE_READY;
 8042324:	2301      	movs	r3, #1
 8042326:	f885 3044 	strb.w	r3, [r5, #68]	; 0x44
  return HAL_OK;
 804232a:	2000      	movs	r0, #0
}
 804232c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return HAL_BUSY;
 804232e:	2002      	movs	r0, #2
 8042330:	e7fc      	b.n	804232c <HAL_ETH_ReadPHYRegister+0x72>

08042332 <HAL_ETH_WritePHYRegister>:
  if(heth->State == HAL_ETH_STATE_BUSY_WR)
 8042332:	f890 3044 	ldrb.w	r3, [r0, #68]	; 0x44
 8042336:	b2db      	uxtb	r3, r3
 8042338:	2b42      	cmp	r3, #66	; 0x42
 804233a:	d032      	beq.n	80423a2 <HAL_ETH_WritePHYRegister+0x70>
{
 804233c:	b570      	push	{r4, r5, r6, lr}
 804233e:	4605      	mov	r5, r0
  heth->State = HAL_ETH_STATE_BUSY_WR;
 8042340:	2342      	movs	r3, #66	; 0x42
 8042342:	f880 3044 	strb.w	r3, [r0, #68]	; 0x44
  tmpreg1 = heth->Instance->MACMIIAR;
 8042346:	6806      	ldr	r6, [r0, #0]
 8042348:	6930      	ldr	r0, [r6, #16]
  tmpreg1 &= ~ETH_MACMIIAR_CR_MASK;
 804234a:	f000 001c 	and.w	r0, r0, #28
  tmpreg1 |=(((uint32_t)heth->Init.PhyAddress<<11U) & ETH_MACMIIAR_PA); /* Set the PHY device address */
 804234e:	8a2b      	ldrh	r3, [r5, #16]
 8042350:	02db      	lsls	r3, r3, #11
 8042352:	b29b      	uxth	r3, r3
 8042354:	4303      	orrs	r3, r0
  tmpreg1 |=(((uint32_t)PHYReg<<6U) & ETH_MACMIIAR_MR);                 /* Set the PHY register address */
 8042356:	018c      	lsls	r4, r1, #6
 8042358:	f404 64f8 	and.w	r4, r4, #1984	; 0x7c0
 804235c:	431c      	orrs	r4, r3
  tmpreg1 |= ETH_MACMIIAR_MB;                                           /* Set the MII Busy bit */
 804235e:	f044 0403 	orr.w	r4, r4, #3
  heth->Instance->MACMIIDR = (uint16_t)RegValue;
 8042362:	b292      	uxth	r2, r2
 8042364:	6172      	str	r2, [r6, #20]
  heth->Instance->MACMIIAR = tmpreg1;
 8042366:	682b      	ldr	r3, [r5, #0]
 8042368:	611c      	str	r4, [r3, #16]
  tickstart = HAL_GetTick();
 804236a:	f7fe fea9 	bl	80410c0 <HAL_GetTick>
 804236e:	4606      	mov	r6, r0
  while((tmpreg1 & ETH_MACMIIAR_MB) == ETH_MACMIIAR_MB)
 8042370:	f014 0f01 	tst.w	r4, #1
 8042374:	d010      	beq.n	8042398 <HAL_ETH_WritePHYRegister+0x66>
    if((HAL_GetTick() - tickstart ) > PHY_WRITE_TO)
 8042376:	f7fe fea3 	bl	80410c0 <HAL_GetTick>
 804237a:	1b83      	subs	r3, r0, r6
 804237c:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8042380:	d202      	bcs.n	8042388 <HAL_ETH_WritePHYRegister+0x56>
    tmpreg1 = heth->Instance->MACMIIAR;
 8042382:	682b      	ldr	r3, [r5, #0]
 8042384:	691c      	ldr	r4, [r3, #16]
 8042386:	e7f3      	b.n	8042370 <HAL_ETH_WritePHYRegister+0x3e>
      heth->State= HAL_ETH_STATE_READY;
 8042388:	2301      	movs	r3, #1
 804238a:	f885 3044 	strb.w	r3, [r5, #68]	; 0x44
      __HAL_UNLOCK(heth);
 804238e:	2300      	movs	r3, #0
 8042390:	f885 3045 	strb.w	r3, [r5, #69]	; 0x45
      return HAL_TIMEOUT;
 8042394:	2003      	movs	r0, #3
 8042396:	e003      	b.n	80423a0 <HAL_ETH_WritePHYRegister+0x6e>
  heth->State = HAL_ETH_STATE_READY;
 8042398:	2301      	movs	r3, #1
 804239a:	f885 3044 	strb.w	r3, [r5, #68]	; 0x44
  return HAL_OK; 
 804239e:	2000      	movs	r0, #0
}
 80423a0:	bd70      	pop	{r4, r5, r6, pc}
    return HAL_BUSY;
 80423a2:	2002      	movs	r0, #2
}
 80423a4:	4770      	bx	lr
	...

080423a8 <HAL_ETH_Init>:
{
 80423a8:	b570      	push	{r4, r5, r6, lr}
 80423aa:	b082      	sub	sp, #8
  uint32_t tmpreg1 = 0U, phyreg = 0U;
 80423ac:	2300      	movs	r3, #0
 80423ae:	9301      	str	r3, [sp, #4]
  if(heth == NULL)
 80423b0:	2800      	cmp	r0, #0
 80423b2:	f000 810e 	beq.w	80425d2 <HAL_ETH_Init+0x22a>
 80423b6:	4604      	mov	r4, r0
  if(heth->State == HAL_ETH_STATE_RESET)
 80423b8:	f890 3044 	ldrb.w	r3, [r0, #68]	; 0x44
 80423bc:	2b00      	cmp	r3, #0
 80423be:	d034      	beq.n	804242a <HAL_ETH_Init+0x82>
  __HAL_RCC_SYSCFG_CLK_ENABLE();
 80423c0:	2300      	movs	r3, #0
 80423c2:	9300      	str	r3, [sp, #0]
 80423c4:	4b84      	ldr	r3, [pc, #528]	; (80425d8 <HAL_ETH_Init+0x230>)
 80423c6:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 80423c8:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 80423cc:	645a      	str	r2, [r3, #68]	; 0x44
 80423ce:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80423d0:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 80423d4:	9300      	str	r3, [sp, #0]
 80423d6:	9b00      	ldr	r3, [sp, #0]
  SYSCFG->PMC &= ~(SYSCFG_PMC_MII_RMII_SEL);
 80423d8:	4b80      	ldr	r3, [pc, #512]	; (80425dc <HAL_ETH_Init+0x234>)
 80423da:	685a      	ldr	r2, [r3, #4]
 80423dc:	f422 0200 	bic.w	r2, r2, #8388608	; 0x800000
 80423e0:	605a      	str	r2, [r3, #4]
  SYSCFG->PMC |= (uint32_t)heth->Init.MediaInterface;
 80423e2:	685a      	ldr	r2, [r3, #4]
 80423e4:	6a21      	ldr	r1, [r4, #32]
 80423e6:	430a      	orrs	r2, r1
 80423e8:	605a      	str	r2, [r3, #4]
  (heth->Instance)->DMABMR |= ETH_DMABMR_SR;
 80423ea:	6823      	ldr	r3, [r4, #0]
 80423ec:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 80423f0:	681a      	ldr	r2, [r3, #0]
 80423f2:	f042 0201 	orr.w	r2, r2, #1
 80423f6:	601a      	str	r2, [r3, #0]
  tickstart = HAL_GetTick();
 80423f8:	f7fe fe62 	bl	80410c0 <HAL_GetTick>
 80423fc:	4605      	mov	r5, r0
  while (((heth->Instance)->DMABMR & ETH_DMABMR_SR) != (uint32_t)RESET)
 80423fe:	6823      	ldr	r3, [r4, #0]
 8042400:	f503 5280 	add.w	r2, r3, #4096	; 0x1000
 8042404:	6812      	ldr	r2, [r2, #0]
 8042406:	f012 0f01 	tst.w	r2, #1
 804240a:	d013      	beq.n	8042434 <HAL_ETH_Init+0x8c>
    if((HAL_GetTick() - tickstart ) > ETH_TIMEOUT_SWRESET)
 804240c:	f7fe fe58 	bl	80410c0 <HAL_GetTick>
 8042410:	1b40      	subs	r0, r0, r5
 8042412:	f5b0 7ffa 	cmp.w	r0, #500	; 0x1f4
 8042416:	d9f2      	bls.n	80423fe <HAL_ETH_Init+0x56>
      heth->State= HAL_ETH_STATE_TIMEOUT;
 8042418:	2503      	movs	r5, #3
 804241a:	f884 5044 	strb.w	r5, [r4, #68]	; 0x44
      __HAL_UNLOCK(heth);
 804241e:	2300      	movs	r3, #0
 8042420:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
}
 8042424:	4628      	mov	r0, r5
 8042426:	b002      	add	sp, #8
 8042428:	bd70      	pop	{r4, r5, r6, pc}
    heth->Lock = HAL_UNLOCKED;
 804242a:	f880 3045 	strb.w	r3, [r0, #69]	; 0x45
    HAL_ETH_MspInit(heth);
 804242e:	f009 fba7 	bl	804bb80 <HAL_ETH_MspInit>
 8042432:	e7c5      	b.n	80423c0 <HAL_ETH_Init+0x18>
  tmpreg1 = (heth->Instance)->MACMIIAR;
 8042434:	691d      	ldr	r5, [r3, #16]
  tmpreg1 &= ETH_MACMIIAR_CR_MASK;
 8042436:	f025 051c 	bic.w	r5, r5, #28
  hclk = HAL_RCC_GetHCLKFreq();
 804243a:	f001 fffd 	bl	8044438 <HAL_RCC_GetHCLKFreq>
  if((hclk >= 20000000U)&&(hclk < 35000000U))
 804243e:	4b68      	ldr	r3, [pc, #416]	; (80425e0 <HAL_ETH_Init+0x238>)
 8042440:	4403      	add	r3, r0
 8042442:	4a68      	ldr	r2, [pc, #416]	; (80425e4 <HAL_ETH_Init+0x23c>)
 8042444:	4293      	cmp	r3, r2
 8042446:	d255      	bcs.n	80424f4 <HAL_ETH_Init+0x14c>
    tmpreg1 |= (uint32_t)ETH_MACMIIAR_CR_Div16;
 8042448:	f045 0508 	orr.w	r5, r5, #8
  (heth->Instance)->MACMIIAR = (uint32_t)tmpreg1;
 804244c:	6823      	ldr	r3, [r4, #0]
 804244e:	611d      	str	r5, [r3, #16]
  if((HAL_ETH_WritePHYRegister(heth, PHY_BCR, PHY_RESET)) != HAL_OK)
 8042450:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 8042454:	2100      	movs	r1, #0
 8042456:	4620      	mov	r0, r4
 8042458:	f7ff ff6b 	bl	8042332 <HAL_ETH_WritePHYRegister>
 804245c:	4605      	mov	r5, r0
 804245e:	2800      	cmp	r0, #0
 8042460:	d160      	bne.n	8042524 <HAL_ETH_Init+0x17c>
  HAL_Delay(PHY_RESET_DELAY);
 8042462:	20ff      	movs	r0, #255	; 0xff
 8042464:	f7fe fe32 	bl	80410cc <HAL_Delay>
  if((heth->Init).AutoNegotiation != ETH_AUTONEGOTIATION_DISABLE)
 8042468:	6863      	ldr	r3, [r4, #4]
 804246a:	2b00      	cmp	r3, #0
 804246c:	f000 8091 	beq.w	8042592 <HAL_ETH_Init+0x1ea>
    tickstart = HAL_GetTick();
 8042470:	f7fe fe26 	bl	80410c0 <HAL_GetTick>
 8042474:	4606      	mov	r6, r0
      HAL_ETH_ReadPHYRegister(heth, PHY_BSR, &phyreg);
 8042476:	aa01      	add	r2, sp, #4
 8042478:	2101      	movs	r1, #1
 804247a:	4620      	mov	r0, r4
 804247c:	f7ff ff1d 	bl	80422ba <HAL_ETH_ReadPHYRegister>
      if((HAL_GetTick() - tickstart ) > ETH_TIMEOUT_LINKED_STATE)
 8042480:	f7fe fe1e 	bl	80410c0 <HAL_GetTick>
 8042484:	1b80      	subs	r0, r0, r6
 8042486:	f241 3388 	movw	r3, #5000	; 0x1388
 804248a:	4298      	cmp	r0, r3
 804248c:	d852      	bhi.n	8042534 <HAL_ETH_Init+0x18c>
    } while (((phyreg & PHY_LINKED_STATUS) != PHY_LINKED_STATUS));
 804248e:	9b01      	ldr	r3, [sp, #4]
 8042490:	f013 0f04 	tst.w	r3, #4
 8042494:	d0ef      	beq.n	8042476 <HAL_ETH_Init+0xce>
    if((HAL_ETH_WritePHYRegister(heth, PHY_BCR, PHY_AUTONEGOTIATION)) != HAL_OK)
 8042496:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 804249a:	2100      	movs	r1, #0
 804249c:	4620      	mov	r0, r4
 804249e:	f7ff ff48 	bl	8042332 <HAL_ETH_WritePHYRegister>
 80424a2:	2800      	cmp	r0, #0
 80424a4:	d152      	bne.n	804254c <HAL_ETH_Init+0x1a4>
    tickstart = HAL_GetTick();
 80424a6:	f7fe fe0b 	bl	80410c0 <HAL_GetTick>
 80424aa:	4606      	mov	r6, r0
      HAL_ETH_ReadPHYRegister(heth, PHY_BSR, &phyreg);
 80424ac:	aa01      	add	r2, sp, #4
 80424ae:	2101      	movs	r1, #1
 80424b0:	4620      	mov	r0, r4
 80424b2:	f7ff ff02 	bl	80422ba <HAL_ETH_ReadPHYRegister>
      if((HAL_GetTick() - tickstart ) > ETH_TIMEOUT_AUTONEGO_COMPLETED)
 80424b6:	f7fe fe03 	bl	80410c0 <HAL_GetTick>
 80424ba:	1b80      	subs	r0, r0, r6
 80424bc:	f241 3388 	movw	r3, #5000	; 0x1388
 80424c0:	4298      	cmp	r0, r3
 80424c2:	d84b      	bhi.n	804255c <HAL_ETH_Init+0x1b4>
    } while (((phyreg & PHY_AUTONEGO_COMPLETE) != PHY_AUTONEGO_COMPLETE));
 80424c4:	9b01      	ldr	r3, [sp, #4]
 80424c6:	f013 0f20 	tst.w	r3, #32
 80424ca:	d0ef      	beq.n	80424ac <HAL_ETH_Init+0x104>
    if((HAL_ETH_ReadPHYRegister(heth, PHY_SR, &phyreg)) != HAL_OK)
 80424cc:	aa01      	add	r2, sp, #4
 80424ce:	211f      	movs	r1, #31
 80424d0:	4620      	mov	r0, r4
 80424d2:	f7ff fef2 	bl	80422ba <HAL_ETH_ReadPHYRegister>
 80424d6:	2800      	cmp	r0, #0
 80424d8:	d14c      	bne.n	8042574 <HAL_ETH_Init+0x1cc>
    if((phyreg & PHY_DUPLEX_STATUS) != (uint32_t)RESET)
 80424da:	9b01      	ldr	r3, [sp, #4]
 80424dc:	f013 0f10 	tst.w	r3, #16
 80424e0:	d050      	beq.n	8042584 <HAL_ETH_Init+0x1dc>
      (heth->Init).DuplexMode = ETH_MODE_FULLDUPLEX;  
 80424e2:	f44f 6200 	mov.w	r2, #2048	; 0x800
 80424e6:	60e2      	str	r2, [r4, #12]
    if((phyreg & PHY_SPEED_STATUS) == PHY_SPEED_STATUS)
 80424e8:	f013 0f04 	tst.w	r3, #4
 80424ec:	d04d      	beq.n	804258a <HAL_ETH_Init+0x1e2>
      (heth->Init).Speed = ETH_SPEED_10M; 
 80424ee:	2300      	movs	r3, #0
 80424f0:	60a3      	str	r3, [r4, #8]
 80424f2:	e05e      	b.n	80425b2 <HAL_ETH_Init+0x20a>
  else if((hclk >= 35000000U)&&(hclk < 60000000U))
 80424f4:	4b3c      	ldr	r3, [pc, #240]	; (80425e8 <HAL_ETH_Init+0x240>)
 80424f6:	4403      	add	r3, r0
 80424f8:	4a3c      	ldr	r2, [pc, #240]	; (80425ec <HAL_ETH_Init+0x244>)
 80424fa:	4293      	cmp	r3, r2
 80424fc:	d802      	bhi.n	8042504 <HAL_ETH_Init+0x15c>
    tmpreg1 |= (uint32_t)ETH_MACMIIAR_CR_Div26;
 80424fe:	f045 050c 	orr.w	r5, r5, #12
 8042502:	e7a3      	b.n	804244c <HAL_ETH_Init+0xa4>
  else if((hclk >= 60000000U)&&(hclk < 100000000U))
 8042504:	4b3a      	ldr	r3, [pc, #232]	; (80425f0 <HAL_ETH_Init+0x248>)
 8042506:	4403      	add	r3, r0
 8042508:	4a3a      	ldr	r2, [pc, #232]	; (80425f4 <HAL_ETH_Init+0x24c>)
 804250a:	4293      	cmp	r3, r2
 804250c:	d39e      	bcc.n	804244c <HAL_ETH_Init+0xa4>
  else if((hclk >= 100000000U)&&(hclk < 150000000U))
 804250e:	4b3a      	ldr	r3, [pc, #232]	; (80425f8 <HAL_ETH_Init+0x250>)
 8042510:	4403      	add	r3, r0
 8042512:	4a3a      	ldr	r2, [pc, #232]	; (80425fc <HAL_ETH_Init+0x254>)
 8042514:	4293      	cmp	r3, r2
 8042516:	d802      	bhi.n	804251e <HAL_ETH_Init+0x176>
    tmpreg1 |= (uint32_t)ETH_MACMIIAR_CR_Div62;
 8042518:	f045 0504 	orr.w	r5, r5, #4
 804251c:	e796      	b.n	804244c <HAL_ETH_Init+0xa4>
    tmpreg1 |= (uint32_t)ETH_MACMIIAR_CR_Div102;    
 804251e:	f045 0510 	orr.w	r5, r5, #16
 8042522:	e793      	b.n	804244c <HAL_ETH_Init+0xa4>
    ETH_MACDMAConfig(heth, err);
 8042524:	2101      	movs	r1, #1
 8042526:	4620      	mov	r0, r4
 8042528:	f7ff fcf2 	bl	8041f10 <ETH_MACDMAConfig>
    heth->State = HAL_ETH_STATE_READY;
 804252c:	2501      	movs	r5, #1
 804252e:	f884 5044 	strb.w	r5, [r4, #68]	; 0x44
    return HAL_ERROR;
 8042532:	e777      	b.n	8042424 <HAL_ETH_Init+0x7c>
        ETH_MACDMAConfig(heth, err);
 8042534:	2101      	movs	r1, #1
 8042536:	4620      	mov	r0, r4
 8042538:	f7ff fcea 	bl	8041f10 <ETH_MACDMAConfig>
        heth->State= HAL_ETH_STATE_READY;
 804253c:	2301      	movs	r3, #1
 804253e:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
        __HAL_UNLOCK(heth);
 8042542:	2300      	movs	r3, #0
 8042544:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
        return HAL_TIMEOUT;
 8042548:	2503      	movs	r5, #3
 804254a:	e76b      	b.n	8042424 <HAL_ETH_Init+0x7c>
      ETH_MACDMAConfig(heth, err);
 804254c:	2101      	movs	r1, #1
 804254e:	4620      	mov	r0, r4
 8042550:	f7ff fcde 	bl	8041f10 <ETH_MACDMAConfig>
      heth->State = HAL_ETH_STATE_READY;
 8042554:	2501      	movs	r5, #1
 8042556:	f884 5044 	strb.w	r5, [r4, #68]	; 0x44
      return HAL_ERROR;   
 804255a:	e763      	b.n	8042424 <HAL_ETH_Init+0x7c>
        ETH_MACDMAConfig(heth, err);
 804255c:	2101      	movs	r1, #1
 804255e:	4620      	mov	r0, r4
 8042560:	f7ff fcd6 	bl	8041f10 <ETH_MACDMAConfig>
        heth->State= HAL_ETH_STATE_READY;
 8042564:	2301      	movs	r3, #1
 8042566:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
        __HAL_UNLOCK(heth);
 804256a:	2300      	movs	r3, #0
 804256c:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
        return HAL_TIMEOUT;
 8042570:	2503      	movs	r5, #3
 8042572:	e757      	b.n	8042424 <HAL_ETH_Init+0x7c>
      ETH_MACDMAConfig(heth, err);
 8042574:	2101      	movs	r1, #1
 8042576:	4620      	mov	r0, r4
 8042578:	f7ff fcca 	bl	8041f10 <ETH_MACDMAConfig>
      heth->State = HAL_ETH_STATE_READY;
 804257c:	2501      	movs	r5, #1
 804257e:	f884 5044 	strb.w	r5, [r4, #68]	; 0x44
      return HAL_ERROR;   
 8042582:	e74f      	b.n	8042424 <HAL_ETH_Init+0x7c>
      (heth->Init).DuplexMode = ETH_MODE_HALFDUPLEX;           
 8042584:	2200      	movs	r2, #0
 8042586:	60e2      	str	r2, [r4, #12]
 8042588:	e7ae      	b.n	80424e8 <HAL_ETH_Init+0x140>
      (heth->Init).Speed = ETH_SPEED_100M;
 804258a:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 804258e:	60a3      	str	r3, [r4, #8]
 8042590:	e00f      	b.n	80425b2 <HAL_ETH_Init+0x20a>
    if(HAL_ETH_WritePHYRegister(heth, PHY_BCR, ((uint16_t)((heth->Init).DuplexMode >> 3U) |
 8042592:	68e2      	ldr	r2, [r4, #12]
 8042594:	f3c2 02cf 	ubfx	r2, r2, #3, #16
                                                (uint16_t)((heth->Init).Speed >> 1U))) != HAL_OK)
 8042598:	68a3      	ldr	r3, [r4, #8]
 804259a:	f3c3 034f 	ubfx	r3, r3, #1, #16
    if(HAL_ETH_WritePHYRegister(heth, PHY_BCR, ((uint16_t)((heth->Init).DuplexMode >> 3U) |
 804259e:	431a      	orrs	r2, r3
 80425a0:	2100      	movs	r1, #0
 80425a2:	4620      	mov	r0, r4
 80425a4:	f7ff fec5 	bl	8042332 <HAL_ETH_WritePHYRegister>
 80425a8:	b958      	cbnz	r0, 80425c2 <HAL_ETH_Init+0x21a>
    HAL_Delay(PHY_CONFIG_DELAY);
 80425aa:	f640 70ff 	movw	r0, #4095	; 0xfff
 80425ae:	f7fe fd8d 	bl	80410cc <HAL_Delay>
  ETH_MACDMAConfig(heth, err);
 80425b2:	2100      	movs	r1, #0
 80425b4:	4620      	mov	r0, r4
 80425b6:	f7ff fcab 	bl	8041f10 <ETH_MACDMAConfig>
  heth->State= HAL_ETH_STATE_READY;
 80425ba:	2301      	movs	r3, #1
 80425bc:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
  return HAL_OK;
 80425c0:	e730      	b.n	8042424 <HAL_ETH_Init+0x7c>
      ETH_MACDMAConfig(heth, err);
 80425c2:	2101      	movs	r1, #1
 80425c4:	4620      	mov	r0, r4
 80425c6:	f7ff fca3 	bl	8041f10 <ETH_MACDMAConfig>
      heth->State = HAL_ETH_STATE_READY;
 80425ca:	2501      	movs	r5, #1
 80425cc:	f884 5044 	strb.w	r5, [r4, #68]	; 0x44
      return HAL_ERROR;
 80425d0:	e728      	b.n	8042424 <HAL_ETH_Init+0x7c>
    return HAL_ERROR;
 80425d2:	2501      	movs	r5, #1
 80425d4:	e726      	b.n	8042424 <HAL_ETH_Init+0x7c>
 80425d6:	bf00      	nop
 80425d8:	40023800 	.word	0x40023800
 80425dc:	40013800 	.word	0x40013800
 80425e0:	feced300 	.word	0xfeced300
 80425e4:	00e4e1c0 	.word	0x00e4e1c0
 80425e8:	fde9f140 	.word	0xfde9f140
 80425ec:	017d783f 	.word	0x017d783f
 80425f0:	fc6c7900 	.word	0xfc6c7900
 80425f4:	02625a00 	.word	0x02625a00
 80425f8:	fa0a1f00 	.word	0xfa0a1f00
 80425fc:	02faf07f 	.word	0x02faf07f

08042600 <HAL_ETH_Start>:
{  
 8042600:	b538      	push	{r3, r4, r5, lr}
  __HAL_LOCK(heth);
 8042602:	f890 3045 	ldrb.w	r3, [r0, #69]	; 0x45
 8042606:	2b01      	cmp	r3, #1
 8042608:	d01a      	beq.n	8042640 <HAL_ETH_Start+0x40>
 804260a:	4604      	mov	r4, r0
 804260c:	2501      	movs	r5, #1
 804260e:	f880 5045 	strb.w	r5, [r0, #69]	; 0x45
  heth->State = HAL_ETH_STATE_BUSY;
 8042612:	2302      	movs	r3, #2
 8042614:	f880 3044 	strb.w	r3, [r0, #68]	; 0x44
  ETH_MACTransmissionEnable(heth);
 8042618:	f7ff fc38 	bl	8041e8c <ETH_MACTransmissionEnable>
  ETH_MACReceptionEnable(heth);
 804261c:	4620      	mov	r0, r4
 804261e:	f7ff fc4a 	bl	8041eb6 <ETH_MACReceptionEnable>
  ETH_FlushTransmitFIFO(heth);
 8042622:	4620      	mov	r0, r4
 8042624:	f7ff fc5c 	bl	8041ee0 <ETH_FlushTransmitFIFO>
  ETH_DMATransmissionEnable(heth);
 8042628:	4620      	mov	r0, r4
 804262a:	f7ff fc09 	bl	8041e40 <ETH_DMATransmissionEnable>
  ETH_DMAReceptionEnable(heth);
 804262e:	4620      	mov	r0, r4
 8042630:	f7ff fc0e 	bl	8041e50 <ETH_DMAReceptionEnable>
  heth->State= HAL_ETH_STATE_READY;
 8042634:	f884 5044 	strb.w	r5, [r4, #68]	; 0x44
  __HAL_UNLOCK(heth);
 8042638:	2000      	movs	r0, #0
 804263a:	f884 0045 	strb.w	r0, [r4, #69]	; 0x45
}
 804263e:	bd38      	pop	{r3, r4, r5, pc}
  __HAL_LOCK(heth);
 8042640:	2002      	movs	r0, #2
 8042642:	e7fc      	b.n	804263e <HAL_ETH_Start+0x3e>

08042644 <FLASH_Program_DoubleWord>:
  * @param  Address specifies the address to be programmed.
  * @param  Data specifies the data to be programmed.
  * @retval None
  */
static void FLASH_Program_DoubleWord(uint32_t Address, uint64_t Data)
{
 8042644:	b410      	push	{r4}
  /* Check the parameters */
  assert_param(IS_FLASH_ADDRESS(Address));
  
  /* If the previous operation is completed, proceed to program the new data */
  CLEAR_BIT(FLASH->CR, FLASH_CR_PSIZE);
 8042646:	4909      	ldr	r1, [pc, #36]	; (804266c <FLASH_Program_DoubleWord+0x28>)
 8042648:	690c      	ldr	r4, [r1, #16]
 804264a:	f424 7440 	bic.w	r4, r4, #768	; 0x300
 804264e:	610c      	str	r4, [r1, #16]
  FLASH->CR |= FLASH_PSIZE_DOUBLE_WORD;
 8042650:	690c      	ldr	r4, [r1, #16]
 8042652:	f444 7440 	orr.w	r4, r4, #768	; 0x300
 8042656:	610c      	str	r4, [r1, #16]
  FLASH->CR |= FLASH_CR_PG;
 8042658:	690c      	ldr	r4, [r1, #16]
 804265a:	f044 0401 	orr.w	r4, r4, #1
 804265e:	610c      	str	r4, [r1, #16]

  /* Program the double-word */
  *(__IO uint32_t*)Address = (uint32_t)Data;
 8042660:	6002      	str	r2, [r0, #0]
  *(__IO uint32_t*)(Address+4) = (uint32_t)(Data >> 32);
 8042662:	6043      	str	r3, [r0, #4]
}
 8042664:	f85d 4b04 	ldr.w	r4, [sp], #4
 8042668:	4770      	bx	lr
 804266a:	bf00      	nop
 804266c:	40023c00 	.word	0x40023c00

08042670 <FLASH_Program_Word>:
{
  /* Check the parameters */
  assert_param(IS_FLASH_ADDRESS(Address));
  
  /* If the previous operation is completed, proceed to program the new data */
  CLEAR_BIT(FLASH->CR, FLASH_CR_PSIZE);
 8042670:	4b07      	ldr	r3, [pc, #28]	; (8042690 <FLASH_Program_Word+0x20>)
 8042672:	691a      	ldr	r2, [r3, #16]
 8042674:	f422 7240 	bic.w	r2, r2, #768	; 0x300
 8042678:	611a      	str	r2, [r3, #16]
  FLASH->CR |= FLASH_PSIZE_WORD;
 804267a:	691a      	ldr	r2, [r3, #16]
 804267c:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8042680:	611a      	str	r2, [r3, #16]
  FLASH->CR |= FLASH_CR_PG;
 8042682:	691a      	ldr	r2, [r3, #16]
 8042684:	f042 0201 	orr.w	r2, r2, #1
 8042688:	611a      	str	r2, [r3, #16]

  *(__IO uint32_t*)Address = Data;
 804268a:	6001      	str	r1, [r0, #0]
}
 804268c:	4770      	bx	lr
 804268e:	bf00      	nop
 8042690:	40023c00 	.word	0x40023c00

08042694 <FLASH_Program_HalfWord>:
{
  /* Check the parameters */
  assert_param(IS_FLASH_ADDRESS(Address));
  
  /* If the previous operation is completed, proceed to program the new data */
  CLEAR_BIT(FLASH->CR, FLASH_CR_PSIZE);
 8042694:	4b07      	ldr	r3, [pc, #28]	; (80426b4 <FLASH_Program_HalfWord+0x20>)
 8042696:	691a      	ldr	r2, [r3, #16]
 8042698:	f422 7240 	bic.w	r2, r2, #768	; 0x300
 804269c:	611a      	str	r2, [r3, #16]
  FLASH->CR |= FLASH_PSIZE_HALF_WORD;
 804269e:	691a      	ldr	r2, [r3, #16]
 80426a0:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 80426a4:	611a      	str	r2, [r3, #16]
  FLASH->CR |= FLASH_CR_PG;
 80426a6:	691a      	ldr	r2, [r3, #16]
 80426a8:	f042 0201 	orr.w	r2, r2, #1
 80426ac:	611a      	str	r2, [r3, #16]

  *(__IO uint16_t*)Address = Data;
 80426ae:	8001      	strh	r1, [r0, #0]
}
 80426b0:	4770      	bx	lr
 80426b2:	bf00      	nop
 80426b4:	40023c00 	.word	0x40023c00

080426b8 <FLASH_Program_Byte>:
{
  /* Check the parameters */
  assert_param(IS_FLASH_ADDRESS(Address));
  
  /* If the previous operation is completed, proceed to program the new data */
  CLEAR_BIT(FLASH->CR, FLASH_CR_PSIZE);
 80426b8:	4b06      	ldr	r3, [pc, #24]	; (80426d4 <FLASH_Program_Byte+0x1c>)
 80426ba:	691a      	ldr	r2, [r3, #16]
 80426bc:	f422 7240 	bic.w	r2, r2, #768	; 0x300
 80426c0:	611a      	str	r2, [r3, #16]
  FLASH->CR |= FLASH_PSIZE_BYTE;
 80426c2:	691a      	ldr	r2, [r3, #16]
 80426c4:	611a      	str	r2, [r3, #16]
  FLASH->CR |= FLASH_CR_PG;
 80426c6:	691a      	ldr	r2, [r3, #16]
 80426c8:	f042 0201 	orr.w	r2, r2, #1
 80426cc:	611a      	str	r2, [r3, #16]

  *(__IO uint8_t*)Address = Data;
 80426ce:	7001      	strb	r1, [r0, #0]
}
 80426d0:	4770      	bx	lr
 80426d2:	bf00      	nop
 80426d4:	40023c00 	.word	0x40023c00

080426d8 <FLASH_SetErrorCode>:
  * @brief  Set the specific FLASH error flag.
  * @retval None
  */
static void FLASH_SetErrorCode(void)
{ 
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR) != RESET)
 80426d8:	4b27      	ldr	r3, [pc, #156]	; (8042778 <FLASH_SetErrorCode+0xa0>)
 80426da:	68db      	ldr	r3, [r3, #12]
 80426dc:	f013 0f10 	tst.w	r3, #16
 80426e0:	d007      	beq.n	80426f2 <FLASH_SetErrorCode+0x1a>
  {
   pFlash.ErrorCode |= HAL_FLASH_ERROR_WRP;
 80426e2:	4a26      	ldr	r2, [pc, #152]	; (804277c <FLASH_SetErrorCode+0xa4>)
 80426e4:	69d3      	ldr	r3, [r2, #28]
 80426e6:	f043 0310 	orr.w	r3, r3, #16
 80426ea:	61d3      	str	r3, [r2, #28]
   
   /* Clear FLASH write protection error pending bit */
   __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_WRPERR);
 80426ec:	4b22      	ldr	r3, [pc, #136]	; (8042778 <FLASH_SetErrorCode+0xa0>)
 80426ee:	2210      	movs	r2, #16
 80426f0:	60da      	str	r2, [r3, #12]
  }
  
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGAERR) != RESET)
 80426f2:	4b21      	ldr	r3, [pc, #132]	; (8042778 <FLASH_SetErrorCode+0xa0>)
 80426f4:	68db      	ldr	r3, [r3, #12]
 80426f6:	f013 0f20 	tst.w	r3, #32
 80426fa:	d007      	beq.n	804270c <FLASH_SetErrorCode+0x34>
  {
   pFlash.ErrorCode |= HAL_FLASH_ERROR_PGA;
 80426fc:	4a1f      	ldr	r2, [pc, #124]	; (804277c <FLASH_SetErrorCode+0xa4>)
 80426fe:	69d3      	ldr	r3, [r2, #28]
 8042700:	f043 0308 	orr.w	r3, r3, #8
 8042704:	61d3      	str	r3, [r2, #28]
   
   /* Clear FLASH Programming alignment error pending bit */
   __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_PGAERR);
 8042706:	4b1c      	ldr	r3, [pc, #112]	; (8042778 <FLASH_SetErrorCode+0xa0>)
 8042708:	2220      	movs	r2, #32
 804270a:	60da      	str	r2, [r3, #12]
  }
  
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGPERR) != RESET)
 804270c:	4b1a      	ldr	r3, [pc, #104]	; (8042778 <FLASH_SetErrorCode+0xa0>)
 804270e:	68db      	ldr	r3, [r3, #12]
 8042710:	f013 0f40 	tst.w	r3, #64	; 0x40
 8042714:	d007      	beq.n	8042726 <FLASH_SetErrorCode+0x4e>
  {
    pFlash.ErrorCode |= HAL_FLASH_ERROR_PGP;
 8042716:	4a19      	ldr	r2, [pc, #100]	; (804277c <FLASH_SetErrorCode+0xa4>)
 8042718:	69d3      	ldr	r3, [r2, #28]
 804271a:	f043 0304 	orr.w	r3, r3, #4
 804271e:	61d3      	str	r3, [r2, #28]
    
    /* Clear FLASH Programming parallelism error pending bit */
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_PGPERR);
 8042720:	4b15      	ldr	r3, [pc, #84]	; (8042778 <FLASH_SetErrorCode+0xa0>)
 8042722:	2240      	movs	r2, #64	; 0x40
 8042724:	60da      	str	r2, [r3, #12]
  }
  
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGSERR) != RESET)
 8042726:	4b14      	ldr	r3, [pc, #80]	; (8042778 <FLASH_SetErrorCode+0xa0>)
 8042728:	68db      	ldr	r3, [r3, #12]
 804272a:	f013 0f80 	tst.w	r3, #128	; 0x80
 804272e:	d007      	beq.n	8042740 <FLASH_SetErrorCode+0x68>
  {
    pFlash.ErrorCode |= HAL_FLASH_ERROR_PGS;
 8042730:	4a12      	ldr	r2, [pc, #72]	; (804277c <FLASH_SetErrorCode+0xa4>)
 8042732:	69d3      	ldr	r3, [r2, #28]
 8042734:	f043 0302 	orr.w	r3, r3, #2
 8042738:	61d3      	str	r3, [r2, #28]
    
    /* Clear FLASH Programming sequence error pending bit */
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_PGSERR);
 804273a:	4b0f      	ldr	r3, [pc, #60]	; (8042778 <FLASH_SetErrorCode+0xa0>)
 804273c:	2280      	movs	r2, #128	; 0x80
 804273e:	60da      	str	r2, [r3, #12]
  }
#if defined(FLASH_SR_RDERR) 
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_RDERR) != RESET)
 8042740:	4b0d      	ldr	r3, [pc, #52]	; (8042778 <FLASH_SetErrorCode+0xa0>)
 8042742:	68db      	ldr	r3, [r3, #12]
 8042744:	f413 7f80 	tst.w	r3, #256	; 0x100
 8042748:	d008      	beq.n	804275c <FLASH_SetErrorCode+0x84>
  {
    pFlash.ErrorCode |= HAL_FLASH_ERROR_RD;
 804274a:	4a0c      	ldr	r2, [pc, #48]	; (804277c <FLASH_SetErrorCode+0xa4>)
 804274c:	69d3      	ldr	r3, [r2, #28]
 804274e:	f043 0301 	orr.w	r3, r3, #1
 8042752:	61d3      	str	r3, [r2, #28]
    
    /* Clear FLASH Proprietary readout protection error pending bit */
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_RDERR);
 8042754:	4b08      	ldr	r3, [pc, #32]	; (8042778 <FLASH_SetErrorCode+0xa0>)
 8042756:	f44f 7280 	mov.w	r2, #256	; 0x100
 804275a:	60da      	str	r2, [r3, #12]
  }
#endif /* FLASH_SR_RDERR */  
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_OPERR) != RESET)
 804275c:	4b06      	ldr	r3, [pc, #24]	; (8042778 <FLASH_SetErrorCode+0xa0>)
 804275e:	68db      	ldr	r3, [r3, #12]
 8042760:	f013 0f02 	tst.w	r3, #2
 8042764:	d007      	beq.n	8042776 <FLASH_SetErrorCode+0x9e>
  {
    pFlash.ErrorCode |= HAL_FLASH_ERROR_OPERATION;
 8042766:	4a05      	ldr	r2, [pc, #20]	; (804277c <FLASH_SetErrorCode+0xa4>)
 8042768:	69d3      	ldr	r3, [r2, #28]
 804276a:	f043 0320 	orr.w	r3, r3, #32
 804276e:	61d3      	str	r3, [r2, #28]
    
    /* Clear FLASH Operation error pending bit */
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_OPERR);
 8042770:	4b01      	ldr	r3, [pc, #4]	; (8042778 <FLASH_SetErrorCode+0xa0>)
 8042772:	2202      	movs	r2, #2
 8042774:	60da      	str	r2, [r3, #12]
  }
}
 8042776:	4770      	bx	lr
 8042778:	40023c00 	.word	0x40023c00
 804277c:	200051d0 	.word	0x200051d0

08042780 <HAL_FLASH_EndOfOperationCallback>:
}
 8042780:	4770      	bx	lr

08042782 <HAL_FLASH_OperationErrorCallback>:
}
 8042782:	4770      	bx	lr

08042784 <HAL_FLASH_IRQHandler>:
{
 8042784:	b510      	push	{r4, lr}
  if(__HAL_FLASH_GET_FLAG((FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR | FLASH_FLAG_PGAERR | \
 8042786:	4b3b      	ldr	r3, [pc, #236]	; (8042874 <HAL_FLASH_IRQHandler+0xf0>)
 8042788:	68db      	ldr	r3, [r3, #12]
 804278a:	f413 7ff9 	tst.w	r3, #498	; 0x1f2
 804278e:	d013      	beq.n	80427b8 <HAL_FLASH_IRQHandler+0x34>
    if(pFlash.ProcedureOnGoing == FLASH_PROC_SECTERASE)
 8042790:	4b39      	ldr	r3, [pc, #228]	; (8042878 <HAL_FLASH_IRQHandler+0xf4>)
 8042792:	781b      	ldrb	r3, [r3, #0]
 8042794:	b2db      	uxtb	r3, r3
 8042796:	2b01      	cmp	r3, #1
 8042798:	d03d      	beq.n	8042816 <HAL_FLASH_IRQHandler+0x92>
    else if(pFlash.ProcedureOnGoing == FLASH_PROC_MASSERASE)
 804279a:	4b37      	ldr	r3, [pc, #220]	; (8042878 <HAL_FLASH_IRQHandler+0xf4>)
 804279c:	781b      	ldrb	r3, [r3, #0]
 804279e:	b2db      	uxtb	r3, r3
 80427a0:	2b02      	cmp	r3, #2
 80427a2:	d03e      	beq.n	8042822 <HAL_FLASH_IRQHandler+0x9e>
      addresstmp = pFlash.Address;
 80427a4:	4b34      	ldr	r3, [pc, #208]	; (8042878 <HAL_FLASH_IRQHandler+0xf4>)
 80427a6:	695c      	ldr	r4, [r3, #20]
    FLASH_SetErrorCode();
 80427a8:	f7ff ff96 	bl	80426d8 <FLASH_SetErrorCode>
    HAL_FLASH_OperationErrorCallback(addresstmp);
 80427ac:	4620      	mov	r0, r4
 80427ae:	f7ff ffe8 	bl	8042782 <HAL_FLASH_OperationErrorCallback>
    pFlash.ProcedureOnGoing = FLASH_PROC_NONE;
 80427b2:	4b31      	ldr	r3, [pc, #196]	; (8042878 <HAL_FLASH_IRQHandler+0xf4>)
 80427b4:	2200      	movs	r2, #0
 80427b6:	701a      	strb	r2, [r3, #0]
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_EOP) != RESET)
 80427b8:	4b2e      	ldr	r3, [pc, #184]	; (8042874 <HAL_FLASH_IRQHandler+0xf0>)
 80427ba:	68db      	ldr	r3, [r3, #12]
 80427bc:	f013 0f01 	tst.w	r3, #1
 80427c0:	d013      	beq.n	80427ea <HAL_FLASH_IRQHandler+0x66>
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP);
 80427c2:	4b2c      	ldr	r3, [pc, #176]	; (8042874 <HAL_FLASH_IRQHandler+0xf0>)
 80427c4:	2201      	movs	r2, #1
 80427c6:	60da      	str	r2, [r3, #12]
    if(pFlash.ProcedureOnGoing == FLASH_PROC_SECTERASE)
 80427c8:	4b2b      	ldr	r3, [pc, #172]	; (8042878 <HAL_FLASH_IRQHandler+0xf4>)
 80427ca:	781b      	ldrb	r3, [r3, #0]
 80427cc:	b2db      	uxtb	r3, r3
 80427ce:	4293      	cmp	r3, r2
 80427d0:	d02a      	beq.n	8042828 <HAL_FLASH_IRQHandler+0xa4>
      if(pFlash.ProcedureOnGoing == FLASH_PROC_MASSERASE) 
 80427d2:	4b29      	ldr	r3, [pc, #164]	; (8042878 <HAL_FLASH_IRQHandler+0xf4>)
 80427d4:	781b      	ldrb	r3, [r3, #0]
 80427d6:	b2db      	uxtb	r3, r3
 80427d8:	2b02      	cmp	r3, #2
 80427da:	d043      	beq.n	8042864 <HAL_FLASH_IRQHandler+0xe0>
        HAL_FLASH_EndOfOperationCallback(pFlash.Address);
 80427dc:	4b26      	ldr	r3, [pc, #152]	; (8042878 <HAL_FLASH_IRQHandler+0xf4>)
 80427de:	6958      	ldr	r0, [r3, #20]
 80427e0:	f7ff ffce 	bl	8042780 <HAL_FLASH_EndOfOperationCallback>
      pFlash.ProcedureOnGoing = FLASH_PROC_NONE;
 80427e4:	4b24      	ldr	r3, [pc, #144]	; (8042878 <HAL_FLASH_IRQHandler+0xf4>)
 80427e6:	2200      	movs	r2, #0
 80427e8:	701a      	strb	r2, [r3, #0]
  if(pFlash.ProcedureOnGoing == FLASH_PROC_NONE)
 80427ea:	4b23      	ldr	r3, [pc, #140]	; (8042878 <HAL_FLASH_IRQHandler+0xf4>)
 80427ec:	781b      	ldrb	r3, [r3, #0]
 80427ee:	b98b      	cbnz	r3, 8042814 <HAL_FLASH_IRQHandler+0x90>
    CLEAR_BIT(FLASH->CR, (FLASH_CR_PG | FLASH_CR_SER | FLASH_CR_SNB | FLASH_MER_BIT));
 80427f0:	4b20      	ldr	r3, [pc, #128]	; (8042874 <HAL_FLASH_IRQHandler+0xf0>)
 80427f2:	691a      	ldr	r2, [r3, #16]
 80427f4:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 80427f8:	f022 02ff 	bic.w	r2, r2, #255	; 0xff
 80427fc:	611a      	str	r2, [r3, #16]
    __HAL_FLASH_DISABLE_IT(FLASH_IT_EOP);
 80427fe:	691a      	ldr	r2, [r3, #16]
 8042800:	f022 7280 	bic.w	r2, r2, #16777216	; 0x1000000
 8042804:	611a      	str	r2, [r3, #16]
    __HAL_FLASH_DISABLE_IT(FLASH_IT_ERR);
 8042806:	691a      	ldr	r2, [r3, #16]
 8042808:	f022 7200 	bic.w	r2, r2, #33554432	; 0x2000000
 804280c:	611a      	str	r2, [r3, #16]
    __HAL_UNLOCK(&pFlash);
 804280e:	4b1a      	ldr	r3, [pc, #104]	; (8042878 <HAL_FLASH_IRQHandler+0xf4>)
 8042810:	2200      	movs	r2, #0
 8042812:	761a      	strb	r2, [r3, #24]
}
 8042814:	bd10      	pop	{r4, pc}
      addresstmp = pFlash.Sector;
 8042816:	4b18      	ldr	r3, [pc, #96]	; (8042878 <HAL_FLASH_IRQHandler+0xf4>)
 8042818:	68dc      	ldr	r4, [r3, #12]
      pFlash.Sector = 0xFFFFFFFFU;
 804281a:	f04f 32ff 	mov.w	r2, #4294967295
 804281e:	60da      	str	r2, [r3, #12]
 8042820:	e7c2      	b.n	80427a8 <HAL_FLASH_IRQHandler+0x24>
      addresstmp = pFlash.Bank;
 8042822:	4b15      	ldr	r3, [pc, #84]	; (8042878 <HAL_FLASH_IRQHandler+0xf4>)
 8042824:	691c      	ldr	r4, [r3, #16]
 8042826:	e7bf      	b.n	80427a8 <HAL_FLASH_IRQHandler+0x24>
      pFlash.NbSectorsToErase--;
 8042828:	4b13      	ldr	r3, [pc, #76]	; (8042878 <HAL_FLASH_IRQHandler+0xf4>)
 804282a:	685a      	ldr	r2, [r3, #4]
 804282c:	3a01      	subs	r2, #1
 804282e:	605a      	str	r2, [r3, #4]
      if(pFlash.NbSectorsToErase != 0U)
 8042830:	685b      	ldr	r3, [r3, #4]
 8042832:	b15b      	cbz	r3, 804284c <HAL_FLASH_IRQHandler+0xc8>
        addresstmp = pFlash.Sector;
 8042834:	4c10      	ldr	r4, [pc, #64]	; (8042878 <HAL_FLASH_IRQHandler+0xf4>)
 8042836:	68e0      	ldr	r0, [r4, #12]
        HAL_FLASH_EndOfOperationCallback(addresstmp);
 8042838:	f7ff ffa2 	bl	8042780 <HAL_FLASH_EndOfOperationCallback>
        pFlash.Sector++;
 804283c:	68e3      	ldr	r3, [r4, #12]
 804283e:	3301      	adds	r3, #1
 8042840:	60e3      	str	r3, [r4, #12]
        addresstmp = pFlash.Sector;
 8042842:	68e0      	ldr	r0, [r4, #12]
        FLASH_Erase_Sector(addresstmp, pFlash.VoltageForErase);
 8042844:	7a21      	ldrb	r1, [r4, #8]
 8042846:	f000 f8cf 	bl	80429e8 <FLASH_Erase_Sector>
 804284a:	e7ce      	b.n	80427ea <HAL_FLASH_IRQHandler+0x66>
        pFlash.Sector = addresstmp = 0xFFFFFFFFU;
 804284c:	4b0a      	ldr	r3, [pc, #40]	; (8042878 <HAL_FLASH_IRQHandler+0xf4>)
 804284e:	f04f 34ff 	mov.w	r4, #4294967295
 8042852:	60dc      	str	r4, [r3, #12]
        pFlash.ProcedureOnGoing = FLASH_PROC_NONE;
 8042854:	2200      	movs	r2, #0
 8042856:	701a      	strb	r2, [r3, #0]
        FLASH_FlushCaches() ;
 8042858:	f000 f8f4 	bl	8042a44 <FLASH_FlushCaches>
        HAL_FLASH_EndOfOperationCallback(addresstmp);
 804285c:	4620      	mov	r0, r4
 804285e:	f7ff ff8f 	bl	8042780 <HAL_FLASH_EndOfOperationCallback>
 8042862:	e7c2      	b.n	80427ea <HAL_FLASH_IRQHandler+0x66>
        FLASH_FlushCaches() ;
 8042864:	f000 f8ee 	bl	8042a44 <FLASH_FlushCaches>
        HAL_FLASH_EndOfOperationCallback(pFlash.Bank);
 8042868:	4b03      	ldr	r3, [pc, #12]	; (8042878 <HAL_FLASH_IRQHandler+0xf4>)
 804286a:	6918      	ldr	r0, [r3, #16]
 804286c:	f7ff ff88 	bl	8042780 <HAL_FLASH_EndOfOperationCallback>
 8042870:	e7b8      	b.n	80427e4 <HAL_FLASH_IRQHandler+0x60>
 8042872:	bf00      	nop
 8042874:	40023c00 	.word	0x40023c00
 8042878:	200051d0 	.word	0x200051d0

0804287c <HAL_FLASH_Unlock>:
  if(READ_BIT(FLASH->CR, FLASH_CR_LOCK) != RESET)
 804287c:	4b09      	ldr	r3, [pc, #36]	; (80428a4 <HAL_FLASH_Unlock+0x28>)
 804287e:	691b      	ldr	r3, [r3, #16]
 8042880:	2b00      	cmp	r3, #0
 8042882:	db01      	blt.n	8042888 <HAL_FLASH_Unlock+0xc>
  HAL_StatusTypeDef status = HAL_OK;
 8042884:	2000      	movs	r0, #0
 8042886:	4770      	bx	lr
    WRITE_REG(FLASH->KEYR, FLASH_KEY1);
 8042888:	4b06      	ldr	r3, [pc, #24]	; (80428a4 <HAL_FLASH_Unlock+0x28>)
 804288a:	4a07      	ldr	r2, [pc, #28]	; (80428a8 <HAL_FLASH_Unlock+0x2c>)
 804288c:	605a      	str	r2, [r3, #4]
    WRITE_REG(FLASH->KEYR, FLASH_KEY2);
 804288e:	f102 3288 	add.w	r2, r2, #2290649224	; 0x88888888
 8042892:	605a      	str	r2, [r3, #4]
    if(READ_BIT(FLASH->CR, FLASH_CR_LOCK) != RESET)
 8042894:	691b      	ldr	r3, [r3, #16]
 8042896:	2b00      	cmp	r3, #0
 8042898:	db01      	blt.n	804289e <HAL_FLASH_Unlock+0x22>
  HAL_StatusTypeDef status = HAL_OK;
 804289a:	2000      	movs	r0, #0
 804289c:	4770      	bx	lr
      status = HAL_ERROR;
 804289e:	2001      	movs	r0, #1
}
 80428a0:	4770      	bx	lr
 80428a2:	bf00      	nop
 80428a4:	40023c00 	.word	0x40023c00
 80428a8:	45670123 	.word	0x45670123

080428ac <HAL_FLASH_Lock>:
  FLASH->CR |= FLASH_CR_LOCK;
 80428ac:	4a03      	ldr	r2, [pc, #12]	; (80428bc <HAL_FLASH_Lock+0x10>)
 80428ae:	6913      	ldr	r3, [r2, #16]
 80428b0:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 80428b4:	6113      	str	r3, [r2, #16]
}
 80428b6:	2000      	movs	r0, #0
 80428b8:	4770      	bx	lr
 80428ba:	bf00      	nop
 80428bc:	40023c00 	.word	0x40023c00

080428c0 <FLASH_WaitForLastOperation>:
{ 
 80428c0:	b538      	push	{r3, r4, r5, lr}
 80428c2:	4604      	mov	r4, r0
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 80428c4:	4b14      	ldr	r3, [pc, #80]	; (8042918 <FLASH_WaitForLastOperation+0x58>)
 80428c6:	2200      	movs	r2, #0
 80428c8:	61da      	str	r2, [r3, #28]
  tickstart = HAL_GetTick();
 80428ca:	f7fe fbf9 	bl	80410c0 <HAL_GetTick>
 80428ce:	4605      	mov	r5, r0
  while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY) != RESET) 
 80428d0:	4b12      	ldr	r3, [pc, #72]	; (804291c <FLASH_WaitForLastOperation+0x5c>)
 80428d2:	68db      	ldr	r3, [r3, #12]
 80428d4:	f413 3f80 	tst.w	r3, #65536	; 0x10000
 80428d8:	d00a      	beq.n	80428f0 <FLASH_WaitForLastOperation+0x30>
    if(Timeout != HAL_MAX_DELAY)
 80428da:	f1b4 3fff 	cmp.w	r4, #4294967295
 80428de:	d0f7      	beq.n	80428d0 <FLASH_WaitForLastOperation+0x10>
      if((Timeout == 0U)||((HAL_GetTick() - tickstart ) > Timeout))
 80428e0:	b124      	cbz	r4, 80428ec <FLASH_WaitForLastOperation+0x2c>
 80428e2:	f7fe fbed 	bl	80410c0 <HAL_GetTick>
 80428e6:	1b40      	subs	r0, r0, r5
 80428e8:	42a0      	cmp	r0, r4
 80428ea:	d9f1      	bls.n	80428d0 <FLASH_WaitForLastOperation+0x10>
        return HAL_TIMEOUT;
 80428ec:	2003      	movs	r0, #3
 80428ee:	e00d      	b.n	804290c <FLASH_WaitForLastOperation+0x4c>
  if (__HAL_FLASH_GET_FLAG(FLASH_FLAG_EOP) != RESET)
 80428f0:	4b0a      	ldr	r3, [pc, #40]	; (804291c <FLASH_WaitForLastOperation+0x5c>)
 80428f2:	68db      	ldr	r3, [r3, #12]
 80428f4:	f013 0f01 	tst.w	r3, #1
 80428f8:	d002      	beq.n	8042900 <FLASH_WaitForLastOperation+0x40>
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP);
 80428fa:	4b08      	ldr	r3, [pc, #32]	; (804291c <FLASH_WaitForLastOperation+0x5c>)
 80428fc:	2201      	movs	r2, #1
 80428fe:	60da      	str	r2, [r3, #12]
  if(__HAL_FLASH_GET_FLAG((FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR | FLASH_FLAG_PGAERR | \
 8042900:	4b06      	ldr	r3, [pc, #24]	; (804291c <FLASH_WaitForLastOperation+0x5c>)
 8042902:	68db      	ldr	r3, [r3, #12]
 8042904:	f413 7ff9 	tst.w	r3, #498	; 0x1f2
 8042908:	d101      	bne.n	804290e <FLASH_WaitForLastOperation+0x4e>
  return HAL_OK;
 804290a:	2000      	movs	r0, #0
}  
 804290c:	bd38      	pop	{r3, r4, r5, pc}
    FLASH_SetErrorCode();
 804290e:	f7ff fee3 	bl	80426d8 <FLASH_SetErrorCode>
    return HAL_ERROR;
 8042912:	2001      	movs	r0, #1
 8042914:	e7fa      	b.n	804290c <FLASH_WaitForLastOperation+0x4c>
 8042916:	bf00      	nop
 8042918:	200051d0 	.word	0x200051d0
 804291c:	40023c00 	.word	0x40023c00

08042920 <HAL_FLASH_Program>:
{
 8042920:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8042922:	4616      	mov	r6, r2
  __HAL_LOCK(&pFlash);
 8042924:	4a1b      	ldr	r2, [pc, #108]	; (8042994 <HAL_FLASH_Program+0x74>)
 8042926:	7e12      	ldrb	r2, [r2, #24]
 8042928:	2a01      	cmp	r2, #1
 804292a:	d030      	beq.n	804298e <HAL_FLASH_Program+0x6e>
 804292c:	4604      	mov	r4, r0
 804292e:	460d      	mov	r5, r1
 8042930:	461f      	mov	r7, r3
 8042932:	4b18      	ldr	r3, [pc, #96]	; (8042994 <HAL_FLASH_Program+0x74>)
 8042934:	2201      	movs	r2, #1
 8042936:	761a      	strb	r2, [r3, #24]
  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 8042938:	f24c 3050 	movw	r0, #50000	; 0xc350
 804293c:	f7ff ffc0 	bl	80428c0 <FLASH_WaitForLastOperation>
  if(status == HAL_OK)
 8042940:	b990      	cbnz	r0, 8042968 <HAL_FLASH_Program+0x48>
    if(TypeProgram == FLASH_TYPEPROGRAM_BYTE)
 8042942:	b1ac      	cbz	r4, 8042970 <HAL_FLASH_Program+0x50>
    else if(TypeProgram == FLASH_TYPEPROGRAM_HALFWORD)
 8042944:	2c01      	cmp	r4, #1
 8042946:	d018      	beq.n	804297a <HAL_FLASH_Program+0x5a>
    else if(TypeProgram == FLASH_TYPEPROGRAM_WORD)
 8042948:	2c02      	cmp	r4, #2
 804294a:	d01b      	beq.n	8042984 <HAL_FLASH_Program+0x64>
      FLASH_Program_DoubleWord(Address, Data);
 804294c:	4632      	mov	r2, r6
 804294e:	463b      	mov	r3, r7
 8042950:	4628      	mov	r0, r5
 8042952:	f7ff fe77 	bl	8042644 <FLASH_Program_DoubleWord>
    status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 8042956:	f24c 3050 	movw	r0, #50000	; 0xc350
 804295a:	f7ff ffb1 	bl	80428c0 <FLASH_WaitForLastOperation>
    FLASH->CR &= (~FLASH_CR_PG);  
 804295e:	4a0e      	ldr	r2, [pc, #56]	; (8042998 <HAL_FLASH_Program+0x78>)
 8042960:	6913      	ldr	r3, [r2, #16]
 8042962:	f023 0301 	bic.w	r3, r3, #1
 8042966:	6113      	str	r3, [r2, #16]
  __HAL_UNLOCK(&pFlash);
 8042968:	4b0a      	ldr	r3, [pc, #40]	; (8042994 <HAL_FLASH_Program+0x74>)
 804296a:	2200      	movs	r2, #0
 804296c:	761a      	strb	r2, [r3, #24]
}
 804296e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      FLASH_Program_Byte(Address, (uint8_t) Data);
 8042970:	b2f1      	uxtb	r1, r6
 8042972:	4628      	mov	r0, r5
 8042974:	f7ff fea0 	bl	80426b8 <FLASH_Program_Byte>
 8042978:	e7ed      	b.n	8042956 <HAL_FLASH_Program+0x36>
      FLASH_Program_HalfWord(Address, (uint16_t) Data);
 804297a:	b2b1      	uxth	r1, r6
 804297c:	4628      	mov	r0, r5
 804297e:	f7ff fe89 	bl	8042694 <FLASH_Program_HalfWord>
 8042982:	e7e8      	b.n	8042956 <HAL_FLASH_Program+0x36>
      FLASH_Program_Word(Address, (uint32_t) Data);
 8042984:	4631      	mov	r1, r6
 8042986:	4628      	mov	r0, r5
 8042988:	f7ff fe72 	bl	8042670 <FLASH_Program_Word>
 804298c:	e7e3      	b.n	8042956 <HAL_FLASH_Program+0x36>
  __HAL_LOCK(&pFlash);
 804298e:	2002      	movs	r0, #2
 8042990:	e7ed      	b.n	804296e <HAL_FLASH_Program+0x4e>
 8042992:	bf00      	nop
 8042994:	200051d0 	.word	0x200051d0
 8042998:	40023c00 	.word	0x40023c00

0804299c <FLASH_MassErase>:
  /* Check the parameters */
  assert_param(IS_VOLTAGERANGE(VoltageRange));
  assert_param(IS_FLASH_BANK(Banks));

  /* if the previous operation is completed, proceed to erase all sectors */
  CLEAR_BIT(FLASH->CR, FLASH_CR_PSIZE);
 804299c:	4a11      	ldr	r2, [pc, #68]	; (80429e4 <FLASH_MassErase+0x48>)
 804299e:	6913      	ldr	r3, [r2, #16]
 80429a0:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 80429a4:	6113      	str	r3, [r2, #16]

  if(Banks == FLASH_BANK_BOTH)
 80429a6:	2903      	cmp	r1, #3
 80429a8:	d00e      	beq.n	80429c8 <FLASH_MassErase+0x2c>
  {
    /* bank1 & bank2 will be erased*/
    FLASH->CR |= FLASH_MER_BIT;
  }
  else if(Banks == FLASH_BANK_1)
 80429aa:	2901      	cmp	r1, #1
 80429ac:	d013      	beq.n	80429d6 <FLASH_MassErase+0x3a>
    FLASH->CR |= FLASH_CR_MER1;
  }
  else
  {
    /*Only bank2 will be erased*/
    FLASH->CR |= FLASH_CR_MER2;
 80429ae:	4a0d      	ldr	r2, [pc, #52]	; (80429e4 <FLASH_MassErase+0x48>)
 80429b0:	6913      	ldr	r3, [r2, #16]
 80429b2:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 80429b6:	6113      	str	r3, [r2, #16]
  }
  FLASH->CR |= FLASH_CR_STRT | ((uint32_t)VoltageRange <<8U);
 80429b8:	4a0a      	ldr	r2, [pc, #40]	; (80429e4 <FLASH_MassErase+0x48>)
 80429ba:	6913      	ldr	r3, [r2, #16]
 80429bc:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
 80429c0:	f440 3080 	orr.w	r0, r0, #65536	; 0x10000
 80429c4:	6110      	str	r0, [r2, #16]
}
 80429c6:	4770      	bx	lr
    FLASH->CR |= FLASH_MER_BIT;
 80429c8:	6913      	ldr	r3, [r2, #16]
 80429ca:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 80429ce:	f043 0304 	orr.w	r3, r3, #4
 80429d2:	6113      	str	r3, [r2, #16]
 80429d4:	e7f0      	b.n	80429b8 <FLASH_MassErase+0x1c>
    FLASH->CR |= FLASH_CR_MER1;
 80429d6:	4a03      	ldr	r2, [pc, #12]	; (80429e4 <FLASH_MassErase+0x48>)
 80429d8:	6913      	ldr	r3, [r2, #16]
 80429da:	f043 0304 	orr.w	r3, r3, #4
 80429de:	6113      	str	r3, [r2, #16]
 80429e0:	e7ea      	b.n	80429b8 <FLASH_MassErase+0x1c>
 80429e2:	bf00      	nop
 80429e4:	40023c00 	.word	0x40023c00

080429e8 <FLASH_Erase_Sector>:
  *                                  the operation will be done by double word (64-bit)
  * 
  * @retval None
  */
void FLASH_Erase_Sector(uint32_t Sector, uint8_t VoltageRange)
{
 80429e8:	b410      	push	{r4}

  /* Check the parameters */
  assert_param(IS_FLASH_SECTOR(Sector));
  assert_param(IS_VOLTAGERANGE(VoltageRange));
  
  if(VoltageRange == FLASH_VOLTAGE_RANGE_1)
 80429ea:	b149      	cbz	r1, 8042a00 <FLASH_Erase_Sector+0x18>
  {
     tmp_psize = FLASH_PSIZE_BYTE;
  }
  else if(VoltageRange == FLASH_VOLTAGE_RANGE_2)
 80429ec:	2901      	cmp	r1, #1
 80429ee:	d024      	beq.n	8042a3a <FLASH_Erase_Sector+0x52>
  {
    tmp_psize = FLASH_PSIZE_HALF_WORD;
  }
  else if(VoltageRange == FLASH_VOLTAGE_RANGE_3)
 80429f0:	2902      	cmp	r1, #2
 80429f2:	d002      	beq.n	80429fa <FLASH_Erase_Sector+0x12>
  {
    tmp_psize = FLASH_PSIZE_WORD;
  }
  else
  {
    tmp_psize = FLASH_PSIZE_DOUBLE_WORD;
 80429f4:	f44f 7440 	mov.w	r4, #768	; 0x300
 80429f8:	e003      	b.n	8042a02 <FLASH_Erase_Sector+0x1a>
    tmp_psize = FLASH_PSIZE_WORD;
 80429fa:	f44f 7400 	mov.w	r4, #512	; 0x200
 80429fe:	e000      	b.n	8042a02 <FLASH_Erase_Sector+0x1a>
     tmp_psize = FLASH_PSIZE_BYTE;
 8042a00:	2400      	movs	r4, #0
  }

  /* Need to add offset of 4 when sector higher than FLASH_SECTOR_11 */
  if(Sector > FLASH_SECTOR_11) 
 8042a02:	280b      	cmp	r0, #11
 8042a04:	d900      	bls.n	8042a08 <FLASH_Erase_Sector+0x20>
  {
    Sector += 4U;
 8042a06:	3004      	adds	r0, #4
  }
  /* If the previous operation is completed, proceed to erase the sector */
  CLEAR_BIT(FLASH->CR, FLASH_CR_PSIZE);
 8042a08:	4b0d      	ldr	r3, [pc, #52]	; (8042a40 <FLASH_Erase_Sector+0x58>)
 8042a0a:	6919      	ldr	r1, [r3, #16]
 8042a0c:	f421 7140 	bic.w	r1, r1, #768	; 0x300
 8042a10:	6119      	str	r1, [r3, #16]
  FLASH->CR |= tmp_psize;
 8042a12:	691a      	ldr	r2, [r3, #16]
 8042a14:	4322      	orrs	r2, r4
 8042a16:	611a      	str	r2, [r3, #16]
  CLEAR_BIT(FLASH->CR, FLASH_CR_SNB);
 8042a18:	691a      	ldr	r2, [r3, #16]
 8042a1a:	f022 02f8 	bic.w	r2, r2, #248	; 0xf8
 8042a1e:	611a      	str	r2, [r3, #16]
  FLASH->CR |= FLASH_CR_SER | (Sector << FLASH_CR_SNB_Pos);
 8042a20:	691a      	ldr	r2, [r3, #16]
 8042a22:	ea42 00c0 	orr.w	r0, r2, r0, lsl #3
 8042a26:	f040 0002 	orr.w	r0, r0, #2
 8042a2a:	6118      	str	r0, [r3, #16]
  FLASH->CR |= FLASH_CR_STRT;
 8042a2c:	691a      	ldr	r2, [r3, #16]
 8042a2e:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 8042a32:	611a      	str	r2, [r3, #16]
}
 8042a34:	f85d 4b04 	ldr.w	r4, [sp], #4
 8042a38:	4770      	bx	lr
    tmp_psize = FLASH_PSIZE_HALF_WORD;
 8042a3a:	f44f 7480 	mov.w	r4, #256	; 0x100
 8042a3e:	e7e0      	b.n	8042a02 <FLASH_Erase_Sector+0x1a>
 8042a40:	40023c00 	.word	0x40023c00

08042a44 <FLASH_FlushCaches>:
  * @retval None
  */
void FLASH_FlushCaches(void)
{
  /* Flush instruction cache  */
  if(READ_BIT(FLASH->ACR, FLASH_ACR_ICEN)!= RESET)
 8042a44:	4b16      	ldr	r3, [pc, #88]	; (8042aa0 <FLASH_FlushCaches+0x5c>)
 8042a46:	681b      	ldr	r3, [r3, #0]
 8042a48:	f413 7f00 	tst.w	r3, #512	; 0x200
 8042a4c:	d010      	beq.n	8042a70 <FLASH_FlushCaches+0x2c>
  {
    /* Disable instruction cache  */
    __HAL_FLASH_INSTRUCTION_CACHE_DISABLE();
 8042a4e:	4b14      	ldr	r3, [pc, #80]	; (8042aa0 <FLASH_FlushCaches+0x5c>)
 8042a50:	681a      	ldr	r2, [r3, #0]
 8042a52:	f422 7200 	bic.w	r2, r2, #512	; 0x200
 8042a56:	601a      	str	r2, [r3, #0]
    /* Reset instruction cache */
    __HAL_FLASH_INSTRUCTION_CACHE_RESET();
 8042a58:	681a      	ldr	r2, [r3, #0]
 8042a5a:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 8042a5e:	601a      	str	r2, [r3, #0]
 8042a60:	681a      	ldr	r2, [r3, #0]
 8042a62:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
 8042a66:	601a      	str	r2, [r3, #0]
    /* Enable instruction cache */
    __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();
 8042a68:	681a      	ldr	r2, [r3, #0]
 8042a6a:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8042a6e:	601a      	str	r2, [r3, #0]
  }
  
  /* Flush data cache */
  if(READ_BIT(FLASH->ACR, FLASH_ACR_DCEN) != RESET)
 8042a70:	4b0b      	ldr	r3, [pc, #44]	; (8042aa0 <FLASH_FlushCaches+0x5c>)
 8042a72:	681b      	ldr	r3, [r3, #0]
 8042a74:	f413 6f80 	tst.w	r3, #1024	; 0x400
 8042a78:	d010      	beq.n	8042a9c <FLASH_FlushCaches+0x58>
  {
    /* Disable data cache  */
    __HAL_FLASH_DATA_CACHE_DISABLE();
 8042a7a:	4b09      	ldr	r3, [pc, #36]	; (8042aa0 <FLASH_FlushCaches+0x5c>)
 8042a7c:	681a      	ldr	r2, [r3, #0]
 8042a7e:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 8042a82:	601a      	str	r2, [r3, #0]
    /* Reset data cache */
    __HAL_FLASH_DATA_CACHE_RESET();
 8042a84:	681a      	ldr	r2, [r3, #0]
 8042a86:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 8042a8a:	601a      	str	r2, [r3, #0]
 8042a8c:	681a      	ldr	r2, [r3, #0]
 8042a8e:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 8042a92:	601a      	str	r2, [r3, #0]
    /* Enable data cache */
    __HAL_FLASH_DATA_CACHE_ENABLE();
 8042a94:	681a      	ldr	r2, [r3, #0]
 8042a96:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 8042a9a:	601a      	str	r2, [r3, #0]
  }
}
 8042a9c:	4770      	bx	lr
 8042a9e:	bf00      	nop
 8042aa0:	40023c00 	.word	0x40023c00

08042aa4 <HAL_FLASHEx_Erase>:
{
 8042aa4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  __HAL_LOCK(&pFlash);
 8042aa6:	4b23      	ldr	r3, [pc, #140]	; (8042b34 <HAL_FLASHEx_Erase+0x90>)
 8042aa8:	7e1b      	ldrb	r3, [r3, #24]
 8042aaa:	2b01      	cmp	r3, #1
 8042aac:	d040      	beq.n	8042b30 <HAL_FLASHEx_Erase+0x8c>
 8042aae:	4604      	mov	r4, r0
 8042ab0:	460e      	mov	r6, r1
 8042ab2:	4b20      	ldr	r3, [pc, #128]	; (8042b34 <HAL_FLASHEx_Erase+0x90>)
 8042ab4:	2201      	movs	r2, #1
 8042ab6:	761a      	strb	r2, [r3, #24]
  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 8042ab8:	f24c 3050 	movw	r0, #50000	; 0xc350
 8042abc:	f7ff ff00 	bl	80428c0 <FLASH_WaitForLastOperation>
  if(status == HAL_OK)
 8042ac0:	4607      	mov	r7, r0
 8042ac2:	bb80      	cbnz	r0, 8042b26 <HAL_FLASHEx_Erase+0x82>
    *SectorError = 0xFFFFFFFFU;
 8042ac4:	f04f 33ff 	mov.w	r3, #4294967295
 8042ac8:	6033      	str	r3, [r6, #0]
    if(pEraseInit->TypeErase == FLASH_TYPEERASE_MASSERASE)
 8042aca:	6823      	ldr	r3, [r4, #0]
 8042acc:	2b01      	cmp	r3, #1
 8042ace:	d016      	beq.n	8042afe <HAL_FLASHEx_Erase+0x5a>
      for(index = pEraseInit->Sector; index < (pEraseInit->NbSectors + pEraseInit->Sector); index++)
 8042ad0:	68a5      	ldr	r5, [r4, #8]
 8042ad2:	68e3      	ldr	r3, [r4, #12]
 8042ad4:	68a2      	ldr	r2, [r4, #8]
 8042ad6:	4413      	add	r3, r2
 8042ad8:	42ab      	cmp	r3, r5
 8042ada:	d922      	bls.n	8042b22 <HAL_FLASHEx_Erase+0x7e>
        FLASH_Erase_Sector(index, (uint8_t) pEraseInit->VoltageRange);
 8042adc:	7c21      	ldrb	r1, [r4, #16]
 8042ade:	4628      	mov	r0, r5
 8042ae0:	f7ff ff82 	bl	80429e8 <FLASH_Erase_Sector>
        status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 8042ae4:	f24c 3050 	movw	r0, #50000	; 0xc350
 8042ae8:	f7ff feea 	bl	80428c0 <FLASH_WaitForLastOperation>
        CLEAR_BIT(FLASH->CR, (FLASH_CR_SER | FLASH_CR_SNB));
 8042aec:	4a12      	ldr	r2, [pc, #72]	; (8042b38 <HAL_FLASHEx_Erase+0x94>)
 8042aee:	6913      	ldr	r3, [r2, #16]
 8042af0:	f023 03fa 	bic.w	r3, r3, #250	; 0xfa
 8042af4:	6113      	str	r3, [r2, #16]
        if(status != HAL_OK) 
 8042af6:	4607      	mov	r7, r0
 8042af8:	b990      	cbnz	r0, 8042b20 <HAL_FLASHEx_Erase+0x7c>
      for(index = pEraseInit->Sector; index < (pEraseInit->NbSectors + pEraseInit->Sector); index++)
 8042afa:	3501      	adds	r5, #1
 8042afc:	e7e9      	b.n	8042ad2 <HAL_FLASHEx_Erase+0x2e>
      FLASH_MassErase((uint8_t) pEraseInit->VoltageRange, pEraseInit->Banks);
 8042afe:	6861      	ldr	r1, [r4, #4]
 8042b00:	7c20      	ldrb	r0, [r4, #16]
 8042b02:	f7ff ff4b 	bl	804299c <FLASH_MassErase>
      status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 8042b06:	f24c 3050 	movw	r0, #50000	; 0xc350
 8042b0a:	f7ff fed9 	bl	80428c0 <FLASH_WaitForLastOperation>
 8042b0e:	4607      	mov	r7, r0
      FLASH->CR &= (~FLASH_MER_BIT);
 8042b10:	4a09      	ldr	r2, [pc, #36]	; (8042b38 <HAL_FLASHEx_Erase+0x94>)
 8042b12:	6913      	ldr	r3, [r2, #16]
 8042b14:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 8042b18:	f023 0304 	bic.w	r3, r3, #4
 8042b1c:	6113      	str	r3, [r2, #16]
 8042b1e:	e000      	b.n	8042b22 <HAL_FLASHEx_Erase+0x7e>
          *SectorError = index;
 8042b20:	6035      	str	r5, [r6, #0]
    FLASH_FlushCaches();    
 8042b22:	f7ff ff8f 	bl	8042a44 <FLASH_FlushCaches>
  __HAL_UNLOCK(&pFlash);
 8042b26:	4b03      	ldr	r3, [pc, #12]	; (8042b34 <HAL_FLASHEx_Erase+0x90>)
 8042b28:	2200      	movs	r2, #0
 8042b2a:	761a      	strb	r2, [r3, #24]
}
 8042b2c:	4638      	mov	r0, r7
 8042b2e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  __HAL_LOCK(&pFlash);
 8042b30:	2702      	movs	r7, #2
 8042b32:	e7fb      	b.n	8042b2c <HAL_FLASHEx_Erase+0x88>
 8042b34:	200051d0 	.word	0x200051d0
 8042b38:	40023c00 	.word	0x40023c00

08042b3c <HAL_GPIO_Init>:
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  for(position = 0U; position < GPIO_NUMBER; position++)
 8042b3c:	2300      	movs	r3, #0
 8042b3e:	2b0f      	cmp	r3, #15
 8042b40:	f200 80e5 	bhi.w	8042d0e <HAL_GPIO_Init+0x1d2>
{
 8042b44:	b4f0      	push	{r4, r5, r6, r7}
 8042b46:	b082      	sub	sp, #8
 8042b48:	e039      	b.n	8042bbe <HAL_GPIO_Init+0x82>
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();

        temp = SYSCFG->EXTICR[position >> 2U];
        temp &= ~(0x0FU << (4U * (position & 0x03U)));
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 8042b4a:	2209      	movs	r2, #9
 8042b4c:	e000      	b.n	8042b50 <HAL_GPIO_Init+0x14>
 8042b4e:	2200      	movs	r2, #0
 8042b50:	40b2      	lsls	r2, r6
 8042b52:	433a      	orrs	r2, r7
        SYSCFG->EXTICR[position >> 2U] = temp;
 8042b54:	3402      	adds	r4, #2
 8042b56:	4e6e      	ldr	r6, [pc, #440]	; (8042d10 <HAL_GPIO_Init+0x1d4>)
 8042b58:	f846 2024 	str.w	r2, [r6, r4, lsl #2]

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
 8042b5c:	4a6d      	ldr	r2, [pc, #436]	; (8042d14 <HAL_GPIO_Init+0x1d8>)
 8042b5e:	6814      	ldr	r4, [r2, #0]
        temp &= ~((uint32_t)iocurrent);
 8042b60:	43ea      	mvns	r2, r5
 8042b62:	ea24 0605 	bic.w	r6, r4, r5
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 8042b66:	684f      	ldr	r7, [r1, #4]
 8042b68:	f417 3f80 	tst.w	r7, #65536	; 0x10000
 8042b6c:	d001      	beq.n	8042b72 <HAL_GPIO_Init+0x36>
        {
          temp |= iocurrent;
 8042b6e:	ea45 0604 	orr.w	r6, r5, r4
        }
        EXTI->IMR = temp;
 8042b72:	4c68      	ldr	r4, [pc, #416]	; (8042d14 <HAL_GPIO_Init+0x1d8>)
 8042b74:	6026      	str	r6, [r4, #0]

        temp = EXTI->EMR;
 8042b76:	6864      	ldr	r4, [r4, #4]
        temp &= ~((uint32_t)iocurrent);
 8042b78:	ea02 0604 	and.w	r6, r2, r4
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 8042b7c:	684f      	ldr	r7, [r1, #4]
 8042b7e:	f417 3f00 	tst.w	r7, #131072	; 0x20000
 8042b82:	d001      	beq.n	8042b88 <HAL_GPIO_Init+0x4c>
        {
          temp |= iocurrent;
 8042b84:	ea45 0604 	orr.w	r6, r5, r4
        }
        EXTI->EMR = temp;
 8042b88:	4c62      	ldr	r4, [pc, #392]	; (8042d14 <HAL_GPIO_Init+0x1d8>)
 8042b8a:	6066      	str	r6, [r4, #4]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR;
 8042b8c:	68a4      	ldr	r4, [r4, #8]
        temp &= ~((uint32_t)iocurrent);
 8042b8e:	ea02 0604 	and.w	r6, r2, r4
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 8042b92:	684f      	ldr	r7, [r1, #4]
 8042b94:	f417 1f80 	tst.w	r7, #1048576	; 0x100000
 8042b98:	d001      	beq.n	8042b9e <HAL_GPIO_Init+0x62>
        {
          temp |= iocurrent;
 8042b9a:	ea45 0604 	orr.w	r6, r5, r4
        }
        EXTI->RTSR = temp;
 8042b9e:	4c5d      	ldr	r4, [pc, #372]	; (8042d14 <HAL_GPIO_Init+0x1d8>)
 8042ba0:	60a6      	str	r6, [r4, #8]

        temp = EXTI->FTSR;
 8042ba2:	68e4      	ldr	r4, [r4, #12]
        temp &= ~((uint32_t)iocurrent);
 8042ba4:	4022      	ands	r2, r4
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 8042ba6:	684e      	ldr	r6, [r1, #4]
 8042ba8:	f416 1f00 	tst.w	r6, #2097152	; 0x200000
 8042bac:	d001      	beq.n	8042bb2 <HAL_GPIO_Init+0x76>
        {
          temp |= iocurrent;
 8042bae:	ea45 0204 	orr.w	r2, r5, r4
        }
        EXTI->FTSR = temp;
 8042bb2:	4c58      	ldr	r4, [pc, #352]	; (8042d14 <HAL_GPIO_Init+0x1d8>)
 8042bb4:	60e2      	str	r2, [r4, #12]
  for(position = 0U; position < GPIO_NUMBER; position++)
 8042bb6:	3301      	adds	r3, #1
 8042bb8:	2b0f      	cmp	r3, #15
 8042bba:	f200 80a5 	bhi.w	8042d08 <HAL_GPIO_Init+0x1cc>
    ioposition = 0x01U << position;
 8042bbe:	2201      	movs	r2, #1
 8042bc0:	409a      	lsls	r2, r3
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 8042bc2:	680c      	ldr	r4, [r1, #0]
 8042bc4:	ea04 0502 	and.w	r5, r4, r2
    if(iocurrent == ioposition)
 8042bc8:	ea32 0404 	bics.w	r4, r2, r4
 8042bcc:	d1f3      	bne.n	8042bb6 <HAL_GPIO_Init+0x7a>
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 8042bce:	684c      	ldr	r4, [r1, #4]
 8042bd0:	2c02      	cmp	r4, #2
 8042bd2:	d001      	beq.n	8042bd8 <HAL_GPIO_Init+0x9c>
 8042bd4:	2c12      	cmp	r4, #18
 8042bd6:	d110      	bne.n	8042bfa <HAL_GPIO_Init+0xbe>
        temp = GPIOx->AFR[position >> 3U];
 8042bd8:	08de      	lsrs	r6, r3, #3
 8042bda:	3608      	adds	r6, #8
 8042bdc:	f850 c026 	ldr.w	ip, [r0, r6, lsl #2]
        temp &= ~(0xFU << ((uint32_t)(position & 0x07U) * 4U)) ;
 8042be0:	f003 0407 	and.w	r4, r3, #7
 8042be4:	00a7      	lsls	r7, r4, #2
 8042be6:	240f      	movs	r4, #15
 8042be8:	40bc      	lsls	r4, r7
 8042bea:	ea2c 0c04 	bic.w	ip, ip, r4
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & 0x07U) * 4U));
 8042bee:	690c      	ldr	r4, [r1, #16]
 8042bf0:	40bc      	lsls	r4, r7
 8042bf2:	ea44 040c 	orr.w	r4, r4, ip
        GPIOx->AFR[position >> 3U] = temp;
 8042bf6:	f840 4026 	str.w	r4, [r0, r6, lsl #2]
      temp = GPIOx->MODER;
 8042bfa:	f8d0 c000 	ldr.w	ip, [r0]
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
 8042bfe:	005e      	lsls	r6, r3, #1
 8042c00:	2403      	movs	r4, #3
 8042c02:	40b4      	lsls	r4, r6
 8042c04:	43e7      	mvns	r7, r4
 8042c06:	ea2c 0c04 	bic.w	ip, ip, r4
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 8042c0a:	684c      	ldr	r4, [r1, #4]
 8042c0c:	f004 0403 	and.w	r4, r4, #3
 8042c10:	40b4      	lsls	r4, r6
 8042c12:	ea44 040c 	orr.w	r4, r4, ip
      GPIOx->MODER = temp;
 8042c16:	6004      	str	r4, [r0, #0]
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8042c18:	684c      	ldr	r4, [r1, #4]
 8042c1a:	f104 3cff 	add.w	ip, r4, #4294967295
 8042c1e:	f1bc 0f01 	cmp.w	ip, #1
 8042c22:	d903      	bls.n	8042c2c <HAL_GPIO_Init+0xf0>
 8042c24:	2c11      	cmp	r4, #17
 8042c26:	d001      	beq.n	8042c2c <HAL_GPIO_Init+0xf0>
         (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 8042c28:	2c12      	cmp	r4, #18
 8042c2a:	d110      	bne.n	8042c4e <HAL_GPIO_Init+0x112>
        temp = GPIOx->OSPEEDR; 
 8042c2c:	6884      	ldr	r4, [r0, #8]
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2U));
 8042c2e:	ea07 0c04 	and.w	ip, r7, r4
        temp |= (GPIO_Init->Speed << (position * 2U));
 8042c32:	68cc      	ldr	r4, [r1, #12]
 8042c34:	40b4      	lsls	r4, r6
 8042c36:	ea44 040c 	orr.w	r4, r4, ip
        GPIOx->OSPEEDR = temp;
 8042c3a:	6084      	str	r4, [r0, #8]
        temp = GPIOx->OTYPER;
 8042c3c:	6844      	ldr	r4, [r0, #4]
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
 8042c3e:	ea24 0202 	bic.w	r2, r4, r2
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4U) << position);
 8042c42:	684c      	ldr	r4, [r1, #4]
 8042c44:	f3c4 1400 	ubfx	r4, r4, #4, #1
 8042c48:	409c      	lsls	r4, r3
 8042c4a:	4314      	orrs	r4, r2
        GPIOx->OTYPER = temp;
 8042c4c:	6044      	str	r4, [r0, #4]
      temp = GPIOx->PUPDR;
 8042c4e:	68c2      	ldr	r2, [r0, #12]
      temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2U));
 8042c50:	4017      	ands	r7, r2
      temp |= ((GPIO_Init->Pull) << (position * 2U));
 8042c52:	688a      	ldr	r2, [r1, #8]
 8042c54:	40b2      	lsls	r2, r6
 8042c56:	433a      	orrs	r2, r7
      GPIOx->PUPDR = temp;
 8042c58:	60c2      	str	r2, [r0, #12]
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 8042c5a:	684a      	ldr	r2, [r1, #4]
 8042c5c:	f012 5f80 	tst.w	r2, #268435456	; 0x10000000
 8042c60:	d0a9      	beq.n	8042bb6 <HAL_GPIO_Init+0x7a>
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8042c62:	2200      	movs	r2, #0
 8042c64:	9201      	str	r2, [sp, #4]
 8042c66:	4a2c      	ldr	r2, [pc, #176]	; (8042d18 <HAL_GPIO_Init+0x1dc>)
 8042c68:	6c54      	ldr	r4, [r2, #68]	; 0x44
 8042c6a:	f444 4480 	orr.w	r4, r4, #16384	; 0x4000
 8042c6e:	6454      	str	r4, [r2, #68]	; 0x44
 8042c70:	6c52      	ldr	r2, [r2, #68]	; 0x44
 8042c72:	f402 4280 	and.w	r2, r2, #16384	; 0x4000
 8042c76:	9201      	str	r2, [sp, #4]
 8042c78:	9a01      	ldr	r2, [sp, #4]
        temp = SYSCFG->EXTICR[position >> 2U];
 8042c7a:	089c      	lsrs	r4, r3, #2
 8042c7c:	1ca6      	adds	r6, r4, #2
 8042c7e:	4a24      	ldr	r2, [pc, #144]	; (8042d10 <HAL_GPIO_Init+0x1d4>)
 8042c80:	f852 7026 	ldr.w	r7, [r2, r6, lsl #2]
        temp &= ~(0x0FU << (4U * (position & 0x03U)));
 8042c84:	f003 0203 	and.w	r2, r3, #3
 8042c88:	0096      	lsls	r6, r2, #2
 8042c8a:	220f      	movs	r2, #15
 8042c8c:	40b2      	lsls	r2, r6
 8042c8e:	ea27 0702 	bic.w	r7, r7, r2
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 8042c92:	4a22      	ldr	r2, [pc, #136]	; (8042d1c <HAL_GPIO_Init+0x1e0>)
 8042c94:	4290      	cmp	r0, r2
 8042c96:	f43f af5a 	beq.w	8042b4e <HAL_GPIO_Init+0x12>
 8042c9a:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8042c9e:	4290      	cmp	r0, r2
 8042ca0:	d022      	beq.n	8042ce8 <HAL_GPIO_Init+0x1ac>
 8042ca2:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8042ca6:	4290      	cmp	r0, r2
 8042ca8:	d020      	beq.n	8042cec <HAL_GPIO_Init+0x1b0>
 8042caa:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8042cae:	4290      	cmp	r0, r2
 8042cb0:	d01e      	beq.n	8042cf0 <HAL_GPIO_Init+0x1b4>
 8042cb2:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8042cb6:	4290      	cmp	r0, r2
 8042cb8:	d01c      	beq.n	8042cf4 <HAL_GPIO_Init+0x1b8>
 8042cba:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8042cbe:	4290      	cmp	r0, r2
 8042cc0:	d01a      	beq.n	8042cf8 <HAL_GPIO_Init+0x1bc>
 8042cc2:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8042cc6:	4290      	cmp	r0, r2
 8042cc8:	d018      	beq.n	8042cfc <HAL_GPIO_Init+0x1c0>
 8042cca:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8042cce:	4290      	cmp	r0, r2
 8042cd0:	d016      	beq.n	8042d00 <HAL_GPIO_Init+0x1c4>
 8042cd2:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8042cd6:	4290      	cmp	r0, r2
 8042cd8:	d014      	beq.n	8042d04 <HAL_GPIO_Init+0x1c8>
 8042cda:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8042cde:	4290      	cmp	r0, r2
 8042ce0:	f43f af33 	beq.w	8042b4a <HAL_GPIO_Init+0xe>
 8042ce4:	220a      	movs	r2, #10
 8042ce6:	e733      	b.n	8042b50 <HAL_GPIO_Init+0x14>
 8042ce8:	2201      	movs	r2, #1
 8042cea:	e731      	b.n	8042b50 <HAL_GPIO_Init+0x14>
 8042cec:	2202      	movs	r2, #2
 8042cee:	e72f      	b.n	8042b50 <HAL_GPIO_Init+0x14>
 8042cf0:	2203      	movs	r2, #3
 8042cf2:	e72d      	b.n	8042b50 <HAL_GPIO_Init+0x14>
 8042cf4:	2204      	movs	r2, #4
 8042cf6:	e72b      	b.n	8042b50 <HAL_GPIO_Init+0x14>
 8042cf8:	2205      	movs	r2, #5
 8042cfa:	e729      	b.n	8042b50 <HAL_GPIO_Init+0x14>
 8042cfc:	2206      	movs	r2, #6
 8042cfe:	e727      	b.n	8042b50 <HAL_GPIO_Init+0x14>
 8042d00:	2207      	movs	r2, #7
 8042d02:	e725      	b.n	8042b50 <HAL_GPIO_Init+0x14>
 8042d04:	2208      	movs	r2, #8
 8042d06:	e723      	b.n	8042b50 <HAL_GPIO_Init+0x14>
      }
    }
  }
}
 8042d08:	b002      	add	sp, #8
 8042d0a:	bcf0      	pop	{r4, r5, r6, r7}
 8042d0c:	4770      	bx	lr
 8042d0e:	4770      	bx	lr
 8042d10:	40013800 	.word	0x40013800
 8042d14:	40013c00 	.word	0x40013c00
 8042d18:	40023800 	.word	0x40023800
 8042d1c:	40020000 	.word	0x40020000

08042d20 <HAL_GPIO_WritePin>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if(PinState != GPIO_PIN_RESET)
 8042d20:	b10a      	cbz	r2, 8042d26 <HAL_GPIO_WritePin+0x6>
  {
    GPIOx->BSRR = GPIO_Pin;
 8042d22:	6181      	str	r1, [r0, #24]
 8042d24:	4770      	bx	lr
  }
  else
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << 16U;
 8042d26:	0409      	lsls	r1, r1, #16
 8042d28:	6181      	str	r1, [r0, #24]
  }
}
 8042d2a:	4770      	bx	lr

08042d2c <HAL_GPIO_TogglePin>:
void HAL_GPIO_TogglePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  if ((GPIOx->ODR & GPIO_Pin) == GPIO_Pin)
 8042d2c:	6943      	ldr	r3, [r0, #20]
 8042d2e:	ea31 0303 	bics.w	r3, r1, r3
 8042d32:	d001      	beq.n	8042d38 <HAL_GPIO_TogglePin+0xc>
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << GPIO_NUMBER;
  }
  else
  {
    GPIOx->BSRR = GPIO_Pin;
 8042d34:	6181      	str	r1, [r0, #24]
  }
}
 8042d36:	4770      	bx	lr
    GPIOx->BSRR = (uint32_t)GPIO_Pin << GPIO_NUMBER;
 8042d38:	0409      	lsls	r1, r1, #16
 8042d3a:	6181      	str	r1, [r0, #24]
 8042d3c:	4770      	bx	lr

08042d3e <I2C_Master_SB>:
  *         the configuration information for I2C module
  * @retval None
  */
static void I2C_Master_SB(I2C_HandleTypeDef *hi2c)
{
  if (hi2c->Mode == HAL_I2C_MODE_MEM)
 8042d3e:	f890 303e 	ldrb.w	r3, [r0, #62]	; 0x3e
 8042d42:	b2db      	uxtb	r3, r3
 8042d44:	2b40      	cmp	r3, #64	; 0x40
 8042d46:	d010      	beq.n	8042d6a <I2C_Master_SB+0x2c>
      hi2c->Instance->DR = I2C_7BIT_ADD_READ(hi2c->Devaddress);
    }
  }
  else
  {
    if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
 8042d48:	6903      	ldr	r3, [r0, #16]
 8042d4a:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 8042d4e:	d01b      	beq.n	8042d88 <I2C_Master_SB+0x4a>
        }
      }
    }
    else
    {
      if (hi2c->EventCount == 0U)
 8042d50:	6d03      	ldr	r3, [r0, #80]	; 0x50
 8042d52:	2b00      	cmp	r3, #0
 8042d54:	d13c      	bne.n	8042dd0 <I2C_Master_SB+0x92>
      {
        /* Send header of slave address */
        hi2c->Instance->DR = I2C_10BIT_HEADER_WRITE(hi2c->Devaddress);
 8042d56:	6c43      	ldr	r3, [r0, #68]	; 0x44
 8042d58:	f3c3 13c8 	ubfx	r3, r3, #7, #9
 8042d5c:	6802      	ldr	r2, [r0, #0]
 8042d5e:	f003 0306 	and.w	r3, r3, #6
 8042d62:	f043 03f0 	orr.w	r3, r3, #240	; 0xf0
 8042d66:	6113      	str	r3, [r2, #16]
 8042d68:	4770      	bx	lr
    if (hi2c->EventCount == 0U)
 8042d6a:	6d03      	ldr	r3, [r0, #80]	; 0x50
 8042d6c:	b92b      	cbnz	r3, 8042d7a <I2C_Master_SB+0x3c>
      hi2c->Instance->DR = I2C_7BIT_ADD_WRITE(hi2c->Devaddress);
 8042d6e:	6c43      	ldr	r3, [r0, #68]	; 0x44
 8042d70:	6802      	ldr	r2, [r0, #0]
 8042d72:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
 8042d76:	6113      	str	r3, [r2, #16]
 8042d78:	4770      	bx	lr
      hi2c->Instance->DR = I2C_7BIT_ADD_READ(hi2c->Devaddress);
 8042d7a:	6c43      	ldr	r3, [r0, #68]	; 0x44
 8042d7c:	6802      	ldr	r2, [r0, #0]
 8042d7e:	f043 0301 	orr.w	r3, r3, #1
 8042d82:	b2db      	uxtb	r3, r3
 8042d84:	6113      	str	r3, [r2, #16]
 8042d86:	4770      	bx	lr
      if (hi2c->State == HAL_I2C_STATE_BUSY_TX)
 8042d88:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 8042d8c:	b2db      	uxtb	r3, r3
 8042d8e:	2b21      	cmp	r3, #33	; 0x21
 8042d90:	d00f      	beq.n	8042db2 <I2C_Master_SB+0x74>
        hi2c->Instance->DR = I2C_7BIT_ADD_READ(hi2c->Devaddress);
 8042d92:	6c43      	ldr	r3, [r0, #68]	; 0x44
 8042d94:	6802      	ldr	r2, [r0, #0]
 8042d96:	f043 0301 	orr.w	r3, r3, #1
 8042d9a:	b2db      	uxtb	r3, r3
 8042d9c:	6113      	str	r3, [r2, #16]
      if ((hi2c->hdmatx != NULL) || (hi2c->hdmarx != NULL))
 8042d9e:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8042da0:	b16b      	cbz	r3, 8042dbe <I2C_Master_SB+0x80>
        if ((hi2c->hdmatx->XferCpltCallback != NULL) || (hi2c->hdmarx->XferCpltCallback != NULL))
 8042da2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8042da4:	b17b      	cbz	r3, 8042dc6 <I2C_Master_SB+0x88>
          SET_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
 8042da6:	6802      	ldr	r2, [r0, #0]
 8042da8:	6853      	ldr	r3, [r2, #4]
 8042daa:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 8042dae:	6053      	str	r3, [r2, #4]
 8042db0:	4770      	bx	lr
        hi2c->Instance->DR = I2C_7BIT_ADD_WRITE(hi2c->Devaddress);
 8042db2:	6c43      	ldr	r3, [r0, #68]	; 0x44
 8042db4:	6802      	ldr	r2, [r0, #0]
 8042db6:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
 8042dba:	6113      	str	r3, [r2, #16]
 8042dbc:	e7ef      	b.n	8042d9e <I2C_Master_SB+0x60>
      if ((hi2c->hdmatx != NULL) || (hi2c->hdmarx != NULL))
 8042dbe:	6b82      	ldr	r2, [r0, #56]	; 0x38
 8042dc0:	2a00      	cmp	r2, #0
 8042dc2:	d1ee      	bne.n	8042da2 <I2C_Master_SB+0x64>
 8042dc4:	e007      	b.n	8042dd6 <I2C_Master_SB+0x98>
        if ((hi2c->hdmatx->XferCpltCallback != NULL) || (hi2c->hdmarx->XferCpltCallback != NULL))
 8042dc6:	6b83      	ldr	r3, [r0, #56]	; 0x38
 8042dc8:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8042dca:	2b00      	cmp	r3, #0
 8042dcc:	d1eb      	bne.n	8042da6 <I2C_Master_SB+0x68>
 8042dce:	e002      	b.n	8042dd6 <I2C_Master_SB+0x98>
      }
      else if (hi2c->EventCount == 1U)
 8042dd0:	6d03      	ldr	r3, [r0, #80]	; 0x50
 8042dd2:	2b01      	cmp	r3, #1
 8042dd4:	d000      	beq.n	8042dd8 <I2C_Master_SB+0x9a>
      {
        /* Do nothing */
      }
    }
  }
}
 8042dd6:	4770      	bx	lr
        hi2c->Instance->DR = I2C_10BIT_HEADER_READ(hi2c->Devaddress);
 8042dd8:	6c43      	ldr	r3, [r0, #68]	; 0x44
 8042dda:	f3c3 13c8 	ubfx	r3, r3, #7, #9
 8042dde:	6802      	ldr	r2, [r0, #0]
 8042de0:	f003 0306 	and.w	r3, r3, #6
 8042de4:	f043 03f1 	orr.w	r3, r3, #241	; 0xf1
 8042de8:	6113      	str	r3, [r2, #16]
}
 8042dea:	e7f4      	b.n	8042dd6 <I2C_Master_SB+0x98>

08042dec <I2C_Master_ADD10>:
  * @retval None
  */
static void I2C_Master_ADD10(I2C_HandleTypeDef *hi2c)
{
  /* Send slave address */
  hi2c->Instance->DR = I2C_10BIT_ADDRESS(hi2c->Devaddress);
 8042dec:	6c43      	ldr	r3, [r0, #68]	; 0x44
 8042dee:	6802      	ldr	r2, [r0, #0]
 8042df0:	b2db      	uxtb	r3, r3
 8042df2:	6113      	str	r3, [r2, #16]

  if ((hi2c->hdmatx != NULL) || (hi2c->hdmarx != NULL))
 8042df4:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8042df6:	b13b      	cbz	r3, 8042e08 <I2C_Master_ADD10+0x1c>
  {
    if ((hi2c->hdmatx->XferCpltCallback != NULL) || (hi2c->hdmarx->XferCpltCallback != NULL))
 8042df8:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8042dfa:	b14b      	cbz	r3, 8042e10 <I2C_Master_ADD10+0x24>
    {
      /* Enable DMA Request */
      SET_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
 8042dfc:	6802      	ldr	r2, [r0, #0]
 8042dfe:	6853      	ldr	r3, [r2, #4]
 8042e00:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 8042e04:	6053      	str	r3, [r2, #4]
    }
  }
}
 8042e06:	4770      	bx	lr
  if ((hi2c->hdmatx != NULL) || (hi2c->hdmarx != NULL))
 8042e08:	6b82      	ldr	r2, [r0, #56]	; 0x38
 8042e0a:	2a00      	cmp	r2, #0
 8042e0c:	d1f4      	bne.n	8042df8 <I2C_Master_ADD10+0xc>
 8042e0e:	e7fa      	b.n	8042e06 <I2C_Master_ADD10+0x1a>
    if ((hi2c->hdmatx->XferCpltCallback != NULL) || (hi2c->hdmarx->XferCpltCallback != NULL))
 8042e10:	6b83      	ldr	r3, [r0, #56]	; 0x38
 8042e12:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8042e14:	2b00      	cmp	r3, #0
 8042e16:	d1f1      	bne.n	8042dfc <I2C_Master_ADD10+0x10>
 8042e18:	e7f5      	b.n	8042e06 <I2C_Master_ADD10+0x1a>

08042e1a <I2C_Master_ADDR>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *         the configuration information for I2C module
  * @retval None
  */
static void I2C_Master_ADDR(I2C_HandleTypeDef *hi2c)
{
 8042e1a:	b410      	push	{r4}
 8042e1c:	b08b      	sub	sp, #44	; 0x2c
  /* Declaration of temporary variable to prevent undefined behavior of volatile usage */
  HAL_I2C_ModeTypeDef CurrentMode       = hi2c->Mode;
 8042e1e:	f890 303e 	ldrb.w	r3, [r0, #62]	; 0x3e
 8042e22:	b2da      	uxtb	r2, r3
  uint32_t CurrentXferOptions           = hi2c->XferOptions;
 8042e24:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
  uint32_t Prev_State                   = hi2c->PreviousState;
 8042e26:	6b04      	ldr	r4, [r0, #48]	; 0x30

  if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
 8042e28:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 8042e2c:	b2db      	uxtb	r3, r3
 8042e2e:	2b22      	cmp	r3, #34	; 0x22
 8042e30:	d00b      	beq.n	8042e4a <I2C_Master_ADDR+0x30>
    }
  }
  else
  {
    /* Clear ADDR flag */
    __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 8042e32:	2300      	movs	r3, #0
 8042e34:	9309      	str	r3, [sp, #36]	; 0x24
 8042e36:	6803      	ldr	r3, [r0, #0]
 8042e38:	695a      	ldr	r2, [r3, #20]
 8042e3a:	9209      	str	r2, [sp, #36]	; 0x24
 8042e3c:	699b      	ldr	r3, [r3, #24]
 8042e3e:	9309      	str	r3, [sp, #36]	; 0x24
 8042e40:	9b09      	ldr	r3, [sp, #36]	; 0x24
  }
}
 8042e42:	b00b      	add	sp, #44	; 0x2c
 8042e44:	f85d 4b04 	ldr.w	r4, [sp], #4
 8042e48:	4770      	bx	lr
    if ((hi2c->EventCount == 0U) && (CurrentMode == HAL_I2C_MODE_MEM))
 8042e4a:	6d03      	ldr	r3, [r0, #80]	; 0x50
 8042e4c:	b90b      	cbnz	r3, 8042e52 <I2C_Master_ADDR+0x38>
 8042e4e:	2a40      	cmp	r2, #64	; 0x40
 8042e50:	d017      	beq.n	8042e82 <I2C_Master_ADDR+0x68>
    else if ((hi2c->EventCount == 0U) && (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT))
 8042e52:	6d03      	ldr	r3, [r0, #80]	; 0x50
 8042e54:	b91b      	cbnz	r3, 8042e5e <I2C_Master_ADDR+0x44>
 8042e56:	6903      	ldr	r3, [r0, #16]
 8042e58:	f5b3 4f40 	cmp.w	r3, #49152	; 0xc000
 8042e5c:	d019      	beq.n	8042e92 <I2C_Master_ADDR+0x78>
      if (hi2c->XferCount == 0U)
 8042e5e:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 8042e60:	b29b      	uxth	r3, r3
 8042e62:	2b00      	cmp	r3, #0
 8042e64:	d125      	bne.n	8042eb2 <I2C_Master_ADDR+0x98>
        __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 8042e66:	9302      	str	r3, [sp, #8]
 8042e68:	6803      	ldr	r3, [r0, #0]
 8042e6a:	695a      	ldr	r2, [r3, #20]
 8042e6c:	9202      	str	r2, [sp, #8]
 8042e6e:	699a      	ldr	r2, [r3, #24]
 8042e70:	9202      	str	r2, [sp, #8]
 8042e72:	9a02      	ldr	r2, [sp, #8]
        SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
 8042e74:	681a      	ldr	r2, [r3, #0]
 8042e76:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8042e7a:	601a      	str	r2, [r3, #0]
      hi2c->EventCount = 0U;
 8042e7c:	2300      	movs	r3, #0
 8042e7e:	6503      	str	r3, [r0, #80]	; 0x50
 8042e80:	e7df      	b.n	8042e42 <I2C_Master_ADDR+0x28>
      __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 8042e82:	9300      	str	r3, [sp, #0]
 8042e84:	6803      	ldr	r3, [r0, #0]
 8042e86:	695a      	ldr	r2, [r3, #20]
 8042e88:	9200      	str	r2, [sp, #0]
 8042e8a:	699b      	ldr	r3, [r3, #24]
 8042e8c:	9300      	str	r3, [sp, #0]
 8042e8e:	9b00      	ldr	r3, [sp, #0]
 8042e90:	e7d7      	b.n	8042e42 <I2C_Master_ADDR+0x28>
      __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 8042e92:	2300      	movs	r3, #0
 8042e94:	9301      	str	r3, [sp, #4]
 8042e96:	6803      	ldr	r3, [r0, #0]
 8042e98:	695a      	ldr	r2, [r3, #20]
 8042e9a:	9201      	str	r2, [sp, #4]
 8042e9c:	699a      	ldr	r2, [r3, #24]
 8042e9e:	9201      	str	r2, [sp, #4]
 8042ea0:	9a01      	ldr	r2, [sp, #4]
      SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
 8042ea2:	681a      	ldr	r2, [r3, #0]
 8042ea4:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8042ea8:	601a      	str	r2, [r3, #0]
      hi2c->EventCount++;
 8042eaa:	6d03      	ldr	r3, [r0, #80]	; 0x50
 8042eac:	3301      	adds	r3, #1
 8042eae:	6503      	str	r3, [r0, #80]	; 0x50
 8042eb0:	e7c7      	b.n	8042e42 <I2C_Master_ADDR+0x28>
      else if (hi2c->XferCount == 1U)
 8042eb2:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 8042eb4:	b29b      	uxth	r3, r3
 8042eb6:	2b01      	cmp	r3, #1
 8042eb8:	d025      	beq.n	8042f06 <I2C_Master_ADDR+0xec>
      else if (hi2c->XferCount == 2U)
 8042eba:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 8042ebc:	b29b      	uxth	r3, r3
 8042ebe:	2b02      	cmp	r3, #2
 8042ec0:	d07b      	beq.n	8042fba <I2C_Master_ADDR+0x1a0>
        SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 8042ec2:	6802      	ldr	r2, [r0, #0]
 8042ec4:	6813      	ldr	r3, [r2, #0]
 8042ec6:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8042eca:	6013      	str	r3, [r2, #0]
        if (((hi2c->Instance->CR2 & I2C_CR2_DMAEN) == I2C_CR2_DMAEN) && ((CurrentXferOptions == I2C_NO_OPTION_FRAME) || (CurrentXferOptions == I2C_FIRST_FRAME) || (CurrentXferOptions == I2C_FIRST_AND_LAST_FRAME) || (CurrentXferOptions == I2C_LAST_FRAME_NO_STOP) || (CurrentXferOptions == I2C_LAST_FRAME)))
 8042ecc:	6803      	ldr	r3, [r0, #0]
 8042ece:	685a      	ldr	r2, [r3, #4]
 8042ed0:	f412 6f00 	tst.w	r2, #2048	; 0x800
 8042ed4:	d00e      	beq.n	8042ef4 <I2C_Master_ADDR+0xda>
 8042ed6:	f511 3f80 	cmn.w	r1, #65536	; 0x10000
 8042eda:	d007      	beq.n	8042eec <I2C_Master_ADDR+0xd2>
 8042edc:	2901      	cmp	r1, #1
 8042ede:	d005      	beq.n	8042eec <I2C_Master_ADDR+0xd2>
 8042ee0:	2908      	cmp	r1, #8
 8042ee2:	d003      	beq.n	8042eec <I2C_Master_ADDR+0xd2>
 8042ee4:	2910      	cmp	r1, #16
 8042ee6:	d001      	beq.n	8042eec <I2C_Master_ADDR+0xd2>
 8042ee8:	2920      	cmp	r1, #32
 8042eea:	d103      	bne.n	8042ef4 <I2C_Master_ADDR+0xda>
          SET_BIT(hi2c->Instance->CR2, I2C_CR2_LAST);
 8042eec:	685a      	ldr	r2, [r3, #4]
 8042eee:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 8042ef2:	605a      	str	r2, [r3, #4]
        __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 8042ef4:	2300      	movs	r3, #0
 8042ef6:	9308      	str	r3, [sp, #32]
 8042ef8:	6803      	ldr	r3, [r0, #0]
 8042efa:	695a      	ldr	r2, [r3, #20]
 8042efc:	9208      	str	r2, [sp, #32]
 8042efe:	699b      	ldr	r3, [r3, #24]
 8042f00:	9308      	str	r3, [sp, #32]
 8042f02:	9b08      	ldr	r3, [sp, #32]
 8042f04:	e7ba      	b.n	8042e7c <I2C_Master_ADDR+0x62>
        if (CurrentXferOptions == I2C_NO_OPTION_FRAME)
 8042f06:	f511 3f80 	cmn.w	r1, #65536	; 0x10000
 8042f0a:	d011      	beq.n	8042f30 <I2C_Master_ADDR+0x116>
        else if ((CurrentXferOptions != I2C_FIRST_AND_LAST_FRAME) && (CurrentXferOptions != I2C_LAST_FRAME) \
 8042f0c:	2908      	cmp	r1, #8
 8042f0e:	d034      	beq.n	8042f7a <I2C_Master_ADDR+0x160>
 8042f10:	2920      	cmp	r1, #32
 8042f12:	d032      	beq.n	8042f7a <I2C_Master_ADDR+0x160>
                 && ((Prev_State != I2C_STATE_MASTER_BUSY_RX) || (CurrentXferOptions == I2C_FIRST_FRAME)))
 8042f14:	2c12      	cmp	r4, #18
 8042f16:	d02e      	beq.n	8042f76 <I2C_Master_ADDR+0x15c>
          if ((CurrentXferOptions != I2C_NEXT_FRAME) && (CurrentXferOptions != I2C_FIRST_AND_NEXT_FRAME) && (CurrentXferOptions != I2C_LAST_FRAME_NO_STOP))
 8042f18:	2904      	cmp	r1, #4
 8042f1a:	d040      	beq.n	8042f9e <I2C_Master_ADDR+0x184>
 8042f1c:	2902      	cmp	r1, #2
 8042f1e:	d03e      	beq.n	8042f9e <I2C_Master_ADDR+0x184>
 8042f20:	2910      	cmp	r1, #16
 8042f22:	d03c      	beq.n	8042f9e <I2C_Master_ADDR+0x184>
            CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 8042f24:	6802      	ldr	r2, [r0, #0]
 8042f26:	6813      	ldr	r3, [r2, #0]
 8042f28:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8042f2c:	6013      	str	r3, [r2, #0]
 8042f2e:	e03b      	b.n	8042fa8 <I2C_Master_ADDR+0x18e>
          CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 8042f30:	6802      	ldr	r2, [r0, #0]
 8042f32:	6813      	ldr	r3, [r2, #0]
 8042f34:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8042f38:	6013      	str	r3, [r2, #0]
          if ((hi2c->Instance->CR2 & I2C_CR2_DMAEN) == I2C_CR2_DMAEN)
 8042f3a:	6803      	ldr	r3, [r0, #0]
 8042f3c:	685a      	ldr	r2, [r3, #4]
 8042f3e:	f412 6f00 	tst.w	r2, #2048	; 0x800
 8042f42:	d00c      	beq.n	8042f5e <I2C_Master_ADDR+0x144>
            CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 8042f44:	681a      	ldr	r2, [r3, #0]
 8042f46:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 8042f4a:	601a      	str	r2, [r3, #0]
            __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 8042f4c:	2300      	movs	r3, #0
 8042f4e:	9303      	str	r3, [sp, #12]
 8042f50:	6803      	ldr	r3, [r0, #0]
 8042f52:	695a      	ldr	r2, [r3, #20]
 8042f54:	9203      	str	r2, [sp, #12]
 8042f56:	699b      	ldr	r3, [r3, #24]
 8042f58:	9303      	str	r3, [sp, #12]
 8042f5a:	9b03      	ldr	r3, [sp, #12]
 8042f5c:	e78e      	b.n	8042e7c <I2C_Master_ADDR+0x62>
            __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 8042f5e:	2200      	movs	r2, #0
 8042f60:	9204      	str	r2, [sp, #16]
 8042f62:	695a      	ldr	r2, [r3, #20]
 8042f64:	9204      	str	r2, [sp, #16]
 8042f66:	699a      	ldr	r2, [r3, #24]
 8042f68:	9204      	str	r2, [sp, #16]
 8042f6a:	9a04      	ldr	r2, [sp, #16]
            SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
 8042f6c:	681a      	ldr	r2, [r3, #0]
 8042f6e:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8042f72:	601a      	str	r2, [r3, #0]
 8042f74:	e782      	b.n	8042e7c <I2C_Master_ADDR+0x62>
                 && ((Prev_State != I2C_STATE_MASTER_BUSY_RX) || (CurrentXferOptions == I2C_FIRST_FRAME)))
 8042f76:	2901      	cmp	r1, #1
 8042f78:	d0ce      	beq.n	8042f18 <I2C_Master_ADDR+0xfe>
          CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 8042f7a:	6802      	ldr	r2, [r0, #0]
 8042f7c:	6813      	ldr	r3, [r2, #0]
 8042f7e:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8042f82:	6013      	str	r3, [r2, #0]
          __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 8042f84:	2300      	movs	r3, #0
 8042f86:	9306      	str	r3, [sp, #24]
 8042f88:	6803      	ldr	r3, [r0, #0]
 8042f8a:	695a      	ldr	r2, [r3, #20]
 8042f8c:	9206      	str	r2, [sp, #24]
 8042f8e:	699a      	ldr	r2, [r3, #24]
 8042f90:	9206      	str	r2, [sp, #24]
 8042f92:	9a06      	ldr	r2, [sp, #24]
          SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
 8042f94:	681a      	ldr	r2, [r3, #0]
 8042f96:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8042f9a:	601a      	str	r2, [r3, #0]
 8042f9c:	e76e      	b.n	8042e7c <I2C_Master_ADDR+0x62>
            SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 8042f9e:	6802      	ldr	r2, [r0, #0]
 8042fa0:	6813      	ldr	r3, [r2, #0]
 8042fa2:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8042fa6:	6013      	str	r3, [r2, #0]
          __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 8042fa8:	2300      	movs	r3, #0
 8042faa:	9305      	str	r3, [sp, #20]
 8042fac:	6803      	ldr	r3, [r0, #0]
 8042fae:	695a      	ldr	r2, [r3, #20]
 8042fb0:	9205      	str	r2, [sp, #20]
 8042fb2:	699b      	ldr	r3, [r3, #24]
 8042fb4:	9305      	str	r3, [sp, #20]
 8042fb6:	9b05      	ldr	r3, [sp, #20]
 8042fb8:	e760      	b.n	8042e7c <I2C_Master_ADDR+0x62>
        if ((CurrentXferOptions != I2C_NEXT_FRAME) && (CurrentXferOptions != I2C_FIRST_AND_NEXT_FRAME) && (CurrentXferOptions != I2C_LAST_FRAME_NO_STOP))
 8042fba:	2904      	cmp	r1, #4
 8042fbc:	d00e      	beq.n	8042fdc <I2C_Master_ADDR+0x1c2>
 8042fbe:	2902      	cmp	r1, #2
 8042fc0:	d00c      	beq.n	8042fdc <I2C_Master_ADDR+0x1c2>
 8042fc2:	2910      	cmp	r1, #16
 8042fc4:	d00a      	beq.n	8042fdc <I2C_Master_ADDR+0x1c2>
          CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 8042fc6:	6802      	ldr	r2, [r0, #0]
 8042fc8:	6813      	ldr	r3, [r2, #0]
 8042fca:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8042fce:	6013      	str	r3, [r2, #0]
          SET_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
 8042fd0:	6802      	ldr	r2, [r0, #0]
 8042fd2:	6813      	ldr	r3, [r2, #0]
 8042fd4:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 8042fd8:	6013      	str	r3, [r2, #0]
 8042fda:	e004      	b.n	8042fe6 <I2C_Master_ADDR+0x1cc>
          SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 8042fdc:	6802      	ldr	r2, [r0, #0]
 8042fde:	6813      	ldr	r3, [r2, #0]
 8042fe0:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8042fe4:	6013      	str	r3, [r2, #0]
        if (((hi2c->Instance->CR2 & I2C_CR2_DMAEN) == I2C_CR2_DMAEN) && ((CurrentXferOptions == I2C_NO_OPTION_FRAME) || (CurrentXferOptions == I2C_FIRST_FRAME) || (CurrentXferOptions == I2C_FIRST_AND_LAST_FRAME) || (CurrentXferOptions == I2C_LAST_FRAME_NO_STOP) || (CurrentXferOptions == I2C_LAST_FRAME)))
 8042fe6:	6803      	ldr	r3, [r0, #0]
 8042fe8:	685a      	ldr	r2, [r3, #4]
 8042fea:	f412 6f00 	tst.w	r2, #2048	; 0x800
 8042fee:	d00e      	beq.n	804300e <I2C_Master_ADDR+0x1f4>
 8042ff0:	f511 3f80 	cmn.w	r1, #65536	; 0x10000
 8042ff4:	d007      	beq.n	8043006 <I2C_Master_ADDR+0x1ec>
 8042ff6:	2901      	cmp	r1, #1
 8042ff8:	d005      	beq.n	8043006 <I2C_Master_ADDR+0x1ec>
 8042ffa:	2908      	cmp	r1, #8
 8042ffc:	d003      	beq.n	8043006 <I2C_Master_ADDR+0x1ec>
 8042ffe:	2910      	cmp	r1, #16
 8043000:	d001      	beq.n	8043006 <I2C_Master_ADDR+0x1ec>
 8043002:	2920      	cmp	r1, #32
 8043004:	d103      	bne.n	804300e <I2C_Master_ADDR+0x1f4>
          SET_BIT(hi2c->Instance->CR2, I2C_CR2_LAST);
 8043006:	685a      	ldr	r2, [r3, #4]
 8043008:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 804300c:	605a      	str	r2, [r3, #4]
        __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 804300e:	2300      	movs	r3, #0
 8043010:	9307      	str	r3, [sp, #28]
 8043012:	6803      	ldr	r3, [r0, #0]
 8043014:	695a      	ldr	r2, [r3, #20]
 8043016:	9207      	str	r2, [sp, #28]
 8043018:	699b      	ldr	r3, [r3, #24]
 804301a:	9307      	str	r3, [sp, #28]
 804301c:	9b07      	ldr	r3, [sp, #28]
 804301e:	e72d      	b.n	8042e7c <I2C_Master_ADDR+0x62>

08043020 <I2C_SlaveTransmit_BTF>:
  *         the configuration information for I2C module
  * @retval None
  */
static void I2C_SlaveTransmit_BTF(I2C_HandleTypeDef *hi2c)
{
  if (hi2c->XferCount != 0U)
 8043020:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 8043022:	b29b      	uxth	r3, r3
 8043024:	b15b      	cbz	r3, 804303e <I2C_SlaveTransmit_BTF+0x1e>
  {
    /* Write data to DR */
    hi2c->Instance->DR = *hi2c->pBuffPtr;
 8043026:	6a42      	ldr	r2, [r0, #36]	; 0x24
 8043028:	6803      	ldr	r3, [r0, #0]
 804302a:	7812      	ldrb	r2, [r2, #0]
 804302c:	611a      	str	r2, [r3, #16]

    /* Increment Buffer pointer */
    hi2c->pBuffPtr++;
 804302e:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8043030:	3301      	adds	r3, #1
 8043032:	6243      	str	r3, [r0, #36]	; 0x24

    /* Update counter */
    hi2c->XferCount--;
 8043034:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 8043036:	b29b      	uxth	r3, r3
 8043038:	3b01      	subs	r3, #1
 804303a:	b29b      	uxth	r3, r3
 804303c:	8543      	strh	r3, [r0, #42]	; 0x2a
  }
}
 804303e:	4770      	bx	lr

08043040 <I2C_SlaveReceive_BTF>:
  *         the configuration information for I2C module
  * @retval None
  */
static void I2C_SlaveReceive_BTF(I2C_HandleTypeDef *hi2c)
{
  if (hi2c->XferCount != 0U)
 8043040:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 8043042:	b29b      	uxth	r3, r3
 8043044:	b15b      	cbz	r3, 804305e <I2C_SlaveReceive_BTF+0x1e>
  {
    /* Read data from DR */
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 8043046:	6803      	ldr	r3, [r0, #0]
 8043048:	691a      	ldr	r2, [r3, #16]
 804304a:	6a43      	ldr	r3, [r0, #36]	; 0x24
 804304c:	701a      	strb	r2, [r3, #0]

    /* Increment Buffer pointer */
    hi2c->pBuffPtr++;
 804304e:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8043050:	3301      	adds	r3, #1
 8043052:	6243      	str	r3, [r0, #36]	; 0x24

    /* Update counter */
    hi2c->XferCount--;
 8043054:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 8043056:	b29b      	uxth	r3, r3
 8043058:	3b01      	subs	r3, #1
 804305a:	b29b      	uxth	r3, r3
 804305c:	8543      	strh	r3, [r0, #42]	; 0x2a
  }
}
 804305e:	4770      	bx	lr

08043060 <I2C_ConvertOtherXferOptions>:
static void I2C_ConvertOtherXferOptions(I2C_HandleTypeDef *hi2c)
{
  /* if user set XferOptions to I2C_OTHER_FRAME            */
  /* it request implicitly to generate a restart condition */
  /* set XferOptions to I2C_FIRST_FRAME                    */
  if (hi2c->XferOptions == I2C_OTHER_FRAME)
 8043060:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 8043062:	f5b3 0f2a 	cmp.w	r3, #11141120	; 0xaa0000
 8043066:	d004      	beq.n	8043072 <I2C_ConvertOtherXferOptions+0x12>
  }
  /* else if user set XferOptions to I2C_OTHER_AND_LAST_FRAME */
  /* it request implicitly to generate a restart condition    */
  /* then generate a stop condition at the end of transfer    */
  /* set XferOptions to I2C_FIRST_AND_LAST_FRAME              */
  else if (hi2c->XferOptions == I2C_OTHER_AND_LAST_FRAME)
 8043068:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 804306a:	f1b3 4f2a 	cmp.w	r3, #2852126720	; 0xaa000000
 804306e:	d003      	beq.n	8043078 <I2C_ConvertOtherXferOptions+0x18>
  }
  else
  {
    /* Nothing to do */
  }
}
 8043070:	4770      	bx	lr
    hi2c->XferOptions = I2C_FIRST_FRAME;
 8043072:	2301      	movs	r3, #1
 8043074:	62c3      	str	r3, [r0, #44]	; 0x2c
 8043076:	4770      	bx	lr
    hi2c->XferOptions = I2C_FIRST_AND_LAST_FRAME;
 8043078:	2308      	movs	r3, #8
 804307a:	62c3      	str	r3, [r0, #44]	; 0x2c
}
 804307c:	e7f8      	b.n	8043070 <I2C_ConvertOtherXferOptions+0x10>
	...

08043080 <HAL_I2C_Init>:
  if (hi2c == NULL)
 8043080:	2800      	cmp	r0, #0
 8043082:	f000 80c2 	beq.w	804320a <HAL_I2C_Init+0x18a>
{
 8043086:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8043088:	4604      	mov	r4, r0
  if (hi2c->State == HAL_I2C_STATE_RESET)
 804308a:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 804308e:	2b00      	cmp	r3, #0
 8043090:	d06d      	beq.n	804316e <HAL_I2C_Init+0xee>
  hi2c->State = HAL_I2C_STATE_BUSY;
 8043092:	2324      	movs	r3, #36	; 0x24
 8043094:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  __HAL_I2C_DISABLE(hi2c);
 8043098:	6822      	ldr	r2, [r4, #0]
 804309a:	6813      	ldr	r3, [r2, #0]
 804309c:	f023 0301 	bic.w	r3, r3, #1
 80430a0:	6013      	str	r3, [r2, #0]
  pclk1 = HAL_RCC_GetPCLK1Freq();
 80430a2:	f001 f9cf 	bl	8044444 <HAL_RCC_GetPCLK1Freq>
  if (I2C_MIN_PCLK_FREQ(pclk1, hi2c->Init.ClockSpeed) == 1U)
 80430a6:	6862      	ldr	r2, [r4, #4]
 80430a8:	4b5a      	ldr	r3, [pc, #360]	; (8043214 <HAL_I2C_Init+0x194>)
 80430aa:	429a      	cmp	r2, r3
 80430ac:	d864      	bhi.n	8043178 <HAL_I2C_Init+0xf8>
 80430ae:	4b5a      	ldr	r3, [pc, #360]	; (8043218 <HAL_I2C_Init+0x198>)
 80430b0:	4298      	cmp	r0, r3
 80430b2:	bf8c      	ite	hi
 80430b4:	2300      	movhi	r3, #0
 80430b6:	2301      	movls	r3, #1
 80430b8:	2b00      	cmp	r3, #0
 80430ba:	f040 80a8 	bne.w	804320e <HAL_I2C_Init+0x18e>
  freqrange = I2C_FREQRANGE(pclk1);
 80430be:	4d57      	ldr	r5, [pc, #348]	; (804321c <HAL_I2C_Init+0x19c>)
 80430c0:	fba5 3500 	umull	r3, r5, r5, r0
 80430c4:	0caf      	lsrs	r7, r5, #18
  MODIFY_REG(hi2c->Instance->CR2, I2C_CR2_FREQ, freqrange);
 80430c6:	6826      	ldr	r6, [r4, #0]
 80430c8:	6871      	ldr	r1, [r6, #4]
 80430ca:	f021 013f 	bic.w	r1, r1, #63	; 0x3f
 80430ce:	ea41 4195 	orr.w	r1, r1, r5, lsr #18
 80430d2:	6071      	str	r1, [r6, #4]
  MODIFY_REG(hi2c->Instance->TRISE, I2C_TRISE_TRISE, I2C_RISE_TIME(freqrange, hi2c->Init.ClockSpeed));
 80430d4:	6821      	ldr	r1, [r4, #0]
 80430d6:	6a0b      	ldr	r3, [r1, #32]
 80430d8:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
 80430dc:	6865      	ldr	r5, [r4, #4]
 80430de:	4a4d      	ldr	r2, [pc, #308]	; (8043214 <HAL_I2C_Init+0x194>)
 80430e0:	4295      	cmp	r5, r2
 80430e2:	d84f      	bhi.n	8043184 <HAL_I2C_Init+0x104>
 80430e4:	1c7a      	adds	r2, r7, #1
 80430e6:	4313      	orrs	r3, r2
 80430e8:	620b      	str	r3, [r1, #32]
  MODIFY_REG(hi2c->Instance->CCR, (I2C_CCR_FS | I2C_CCR_DUTY | I2C_CCR_CCR), I2C_SPEED(pclk1, hi2c->Init.ClockSpeed, hi2c->Init.DutyCycle));
 80430ea:	6825      	ldr	r5, [r4, #0]
 80430ec:	69e9      	ldr	r1, [r5, #28]
 80430ee:	f421 414f 	bic.w	r1, r1, #52992	; 0xcf00
 80430f2:	f021 01ff 	bic.w	r1, r1, #255	; 0xff
 80430f6:	6863      	ldr	r3, [r4, #4]
 80430f8:	4a46      	ldr	r2, [pc, #280]	; (8043214 <HAL_I2C_Init+0x194>)
 80430fa:	4293      	cmp	r3, r2
 80430fc:	d84c      	bhi.n	8043198 <HAL_I2C_Init+0x118>
 80430fe:	3801      	subs	r0, #1
 8043100:	005b      	lsls	r3, r3, #1
 8043102:	fbb0 f0f3 	udiv	r0, r0, r3
 8043106:	3001      	adds	r0, #1
 8043108:	f640 73fc 	movw	r3, #4092	; 0xffc
 804310c:	4218      	tst	r0, r3
 804310e:	d078      	beq.n	8043202 <HAL_I2C_Init+0x182>
 8043110:	f3c0 030b 	ubfx	r3, r0, #0, #12
 8043114:	430b      	orrs	r3, r1
 8043116:	61eb      	str	r3, [r5, #28]
  MODIFY_REG(hi2c->Instance->CR1, (I2C_CR1_ENGC | I2C_CR1_NOSTRETCH), (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode));
 8043118:	6821      	ldr	r1, [r4, #0]
 804311a:	680b      	ldr	r3, [r1, #0]
 804311c:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
 8043120:	69e2      	ldr	r2, [r4, #28]
 8043122:	6a20      	ldr	r0, [r4, #32]
 8043124:	4302      	orrs	r2, r0
 8043126:	4313      	orrs	r3, r2
 8043128:	600b      	str	r3, [r1, #0]
  MODIFY_REG(hi2c->Instance->OAR1, (I2C_OAR1_ADDMODE | I2C_OAR1_ADD8_9 | I2C_OAR1_ADD1_7 | I2C_OAR1_ADD0), (hi2c->Init.AddressingMode | hi2c->Init.OwnAddress1));
 804312a:	6821      	ldr	r1, [r4, #0]
 804312c:	688b      	ldr	r3, [r1, #8]
 804312e:	f423 4303 	bic.w	r3, r3, #33536	; 0x8300
 8043132:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
 8043136:	6922      	ldr	r2, [r4, #16]
 8043138:	68e0      	ldr	r0, [r4, #12]
 804313a:	4302      	orrs	r2, r0
 804313c:	4313      	orrs	r3, r2
 804313e:	608b      	str	r3, [r1, #8]
  MODIFY_REG(hi2c->Instance->OAR2, (I2C_OAR2_ENDUAL | I2C_OAR2_ADD2), (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2));
 8043140:	6821      	ldr	r1, [r4, #0]
 8043142:	68cb      	ldr	r3, [r1, #12]
 8043144:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
 8043148:	6962      	ldr	r2, [r4, #20]
 804314a:	69a0      	ldr	r0, [r4, #24]
 804314c:	4302      	orrs	r2, r0
 804314e:	4313      	orrs	r3, r2
 8043150:	60cb      	str	r3, [r1, #12]
  __HAL_I2C_ENABLE(hi2c);
 8043152:	6822      	ldr	r2, [r4, #0]
 8043154:	6813      	ldr	r3, [r2, #0]
 8043156:	f043 0301 	orr.w	r3, r3, #1
 804315a:	6013      	str	r3, [r2, #0]
  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 804315c:	2000      	movs	r0, #0
 804315e:	6420      	str	r0, [r4, #64]	; 0x40
  hi2c->State = HAL_I2C_STATE_READY;
 8043160:	2320      	movs	r3, #32
 8043162:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  hi2c->PreviousState = I2C_STATE_NONE;
 8043166:	6320      	str	r0, [r4, #48]	; 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
 8043168:	f884 003e 	strb.w	r0, [r4, #62]	; 0x3e
}
 804316c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    hi2c->Lock = HAL_UNLOCKED;
 804316e:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
    HAL_I2C_MspInit(hi2c);
 8043172:	f00a f8ed 	bl	804d350 <HAL_I2C_MspInit>
 8043176:	e78c      	b.n	8043092 <HAL_I2C_Init+0x12>
  if (I2C_MIN_PCLK_FREQ(pclk1, hi2c->Init.ClockSpeed) == 1U)
 8043178:	4b29      	ldr	r3, [pc, #164]	; (8043220 <HAL_I2C_Init+0x1a0>)
 804317a:	4298      	cmp	r0, r3
 804317c:	bf8c      	ite	hi
 804317e:	2300      	movhi	r3, #0
 8043180:	2301      	movls	r3, #1
 8043182:	e799      	b.n	80430b8 <HAL_I2C_Init+0x38>
  MODIFY_REG(hi2c->Instance->TRISE, I2C_TRISE_TRISE, I2C_RISE_TIME(freqrange, hi2c->Init.ClockSpeed));
 8043184:	f44f 7296 	mov.w	r2, #300	; 0x12c
 8043188:	fb02 f207 	mul.w	r2, r2, r7
 804318c:	4d25      	ldr	r5, [pc, #148]	; (8043224 <HAL_I2C_Init+0x1a4>)
 804318e:	fba5 5202 	umull	r5, r2, r5, r2
 8043192:	0992      	lsrs	r2, r2, #6
 8043194:	3201      	adds	r2, #1
 8043196:	e7a6      	b.n	80430e6 <HAL_I2C_Init+0x66>
  MODIFY_REG(hi2c->Instance->CCR, (I2C_CCR_FS | I2C_CCR_DUTY | I2C_CCR_CCR), I2C_SPEED(pclk1, hi2c->Init.ClockSpeed, hi2c->Init.DutyCycle));
 8043198:	68a2      	ldr	r2, [r4, #8]
 804319a:	b9ba      	cbnz	r2, 80431cc <HAL_I2C_Init+0x14c>
 804319c:	1e46      	subs	r6, r0, #1
 804319e:	eb03 0743 	add.w	r7, r3, r3, lsl #1
 80431a2:	fbb6 f6f7 	udiv	r6, r6, r7
 80431a6:	3601      	adds	r6, #1
 80431a8:	f3c6 060b 	ubfx	r6, r6, #0, #12
 80431ac:	fab6 f686 	clz	r6, r6
 80431b0:	0976      	lsrs	r6, r6, #5
 80431b2:	bb46      	cbnz	r6, 8043206 <HAL_I2C_Init+0x186>
 80431b4:	b9c2      	cbnz	r2, 80431e8 <HAL_I2C_Init+0x168>
 80431b6:	1e42      	subs	r2, r0, #1
 80431b8:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 80431bc:	fbb2 f2f3 	udiv	r2, r2, r3
 80431c0:	3201      	adds	r2, #1
 80431c2:	f3c2 020b 	ubfx	r2, r2, #0, #12
 80431c6:	f442 4300 	orr.w	r3, r2, #32768	; 0x8000
 80431ca:	e7a3      	b.n	8043114 <HAL_I2C_Init+0x94>
 80431cc:	1e46      	subs	r6, r0, #1
 80431ce:	eb03 0783 	add.w	r7, r3, r3, lsl #2
 80431d2:	eb07 0787 	add.w	r7, r7, r7, lsl #2
 80431d6:	fbb6 f6f7 	udiv	r6, r6, r7
 80431da:	3601      	adds	r6, #1
 80431dc:	f3c6 060b 	ubfx	r6, r6, #0, #12
 80431e0:	fab6 f686 	clz	r6, r6
 80431e4:	0976      	lsrs	r6, r6, #5
 80431e6:	e7e4      	b.n	80431b2 <HAL_I2C_Init+0x132>
 80431e8:	1e42      	subs	r2, r0, #1
 80431ea:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 80431ee:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 80431f2:	fbb2 f2f3 	udiv	r2, r2, r3
 80431f6:	3201      	adds	r2, #1
 80431f8:	f3c2 020b 	ubfx	r2, r2, #0, #12
 80431fc:	f442 4340 	orr.w	r3, r2, #49152	; 0xc000
 8043200:	e788      	b.n	8043114 <HAL_I2C_Init+0x94>
 8043202:	2304      	movs	r3, #4
 8043204:	e786      	b.n	8043114 <HAL_I2C_Init+0x94>
 8043206:	2301      	movs	r3, #1
 8043208:	e784      	b.n	8043114 <HAL_I2C_Init+0x94>
    return HAL_ERROR;
 804320a:	2001      	movs	r0, #1
}
 804320c:	4770      	bx	lr
    return HAL_ERROR;
 804320e:	2001      	movs	r0, #1
 8043210:	e7ac      	b.n	804316c <HAL_I2C_Init+0xec>
 8043212:	bf00      	nop
 8043214:	000186a0 	.word	0x000186a0
 8043218:	001e847f 	.word	0x001e847f
 804321c:	431bde83 	.word	0x431bde83
 8043220:	003d08ff 	.word	0x003d08ff
 8043224:	10624dd3 	.word	0x10624dd3

08043228 <HAL_I2C_MasterTxCpltCallback>:
}
 8043228:	4770      	bx	lr

0804322a <HAL_I2C_MasterRxCpltCallback>:
}
 804322a:	4770      	bx	lr

0804322c <HAL_I2C_SlaveTxCpltCallback>:
}
 804322c:	4770      	bx	lr

0804322e <I2C_SlaveTransmit_TXE>:
{
 804322e:	b508      	push	{r3, lr}
  HAL_I2C_StateTypeDef CurrentState = hi2c->State;
 8043230:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 8043234:	b2da      	uxtb	r2, r3
  if (hi2c->XferCount != 0U)
 8043236:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 8043238:	b29b      	uxth	r3, r3
 804323a:	b183      	cbz	r3, 804325e <I2C_SlaveTransmit_TXE+0x30>
    hi2c->Instance->DR = *hi2c->pBuffPtr;
 804323c:	6a41      	ldr	r1, [r0, #36]	; 0x24
 804323e:	6803      	ldr	r3, [r0, #0]
 8043240:	7809      	ldrb	r1, [r1, #0]
 8043242:	6119      	str	r1, [r3, #16]
    hi2c->pBuffPtr++;
 8043244:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8043246:	3301      	adds	r3, #1
 8043248:	6243      	str	r3, [r0, #36]	; 0x24
    hi2c->XferCount--;
 804324a:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 804324c:	b29b      	uxth	r3, r3
 804324e:	3b01      	subs	r3, #1
 8043250:	b29b      	uxth	r3, r3
 8043252:	8543      	strh	r3, [r0, #42]	; 0x2a
    if ((hi2c->XferCount == 0U) && (CurrentState == HAL_I2C_STATE_BUSY_TX_LISTEN))
 8043254:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 8043256:	b29b      	uxth	r3, r3
 8043258:	b90b      	cbnz	r3, 804325e <I2C_SlaveTransmit_TXE+0x30>
 804325a:	2a29      	cmp	r2, #41	; 0x29
 804325c:	d000      	beq.n	8043260 <I2C_SlaveTransmit_TXE+0x32>
}
 804325e:	bd08      	pop	{r3, pc}
      __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_BUF);
 8043260:	6802      	ldr	r2, [r0, #0]
 8043262:	6853      	ldr	r3, [r2, #4]
 8043264:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8043268:	6053      	str	r3, [r2, #4]
      hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_TX;
 804326a:	2321      	movs	r3, #33	; 0x21
 804326c:	6303      	str	r3, [r0, #48]	; 0x30
      hi2c->State = HAL_I2C_STATE_LISTEN;
 804326e:	2328      	movs	r3, #40	; 0x28
 8043270:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
      HAL_I2C_SlaveTxCpltCallback(hi2c);
 8043274:	f7ff ffda 	bl	804322c <HAL_I2C_SlaveTxCpltCallback>
}
 8043278:	e7f1      	b.n	804325e <I2C_SlaveTransmit_TXE+0x30>

0804327a <HAL_I2C_SlaveRxCpltCallback>:
}
 804327a:	4770      	bx	lr

0804327c <I2C_SlaveReceive_RXNE>:
{
 804327c:	b508      	push	{r3, lr}
  HAL_I2C_StateTypeDef CurrentState = hi2c->State;
 804327e:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 8043282:	b2da      	uxtb	r2, r3
  if (hi2c->XferCount != 0U)
 8043284:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 8043286:	b29b      	uxth	r3, r3
 8043288:	b183      	cbz	r3, 80432ac <I2C_SlaveReceive_RXNE+0x30>
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 804328a:	6803      	ldr	r3, [r0, #0]
 804328c:	6919      	ldr	r1, [r3, #16]
 804328e:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8043290:	7019      	strb	r1, [r3, #0]
    hi2c->pBuffPtr++;
 8043292:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8043294:	3301      	adds	r3, #1
 8043296:	6243      	str	r3, [r0, #36]	; 0x24
    hi2c->XferCount--;
 8043298:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 804329a:	b29b      	uxth	r3, r3
 804329c:	3b01      	subs	r3, #1
 804329e:	b29b      	uxth	r3, r3
 80432a0:	8543      	strh	r3, [r0, #42]	; 0x2a
    if ((hi2c->XferCount == 0U) && (CurrentState == HAL_I2C_STATE_BUSY_RX_LISTEN))
 80432a2:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 80432a4:	b29b      	uxth	r3, r3
 80432a6:	b90b      	cbnz	r3, 80432ac <I2C_SlaveReceive_RXNE+0x30>
 80432a8:	2a2a      	cmp	r2, #42	; 0x2a
 80432aa:	d000      	beq.n	80432ae <I2C_SlaveReceive_RXNE+0x32>
}
 80432ac:	bd08      	pop	{r3, pc}
      __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_BUF);
 80432ae:	6802      	ldr	r2, [r0, #0]
 80432b0:	6853      	ldr	r3, [r2, #4]
 80432b2:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 80432b6:	6053      	str	r3, [r2, #4]
      hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_RX;
 80432b8:	2322      	movs	r3, #34	; 0x22
 80432ba:	6303      	str	r3, [r0, #48]	; 0x30
      hi2c->State = HAL_I2C_STATE_LISTEN;
 80432bc:	2328      	movs	r3, #40	; 0x28
 80432be:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
      HAL_I2C_SlaveRxCpltCallback(hi2c);
 80432c2:	f7ff ffda 	bl	804327a <HAL_I2C_SlaveRxCpltCallback>
}
 80432c6:	e7f1      	b.n	80432ac <I2C_SlaveReceive_RXNE+0x30>

080432c8 <HAL_I2C_AddrCallback>:
}
 80432c8:	4770      	bx	lr

080432ca <I2C_Slave_ADDR>:
{
 80432ca:	b508      	push	{r3, lr}
  if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
 80432cc:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 80432d0:	f003 0328 	and.w	r3, r3, #40	; 0x28
 80432d4:	2b28      	cmp	r3, #40	; 0x28
 80432d6:	d007      	beq.n	80432e8 <I2C_Slave_ADDR+0x1e>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
 80432d8:	6803      	ldr	r3, [r0, #0]
 80432da:	f06f 0202 	mvn.w	r2, #2
 80432de:	615a      	str	r2, [r3, #20]
    __HAL_UNLOCK(hi2c);
 80432e0:	2300      	movs	r3, #0
 80432e2:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
}
 80432e6:	bd08      	pop	{r3, pc}
    __HAL_I2C_DISABLE_IT(hi2c, (I2C_IT_BUF));
 80432e8:	6802      	ldr	r2, [r0, #0]
 80432ea:	6853      	ldr	r3, [r2, #4]
 80432ec:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 80432f0:	6053      	str	r3, [r2, #4]
    if (I2C_CHECK_FLAG(IT2Flags, I2C_FLAG_TRA) == RESET)
 80432f2:	f011 0f04 	tst.w	r1, #4
 80432f6:	d00b      	beq.n	8043310 <I2C_Slave_ADDR+0x46>
  uint8_t TransferDirection = I2C_DIRECTION_RECEIVE;
 80432f8:	2300      	movs	r3, #0
    if (I2C_CHECK_FLAG(IT2Flags, I2C_FLAG_DUALF) == RESET)
 80432fa:	f011 0f80 	tst.w	r1, #128	; 0x80
 80432fe:	d109      	bne.n	8043314 <I2C_Slave_ADDR+0x4a>
      SlaveAddrCode = (uint16_t)hi2c->Init.OwnAddress1;
 8043300:	8982      	ldrh	r2, [r0, #12]
    __HAL_UNLOCK(hi2c);
 8043302:	2100      	movs	r1, #0
 8043304:	f880 103c 	strb.w	r1, [r0, #60]	; 0x3c
    HAL_I2C_AddrCallback(hi2c, TransferDirection, SlaveAddrCode);
 8043308:	4619      	mov	r1, r3
 804330a:	f7ff ffdd 	bl	80432c8 <HAL_I2C_AddrCallback>
 804330e:	e7ea      	b.n	80432e6 <I2C_Slave_ADDR+0x1c>
      TransferDirection = I2C_DIRECTION_TRANSMIT;
 8043310:	2301      	movs	r3, #1
 8043312:	e7f2      	b.n	80432fa <I2C_Slave_ADDR+0x30>
      SlaveAddrCode = (uint16_t)hi2c->Init.OwnAddress2;
 8043314:	8b02      	ldrh	r2, [r0, #24]
 8043316:	e7f4      	b.n	8043302 <I2C_Slave_ADDR+0x38>

08043318 <HAL_I2C_ListenCpltCallback>:
}
 8043318:	4770      	bx	lr
	...

0804331c <I2C_Slave_AF>:
{
 804331c:	b508      	push	{r3, lr}
  HAL_I2C_StateTypeDef CurrentState = hi2c->State;
 804331e:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 8043322:	b2db      	uxtb	r3, r3
  uint32_t CurrentXferOptions       = hi2c->XferOptions;
 8043324:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
  if (((CurrentXferOptions ==  I2C_FIRST_AND_LAST_FRAME) || (CurrentXferOptions == I2C_LAST_FRAME)) && \
 8043326:	2a08      	cmp	r2, #8
 8043328:	d001      	beq.n	804332e <I2C_Slave_AF+0x12>
 804332a:	2a20      	cmp	r2, #32
 804332c:	d101      	bne.n	8043332 <I2C_Slave_AF+0x16>
 804332e:	2b28      	cmp	r3, #40	; 0x28
 8043330:	d006      	beq.n	8043340 <I2C_Slave_AF+0x24>
  else if (CurrentState == HAL_I2C_STATE_BUSY_TX)
 8043332:	2b21      	cmp	r3, #33	; 0x21
 8043334:	d01e      	beq.n	8043374 <I2C_Slave_AF+0x58>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8043336:	6803      	ldr	r3, [r0, #0]
 8043338:	f46f 6280 	mvn.w	r2, #1024	; 0x400
 804333c:	615a      	str	r2, [r3, #20]
}
 804333e:	bd08      	pop	{r3, pc}
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
 8043340:	4b1a      	ldr	r3, [pc, #104]	; (80433ac <I2C_Slave_AF+0x90>)
 8043342:	62c3      	str	r3, [r0, #44]	; 0x2c
    __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
 8043344:	6802      	ldr	r2, [r0, #0]
 8043346:	6853      	ldr	r3, [r2, #4]
 8043348:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 804334c:	6053      	str	r3, [r2, #4]
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 804334e:	6803      	ldr	r3, [r0, #0]
 8043350:	f46f 6280 	mvn.w	r2, #1024	; 0x400
 8043354:	615a      	str	r2, [r3, #20]
    CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 8043356:	6802      	ldr	r2, [r0, #0]
 8043358:	6813      	ldr	r3, [r2, #0]
 804335a:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 804335e:	6013      	str	r3, [r2, #0]
    hi2c->PreviousState = I2C_STATE_NONE;
 8043360:	2300      	movs	r3, #0
 8043362:	6303      	str	r3, [r0, #48]	; 0x30
    hi2c->State         = HAL_I2C_STATE_READY;
 8043364:	2220      	movs	r2, #32
 8043366:	f880 203d 	strb.w	r2, [r0, #61]	; 0x3d
    hi2c->Mode          = HAL_I2C_MODE_NONE;
 804336a:	f880 303e 	strb.w	r3, [r0, #62]	; 0x3e
    HAL_I2C_ListenCpltCallback(hi2c);
 804336e:	f7ff ffd3 	bl	8043318 <HAL_I2C_ListenCpltCallback>
 8043372:	e7e4      	b.n	804333e <I2C_Slave_AF+0x22>
    hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
 8043374:	4b0d      	ldr	r3, [pc, #52]	; (80433ac <I2C_Slave_AF+0x90>)
 8043376:	62c3      	str	r3, [r0, #44]	; 0x2c
    hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_TX;
 8043378:	2321      	movs	r3, #33	; 0x21
 804337a:	6303      	str	r3, [r0, #48]	; 0x30
    hi2c->State         = HAL_I2C_STATE_READY;
 804337c:	2320      	movs	r3, #32
 804337e:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
    hi2c->Mode          = HAL_I2C_MODE_NONE;
 8043382:	2300      	movs	r3, #0
 8043384:	f880 303e 	strb.w	r3, [r0, #62]	; 0x3e
    __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
 8043388:	6802      	ldr	r2, [r0, #0]
 804338a:	6853      	ldr	r3, [r2, #4]
 804338c:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 8043390:	6053      	str	r3, [r2, #4]
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8043392:	6803      	ldr	r3, [r0, #0]
 8043394:	f46f 6280 	mvn.w	r2, #1024	; 0x400
 8043398:	615a      	str	r2, [r3, #20]
    CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 804339a:	6802      	ldr	r2, [r0, #0]
 804339c:	6813      	ldr	r3, [r2, #0]
 804339e:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 80433a2:	6013      	str	r3, [r2, #0]
    HAL_I2C_SlaveTxCpltCallback(hi2c);
 80433a4:	f7ff ff42 	bl	804322c <HAL_I2C_SlaveTxCpltCallback>
 80433a8:	e7c9      	b.n	804333e <I2C_Slave_AF+0x22>
 80433aa:	bf00      	nop
 80433ac:	ffff0000 	.word	0xffff0000

080433b0 <I2C_MasterTransmit_TXE>:
{
 80433b0:	b510      	push	{r4, lr}
  HAL_I2C_StateTypeDef CurrentState = hi2c->State;
 80433b2:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 80433b6:	b2db      	uxtb	r3, r3
  HAL_I2C_ModeTypeDef CurrentMode   = hi2c->Mode;
 80433b8:	f890 203e 	ldrb.w	r2, [r0, #62]	; 0x3e
 80433bc:	b2d2      	uxtb	r2, r2
  uint32_t CurrentXferOptions       = hi2c->XferOptions;
 80433be:	6ac4      	ldr	r4, [r0, #44]	; 0x2c
  if ((hi2c->XferSize == 0U) && (CurrentState == HAL_I2C_STATE_BUSY_TX))
 80433c0:	8d01      	ldrh	r1, [r0, #40]	; 0x28
 80433c2:	b909      	cbnz	r1, 80433c8 <I2C_MasterTransmit_TXE+0x18>
 80433c4:	2b21      	cmp	r3, #33	; 0x21
 80433c6:	d004      	beq.n	80433d2 <I2C_MasterTransmit_TXE+0x22>
  else if ((CurrentState == HAL_I2C_STATE_BUSY_TX) || \
 80433c8:	2b21      	cmp	r3, #33	; 0x21
 80433ca:	d03b      	beq.n	8043444 <I2C_MasterTransmit_TXE+0x94>
 80433cc:	2a40      	cmp	r2, #64	; 0x40
 80433ce:	d037      	beq.n	8043440 <I2C_MasterTransmit_TXE+0x90>
}
 80433d0:	bd10      	pop	{r4, pc}
    if ((CurrentXferOptions != I2C_FIRST_AND_LAST_FRAME) && (CurrentXferOptions != I2C_LAST_FRAME) && (CurrentXferOptions != I2C_NO_OPTION_FRAME))
 80433d2:	2c08      	cmp	r4, #8
 80433d4:	d004      	beq.n	80433e0 <I2C_MasterTransmit_TXE+0x30>
 80433d6:	2c20      	cmp	r4, #32
 80433d8:	d002      	beq.n	80433e0 <I2C_MasterTransmit_TXE+0x30>
 80433da:	f514 3f80 	cmn.w	r4, #65536	; 0x10000
 80433de:	d119      	bne.n	8043414 <I2C_MasterTransmit_TXE+0x64>
      __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
 80433e0:	6802      	ldr	r2, [r0, #0]
 80433e2:	6853      	ldr	r3, [r2, #4]
 80433e4:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 80433e8:	6053      	str	r3, [r2, #4]
      SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
 80433ea:	6802      	ldr	r2, [r0, #0]
 80433ec:	6813      	ldr	r3, [r2, #0]
 80433ee:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 80433f2:	6013      	str	r3, [r2, #0]
      hi2c->PreviousState = I2C_STATE_NONE;
 80433f4:	2300      	movs	r3, #0
 80433f6:	6303      	str	r3, [r0, #48]	; 0x30
      hi2c->State = HAL_I2C_STATE_READY;
 80433f8:	2320      	movs	r3, #32
 80433fa:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
      if (hi2c->Mode == HAL_I2C_MODE_MEM)
 80433fe:	f890 303e 	ldrb.w	r3, [r0, #62]	; 0x3e
 8043402:	b2db      	uxtb	r3, r3
 8043404:	2b40      	cmp	r3, #64	; 0x40
 8043406:	d015      	beq.n	8043434 <I2C_MasterTransmit_TXE+0x84>
        hi2c->Mode = HAL_I2C_MODE_NONE;
 8043408:	2300      	movs	r3, #0
 804340a:	f880 303e 	strb.w	r3, [r0, #62]	; 0x3e
        HAL_I2C_MasterTxCpltCallback(hi2c);
 804340e:	f7ff ff0b 	bl	8043228 <HAL_I2C_MasterTxCpltCallback>
 8043412:	e7dd      	b.n	80433d0 <I2C_MasterTransmit_TXE+0x20>
      __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
 8043414:	6802      	ldr	r2, [r0, #0]
 8043416:	6853      	ldr	r3, [r2, #4]
 8043418:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 804341c:	6053      	str	r3, [r2, #4]
      hi2c->PreviousState = I2C_STATE_MASTER_BUSY_TX;
 804341e:	2311      	movs	r3, #17
 8043420:	6303      	str	r3, [r0, #48]	; 0x30
      hi2c->Mode = HAL_I2C_MODE_NONE;
 8043422:	2300      	movs	r3, #0
 8043424:	f880 303e 	strb.w	r3, [r0, #62]	; 0x3e
      hi2c->State = HAL_I2C_STATE_READY;
 8043428:	2320      	movs	r3, #32
 804342a:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
      HAL_I2C_MasterTxCpltCallback(hi2c);
 804342e:	f7ff fefb 	bl	8043228 <HAL_I2C_MasterTxCpltCallback>
 8043432:	e7cd      	b.n	80433d0 <I2C_MasterTransmit_TXE+0x20>
        hi2c->Mode = HAL_I2C_MODE_NONE;
 8043434:	2300      	movs	r3, #0
 8043436:	f880 303e 	strb.w	r3, [r0, #62]	; 0x3e
        HAL_I2C_MemTxCpltCallback(hi2c);
 804343a:	f00d fc6d 	bl	8050d18 <HAL_I2C_MemTxCpltCallback>
 804343e:	e7c7      	b.n	80433d0 <I2C_MasterTransmit_TXE+0x20>
           ((CurrentMode == HAL_I2C_MODE_MEM) && (CurrentState == HAL_I2C_STATE_BUSY_RX)))
 8043440:	2b22      	cmp	r3, #34	; 0x22
 8043442:	d1c5      	bne.n	80433d0 <I2C_MasterTransmit_TXE+0x20>
    if (hi2c->XferCount == 0U)
 8043444:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 8043446:	b29b      	uxth	r3, r3
 8043448:	b92b      	cbnz	r3, 8043456 <I2C_MasterTransmit_TXE+0xa6>
      __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_BUF);
 804344a:	6802      	ldr	r2, [r0, #0]
 804344c:	6853      	ldr	r3, [r2, #4]
 804344e:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8043452:	6053      	str	r3, [r2, #4]
 8043454:	e7bc      	b.n	80433d0 <I2C_MasterTransmit_TXE+0x20>
      if (hi2c->Mode == HAL_I2C_MODE_MEM)
 8043456:	f890 303e 	ldrb.w	r3, [r0, #62]	; 0x3e
 804345a:	b2db      	uxtb	r3, r3
 804345c:	2b40      	cmp	r3, #64	; 0x40
 804345e:	d00c      	beq.n	804347a <I2C_MasterTransmit_TXE+0xca>
        hi2c->Instance->DR = *hi2c->pBuffPtr;
 8043460:	6a42      	ldr	r2, [r0, #36]	; 0x24
 8043462:	6803      	ldr	r3, [r0, #0]
 8043464:	7812      	ldrb	r2, [r2, #0]
 8043466:	611a      	str	r2, [r3, #16]
        hi2c->pBuffPtr++;
 8043468:	6a43      	ldr	r3, [r0, #36]	; 0x24
 804346a:	3301      	adds	r3, #1
 804346c:	6243      	str	r3, [r0, #36]	; 0x24
        hi2c->XferCount--;
 804346e:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 8043470:	b29b      	uxth	r3, r3
 8043472:	3b01      	subs	r3, #1
 8043474:	b29b      	uxth	r3, r3
 8043476:	8543      	strh	r3, [r0, #42]	; 0x2a
}
 8043478:	e7aa      	b.n	80433d0 <I2C_MasterTransmit_TXE+0x20>
        if (hi2c->EventCount == 0U)
 804347a:	6d03      	ldr	r3, [r0, #80]	; 0x50
 804347c:	b99b      	cbnz	r3, 80434a6 <I2C_MasterTransmit_TXE+0xf6>
          if (hi2c->MemaddSize == I2C_MEMADD_SIZE_8BIT)
 804347e:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
 8043480:	2b01      	cmp	r3, #1
 8043482:	d008      	beq.n	8043496 <I2C_MasterTransmit_TXE+0xe6>
            hi2c->Instance->DR = I2C_MEM_ADD_MSB(hi2c->Memaddress);
 8043484:	6c83      	ldr	r3, [r0, #72]	; 0x48
 8043486:	f3c3 2307 	ubfx	r3, r3, #8, #8
 804348a:	6802      	ldr	r2, [r0, #0]
 804348c:	6113      	str	r3, [r2, #16]
            hi2c->EventCount++;
 804348e:	6d03      	ldr	r3, [r0, #80]	; 0x50
 8043490:	3301      	adds	r3, #1
 8043492:	6503      	str	r3, [r0, #80]	; 0x50
 8043494:	e79c      	b.n	80433d0 <I2C_MasterTransmit_TXE+0x20>
            hi2c->Instance->DR = I2C_MEM_ADD_LSB(hi2c->Memaddress);
 8043496:	6c83      	ldr	r3, [r0, #72]	; 0x48
 8043498:	6802      	ldr	r2, [r0, #0]
 804349a:	b2db      	uxtb	r3, r3
 804349c:	6113      	str	r3, [r2, #16]
            hi2c->EventCount += 2U;
 804349e:	6d03      	ldr	r3, [r0, #80]	; 0x50
 80434a0:	3302      	adds	r3, #2
 80434a2:	6503      	str	r3, [r0, #80]	; 0x50
 80434a4:	e794      	b.n	80433d0 <I2C_MasterTransmit_TXE+0x20>
        else if (hi2c->EventCount == 1U)
 80434a6:	6d03      	ldr	r3, [r0, #80]	; 0x50
 80434a8:	2b01      	cmp	r3, #1
 80434aa:	d019      	beq.n	80434e0 <I2C_MasterTransmit_TXE+0x130>
        else if (hi2c->EventCount == 2U)
 80434ac:	6d03      	ldr	r3, [r0, #80]	; 0x50
 80434ae:	2b02      	cmp	r3, #2
 80434b0:	d18e      	bne.n	80433d0 <I2C_MasterTransmit_TXE+0x20>
          if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
 80434b2:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 80434b6:	b2db      	uxtb	r3, r3
 80434b8:	2b22      	cmp	r3, #34	; 0x22
 80434ba:	d019      	beq.n	80434f0 <I2C_MasterTransmit_TXE+0x140>
          else if (hi2c->State == HAL_I2C_STATE_BUSY_TX)
 80434bc:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 80434c0:	b2db      	uxtb	r3, r3
 80434c2:	2b21      	cmp	r3, #33	; 0x21
 80434c4:	d184      	bne.n	80433d0 <I2C_MasterTransmit_TXE+0x20>
            hi2c->Instance->DR = *hi2c->pBuffPtr;
 80434c6:	6a42      	ldr	r2, [r0, #36]	; 0x24
 80434c8:	6803      	ldr	r3, [r0, #0]
 80434ca:	7812      	ldrb	r2, [r2, #0]
 80434cc:	611a      	str	r2, [r3, #16]
            hi2c->pBuffPtr++;
 80434ce:	6a43      	ldr	r3, [r0, #36]	; 0x24
 80434d0:	3301      	adds	r3, #1
 80434d2:	6243      	str	r3, [r0, #36]	; 0x24
            hi2c->XferCount--;
 80434d4:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 80434d6:	b29b      	uxth	r3, r3
 80434d8:	3b01      	subs	r3, #1
 80434da:	b29b      	uxth	r3, r3
 80434dc:	8543      	strh	r3, [r0, #42]	; 0x2a
 80434de:	e777      	b.n	80433d0 <I2C_MasterTransmit_TXE+0x20>
          hi2c->Instance->DR = I2C_MEM_ADD_LSB(hi2c->Memaddress);
 80434e0:	6c83      	ldr	r3, [r0, #72]	; 0x48
 80434e2:	6802      	ldr	r2, [r0, #0]
 80434e4:	b2db      	uxtb	r3, r3
 80434e6:	6113      	str	r3, [r2, #16]
          hi2c->EventCount++;
 80434e8:	6d03      	ldr	r3, [r0, #80]	; 0x50
 80434ea:	3301      	adds	r3, #1
 80434ec:	6503      	str	r3, [r0, #80]	; 0x50
 80434ee:	e76f      	b.n	80433d0 <I2C_MasterTransmit_TXE+0x20>
            hi2c->Instance->CR1 |= I2C_CR1_START;
 80434f0:	6802      	ldr	r2, [r0, #0]
 80434f2:	6813      	ldr	r3, [r2, #0]
 80434f4:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80434f8:	6013      	str	r3, [r2, #0]
 80434fa:	e769      	b.n	80433d0 <I2C_MasterTransmit_TXE+0x20>

080434fc <I2C_MasterTransmit_BTF>:
{
 80434fc:	b508      	push	{r3, lr}
  uint32_t CurrentXferOptions = hi2c->XferOptions;
 80434fe:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
  if (hi2c->State == HAL_I2C_STATE_BUSY_TX)
 8043500:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 8043504:	b2db      	uxtb	r3, r3
 8043506:	2b21      	cmp	r3, #33	; 0x21
 8043508:	d000      	beq.n	804350c <I2C_MasterTransmit_BTF+0x10>
}
 804350a:	bd08      	pop	{r3, pc}
    if (hi2c->XferCount != 0U)
 804350c:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 804350e:	b29b      	uxth	r3, r3
 8043510:	b163      	cbz	r3, 804352c <I2C_MasterTransmit_BTF+0x30>
      hi2c->Instance->DR = *hi2c->pBuffPtr;
 8043512:	6a42      	ldr	r2, [r0, #36]	; 0x24
 8043514:	6803      	ldr	r3, [r0, #0]
 8043516:	7812      	ldrb	r2, [r2, #0]
 8043518:	611a      	str	r2, [r3, #16]
      hi2c->pBuffPtr++;
 804351a:	6a43      	ldr	r3, [r0, #36]	; 0x24
 804351c:	3301      	adds	r3, #1
 804351e:	6243      	str	r3, [r0, #36]	; 0x24
      hi2c->XferCount--;
 8043520:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 8043522:	b29b      	uxth	r3, r3
 8043524:	3b01      	subs	r3, #1
 8043526:	b29b      	uxth	r3, r3
 8043528:	8543      	strh	r3, [r0, #42]	; 0x2a
 804352a:	e7ee      	b.n	804350a <I2C_MasterTransmit_BTF+0xe>
      if ((CurrentXferOptions != I2C_FIRST_AND_LAST_FRAME) && (CurrentXferOptions != I2C_LAST_FRAME) && (CurrentXferOptions != I2C_NO_OPTION_FRAME))
 804352c:	2a08      	cmp	r2, #8
 804352e:	d004      	beq.n	804353a <I2C_MasterTransmit_BTF+0x3e>
 8043530:	2a20      	cmp	r2, #32
 8043532:	d002      	beq.n	804353a <I2C_MasterTransmit_BTF+0x3e>
 8043534:	f512 3f80 	cmn.w	r2, #65536	; 0x10000
 8043538:	d119      	bne.n	804356e <I2C_MasterTransmit_BTF+0x72>
        __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
 804353a:	6802      	ldr	r2, [r0, #0]
 804353c:	6853      	ldr	r3, [r2, #4]
 804353e:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 8043542:	6053      	str	r3, [r2, #4]
        SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
 8043544:	6802      	ldr	r2, [r0, #0]
 8043546:	6813      	ldr	r3, [r2, #0]
 8043548:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 804354c:	6013      	str	r3, [r2, #0]
        hi2c->PreviousState = I2C_STATE_NONE;
 804354e:	2300      	movs	r3, #0
 8043550:	6303      	str	r3, [r0, #48]	; 0x30
        hi2c->State = HAL_I2C_STATE_READY;
 8043552:	2320      	movs	r3, #32
 8043554:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
        if (hi2c->Mode == HAL_I2C_MODE_MEM)
 8043558:	f890 303e 	ldrb.w	r3, [r0, #62]	; 0x3e
 804355c:	b2db      	uxtb	r3, r3
 804355e:	2b40      	cmp	r3, #64	; 0x40
 8043560:	d015      	beq.n	804358e <I2C_MasterTransmit_BTF+0x92>
          hi2c->Mode = HAL_I2C_MODE_NONE;
 8043562:	2300      	movs	r3, #0
 8043564:	f880 303e 	strb.w	r3, [r0, #62]	; 0x3e
          HAL_I2C_MasterTxCpltCallback(hi2c);
 8043568:	f7ff fe5e 	bl	8043228 <HAL_I2C_MasterTxCpltCallback>
}
 804356c:	e7cd      	b.n	804350a <I2C_MasterTransmit_BTF+0xe>
        __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
 804356e:	6802      	ldr	r2, [r0, #0]
 8043570:	6853      	ldr	r3, [r2, #4]
 8043572:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 8043576:	6053      	str	r3, [r2, #4]
        hi2c->PreviousState = I2C_STATE_MASTER_BUSY_TX;
 8043578:	2311      	movs	r3, #17
 804357a:	6303      	str	r3, [r0, #48]	; 0x30
        hi2c->Mode = HAL_I2C_MODE_NONE;
 804357c:	2300      	movs	r3, #0
 804357e:	f880 303e 	strb.w	r3, [r0, #62]	; 0x3e
        hi2c->State = HAL_I2C_STATE_READY;
 8043582:	2320      	movs	r3, #32
 8043584:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
        HAL_I2C_MasterTxCpltCallback(hi2c);
 8043588:	f7ff fe4e 	bl	8043228 <HAL_I2C_MasterTxCpltCallback>
 804358c:	e7bd      	b.n	804350a <I2C_MasterTransmit_BTF+0xe>
          hi2c->Mode = HAL_I2C_MODE_NONE;
 804358e:	2300      	movs	r3, #0
 8043590:	f880 303e 	strb.w	r3, [r0, #62]	; 0x3e
          HAL_I2C_MemTxCpltCallback(hi2c);
 8043594:	f00d fbc0 	bl	8050d18 <HAL_I2C_MemTxCpltCallback>
 8043598:	e7b7      	b.n	804350a <I2C_MasterTransmit_BTF+0xe>

0804359a <I2C_MasterReceive_RXNE>:
{
 804359a:	b508      	push	{r3, lr}
  if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
 804359c:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 80435a0:	b2db      	uxtb	r3, r3
 80435a2:	2b22      	cmp	r3, #34	; 0x22
 80435a4:	d000      	beq.n	80435a8 <I2C_MasterReceive_RXNE+0xe>
}
 80435a6:	bd08      	pop	{r3, pc}
    tmp = hi2c->XferCount;
 80435a8:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 80435aa:	b29b      	uxth	r3, r3
    if (tmp > 3U)
 80435ac:	2b03      	cmp	r3, #3
 80435ae:	d915      	bls.n	80435dc <I2C_MasterReceive_RXNE+0x42>
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 80435b0:	6803      	ldr	r3, [r0, #0]
 80435b2:	691a      	ldr	r2, [r3, #16]
 80435b4:	6a43      	ldr	r3, [r0, #36]	; 0x24
 80435b6:	701a      	strb	r2, [r3, #0]
      hi2c->pBuffPtr++;
 80435b8:	6a43      	ldr	r3, [r0, #36]	; 0x24
 80435ba:	3301      	adds	r3, #1
 80435bc:	6243      	str	r3, [r0, #36]	; 0x24
      hi2c->XferCount--;
 80435be:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 80435c0:	b29b      	uxth	r3, r3
 80435c2:	3b01      	subs	r3, #1
 80435c4:	b29b      	uxth	r3, r3
 80435c6:	8543      	strh	r3, [r0, #42]	; 0x2a
      if (hi2c->XferCount == (uint16_t)3)
 80435c8:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 80435ca:	b29b      	uxth	r3, r3
 80435cc:	2b03      	cmp	r3, #3
 80435ce:	d1ea      	bne.n	80435a6 <I2C_MasterReceive_RXNE+0xc>
        __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_BUF);
 80435d0:	6802      	ldr	r2, [r0, #0]
 80435d2:	6853      	ldr	r3, [r2, #4]
 80435d4:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 80435d8:	6053      	str	r3, [r2, #4]
 80435da:	e7e4      	b.n	80435a6 <I2C_MasterReceive_RXNE+0xc>
    else if ((hi2c->XferOptions != I2C_FIRST_AND_NEXT_FRAME) && ((tmp == 1U) || (tmp == 0U)))
 80435dc:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
 80435de:	2a02      	cmp	r2, #2
 80435e0:	d0e1      	beq.n	80435a6 <I2C_MasterReceive_RXNE+0xc>
 80435e2:	2b01      	cmp	r3, #1
 80435e4:	d8df      	bhi.n	80435a6 <I2C_MasterReceive_RXNE+0xc>
      CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 80435e6:	6802      	ldr	r2, [r0, #0]
 80435e8:	6813      	ldr	r3, [r2, #0]
 80435ea:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 80435ee:	6013      	str	r3, [r2, #0]
      __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
 80435f0:	6802      	ldr	r2, [r0, #0]
 80435f2:	6853      	ldr	r3, [r2, #4]
 80435f4:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 80435f8:	6053      	str	r3, [r2, #4]
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 80435fa:	6803      	ldr	r3, [r0, #0]
 80435fc:	691a      	ldr	r2, [r3, #16]
 80435fe:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8043600:	701a      	strb	r2, [r3, #0]
      hi2c->pBuffPtr++;
 8043602:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8043604:	3301      	adds	r3, #1
 8043606:	6243      	str	r3, [r0, #36]	; 0x24
      hi2c->XferCount--;
 8043608:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 804360a:	b29b      	uxth	r3, r3
 804360c:	3b01      	subs	r3, #1
 804360e:	b29b      	uxth	r3, r3
 8043610:	8543      	strh	r3, [r0, #42]	; 0x2a
      hi2c->State = HAL_I2C_STATE_READY;
 8043612:	2320      	movs	r3, #32
 8043614:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
      if (hi2c->Mode == HAL_I2C_MODE_MEM)
 8043618:	f890 303e 	ldrb.w	r3, [r0, #62]	; 0x3e
 804361c:	b2db      	uxtb	r3, r3
 804361e:	2b40      	cmp	r3, #64	; 0x40
 8043620:	d007      	beq.n	8043632 <I2C_MasterReceive_RXNE+0x98>
        hi2c->Mode = HAL_I2C_MODE_NONE;
 8043622:	2300      	movs	r3, #0
 8043624:	f880 303e 	strb.w	r3, [r0, #62]	; 0x3e
        hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
 8043628:	2312      	movs	r3, #18
 804362a:	6303      	str	r3, [r0, #48]	; 0x30
        HAL_I2C_MasterRxCpltCallback(hi2c);
 804362c:	f7ff fdfd 	bl	804322a <HAL_I2C_MasterRxCpltCallback>
}
 8043630:	e7b9      	b.n	80435a6 <I2C_MasterReceive_RXNE+0xc>
        hi2c->Mode = HAL_I2C_MODE_NONE;
 8043632:	2300      	movs	r3, #0
 8043634:	f880 303e 	strb.w	r3, [r0, #62]	; 0x3e
        hi2c->PreviousState = I2C_STATE_NONE;
 8043638:	6303      	str	r3, [r0, #48]	; 0x30
        HAL_I2C_MemRxCpltCallback(hi2c);
 804363a:	f00d fb23 	bl	8050c84 <HAL_I2C_MemRxCpltCallback>
 804363e:	e7b2      	b.n	80435a6 <I2C_MasterReceive_RXNE+0xc>

08043640 <I2C_MasterReceive_BTF>:
{
 8043640:	b508      	push	{r3, lr}
  uint32_t CurrentXferOptions = hi2c->XferOptions;
 8043642:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
  if (hi2c->XferCount == 4U)
 8043644:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 8043646:	b29b      	uxth	r3, r3
 8043648:	2b04      	cmp	r3, #4
 804364a:	d014      	beq.n	8043676 <I2C_MasterReceive_BTF+0x36>
  else if (hi2c->XferCount == 3U)
 804364c:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 804364e:	b29b      	uxth	r3, r3
 8043650:	2b03      	cmp	r3, #3
 8043652:	d022      	beq.n	804369a <I2C_MasterReceive_BTF+0x5a>
  else if (hi2c->XferCount == 2U)
 8043654:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 8043656:	b29b      	uxth	r3, r3
 8043658:	2b02      	cmp	r3, #2
 804365a:	d039      	beq.n	80436d0 <I2C_MasterReceive_BTF+0x90>
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 804365c:	6803      	ldr	r3, [r0, #0]
 804365e:	691a      	ldr	r2, [r3, #16]
 8043660:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8043662:	701a      	strb	r2, [r3, #0]
    hi2c->pBuffPtr++;
 8043664:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8043666:	3301      	adds	r3, #1
 8043668:	6243      	str	r3, [r0, #36]	; 0x24
    hi2c->XferCount--;
 804366a:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 804366c:	b29b      	uxth	r3, r3
 804366e:	3b01      	subs	r3, #1
 8043670:	b29b      	uxth	r3, r3
 8043672:	8543      	strh	r3, [r0, #42]	; 0x2a
}
 8043674:	e010      	b.n	8043698 <I2C_MasterReceive_BTF+0x58>
    __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_BUF);
 8043676:	6802      	ldr	r2, [r0, #0]
 8043678:	6853      	ldr	r3, [r2, #4]
 804367a:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 804367e:	6053      	str	r3, [r2, #4]
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 8043680:	6803      	ldr	r3, [r0, #0]
 8043682:	691a      	ldr	r2, [r3, #16]
 8043684:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8043686:	701a      	strb	r2, [r3, #0]
    hi2c->pBuffPtr++;
 8043688:	6a43      	ldr	r3, [r0, #36]	; 0x24
 804368a:	3301      	adds	r3, #1
 804368c:	6243      	str	r3, [r0, #36]	; 0x24
    hi2c->XferCount--;
 804368e:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 8043690:	b29b      	uxth	r3, r3
 8043692:	3b01      	subs	r3, #1
 8043694:	b29b      	uxth	r3, r3
 8043696:	8543      	strh	r3, [r0, #42]	; 0x2a
}
 8043698:	bd08      	pop	{r3, pc}
    __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_BUF);
 804369a:	6801      	ldr	r1, [r0, #0]
 804369c:	684b      	ldr	r3, [r1, #4]
 804369e:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 80436a2:	604b      	str	r3, [r1, #4]
    if ((CurrentXferOptions != I2C_NEXT_FRAME) && (CurrentXferOptions != I2C_FIRST_AND_NEXT_FRAME))
 80436a4:	2a04      	cmp	r2, #4
 80436a6:	d006      	beq.n	80436b6 <I2C_MasterReceive_BTF+0x76>
 80436a8:	2a02      	cmp	r2, #2
 80436aa:	d004      	beq.n	80436b6 <I2C_MasterReceive_BTF+0x76>
      CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 80436ac:	6802      	ldr	r2, [r0, #0]
 80436ae:	6813      	ldr	r3, [r2, #0]
 80436b0:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 80436b4:	6013      	str	r3, [r2, #0]
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 80436b6:	6803      	ldr	r3, [r0, #0]
 80436b8:	691a      	ldr	r2, [r3, #16]
 80436ba:	6a43      	ldr	r3, [r0, #36]	; 0x24
 80436bc:	701a      	strb	r2, [r3, #0]
    hi2c->pBuffPtr++;
 80436be:	6a43      	ldr	r3, [r0, #36]	; 0x24
 80436c0:	3301      	adds	r3, #1
 80436c2:	6243      	str	r3, [r0, #36]	; 0x24
    hi2c->XferCount--;
 80436c4:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 80436c6:	b29b      	uxth	r3, r3
 80436c8:	3b01      	subs	r3, #1
 80436ca:	b29b      	uxth	r3, r3
 80436cc:	8543      	strh	r3, [r0, #42]	; 0x2a
 80436ce:	e7e3      	b.n	8043698 <I2C_MasterReceive_BTF+0x58>
    if ((CurrentXferOptions == I2C_FIRST_FRAME) || (CurrentXferOptions == I2C_LAST_FRAME_NO_STOP))
 80436d0:	2a01      	cmp	r2, #1
 80436d2:	d00b      	beq.n	80436ec <I2C_MasterReceive_BTF+0xac>
 80436d4:	2a10      	cmp	r2, #16
 80436d6:	d009      	beq.n	80436ec <I2C_MasterReceive_BTF+0xac>
    else if ((CurrentXferOptions == I2C_NEXT_FRAME) || (CurrentXferOptions == I2C_FIRST_AND_NEXT_FRAME))
 80436d8:	2a04      	cmp	r2, #4
 80436da:	d038      	beq.n	804374e <I2C_MasterReceive_BTF+0x10e>
 80436dc:	2a02      	cmp	r2, #2
 80436de:	d036      	beq.n	804374e <I2C_MasterReceive_BTF+0x10e>
      SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
 80436e0:	6802      	ldr	r2, [r0, #0]
 80436e2:	6813      	ldr	r3, [r2, #0]
 80436e4:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 80436e8:	6013      	str	r3, [r2, #0]
 80436ea:	e004      	b.n	80436f6 <I2C_MasterReceive_BTF+0xb6>
      CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 80436ec:	6802      	ldr	r2, [r0, #0]
 80436ee:	6813      	ldr	r3, [r2, #0]
 80436f0:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 80436f4:	6013      	str	r3, [r2, #0]
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 80436f6:	6803      	ldr	r3, [r0, #0]
 80436f8:	691a      	ldr	r2, [r3, #16]
 80436fa:	6a43      	ldr	r3, [r0, #36]	; 0x24
 80436fc:	701a      	strb	r2, [r3, #0]
    hi2c->pBuffPtr++;
 80436fe:	6a42      	ldr	r2, [r0, #36]	; 0x24
 8043700:	1c53      	adds	r3, r2, #1
 8043702:	6243      	str	r3, [r0, #36]	; 0x24
    hi2c->XferCount--;
 8043704:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 8043706:	b29b      	uxth	r3, r3
 8043708:	3b01      	subs	r3, #1
 804370a:	b29b      	uxth	r3, r3
 804370c:	8543      	strh	r3, [r0, #42]	; 0x2a
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 804370e:	6803      	ldr	r3, [r0, #0]
 8043710:	691b      	ldr	r3, [r3, #16]
 8043712:	7053      	strb	r3, [r2, #1]
    hi2c->pBuffPtr++;
 8043714:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8043716:	3301      	adds	r3, #1
 8043718:	6243      	str	r3, [r0, #36]	; 0x24
    hi2c->XferCount--;
 804371a:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 804371c:	b29b      	uxth	r3, r3
 804371e:	3b01      	subs	r3, #1
 8043720:	b29b      	uxth	r3, r3
 8043722:	8543      	strh	r3, [r0, #42]	; 0x2a
    __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_ERR);
 8043724:	6802      	ldr	r2, [r0, #0]
 8043726:	6853      	ldr	r3, [r2, #4]
 8043728:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 804372c:	6053      	str	r3, [r2, #4]
    hi2c->State = HAL_I2C_STATE_READY;
 804372e:	2320      	movs	r3, #32
 8043730:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
    if (hi2c->Mode == HAL_I2C_MODE_MEM)
 8043734:	f890 303e 	ldrb.w	r3, [r0, #62]	; 0x3e
 8043738:	b2db      	uxtb	r3, r3
 804373a:	2b40      	cmp	r3, #64	; 0x40
 804373c:	d00d      	beq.n	804375a <I2C_MasterReceive_BTF+0x11a>
      hi2c->Mode = HAL_I2C_MODE_NONE;
 804373e:	2300      	movs	r3, #0
 8043740:	f880 303e 	strb.w	r3, [r0, #62]	; 0x3e
      hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
 8043744:	2312      	movs	r3, #18
 8043746:	6303      	str	r3, [r0, #48]	; 0x30
      HAL_I2C_MasterRxCpltCallback(hi2c);
 8043748:	f7ff fd6f 	bl	804322a <HAL_I2C_MasterRxCpltCallback>
 804374c:	e7a4      	b.n	8043698 <I2C_MasterReceive_BTF+0x58>
      SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 804374e:	6802      	ldr	r2, [r0, #0]
 8043750:	6813      	ldr	r3, [r2, #0]
 8043752:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8043756:	6013      	str	r3, [r2, #0]
 8043758:	e7cd      	b.n	80436f6 <I2C_MasterReceive_BTF+0xb6>
      hi2c->Mode = HAL_I2C_MODE_NONE;
 804375a:	2300      	movs	r3, #0
 804375c:	f880 303e 	strb.w	r3, [r0, #62]	; 0x3e
      hi2c->PreviousState = I2C_STATE_NONE;
 8043760:	6303      	str	r3, [r0, #48]	; 0x30
      HAL_I2C_MemRxCpltCallback(hi2c);
 8043762:	f00d fa8f 	bl	8050c84 <HAL_I2C_MemRxCpltCallback>
 8043766:	e797      	b.n	8043698 <I2C_MasterReceive_BTF+0x58>

08043768 <HAL_I2C_AbortCpltCallback>:
}
 8043768:	4770      	bx	lr

0804376a <I2C_DMAAbort>:
{
 804376a:	b510      	push	{r4, lr}
  I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent; /* Derogation MISRAC2012-Rule-11.5 */
 804376c:	6b80      	ldr	r0, [r0, #56]	; 0x38
  HAL_I2C_StateTypeDef CurrentState = hi2c->State;
 804376e:	f890 203d 	ldrb.w	r2, [r0, #61]	; 0x3d
  hi2c->hdmatx->XferCpltCallback = NULL;
 8043772:	6b41      	ldr	r1, [r0, #52]	; 0x34
 8043774:	2300      	movs	r3, #0
 8043776:	63cb      	str	r3, [r1, #60]	; 0x3c
  hi2c->hdmarx->XferCpltCallback = NULL;
 8043778:	6b81      	ldr	r1, [r0, #56]	; 0x38
 804377a:	63cb      	str	r3, [r1, #60]	; 0x3c
  CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 804377c:	6804      	ldr	r4, [r0, #0]
 804377e:	6821      	ldr	r1, [r4, #0]
 8043780:	f421 6180 	bic.w	r1, r1, #1024	; 0x400
 8043784:	6021      	str	r1, [r4, #0]
  hi2c->XferCount = 0U;
 8043786:	8543      	strh	r3, [r0, #42]	; 0x2a
  hi2c->hdmatx->XferAbortCallback = NULL;
 8043788:	6b41      	ldr	r1, [r0, #52]	; 0x34
 804378a:	650b      	str	r3, [r1, #80]	; 0x50
  hi2c->hdmarx->XferAbortCallback = NULL;
 804378c:	6b81      	ldr	r1, [r0, #56]	; 0x38
 804378e:	650b      	str	r3, [r1, #80]	; 0x50
  __HAL_I2C_DISABLE(hi2c);
 8043790:	6801      	ldr	r1, [r0, #0]
 8043792:	680b      	ldr	r3, [r1, #0]
 8043794:	f023 0301 	bic.w	r3, r3, #1
 8043798:	600b      	str	r3, [r1, #0]
  if (hi2c->State == HAL_I2C_STATE_ABORT)
 804379a:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 804379e:	b2db      	uxtb	r3, r3
 80437a0:	2b60      	cmp	r3, #96	; 0x60
 80437a2:	d00d      	beq.n	80437c0 <I2C_DMAAbort+0x56>
 80437a4:	b2d2      	uxtb	r2, r2
    if (((uint32_t)CurrentState & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
 80437a6:	f002 0228 	and.w	r2, r2, #40	; 0x28
 80437aa:	2a28      	cmp	r2, #40	; 0x28
 80437ac:	d012      	beq.n	80437d4 <I2C_DMAAbort+0x6a>
      hi2c->State = HAL_I2C_STATE_READY;
 80437ae:	2320      	movs	r3, #32
 80437b0:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
      hi2c->Mode = HAL_I2C_MODE_NONE;
 80437b4:	2300      	movs	r3, #0
 80437b6:	f880 303e 	strb.w	r3, [r0, #62]	; 0x3e
    HAL_I2C_ErrorCallback(hi2c);
 80437ba:	f00d f9e1 	bl	8050b80 <HAL_I2C_ErrorCallback>
}
 80437be:	bd10      	pop	{r4, pc}
    hi2c->State         = HAL_I2C_STATE_READY;
 80437c0:	2320      	movs	r3, #32
 80437c2:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
    hi2c->Mode          = HAL_I2C_MODE_NONE;
 80437c6:	2300      	movs	r3, #0
 80437c8:	f880 303e 	strb.w	r3, [r0, #62]	; 0x3e
    hi2c->ErrorCode     = HAL_I2C_ERROR_NONE;
 80437cc:	6403      	str	r3, [r0, #64]	; 0x40
    HAL_I2C_AbortCpltCallback(hi2c);
 80437ce:	f7ff ffcb 	bl	8043768 <HAL_I2C_AbortCpltCallback>
 80437d2:	e7f4      	b.n	80437be <I2C_DMAAbort+0x54>
      __HAL_I2C_ENABLE(hi2c);
 80437d4:	6802      	ldr	r2, [r0, #0]
 80437d6:	6813      	ldr	r3, [r2, #0]
 80437d8:	f043 0301 	orr.w	r3, r3, #1
 80437dc:	6013      	str	r3, [r2, #0]
      SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 80437de:	6802      	ldr	r2, [r0, #0]
 80437e0:	6813      	ldr	r3, [r2, #0]
 80437e2:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 80437e6:	6013      	str	r3, [r2, #0]
      hi2c->PreviousState = I2C_STATE_NONE;
 80437e8:	2300      	movs	r3, #0
 80437ea:	6303      	str	r3, [r0, #48]	; 0x30
      hi2c->State = HAL_I2C_STATE_LISTEN;
 80437ec:	2328      	movs	r3, #40	; 0x28
 80437ee:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
 80437f2:	e7e2      	b.n	80437ba <I2C_DMAAbort+0x50>

080437f4 <I2C_ITError>:
{
 80437f4:	b510      	push	{r4, lr}
 80437f6:	4604      	mov	r4, r0
  HAL_I2C_StateTypeDef CurrentState = hi2c->State;
 80437f8:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 80437fc:	b2db      	uxtb	r3, r3
  if ((hi2c->Mode == HAL_I2C_MODE_MASTER) && (CurrentState == HAL_I2C_STATE_BUSY_RX))
 80437fe:	f890 203e 	ldrb.w	r2, [r0, #62]	; 0x3e
 8043802:	b2d2      	uxtb	r2, r2
 8043804:	2a10      	cmp	r2, #16
 8043806:	d033      	beq.n	8043870 <I2C_ITError+0x7c>
  if (((uint32_t)CurrentState & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
 8043808:	f003 0228 	and.w	r2, r3, #40	; 0x28
 804380c:	2a28      	cmp	r2, #40	; 0x28
 804380e:	d037      	beq.n	8043880 <I2C_ITError+0x8c>
    if ((READ_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN) != I2C_CR2_DMAEN) && (CurrentState != HAL_I2C_STATE_ABORT))
 8043810:	6822      	ldr	r2, [r4, #0]
 8043812:	6852      	ldr	r2, [r2, #4]
 8043814:	f412 6f00 	tst.w	r2, #2048	; 0x800
 8043818:	d104      	bne.n	8043824 <I2C_ITError+0x30>
 804381a:	2b60      	cmp	r3, #96	; 0x60
 804381c:	d002      	beq.n	8043824 <I2C_ITError+0x30>
      hi2c->State = HAL_I2C_STATE_READY;
 804381e:	2320      	movs	r3, #32
 8043820:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
    hi2c->PreviousState = I2C_STATE_NONE;
 8043824:	2300      	movs	r3, #0
 8043826:	6323      	str	r3, [r4, #48]	; 0x30
    hi2c->Mode = HAL_I2C_MODE_NONE;
 8043828:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
  if (READ_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN) == I2C_CR2_DMAEN)
 804382c:	6823      	ldr	r3, [r4, #0]
 804382e:	685a      	ldr	r2, [r3, #4]
 8043830:	f412 6f00 	tst.w	r2, #2048	; 0x800
 8043834:	d048      	beq.n	80438c8 <I2C_ITError+0xd4>
    hi2c->Instance->CR2 &= ~I2C_CR2_DMAEN;
 8043836:	685a      	ldr	r2, [r3, #4]
 8043838:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
 804383c:	605a      	str	r2, [r3, #4]
    if (hi2c->hdmatx->State != HAL_DMA_STATE_READY)
 804383e:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8043840:	f892 3035 	ldrb.w	r3, [r2, #53]	; 0x35
 8043844:	b2db      	uxtb	r3, r3
 8043846:	2b01      	cmp	r3, #1
 8043848:	d020      	beq.n	804388c <I2C_ITError+0x98>
      hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
 804384a:	4b42      	ldr	r3, [pc, #264]	; (8043954 <I2C_ITError+0x160>)
 804384c:	6513      	str	r3, [r2, #80]	; 0x50
      if (HAL_DMA_Abort_IT(hi2c->hdmatx) != HAL_OK)
 804384e:	6b60      	ldr	r0, [r4, #52]	; 0x34
 8043850:	f7fe f9d8 	bl	8041c04 <HAL_DMA_Abort_IT>
 8043854:	2800      	cmp	r0, #0
 8043856:	d049      	beq.n	80438ec <I2C_ITError+0xf8>
        __HAL_I2C_DISABLE(hi2c);
 8043858:	6822      	ldr	r2, [r4, #0]
 804385a:	6813      	ldr	r3, [r2, #0]
 804385c:	f023 0301 	bic.w	r3, r3, #1
 8043860:	6013      	str	r3, [r2, #0]
        hi2c->State = HAL_I2C_STATE_READY;
 8043862:	2320      	movs	r3, #32
 8043864:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
        hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
 8043868:	6b60      	ldr	r0, [r4, #52]	; 0x34
 804386a:	6d03      	ldr	r3, [r0, #80]	; 0x50
 804386c:	4798      	blx	r3
 804386e:	e03d      	b.n	80438ec <I2C_ITError+0xf8>
  if ((hi2c->Mode == HAL_I2C_MODE_MASTER) && (CurrentState == HAL_I2C_STATE_BUSY_RX))
 8043870:	2b22      	cmp	r3, #34	; 0x22
 8043872:	d1c9      	bne.n	8043808 <I2C_ITError+0x14>
    hi2c->Instance->CR1 &= ~I2C_CR1_POS;
 8043874:	6801      	ldr	r1, [r0, #0]
 8043876:	680a      	ldr	r2, [r1, #0]
 8043878:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
 804387c:	600a      	str	r2, [r1, #0]
 804387e:	e7c3      	b.n	8043808 <I2C_ITError+0x14>
    hi2c->PreviousState = I2C_STATE_NONE;
 8043880:	2300      	movs	r3, #0
 8043882:	6323      	str	r3, [r4, #48]	; 0x30
    hi2c->State = HAL_I2C_STATE_LISTEN;
 8043884:	2328      	movs	r3, #40	; 0x28
 8043886:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
 804388a:	e7cf      	b.n	804382c <I2C_ITError+0x38>
      hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
 804388c:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 804388e:	4a31      	ldr	r2, [pc, #196]	; (8043954 <I2C_ITError+0x160>)
 8043890:	651a      	str	r2, [r3, #80]	; 0x50
      if (HAL_DMA_Abort_IT(hi2c->hdmarx) != HAL_OK)
 8043892:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 8043894:	f7fe f9b6 	bl	8041c04 <HAL_DMA_Abort_IT>
 8043898:	b340      	cbz	r0, 80438ec <I2C_ITError+0xf8>
        if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET)
 804389a:	6823      	ldr	r3, [r4, #0]
 804389c:	695a      	ldr	r2, [r3, #20]
 804389e:	f012 0f40 	tst.w	r2, #64	; 0x40
 80438a2:	d005      	beq.n	80438b0 <I2C_ITError+0xbc>
          *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 80438a4:	691a      	ldr	r2, [r3, #16]
 80438a6:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80438a8:	701a      	strb	r2, [r3, #0]
          hi2c->pBuffPtr++;
 80438aa:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80438ac:	3301      	adds	r3, #1
 80438ae:	6263      	str	r3, [r4, #36]	; 0x24
        __HAL_I2C_DISABLE(hi2c);
 80438b0:	6822      	ldr	r2, [r4, #0]
 80438b2:	6813      	ldr	r3, [r2, #0]
 80438b4:	f023 0301 	bic.w	r3, r3, #1
 80438b8:	6013      	str	r3, [r2, #0]
        hi2c->State = HAL_I2C_STATE_READY;
 80438ba:	2320      	movs	r3, #32
 80438bc:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
        hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
 80438c0:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 80438c2:	6d03      	ldr	r3, [r0, #80]	; 0x50
 80438c4:	4798      	blx	r3
 80438c6:	e011      	b.n	80438ec <I2C_ITError+0xf8>
  else if (hi2c->State == HAL_I2C_STATE_ABORT)
 80438c8:	f894 203d 	ldrb.w	r2, [r4, #61]	; 0x3d
 80438cc:	b2d2      	uxtb	r2, r2
 80438ce:	2a60      	cmp	r2, #96	; 0x60
 80438d0:	d016      	beq.n	8043900 <I2C_ITError+0x10c>
    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET)
 80438d2:	695a      	ldr	r2, [r3, #20]
 80438d4:	f012 0f40 	tst.w	r2, #64	; 0x40
 80438d8:	d005      	beq.n	80438e6 <I2C_ITError+0xf2>
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 80438da:	691a      	ldr	r2, [r3, #16]
 80438dc:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80438de:	701a      	strb	r2, [r3, #0]
      hi2c->pBuffPtr++;
 80438e0:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80438e2:	3301      	adds	r3, #1
 80438e4:	6263      	str	r3, [r4, #36]	; 0x24
    HAL_I2C_ErrorCallback(hi2c);
 80438e6:	4620      	mov	r0, r4
 80438e8:	f00d f94a 	bl	8050b80 <HAL_I2C_ErrorCallback>
  CurrentState = hi2c->State;
 80438ec:	f894 303d 	ldrb.w	r3, [r4, #61]	; 0x3d
 80438f0:	b2db      	uxtb	r3, r3
  if (((hi2c->ErrorCode & HAL_I2C_ERROR_AF) == HAL_I2C_ERROR_AF) && (CurrentState == HAL_I2C_STATE_LISTEN))
 80438f2:	6c22      	ldr	r2, [r4, #64]	; 0x40
 80438f4:	f012 0f04 	tst.w	r2, #4
 80438f8:	d001      	beq.n	80438fe <I2C_ITError+0x10a>
 80438fa:	2b28      	cmp	r3, #40	; 0x28
 80438fc:	d018      	beq.n	8043930 <I2C_ITError+0x13c>
}
 80438fe:	bd10      	pop	{r4, pc}
    hi2c->State = HAL_I2C_STATE_READY;
 8043900:	2220      	movs	r2, #32
 8043902:	f884 203d 	strb.w	r2, [r4, #61]	; 0x3d
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8043906:	2200      	movs	r2, #0
 8043908:	6422      	str	r2, [r4, #64]	; 0x40
    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET)
 804390a:	695a      	ldr	r2, [r3, #20]
 804390c:	f012 0f40 	tst.w	r2, #64	; 0x40
 8043910:	d005      	beq.n	804391e <I2C_ITError+0x12a>
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 8043912:	691a      	ldr	r2, [r3, #16]
 8043914:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8043916:	701a      	strb	r2, [r3, #0]
      hi2c->pBuffPtr++;
 8043918:	6a63      	ldr	r3, [r4, #36]	; 0x24
 804391a:	3301      	adds	r3, #1
 804391c:	6263      	str	r3, [r4, #36]	; 0x24
    __HAL_I2C_DISABLE(hi2c);
 804391e:	6822      	ldr	r2, [r4, #0]
 8043920:	6813      	ldr	r3, [r2, #0]
 8043922:	f023 0301 	bic.w	r3, r3, #1
 8043926:	6013      	str	r3, [r2, #0]
    HAL_I2C_AbortCpltCallback(hi2c);
 8043928:	4620      	mov	r0, r4
 804392a:	f7ff ff1d 	bl	8043768 <HAL_I2C_AbortCpltCallback>
 804392e:	e7dd      	b.n	80438ec <I2C_ITError+0xf8>
    __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
 8043930:	6822      	ldr	r2, [r4, #0]
 8043932:	6853      	ldr	r3, [r2, #4]
 8043934:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 8043938:	6053      	str	r3, [r2, #4]
    hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
 804393a:	4b07      	ldr	r3, [pc, #28]	; (8043958 <I2C_ITError+0x164>)
 804393c:	62e3      	str	r3, [r4, #44]	; 0x2c
    hi2c->PreviousState = I2C_STATE_NONE;
 804393e:	2300      	movs	r3, #0
 8043940:	6323      	str	r3, [r4, #48]	; 0x30
    hi2c->State         = HAL_I2C_STATE_READY;
 8043942:	2220      	movs	r2, #32
 8043944:	f884 203d 	strb.w	r2, [r4, #61]	; 0x3d
    hi2c->Mode          = HAL_I2C_MODE_NONE;
 8043948:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
    HAL_I2C_ListenCpltCallback(hi2c);
 804394c:	4620      	mov	r0, r4
 804394e:	f7ff fce3 	bl	8043318 <HAL_I2C_ListenCpltCallback>
}
 8043952:	e7d4      	b.n	80438fe <I2C_ITError+0x10a>
 8043954:	0804376b 	.word	0x0804376b
 8043958:	ffff0000 	.word	0xffff0000

0804395c <I2C_Slave_STOPF>:
{
 804395c:	b530      	push	{r4, r5, lr}
 804395e:	b083      	sub	sp, #12
 8043960:	4604      	mov	r4, r0
  HAL_I2C_StateTypeDef CurrentState = hi2c->State;
 8043962:	f890 503d 	ldrb.w	r5, [r0, #61]	; 0x3d
 8043966:	b2ed      	uxtb	r5, r5
  __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
 8043968:	6802      	ldr	r2, [r0, #0]
 804396a:	6853      	ldr	r3, [r2, #4]
 804396c:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 8043970:	6053      	str	r3, [r2, #4]
  __HAL_I2C_CLEAR_STOPFLAG(hi2c);
 8043972:	2300      	movs	r3, #0
 8043974:	9301      	str	r3, [sp, #4]
 8043976:	6803      	ldr	r3, [r0, #0]
 8043978:	695a      	ldr	r2, [r3, #20]
 804397a:	9201      	str	r2, [sp, #4]
 804397c:	681a      	ldr	r2, [r3, #0]
 804397e:	f042 0201 	orr.w	r2, r2, #1
 8043982:	601a      	str	r2, [r3, #0]
 8043984:	9b01      	ldr	r3, [sp, #4]
  CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 8043986:	6802      	ldr	r2, [r0, #0]
 8043988:	6813      	ldr	r3, [r2, #0]
 804398a:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 804398e:	6013      	str	r3, [r2, #0]
  if ((hi2c->Instance->CR2 & I2C_CR2_DMAEN) == I2C_CR2_DMAEN)
 8043990:	6803      	ldr	r3, [r0, #0]
 8043992:	685a      	ldr	r2, [r3, #4]
 8043994:	f412 6f00 	tst.w	r2, #2048	; 0x800
 8043998:	d038      	beq.n	8043a0c <I2C_Slave_STOPF+0xb0>
    if ((CurrentState == HAL_I2C_STATE_BUSY_RX) || (CurrentState == HAL_I2C_STATE_BUSY_RX_LISTEN))
 804399a:	2d22      	cmp	r5, #34	; 0x22
 804399c:	d021      	beq.n	80439e2 <I2C_Slave_STOPF+0x86>
 804399e:	2d2a      	cmp	r5, #42	; 0x2a
 80439a0:	d01f      	beq.n	80439e2 <I2C_Slave_STOPF+0x86>
      hi2c->XferCount = (uint16_t)(__HAL_DMA_GET_COUNTER(hi2c->hdmatx));
 80439a2:	6b42      	ldr	r2, [r0, #52]	; 0x34
 80439a4:	6812      	ldr	r2, [r2, #0]
 80439a6:	6852      	ldr	r2, [r2, #4]
 80439a8:	b292      	uxth	r2, r2
 80439aa:	8542      	strh	r2, [r0, #42]	; 0x2a
      if (hi2c->XferCount != 0U)
 80439ac:	8d42      	ldrh	r2, [r0, #42]	; 0x2a
 80439ae:	b292      	uxth	r2, r2
 80439b0:	b11a      	cbz	r2, 80439ba <I2C_Slave_STOPF+0x5e>
        hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 80439b2:	6c02      	ldr	r2, [r0, #64]	; 0x40
 80439b4:	f042 0204 	orr.w	r2, r2, #4
 80439b8:	6402      	str	r2, [r0, #64]	; 0x40
      CLEAR_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
 80439ba:	685a      	ldr	r2, [r3, #4]
 80439bc:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
 80439c0:	605a      	str	r2, [r3, #4]
      if (HAL_DMA_GetState(hi2c->hdmatx) != HAL_DMA_STATE_READY)
 80439c2:	6b60      	ldr	r0, [r4, #52]	; 0x34
 80439c4:	f7fe fa20 	bl	8041e08 <HAL_DMA_GetState>
 80439c8:	2801      	cmp	r0, #1
 80439ca:	d01f      	beq.n	8043a0c <I2C_Slave_STOPF+0xb0>
        hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
 80439cc:	6b63      	ldr	r3, [r4, #52]	; 0x34
 80439ce:	4a44      	ldr	r2, [pc, #272]	; (8043ae0 <I2C_Slave_STOPF+0x184>)
 80439d0:	651a      	str	r2, [r3, #80]	; 0x50
        if (HAL_DMA_Abort_IT(hi2c->hdmatx) != HAL_OK)
 80439d2:	6b60      	ldr	r0, [r4, #52]	; 0x34
 80439d4:	f7fe f916 	bl	8041c04 <HAL_DMA_Abort_IT>
 80439d8:	b1c0      	cbz	r0, 8043a0c <I2C_Slave_STOPF+0xb0>
          hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
 80439da:	6b60      	ldr	r0, [r4, #52]	; 0x34
 80439dc:	6d03      	ldr	r3, [r0, #80]	; 0x50
 80439de:	4798      	blx	r3
 80439e0:	e014      	b.n	8043a0c <I2C_Slave_STOPF+0xb0>
      hi2c->XferCount = (uint16_t)(__HAL_DMA_GET_COUNTER(hi2c->hdmarx));
 80439e2:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 80439e4:	6812      	ldr	r2, [r2, #0]
 80439e6:	6852      	ldr	r2, [r2, #4]
 80439e8:	b292      	uxth	r2, r2
 80439ea:	8562      	strh	r2, [r4, #42]	; 0x2a
      if (hi2c->XferCount != 0U)
 80439ec:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
 80439ee:	b292      	uxth	r2, r2
 80439f0:	b11a      	cbz	r2, 80439fa <I2C_Slave_STOPF+0x9e>
        hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 80439f2:	6c22      	ldr	r2, [r4, #64]	; 0x40
 80439f4:	f042 0204 	orr.w	r2, r2, #4
 80439f8:	6422      	str	r2, [r4, #64]	; 0x40
      CLEAR_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
 80439fa:	685a      	ldr	r2, [r3, #4]
 80439fc:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
 8043a00:	605a      	str	r2, [r3, #4]
      if (HAL_DMA_GetState(hi2c->hdmarx) != HAL_DMA_STATE_READY)
 8043a02:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 8043a04:	f7fe fa00 	bl	8041e08 <HAL_DMA_GetState>
 8043a08:	2801      	cmp	r0, #1
 8043a0a:	d142      	bne.n	8043a92 <I2C_Slave_STOPF+0x136>
  if (hi2c->XferCount != 0U)
 8043a0c:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 8043a0e:	b29b      	uxth	r3, r3
 8043a10:	b333      	cbz	r3, 8043a60 <I2C_Slave_STOPF+0x104>
    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET)
 8043a12:	6823      	ldr	r3, [r4, #0]
 8043a14:	695a      	ldr	r2, [r3, #20]
 8043a16:	f012 0f04 	tst.w	r2, #4
 8043a1a:	d00a      	beq.n	8043a32 <I2C_Slave_STOPF+0xd6>
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 8043a1c:	691a      	ldr	r2, [r3, #16]
 8043a1e:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8043a20:	701a      	strb	r2, [r3, #0]
      hi2c->pBuffPtr++;
 8043a22:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8043a24:	3301      	adds	r3, #1
 8043a26:	6263      	str	r3, [r4, #36]	; 0x24
      hi2c->XferCount--;
 8043a28:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 8043a2a:	b29b      	uxth	r3, r3
 8043a2c:	3b01      	subs	r3, #1
 8043a2e:	b29b      	uxth	r3, r3
 8043a30:	8563      	strh	r3, [r4, #42]	; 0x2a
    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET)
 8043a32:	6823      	ldr	r3, [r4, #0]
 8043a34:	695a      	ldr	r2, [r3, #20]
 8043a36:	f012 0f40 	tst.w	r2, #64	; 0x40
 8043a3a:	d00a      	beq.n	8043a52 <I2C_Slave_STOPF+0xf6>
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 8043a3c:	691a      	ldr	r2, [r3, #16]
 8043a3e:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8043a40:	701a      	strb	r2, [r3, #0]
      hi2c->pBuffPtr++;
 8043a42:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8043a44:	3301      	adds	r3, #1
 8043a46:	6263      	str	r3, [r4, #36]	; 0x24
      hi2c->XferCount--;
 8043a48:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 8043a4a:	b29b      	uxth	r3, r3
 8043a4c:	3b01      	subs	r3, #1
 8043a4e:	b29b      	uxth	r3, r3
 8043a50:	8563      	strh	r3, [r4, #42]	; 0x2a
    if (hi2c->XferCount != 0U)
 8043a52:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 8043a54:	b29b      	uxth	r3, r3
 8043a56:	b11b      	cbz	r3, 8043a60 <I2C_Slave_STOPF+0x104>
      hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 8043a58:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8043a5a:	f043 0304 	orr.w	r3, r3, #4
 8043a5e:	6423      	str	r3, [r4, #64]	; 0x40
  if (hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
 8043a60:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8043a62:	bb13      	cbnz	r3, 8043aaa <I2C_Slave_STOPF+0x14e>
    if (CurrentState == HAL_I2C_STATE_BUSY_RX_LISTEN)
 8043a64:	2d2a      	cmp	r5, #42	; 0x2a
 8043a66:	d025      	beq.n	8043ab4 <I2C_Slave_STOPF+0x158>
    if (hi2c->State == HAL_I2C_STATE_LISTEN)
 8043a68:	f894 303d 	ldrb.w	r3, [r4, #61]	; 0x3d
 8043a6c:	b2db      	uxtb	r3, r3
 8043a6e:	2b28      	cmp	r3, #40	; 0x28
 8043a70:	d029      	beq.n	8043ac6 <I2C_Slave_STOPF+0x16a>
      if ((hi2c->PreviousState  == I2C_STATE_SLAVE_BUSY_RX) || (CurrentState == HAL_I2C_STATE_BUSY_RX))
 8043a72:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8043a74:	2b22      	cmp	r3, #34	; 0x22
 8043a76:	d001      	beq.n	8043a7c <I2C_Slave_STOPF+0x120>
 8043a78:	2d22      	cmp	r5, #34	; 0x22
 8043a7a:	d119      	bne.n	8043ab0 <I2C_Slave_STOPF+0x154>
        hi2c->PreviousState = I2C_STATE_NONE;
 8043a7c:	2300      	movs	r3, #0
 8043a7e:	6323      	str	r3, [r4, #48]	; 0x30
        hi2c->State = HAL_I2C_STATE_READY;
 8043a80:	2220      	movs	r2, #32
 8043a82:	f884 203d 	strb.w	r2, [r4, #61]	; 0x3d
        hi2c->Mode = HAL_I2C_MODE_NONE;
 8043a86:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
        HAL_I2C_SlaveRxCpltCallback(hi2c);
 8043a8a:	4620      	mov	r0, r4
 8043a8c:	f7ff fbf5 	bl	804327a <HAL_I2C_SlaveRxCpltCallback>
}
 8043a90:	e00e      	b.n	8043ab0 <I2C_Slave_STOPF+0x154>
        hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
 8043a92:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8043a94:	4a12      	ldr	r2, [pc, #72]	; (8043ae0 <I2C_Slave_STOPF+0x184>)
 8043a96:	651a      	str	r2, [r3, #80]	; 0x50
        if (HAL_DMA_Abort_IT(hi2c->hdmarx) != HAL_OK)
 8043a98:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 8043a9a:	f7fe f8b3 	bl	8041c04 <HAL_DMA_Abort_IT>
 8043a9e:	2800      	cmp	r0, #0
 8043aa0:	d0b4      	beq.n	8043a0c <I2C_Slave_STOPF+0xb0>
          hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
 8043aa2:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 8043aa4:	6d03      	ldr	r3, [r0, #80]	; 0x50
 8043aa6:	4798      	blx	r3
 8043aa8:	e7b0      	b.n	8043a0c <I2C_Slave_STOPF+0xb0>
    I2C_ITError(hi2c);
 8043aaa:	4620      	mov	r0, r4
 8043aac:	f7ff fea2 	bl	80437f4 <I2C_ITError>
}
 8043ab0:	b003      	add	sp, #12
 8043ab2:	bd30      	pop	{r4, r5, pc}
      hi2c->PreviousState = I2C_STATE_NONE;
 8043ab4:	2300      	movs	r3, #0
 8043ab6:	6323      	str	r3, [r4, #48]	; 0x30
      hi2c->State = HAL_I2C_STATE_LISTEN;
 8043ab8:	2328      	movs	r3, #40	; 0x28
 8043aba:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
      HAL_I2C_SlaveRxCpltCallback(hi2c);
 8043abe:	4620      	mov	r0, r4
 8043ac0:	f7ff fbdb 	bl	804327a <HAL_I2C_SlaveRxCpltCallback>
 8043ac4:	e7d0      	b.n	8043a68 <I2C_Slave_STOPF+0x10c>
      hi2c->XferOptions = I2C_NO_OPTION_FRAME;
 8043ac6:	4b07      	ldr	r3, [pc, #28]	; (8043ae4 <I2C_Slave_STOPF+0x188>)
 8043ac8:	62e3      	str	r3, [r4, #44]	; 0x2c
      hi2c->PreviousState = I2C_STATE_NONE;
 8043aca:	2300      	movs	r3, #0
 8043acc:	6323      	str	r3, [r4, #48]	; 0x30
      hi2c->State = HAL_I2C_STATE_READY;
 8043ace:	2220      	movs	r2, #32
 8043ad0:	f884 203d 	strb.w	r2, [r4, #61]	; 0x3d
      hi2c->Mode = HAL_I2C_MODE_NONE;
 8043ad4:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
      HAL_I2C_ListenCpltCallback(hi2c);
 8043ad8:	4620      	mov	r0, r4
 8043ada:	f7ff fc1d 	bl	8043318 <HAL_I2C_ListenCpltCallback>
 8043ade:	e7e7      	b.n	8043ab0 <I2C_Slave_STOPF+0x154>
 8043ae0:	0804376b 	.word	0x0804376b
 8043ae4:	ffff0000 	.word	0xffff0000

08043ae8 <HAL_I2C_EV_IRQHandler>:
{
 8043ae8:	b570      	push	{r4, r5, r6, lr}
 8043aea:	4604      	mov	r4, r0
  uint32_t itsources                = READ_REG(hi2c->Instance->CR2);
 8043aec:	6802      	ldr	r2, [r0, #0]
 8043aee:	6855      	ldr	r5, [r2, #4]
  uint32_t CurrentXferOptions       = hi2c->XferOptions;
 8043af0:	6ac6      	ldr	r6, [r0, #44]	; 0x2c
  HAL_I2C_ModeTypeDef CurrentMode   = hi2c->Mode;
 8043af2:	f890 303e 	ldrb.w	r3, [r0, #62]	; 0x3e
 8043af6:	b2db      	uxtb	r3, r3
  HAL_I2C_StateTypeDef CurrentState = hi2c->State;
 8043af8:	f890 103d 	ldrb.w	r1, [r0, #61]	; 0x3d
  if ((CurrentMode == HAL_I2C_MODE_MASTER) || (CurrentMode == HAL_I2C_MODE_MEM))
 8043afc:	2b10      	cmp	r3, #16
 8043afe:	d014      	beq.n	8043b2a <HAL_I2C_EV_IRQHandler+0x42>
 8043b00:	b2c8      	uxtb	r0, r1
 8043b02:	2b40      	cmp	r3, #64	; 0x40
 8043b04:	d011      	beq.n	8043b2a <HAL_I2C_EV_IRQHandler+0x42>
    if (hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
 8043b06:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8043b08:	2b00      	cmp	r3, #0
 8043b0a:	d071      	beq.n	8043bf0 <HAL_I2C_EV_IRQHandler+0x108>
      sr1itflags   = READ_REG(hi2c->Instance->SR1);
 8043b0c:	6953      	ldr	r3, [r2, #20]
  uint32_t sr2itflags               = 0U;
 8043b0e:	2100      	movs	r1, #0
    if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_ADDR) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
 8043b10:	f013 0f02 	tst.w	r3, #2
 8043b14:	d06f      	beq.n	8043bf6 <HAL_I2C_EV_IRQHandler+0x10e>
 8043b16:	f415 7f00 	tst.w	r5, #512	; 0x200
 8043b1a:	d06c      	beq.n	8043bf6 <HAL_I2C_EV_IRQHandler+0x10e>
      if (hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
 8043b1c:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8043b1e:	b103      	cbz	r3, 8043b22 <HAL_I2C_EV_IRQHandler+0x3a>
        sr2itflags   = READ_REG(hi2c->Instance->SR2);
 8043b20:	6991      	ldr	r1, [r2, #24]
      I2C_Slave_ADDR(hi2c, sr2itflags);
 8043b22:	4620      	mov	r0, r4
 8043b24:	f7ff fbd1 	bl	80432ca <I2C_Slave_ADDR>
}
 8043b28:	bd70      	pop	{r4, r5, r6, pc}
    sr2itflags   = READ_REG(hi2c->Instance->SR2);
 8043b2a:	6990      	ldr	r0, [r2, #24]
    sr1itflags   = READ_REG(hi2c->Instance->SR1);
 8043b2c:	6953      	ldr	r3, [r2, #20]
    if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_SB) == RESET) && (IS_I2C_TRANSFER_OTHER_OPTIONS_REQUEST(CurrentXferOptions) == 1U))
 8043b2e:	f013 0101 	ands.w	r1, r3, #1
 8043b32:	d105      	bne.n	8043b40 <HAL_I2C_EV_IRQHandler+0x58>
 8043b34:	f5b6 0f2a 	cmp.w	r6, #11141120	; 0xaa0000
 8043b38:	d0f6      	beq.n	8043b28 <HAL_I2C_EV_IRQHandler+0x40>
 8043b3a:	f1b6 4f2a 	cmp.w	r6, #2852126720	; 0xaa000000
 8043b3e:	d0f3      	beq.n	8043b28 <HAL_I2C_EV_IRQHandler+0x40>
    if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_SB) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
 8043b40:	b111      	cbz	r1, 8043b48 <HAL_I2C_EV_IRQHandler+0x60>
 8043b42:	f415 7f00 	tst.w	r5, #512	; 0x200
 8043b46:	d125      	bne.n	8043b94 <HAL_I2C_EV_IRQHandler+0xac>
    else if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_ADD10) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
 8043b48:	f013 0f08 	tst.w	r3, #8
 8043b4c:	d002      	beq.n	8043b54 <HAL_I2C_EV_IRQHandler+0x6c>
 8043b4e:	f415 7f00 	tst.w	r5, #512	; 0x200
 8043b52:	d126      	bne.n	8043ba2 <HAL_I2C_EV_IRQHandler+0xba>
    else if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_ADDR) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
 8043b54:	f013 0f02 	tst.w	r3, #2
 8043b58:	d002      	beq.n	8043b60 <HAL_I2C_EV_IRQHandler+0x78>
 8043b5a:	f415 7f00 	tst.w	r5, #512	; 0x200
 8043b5e:	d124      	bne.n	8043baa <HAL_I2C_EV_IRQHandler+0xc2>
    else if (I2C_CHECK_FLAG(sr2itflags, I2C_FLAG_TRA) != RESET)
 8043b60:	f010 0f04 	tst.w	r0, #4
 8043b64:	d029      	beq.n	8043bba <HAL_I2C_EV_IRQHandler+0xd2>
      if (READ_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN) != I2C_CR2_DMAEN)
 8043b66:	6852      	ldr	r2, [r2, #4]
 8043b68:	f412 6f00 	tst.w	r2, #2048	; 0x800
 8043b6c:	d1dc      	bne.n	8043b28 <HAL_I2C_EV_IRQHandler+0x40>
        if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_TXE) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_BUF) != RESET) && (I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_BTF) == RESET))
 8043b6e:	f013 0f80 	tst.w	r3, #128	; 0x80
 8043b72:	d005      	beq.n	8043b80 <HAL_I2C_EV_IRQHandler+0x98>
 8043b74:	f415 6f80 	tst.w	r5, #1024	; 0x400
 8043b78:	d002      	beq.n	8043b80 <HAL_I2C_EV_IRQHandler+0x98>
 8043b7a:	f013 0f04 	tst.w	r3, #4
 8043b7e:	d018      	beq.n	8043bb2 <HAL_I2C_EV_IRQHandler+0xca>
        else if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_BTF) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
 8043b80:	f013 0f04 	tst.w	r3, #4
 8043b84:	d0d0      	beq.n	8043b28 <HAL_I2C_EV_IRQHandler+0x40>
 8043b86:	f415 7f00 	tst.w	r5, #512	; 0x200
 8043b8a:	d0cd      	beq.n	8043b28 <HAL_I2C_EV_IRQHandler+0x40>
          I2C_MasterTransmit_BTF(hi2c);
 8043b8c:	4620      	mov	r0, r4
 8043b8e:	f7ff fcb5 	bl	80434fc <I2C_MasterTransmit_BTF>
 8043b92:	e7c9      	b.n	8043b28 <HAL_I2C_EV_IRQHandler+0x40>
      I2C_ConvertOtherXferOptions(hi2c);
 8043b94:	4620      	mov	r0, r4
 8043b96:	f7ff fa63 	bl	8043060 <I2C_ConvertOtherXferOptions>
      I2C_Master_SB(hi2c);
 8043b9a:	4620      	mov	r0, r4
 8043b9c:	f7ff f8cf 	bl	8042d3e <I2C_Master_SB>
 8043ba0:	e7c2      	b.n	8043b28 <HAL_I2C_EV_IRQHandler+0x40>
      I2C_Master_ADD10(hi2c);
 8043ba2:	4620      	mov	r0, r4
 8043ba4:	f7ff f922 	bl	8042dec <I2C_Master_ADD10>
 8043ba8:	e7be      	b.n	8043b28 <HAL_I2C_EV_IRQHandler+0x40>
      I2C_Master_ADDR(hi2c);
 8043baa:	4620      	mov	r0, r4
 8043bac:	f7ff f935 	bl	8042e1a <I2C_Master_ADDR>
 8043bb0:	e7ba      	b.n	8043b28 <HAL_I2C_EV_IRQHandler+0x40>
          I2C_MasterTransmit_TXE(hi2c);
 8043bb2:	4620      	mov	r0, r4
 8043bb4:	f7ff fbfc 	bl	80433b0 <I2C_MasterTransmit_TXE>
 8043bb8:	e7b6      	b.n	8043b28 <HAL_I2C_EV_IRQHandler+0x40>
      if (READ_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN) != I2C_CR2_DMAEN)
 8043bba:	6852      	ldr	r2, [r2, #4]
 8043bbc:	f412 6f00 	tst.w	r2, #2048	; 0x800
 8043bc0:	d1b2      	bne.n	8043b28 <HAL_I2C_EV_IRQHandler+0x40>
        if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_RXNE) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_BUF) != RESET) && (I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_BTF) == RESET))
 8043bc2:	f013 0f40 	tst.w	r3, #64	; 0x40
 8043bc6:	d005      	beq.n	8043bd4 <HAL_I2C_EV_IRQHandler+0xec>
 8043bc8:	f415 6f80 	tst.w	r5, #1024	; 0x400
 8043bcc:	d002      	beq.n	8043bd4 <HAL_I2C_EV_IRQHandler+0xec>
 8043bce:	f013 0f04 	tst.w	r3, #4
 8043bd2:	d009      	beq.n	8043be8 <HAL_I2C_EV_IRQHandler+0x100>
        else if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_BTF) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
 8043bd4:	f013 0f04 	tst.w	r3, #4
 8043bd8:	d0a6      	beq.n	8043b28 <HAL_I2C_EV_IRQHandler+0x40>
 8043bda:	f415 7f00 	tst.w	r5, #512	; 0x200
 8043bde:	d0a3      	beq.n	8043b28 <HAL_I2C_EV_IRQHandler+0x40>
          I2C_MasterReceive_BTF(hi2c);
 8043be0:	4620      	mov	r0, r4
 8043be2:	f7ff fd2d 	bl	8043640 <I2C_MasterReceive_BTF>
 8043be6:	e79f      	b.n	8043b28 <HAL_I2C_EV_IRQHandler+0x40>
          I2C_MasterReceive_RXNE(hi2c);
 8043be8:	4620      	mov	r0, r4
 8043bea:	f7ff fcd6 	bl	804359a <I2C_MasterReceive_RXNE>
 8043bee:	e79b      	b.n	8043b28 <HAL_I2C_EV_IRQHandler+0x40>
      sr2itflags   = READ_REG(hi2c->Instance->SR2);
 8043bf0:	6991      	ldr	r1, [r2, #24]
      sr1itflags   = READ_REG(hi2c->Instance->SR1);
 8043bf2:	6953      	ldr	r3, [r2, #20]
 8043bf4:	e78c      	b.n	8043b10 <HAL_I2C_EV_IRQHandler+0x28>
    else if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_STOPF) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
 8043bf6:	f013 0f10 	tst.w	r3, #16
 8043bfa:	d002      	beq.n	8043c02 <HAL_I2C_EV_IRQHandler+0x11a>
 8043bfc:	f415 7f00 	tst.w	r5, #512	; 0x200
 8043c00:	d117      	bne.n	8043c32 <HAL_I2C_EV_IRQHandler+0x14a>
    else if ((CurrentState == HAL_I2C_STATE_BUSY_TX) || (CurrentState == HAL_I2C_STATE_BUSY_TX_LISTEN))
 8043c02:	2821      	cmp	r0, #33	; 0x21
 8043c04:	d019      	beq.n	8043c3a <HAL_I2C_EV_IRQHandler+0x152>
 8043c06:	2829      	cmp	r0, #41	; 0x29
 8043c08:	d017      	beq.n	8043c3a <HAL_I2C_EV_IRQHandler+0x152>
      if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_RXNE) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_BUF) != RESET) && (I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_BTF) == RESET))
 8043c0a:	f013 0f40 	tst.w	r3, #64	; 0x40
 8043c0e:	d005      	beq.n	8043c1c <HAL_I2C_EV_IRQHandler+0x134>
 8043c10:	f415 6f80 	tst.w	r5, #1024	; 0x400
 8043c14:	d002      	beq.n	8043c1c <HAL_I2C_EV_IRQHandler+0x134>
 8043c16:	f013 0f04 	tst.w	r3, #4
 8043c1a:	d027      	beq.n	8043c6c <HAL_I2C_EV_IRQHandler+0x184>
      else if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_BTF) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
 8043c1c:	f013 0f04 	tst.w	r3, #4
 8043c20:	d082      	beq.n	8043b28 <HAL_I2C_EV_IRQHandler+0x40>
 8043c22:	f415 7f00 	tst.w	r5, #512	; 0x200
 8043c26:	f43f af7f 	beq.w	8043b28 <HAL_I2C_EV_IRQHandler+0x40>
        I2C_SlaveReceive_BTF(hi2c);
 8043c2a:	4620      	mov	r0, r4
 8043c2c:	f7ff fa08 	bl	8043040 <I2C_SlaveReceive_BTF>
      }
 8043c30:	e77a      	b.n	8043b28 <HAL_I2C_EV_IRQHandler+0x40>
      I2C_Slave_STOPF(hi2c);
 8043c32:	4620      	mov	r0, r4
 8043c34:	f7ff fe92 	bl	804395c <I2C_Slave_STOPF>
 8043c38:	e776      	b.n	8043b28 <HAL_I2C_EV_IRQHandler+0x40>
      if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_TXE) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_BUF) != RESET) && (I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_BTF) == RESET))
 8043c3a:	f013 0f80 	tst.w	r3, #128	; 0x80
 8043c3e:	d005      	beq.n	8043c4c <HAL_I2C_EV_IRQHandler+0x164>
 8043c40:	f415 6f80 	tst.w	r5, #1024	; 0x400
 8043c44:	d002      	beq.n	8043c4c <HAL_I2C_EV_IRQHandler+0x164>
 8043c46:	f013 0f04 	tst.w	r3, #4
 8043c4a:	d00b      	beq.n	8043c64 <HAL_I2C_EV_IRQHandler+0x17c>
      else if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_BTF) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
 8043c4c:	f013 0f04 	tst.w	r3, #4
 8043c50:	f43f af6a 	beq.w	8043b28 <HAL_I2C_EV_IRQHandler+0x40>
 8043c54:	f415 7f00 	tst.w	r5, #512	; 0x200
 8043c58:	f43f af66 	beq.w	8043b28 <HAL_I2C_EV_IRQHandler+0x40>
        I2C_SlaveTransmit_BTF(hi2c);
 8043c5c:	4620      	mov	r0, r4
 8043c5e:	f7ff f9df 	bl	8043020 <I2C_SlaveTransmit_BTF>
 8043c62:	e761      	b.n	8043b28 <HAL_I2C_EV_IRQHandler+0x40>
        I2C_SlaveTransmit_TXE(hi2c);
 8043c64:	4620      	mov	r0, r4
 8043c66:	f7ff fae2 	bl	804322e <I2C_SlaveTransmit_TXE>
 8043c6a:	e75d      	b.n	8043b28 <HAL_I2C_EV_IRQHandler+0x40>
        I2C_SlaveReceive_RXNE(hi2c);
 8043c6c:	4620      	mov	r0, r4
 8043c6e:	f7ff fb05 	bl	804327c <I2C_SlaveReceive_RXNE>
 8043c72:	e759      	b.n	8043b28 <HAL_I2C_EV_IRQHandler+0x40>

08043c74 <HAL_I2C_ER_IRQHandler>:
{
 8043c74:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8043c76:	4604      	mov	r4, r0
  uint32_t sr1itflags = READ_REG(hi2c->Instance->SR1);
 8043c78:	6803      	ldr	r3, [r0, #0]
 8043c7a:	695d      	ldr	r5, [r3, #20]
  uint32_t itsources  = READ_REG(hi2c->Instance->CR2);
 8043c7c:	685f      	ldr	r7, [r3, #4]
  if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_BERR) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERR) != RESET))
 8043c7e:	f415 7f80 	tst.w	r5, #256	; 0x100
 8043c82:	d007      	beq.n	8043c94 <HAL_I2C_ER_IRQHandler+0x20>
 8043c84:	f417 7f80 	tst.w	r7, #256	; 0x100
 8043c88:	d03b      	beq.n	8043d02 <HAL_I2C_ER_IRQHandler+0x8e>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_BERR);
 8043c8a:	f46f 7280 	mvn.w	r2, #256	; 0x100
 8043c8e:	615a      	str	r2, [r3, #20]
    error |= HAL_I2C_ERROR_BERR;
 8043c90:	2601      	movs	r6, #1
 8043c92:	e000      	b.n	8043c96 <HAL_I2C_ER_IRQHandler+0x22>
  uint32_t error      = HAL_I2C_ERROR_NONE;
 8043c94:	2600      	movs	r6, #0
  if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_ARLO) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERR) != RESET))
 8043c96:	f415 7f00 	tst.w	r5, #512	; 0x200
 8043c9a:	d008      	beq.n	8043cae <HAL_I2C_ER_IRQHandler+0x3a>
 8043c9c:	f417 7f80 	tst.w	r7, #256	; 0x100
 8043ca0:	d005      	beq.n	8043cae <HAL_I2C_ER_IRQHandler+0x3a>
    error |= HAL_I2C_ERROR_ARLO;
 8043ca2:	f046 0602 	orr.w	r6, r6, #2
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ARLO);
 8043ca6:	6823      	ldr	r3, [r4, #0]
 8043ca8:	f46f 7200 	mvn.w	r2, #512	; 0x200
 8043cac:	615a      	str	r2, [r3, #20]
  if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_AF) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERR) != RESET))
 8043cae:	f415 6f80 	tst.w	r5, #1024	; 0x400
 8043cb2:	d018      	beq.n	8043ce6 <HAL_I2C_ER_IRQHandler+0x72>
 8043cb4:	f417 7f80 	tst.w	r7, #256	; 0x100
 8043cb8:	d015      	beq.n	8043ce6 <HAL_I2C_ER_IRQHandler+0x72>
    tmp1 = hi2c->Mode;
 8043cba:	f894 303e 	ldrb.w	r3, [r4, #62]	; 0x3e
 8043cbe:	b2db      	uxtb	r3, r3
    tmp2 = hi2c->XferCount;
 8043cc0:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
 8043cc2:	b291      	uxth	r1, r2
    tmp3 = hi2c->State;
 8043cc4:	f894 203d 	ldrb.w	r2, [r4, #61]	; 0x3d
 8043cc8:	b2d2      	uxtb	r2, r2
    tmp4 = hi2c->PreviousState;
 8043cca:	6b20      	ldr	r0, [r4, #48]	; 0x30
    if ((tmp1 == HAL_I2C_MODE_SLAVE) && (tmp2 == 0U) && \
 8043ccc:	2b20      	cmp	r3, #32
 8043cce:	d01a      	beq.n	8043d06 <HAL_I2C_ER_IRQHandler+0x92>
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8043cd0:	6823      	ldr	r3, [r4, #0]
 8043cd2:	f46f 6280 	mvn.w	r2, #1024	; 0x400
 8043cd6:	615a      	str	r2, [r3, #20]
      error |= HAL_I2C_ERROR_AF;
 8043cd8:	f046 0604 	orr.w	r6, r6, #4
      if (hi2c->Mode == HAL_I2C_MODE_MASTER)
 8043cdc:	f894 303e 	ldrb.w	r3, [r4, #62]	; 0x3e
 8043ce0:	b2db      	uxtb	r3, r3
 8043ce2:	2b10      	cmp	r3, #16
 8043ce4:	d01d      	beq.n	8043d22 <HAL_I2C_ER_IRQHandler+0xae>
  if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_OVR) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERR) != RESET))
 8043ce6:	f415 6f00 	tst.w	r5, #2048	; 0x800
 8043cea:	d008      	beq.n	8043cfe <HAL_I2C_ER_IRQHandler+0x8a>
 8043cec:	f417 7f80 	tst.w	r7, #256	; 0x100
 8043cf0:	d005      	beq.n	8043cfe <HAL_I2C_ER_IRQHandler+0x8a>
    error |= HAL_I2C_ERROR_OVR;
 8043cf2:	f046 0608 	orr.w	r6, r6, #8
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_OVR);
 8043cf6:	6823      	ldr	r3, [r4, #0]
 8043cf8:	f46f 6200 	mvn.w	r2, #2048	; 0x800
 8043cfc:	615a      	str	r2, [r3, #20]
  if (error != HAL_I2C_ERROR_NONE)
 8043cfe:	b9b6      	cbnz	r6, 8043d2e <HAL_I2C_ER_IRQHandler+0xba>
}
 8043d00:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  uint32_t error      = HAL_I2C_ERROR_NONE;
 8043d02:	2600      	movs	r6, #0
 8043d04:	e7c7      	b.n	8043c96 <HAL_I2C_ER_IRQHandler+0x22>
    if ((tmp1 == HAL_I2C_MODE_SLAVE) && (tmp2 == 0U) && \
 8043d06:	2900      	cmp	r1, #0
 8043d08:	d1e2      	bne.n	8043cd0 <HAL_I2C_ER_IRQHandler+0x5c>
 8043d0a:	2a21      	cmp	r2, #33	; 0x21
 8043d0c:	d005      	beq.n	8043d1a <HAL_I2C_ER_IRQHandler+0xa6>
        ((tmp3 == HAL_I2C_STATE_BUSY_TX) || (tmp3 == HAL_I2C_STATE_BUSY_TX_LISTEN) || \
 8043d0e:	2a29      	cmp	r2, #41	; 0x29
 8043d10:	d003      	beq.n	8043d1a <HAL_I2C_ER_IRQHandler+0xa6>
 8043d12:	2a28      	cmp	r2, #40	; 0x28
 8043d14:	d1dc      	bne.n	8043cd0 <HAL_I2C_ER_IRQHandler+0x5c>
         ((tmp3 == HAL_I2C_STATE_LISTEN) && (tmp4 == I2C_STATE_SLAVE_BUSY_TX))))
 8043d16:	2821      	cmp	r0, #33	; 0x21
 8043d18:	d1da      	bne.n	8043cd0 <HAL_I2C_ER_IRQHandler+0x5c>
      I2C_Slave_AF(hi2c);
 8043d1a:	4620      	mov	r0, r4
 8043d1c:	f7ff fafe 	bl	804331c <I2C_Slave_AF>
 8043d20:	e7e1      	b.n	8043ce6 <HAL_I2C_ER_IRQHandler+0x72>
        SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
 8043d22:	6822      	ldr	r2, [r4, #0]
 8043d24:	6813      	ldr	r3, [r2, #0]
 8043d26:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8043d2a:	6013      	str	r3, [r2, #0]
 8043d2c:	e7db      	b.n	8043ce6 <HAL_I2C_ER_IRQHandler+0x72>
    hi2c->ErrorCode |= error;
 8043d2e:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8043d30:	431e      	orrs	r6, r3
 8043d32:	6426      	str	r6, [r4, #64]	; 0x40
    I2C_ITError(hi2c);
 8043d34:	4620      	mov	r0, r4
 8043d36:	f7ff fd5d 	bl	80437f4 <I2C_ITError>
}
 8043d3a:	e7e1      	b.n	8043d00 <HAL_I2C_ER_IRQHandler+0x8c>

08043d3c <HAL_I2CEx_ConfigAnalogFilter>:
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_I2C_ANALOG_FILTER(AnalogFilter));

  if (hi2c->State == HAL_I2C_STATE_READY)
 8043d3c:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 8043d40:	b2db      	uxtb	r3, r3
 8043d42:	2b20      	cmp	r3, #32
 8043d44:	d001      	beq.n	8043d4a <HAL_I2CEx_ConfigAnalogFilter+0xe>

    return HAL_OK;
  }
  else
  {
    return HAL_BUSY;
 8043d46:	2002      	movs	r0, #2
  }
}
 8043d48:	4770      	bx	lr
    hi2c->State = HAL_I2C_STATE_BUSY;
 8043d4a:	2324      	movs	r3, #36	; 0x24
 8043d4c:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
    __HAL_I2C_DISABLE(hi2c);
 8043d50:	6802      	ldr	r2, [r0, #0]
 8043d52:	6813      	ldr	r3, [r2, #0]
 8043d54:	f023 0301 	bic.w	r3, r3, #1
 8043d58:	6013      	str	r3, [r2, #0]
    hi2c->Instance->FLTR &= ~(I2C_FLTR_ANOFF);
 8043d5a:	6802      	ldr	r2, [r0, #0]
 8043d5c:	6a53      	ldr	r3, [r2, #36]	; 0x24
 8043d5e:	f023 0310 	bic.w	r3, r3, #16
 8043d62:	6253      	str	r3, [r2, #36]	; 0x24
    hi2c->Instance->FLTR |= AnalogFilter;
 8043d64:	6802      	ldr	r2, [r0, #0]
 8043d66:	6a53      	ldr	r3, [r2, #36]	; 0x24
 8043d68:	4319      	orrs	r1, r3
 8043d6a:	6251      	str	r1, [r2, #36]	; 0x24
    __HAL_I2C_ENABLE(hi2c);
 8043d6c:	6802      	ldr	r2, [r0, #0]
 8043d6e:	6813      	ldr	r3, [r2, #0]
 8043d70:	f043 0301 	orr.w	r3, r3, #1
 8043d74:	6013      	str	r3, [r2, #0]
    hi2c->State = HAL_I2C_STATE_READY;
 8043d76:	2320      	movs	r3, #32
 8043d78:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
    return HAL_OK;
 8043d7c:	2000      	movs	r0, #0
 8043d7e:	4770      	bx	lr

08043d80 <HAL_I2CEx_ConfigDigitalFilter>:

  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_I2C_DIGITAL_FILTER(DigitalFilter));

  if (hi2c->State == HAL_I2C_STATE_READY)
 8043d80:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 8043d84:	b2db      	uxtb	r3, r3
 8043d86:	2b20      	cmp	r3, #32
 8043d88:	d001      	beq.n	8043d8e <HAL_I2CEx_ConfigDigitalFilter+0xe>

    return HAL_OK;
  }
  else
  {
    return HAL_BUSY;
 8043d8a:	2002      	movs	r0, #2
  }
}
 8043d8c:	4770      	bx	lr
    hi2c->State = HAL_I2C_STATE_BUSY;
 8043d8e:	2324      	movs	r3, #36	; 0x24
 8043d90:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
    __HAL_I2C_DISABLE(hi2c);
 8043d94:	6802      	ldr	r2, [r0, #0]
 8043d96:	6813      	ldr	r3, [r2, #0]
 8043d98:	f023 0301 	bic.w	r3, r3, #1
 8043d9c:	6013      	str	r3, [r2, #0]
    tmpreg = hi2c->Instance->FLTR;
 8043d9e:	6802      	ldr	r2, [r0, #0]
 8043da0:	6a53      	ldr	r3, [r2, #36]	; 0x24
 8043da2:	b29b      	uxth	r3, r3
    tmpreg &= ~(I2C_FLTR_DNF);
 8043da4:	f023 030f 	bic.w	r3, r3, #15
    tmpreg |= DigitalFilter;
 8043da8:	4319      	orrs	r1, r3
 8043daa:	b289      	uxth	r1, r1
    hi2c->Instance->FLTR = tmpreg;
 8043dac:	6251      	str	r1, [r2, #36]	; 0x24
    __HAL_I2C_ENABLE(hi2c);
 8043dae:	6802      	ldr	r2, [r0, #0]
 8043db0:	6813      	ldr	r3, [r2, #0]
 8043db2:	f043 0301 	orr.w	r3, r3, #1
 8043db6:	6013      	str	r3, [r2, #0]
    hi2c->State = HAL_I2C_STATE_READY;
 8043db8:	2320      	movs	r3, #32
 8043dba:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
    return HAL_OK;
 8043dbe:	2000      	movs	r0, #0
 8043dc0:	4770      	bx	lr

08043dc2 <HAL_IWDG_Init>:
HAL_StatusTypeDef HAL_IWDG_Init(IWDG_HandleTypeDef *hiwdg)
{
  uint32_t tickstart;

  /* Check the IWDG handle allocation */
  if (hiwdg == NULL)
 8043dc2:	b308      	cbz	r0, 8043e08 <HAL_IWDG_Init+0x46>
{
 8043dc4:	b538      	push	{r3, r4, r5, lr}
 8043dc6:	4604      	mov	r4, r0
  assert_param(IS_IWDG_ALL_INSTANCE(hiwdg->Instance));
  assert_param(IS_IWDG_PRESCALER(hiwdg->Init.Prescaler));
  assert_param(IS_IWDG_RELOAD(hiwdg->Init.Reload));

  /* Enable IWDG. LSI is turned on automatically */
  __HAL_IWDG_START(hiwdg);
 8043dc8:	6803      	ldr	r3, [r0, #0]
 8043dca:	f64c 42cc 	movw	r2, #52428	; 0xcccc
 8043dce:	601a      	str	r2, [r3, #0]

  /* Enable write access to IWDG_PR and IWDG_RLR registers by writing
  0x5555 in KR */
  IWDG_ENABLE_WRITE_ACCESS(hiwdg);
 8043dd0:	6803      	ldr	r3, [r0, #0]
 8043dd2:	f245 5255 	movw	r2, #21845	; 0x5555
 8043dd6:	601a      	str	r2, [r3, #0]

  /* Write to IWDG registers the Prescaler & Reload values to work with */
  hiwdg->Instance->PR = hiwdg->Init.Prescaler;
 8043dd8:	6803      	ldr	r3, [r0, #0]
 8043dda:	6842      	ldr	r2, [r0, #4]
 8043ddc:	605a      	str	r2, [r3, #4]
  hiwdg->Instance->RLR = hiwdg->Init.Reload;
 8043dde:	6803      	ldr	r3, [r0, #0]
 8043de0:	6882      	ldr	r2, [r0, #8]
 8043de2:	609a      	str	r2, [r3, #8]

  /* Check pending flag, if previous update not done, return timeout */
  tickstart = HAL_GetTick();
 8043de4:	f7fd f96c 	bl	80410c0 <HAL_GetTick>
 8043de8:	4605      	mov	r5, r0

  /* Wait for register to be updated */
  while (hiwdg->Instance->SR != 0x00u)
 8043dea:	6823      	ldr	r3, [r4, #0]
 8043dec:	68da      	ldr	r2, [r3, #12]
 8043dee:	b132      	cbz	r2, 8043dfe <HAL_IWDG_Init+0x3c>
  {
    if ((HAL_GetTick() - tickstart) > HAL_IWDG_DEFAULT_TIMEOUT)
 8043df0:	f7fd f966 	bl	80410c0 <HAL_GetTick>
 8043df4:	1b40      	subs	r0, r0, r5
 8043df6:	2830      	cmp	r0, #48	; 0x30
 8043df8:	d9f7      	bls.n	8043dea <HAL_IWDG_Init+0x28>
    {
      return HAL_TIMEOUT;
 8043dfa:	2003      	movs	r0, #3
 8043dfc:	e003      	b.n	8043e06 <HAL_IWDG_Init+0x44>
    }
  }

  /* Reload IWDG counter with value defined in the reload register */
  __HAL_IWDG_RELOAD_COUNTER(hiwdg);
 8043dfe:	f64a 22aa 	movw	r2, #43690	; 0xaaaa
 8043e02:	601a      	str	r2, [r3, #0]

  /* Return function status */
  return HAL_OK;
 8043e04:	2000      	movs	r0, #0
}
 8043e06:	bd38      	pop	{r3, r4, r5, pc}
    return HAL_ERROR;
 8043e08:	2001      	movs	r0, #1
}
 8043e0a:	4770      	bx	lr

08043e0c <HAL_IWDG_Refresh>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_IWDG_Refresh(IWDG_HandleTypeDef *hiwdg)
{
  /* Reload IWDG counter with value defined in the reload register */
  __HAL_IWDG_RELOAD_COUNTER(hiwdg);
 8043e0c:	6803      	ldr	r3, [r0, #0]
 8043e0e:	f64a 22aa 	movw	r2, #43690	; 0xaaaa
 8043e12:	601a      	str	r2, [r3, #0]

  /* Return function status */
  return HAL_OK;
}
 8043e14:	2000      	movs	r0, #0
 8043e16:	4770      	bx	lr

08043e18 <HAL_PWREx_EnableOverDrive>:
  *         During the Over-drive switch activation, no peripheral clocks should be enabled.   
  *         The peripheral clocks must be enabled once the Over-drive mode is activated.   
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PWREx_EnableOverDrive(void)
{
 8043e18:	b510      	push	{r4, lr}
 8043e1a:	b082      	sub	sp, #8
  uint32_t tickstart = 0U;

  __HAL_RCC_PWR_CLK_ENABLE();
 8043e1c:	2300      	movs	r3, #0
 8043e1e:	9301      	str	r3, [sp, #4]
 8043e20:	4b19      	ldr	r3, [pc, #100]	; (8043e88 <HAL_PWREx_EnableOverDrive+0x70>)
 8043e22:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8043e24:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8043e28:	641a      	str	r2, [r3, #64]	; 0x40
 8043e2a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8043e2c:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8043e30:	9301      	str	r3, [sp, #4]
 8043e32:	9b01      	ldr	r3, [sp, #4]
  
  /* Enable the Over-drive to extend the clock frequency to 180 Mhz */
  __HAL_PWR_OVERDRIVE_ENABLE();
 8043e34:	4b15      	ldr	r3, [pc, #84]	; (8043e8c <HAL_PWREx_EnableOverDrive+0x74>)
 8043e36:	2201      	movs	r2, #1
 8043e38:	601a      	str	r2, [r3, #0]

  /* Get tick */
  tickstart = HAL_GetTick();
 8043e3a:	f7fd f941 	bl	80410c0 <HAL_GetTick>
 8043e3e:	4604      	mov	r4, r0

  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODRDY))
 8043e40:	4b13      	ldr	r3, [pc, #76]	; (8043e90 <HAL_PWREx_EnableOverDrive+0x78>)
 8043e42:	685b      	ldr	r3, [r3, #4]
 8043e44:	f413 3f80 	tst.w	r3, #65536	; 0x10000
 8043e48:	d108      	bne.n	8043e5c <HAL_PWREx_EnableOverDrive+0x44>
  {
    if((HAL_GetTick() - tickstart) > PWR_OVERDRIVE_TIMEOUT_VALUE)
 8043e4a:	f7fd f939 	bl	80410c0 <HAL_GetTick>
 8043e4e:	1b00      	subs	r0, r0, r4
 8043e50:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 8043e54:	d9f4      	bls.n	8043e40 <HAL_PWREx_EnableOverDrive+0x28>
    {
      return HAL_TIMEOUT;
 8043e56:	2003      	movs	r0, #3
    {
      return HAL_TIMEOUT;
    }
  } 
  return HAL_OK;
}
 8043e58:	b002      	add	sp, #8
 8043e5a:	bd10      	pop	{r4, pc}
  __HAL_PWR_OVERDRIVESWITCHING_ENABLE();
 8043e5c:	4b0d      	ldr	r3, [pc, #52]	; (8043e94 <HAL_PWREx_EnableOverDrive+0x7c>)
 8043e5e:	2201      	movs	r2, #1
 8043e60:	601a      	str	r2, [r3, #0]
  tickstart = HAL_GetTick();
 8043e62:	f7fd f92d 	bl	80410c0 <HAL_GetTick>
 8043e66:	4604      	mov	r4, r0
  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODSWRDY))
 8043e68:	4b09      	ldr	r3, [pc, #36]	; (8043e90 <HAL_PWREx_EnableOverDrive+0x78>)
 8043e6a:	685b      	ldr	r3, [r3, #4]
 8043e6c:	f413 3f00 	tst.w	r3, #131072	; 0x20000
 8043e70:	d107      	bne.n	8043e82 <HAL_PWREx_EnableOverDrive+0x6a>
    if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)
 8043e72:	f7fd f925 	bl	80410c0 <HAL_GetTick>
 8043e76:	1b00      	subs	r0, r0, r4
 8043e78:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 8043e7c:	d9f4      	bls.n	8043e68 <HAL_PWREx_EnableOverDrive+0x50>
      return HAL_TIMEOUT;
 8043e7e:	2003      	movs	r0, #3
 8043e80:	e7ea      	b.n	8043e58 <HAL_PWREx_EnableOverDrive+0x40>
  return HAL_OK;
 8043e82:	2000      	movs	r0, #0
 8043e84:	e7e8      	b.n	8043e58 <HAL_PWREx_EnableOverDrive+0x40>
 8043e86:	bf00      	nop
 8043e88:	40023800 	.word	0x40023800
 8043e8c:	420e0040 	.word	0x420e0040
 8043e90:	40007000 	.word	0x40007000
 8043e94:	420e0044 	.word	0x420e0044

08043e98 <HAL_RCC_OscConfig>:
__weak HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
  uint32_t tickstart;

  /* Check Null pointer */
  if(RCC_OscInitStruct == NULL)
 8043e98:	2800      	cmp	r0, #0
 8043e9a:	f000 81b9 	beq.w	8044210 <HAL_RCC_OscConfig+0x378>
{
 8043e9e:	b570      	push	{r4, r5, r6, lr}
 8043ea0:	b082      	sub	sp, #8
 8043ea2:	4604      	mov	r4, r0
  }

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  /*------------------------------- HSE Configuration ------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8043ea4:	6803      	ldr	r3, [r0, #0]
 8043ea6:	f013 0f01 	tst.w	r3, #1
 8043eaa:	d03b      	beq.n	8043f24 <HAL_RCC_OscConfig+0x8c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
    /* When the HSE is used as system clock or clock source for PLL in these cases HSE will not disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) ||\
 8043eac:	4ba6      	ldr	r3, [pc, #664]	; (8044148 <HAL_RCC_OscConfig+0x2b0>)
 8043eae:	689b      	ldr	r3, [r3, #8]
 8043eb0:	f003 030c 	and.w	r3, r3, #12
 8043eb4:	2b04      	cmp	r3, #4
 8043eb6:	d02c      	beq.n	8043f12 <HAL_RCC_OscConfig+0x7a>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 8043eb8:	4ba3      	ldr	r3, [pc, #652]	; (8044148 <HAL_RCC_OscConfig+0x2b0>)
 8043eba:	689b      	ldr	r3, [r3, #8]
 8043ebc:	f003 030c 	and.w	r3, r3, #12
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) ||\
 8043ec0:	2b08      	cmp	r3, #8
 8043ec2:	d021      	beq.n	8043f08 <HAL_RCC_OscConfig+0x70>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8043ec4:	6863      	ldr	r3, [r4, #4]
 8043ec6:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8043eca:	d04f      	beq.n	8043f6c <HAL_RCC_OscConfig+0xd4>
 8043ecc:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
 8043ed0:	d052      	beq.n	8043f78 <HAL_RCC_OscConfig+0xe0>
 8043ed2:	4b9d      	ldr	r3, [pc, #628]	; (8044148 <HAL_RCC_OscConfig+0x2b0>)
 8043ed4:	681a      	ldr	r2, [r3, #0]
 8043ed6:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8043eda:	601a      	str	r2, [r3, #0]
 8043edc:	681a      	ldr	r2, [r3, #0]
 8043ede:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8043ee2:	601a      	str	r2, [r3, #0]

      /* Check the HSE State */
      if((RCC_OscInitStruct->HSEState) != RCC_HSE_OFF)
 8043ee4:	6863      	ldr	r3, [r4, #4]
 8043ee6:	2b00      	cmp	r3, #0
 8043ee8:	d050      	beq.n	8043f8c <HAL_RCC_OscConfig+0xf4>
      {
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8043eea:	f7fd f8e9 	bl	80410c0 <HAL_GetTick>
 8043eee:	4605      	mov	r5, r0

        /* Wait till HSE is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8043ef0:	4b95      	ldr	r3, [pc, #596]	; (8044148 <HAL_RCC_OscConfig+0x2b0>)
 8043ef2:	681b      	ldr	r3, [r3, #0]
 8043ef4:	f413 3f00 	tst.w	r3, #131072	; 0x20000
 8043ef8:	d114      	bne.n	8043f24 <HAL_RCC_OscConfig+0x8c>
        {
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 8043efa:	f7fd f8e1 	bl	80410c0 <HAL_GetTick>
 8043efe:	1b40      	subs	r0, r0, r5
 8043f00:	2864      	cmp	r0, #100	; 0x64
 8043f02:	d9f5      	bls.n	8043ef0 <HAL_RCC_OscConfig+0x58>
          {
            return HAL_TIMEOUT;
 8043f04:	2003      	movs	r0, #3
 8043f06:	e18a      	b.n	804421e <HAL_RCC_OscConfig+0x386>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 8043f08:	4b8f      	ldr	r3, [pc, #572]	; (8044148 <HAL_RCC_OscConfig+0x2b0>)
 8043f0a:	685b      	ldr	r3, [r3, #4]
 8043f0c:	f413 0f80 	tst.w	r3, #4194304	; 0x400000
 8043f10:	d0d8      	beq.n	8043ec4 <HAL_RCC_OscConfig+0x2c>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 8043f12:	4b8d      	ldr	r3, [pc, #564]	; (8044148 <HAL_RCC_OscConfig+0x2b0>)
 8043f14:	681b      	ldr	r3, [r3, #0]
 8043f16:	f413 3f00 	tst.w	r3, #131072	; 0x20000
 8043f1a:	d003      	beq.n	8043f24 <HAL_RCC_OscConfig+0x8c>
 8043f1c:	6863      	ldr	r3, [r4, #4]
 8043f1e:	2b00      	cmp	r3, #0
 8043f20:	f000 8178 	beq.w	8044214 <HAL_RCC_OscConfig+0x37c>
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 8043f24:	6823      	ldr	r3, [r4, #0]
 8043f26:	f013 0f02 	tst.w	r3, #2
 8043f2a:	d054      	beq.n	8043fd6 <HAL_RCC_OscConfig+0x13e>
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));

    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||\
 8043f2c:	4b86      	ldr	r3, [pc, #536]	; (8044148 <HAL_RCC_OscConfig+0x2b0>)
 8043f2e:	689b      	ldr	r3, [r3, #8]
 8043f30:	f013 0f0c 	tst.w	r3, #12
 8043f34:	d03e      	beq.n	8043fb4 <HAL_RCC_OscConfig+0x11c>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 8043f36:	4b84      	ldr	r3, [pc, #528]	; (8044148 <HAL_RCC_OscConfig+0x2b0>)
 8043f38:	689b      	ldr	r3, [r3, #8]
 8043f3a:	f003 030c 	and.w	r3, r3, #12
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||\
 8043f3e:	2b08      	cmp	r3, #8
 8043f40:	d033      	beq.n	8043faa <HAL_RCC_OscConfig+0x112>
      }
    }
    else
    {
      /* Check the HSI State */
      if((RCC_OscInitStruct->HSIState)!= RCC_HSI_OFF)
 8043f42:	68e3      	ldr	r3, [r4, #12]
 8043f44:	2b00      	cmp	r3, #0
 8043f46:	d067      	beq.n	8044018 <HAL_RCC_OscConfig+0x180>
      {
        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
 8043f48:	4b80      	ldr	r3, [pc, #512]	; (804414c <HAL_RCC_OscConfig+0x2b4>)
 8043f4a:	2201      	movs	r2, #1
 8043f4c:	601a      	str	r2, [r3, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8043f4e:	f7fd f8b7 	bl	80410c0 <HAL_GetTick>
 8043f52:	4605      	mov	r5, r0

        /* Wait till HSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8043f54:	4b7c      	ldr	r3, [pc, #496]	; (8044148 <HAL_RCC_OscConfig+0x2b0>)
 8043f56:	681b      	ldr	r3, [r3, #0]
 8043f58:	f013 0f02 	tst.w	r3, #2
 8043f5c:	d153      	bne.n	8044006 <HAL_RCC_OscConfig+0x16e>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 8043f5e:	f7fd f8af 	bl	80410c0 <HAL_GetTick>
 8043f62:	1b40      	subs	r0, r0, r5
 8043f64:	2802      	cmp	r0, #2
 8043f66:	d9f5      	bls.n	8043f54 <HAL_RCC_OscConfig+0xbc>
          {
            return HAL_TIMEOUT;
 8043f68:	2003      	movs	r0, #3
 8043f6a:	e158      	b.n	804421e <HAL_RCC_OscConfig+0x386>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8043f6c:	4a76      	ldr	r2, [pc, #472]	; (8044148 <HAL_RCC_OscConfig+0x2b0>)
 8043f6e:	6813      	ldr	r3, [r2, #0]
 8043f70:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8043f74:	6013      	str	r3, [r2, #0]
 8043f76:	e7b5      	b.n	8043ee4 <HAL_RCC_OscConfig+0x4c>
 8043f78:	4b73      	ldr	r3, [pc, #460]	; (8044148 <HAL_RCC_OscConfig+0x2b0>)
 8043f7a:	681a      	ldr	r2, [r3, #0]
 8043f7c:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
 8043f80:	601a      	str	r2, [r3, #0]
 8043f82:	681a      	ldr	r2, [r3, #0]
 8043f84:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 8043f88:	601a      	str	r2, [r3, #0]
 8043f8a:	e7ab      	b.n	8043ee4 <HAL_RCC_OscConfig+0x4c>
        tickstart = HAL_GetTick();
 8043f8c:	f7fd f898 	bl	80410c0 <HAL_GetTick>
 8043f90:	4605      	mov	r5, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 8043f92:	4b6d      	ldr	r3, [pc, #436]	; (8044148 <HAL_RCC_OscConfig+0x2b0>)
 8043f94:	681b      	ldr	r3, [r3, #0]
 8043f96:	f413 3f00 	tst.w	r3, #131072	; 0x20000
 8043f9a:	d0c3      	beq.n	8043f24 <HAL_RCC_OscConfig+0x8c>
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 8043f9c:	f7fd f890 	bl	80410c0 <HAL_GetTick>
 8043fa0:	1b40      	subs	r0, r0, r5
 8043fa2:	2864      	cmp	r0, #100	; 0x64
 8043fa4:	d9f5      	bls.n	8043f92 <HAL_RCC_OscConfig+0xfa>
            return HAL_TIMEOUT;
 8043fa6:	2003      	movs	r0, #3
 8043fa8:	e139      	b.n	804421e <HAL_RCC_OscConfig+0x386>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 8043faa:	4b67      	ldr	r3, [pc, #412]	; (8044148 <HAL_RCC_OscConfig+0x2b0>)
 8043fac:	685b      	ldr	r3, [r3, #4]
 8043fae:	f413 0f80 	tst.w	r3, #4194304	; 0x400000
 8043fb2:	d1c6      	bne.n	8043f42 <HAL_RCC_OscConfig+0xaa>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 8043fb4:	4b64      	ldr	r3, [pc, #400]	; (8044148 <HAL_RCC_OscConfig+0x2b0>)
 8043fb6:	681b      	ldr	r3, [r3, #0]
 8043fb8:	f013 0f02 	tst.w	r3, #2
 8043fbc:	d003      	beq.n	8043fc6 <HAL_RCC_OscConfig+0x12e>
 8043fbe:	68e3      	ldr	r3, [r4, #12]
 8043fc0:	2b01      	cmp	r3, #1
 8043fc2:	f040 8129 	bne.w	8044218 <HAL_RCC_OscConfig+0x380>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8043fc6:	4a60      	ldr	r2, [pc, #384]	; (8044148 <HAL_RCC_OscConfig+0x2b0>)
 8043fc8:	6813      	ldr	r3, [r2, #0]
 8043fca:	f023 03f8 	bic.w	r3, r3, #248	; 0xf8
 8043fce:	6921      	ldr	r1, [r4, #16]
 8043fd0:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
 8043fd4:	6013      	str	r3, [r2, #0]
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 8043fd6:	6823      	ldr	r3, [r4, #0]
 8043fd8:	f013 0f08 	tst.w	r3, #8
 8043fdc:	d040      	beq.n	8044060 <HAL_RCC_OscConfig+0x1c8>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if((RCC_OscInitStruct->LSIState)!= RCC_LSI_OFF)
 8043fde:	6963      	ldr	r3, [r4, #20]
 8043fe0:	b363      	cbz	r3, 804403c <HAL_RCC_OscConfig+0x1a4>
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
 8043fe2:	4b5b      	ldr	r3, [pc, #364]	; (8044150 <HAL_RCC_OscConfig+0x2b8>)
 8043fe4:	2201      	movs	r2, #1
 8043fe6:	601a      	str	r2, [r3, #0]

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8043fe8:	f7fd f86a 	bl	80410c0 <HAL_GetTick>
 8043fec:	4605      	mov	r5, r0

      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 8043fee:	4b56      	ldr	r3, [pc, #344]	; (8044148 <HAL_RCC_OscConfig+0x2b0>)
 8043ff0:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8043ff2:	f013 0f02 	tst.w	r3, #2
 8043ff6:	d133      	bne.n	8044060 <HAL_RCC_OscConfig+0x1c8>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 8043ff8:	f7fd f862 	bl	80410c0 <HAL_GetTick>
 8043ffc:	1b40      	subs	r0, r0, r5
 8043ffe:	2802      	cmp	r0, #2
 8044000:	d9f5      	bls.n	8043fee <HAL_RCC_OscConfig+0x156>
        {
          return HAL_TIMEOUT;
 8044002:	2003      	movs	r0, #3
 8044004:	e10b      	b.n	804421e <HAL_RCC_OscConfig+0x386>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8044006:	4a50      	ldr	r2, [pc, #320]	; (8044148 <HAL_RCC_OscConfig+0x2b0>)
 8044008:	6813      	ldr	r3, [r2, #0]
 804400a:	f023 03f8 	bic.w	r3, r3, #248	; 0xf8
 804400e:	6921      	ldr	r1, [r4, #16]
 8044010:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
 8044014:	6013      	str	r3, [r2, #0]
 8044016:	e7de      	b.n	8043fd6 <HAL_RCC_OscConfig+0x13e>
        __HAL_RCC_HSI_DISABLE();
 8044018:	4b4c      	ldr	r3, [pc, #304]	; (804414c <HAL_RCC_OscConfig+0x2b4>)
 804401a:	2200      	movs	r2, #0
 804401c:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 804401e:	f7fd f84f 	bl	80410c0 <HAL_GetTick>
 8044022:	4605      	mov	r5, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 8044024:	4b48      	ldr	r3, [pc, #288]	; (8044148 <HAL_RCC_OscConfig+0x2b0>)
 8044026:	681b      	ldr	r3, [r3, #0]
 8044028:	f013 0f02 	tst.w	r3, #2
 804402c:	d0d3      	beq.n	8043fd6 <HAL_RCC_OscConfig+0x13e>
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 804402e:	f7fd f847 	bl	80410c0 <HAL_GetTick>
 8044032:	1b40      	subs	r0, r0, r5
 8044034:	2802      	cmp	r0, #2
 8044036:	d9f5      	bls.n	8044024 <HAL_RCC_OscConfig+0x18c>
            return HAL_TIMEOUT;
 8044038:	2003      	movs	r0, #3
 804403a:	e0f0      	b.n	804421e <HAL_RCC_OscConfig+0x386>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
 804403c:	4b44      	ldr	r3, [pc, #272]	; (8044150 <HAL_RCC_OscConfig+0x2b8>)
 804403e:	2200      	movs	r2, #0
 8044040:	601a      	str	r2, [r3, #0]

      /* Get Start Tick */
      tickstart = HAL_GetTick();
 8044042:	f7fd f83d 	bl	80410c0 <HAL_GetTick>
 8044046:	4605      	mov	r5, r0

      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 8044048:	4b3f      	ldr	r3, [pc, #252]	; (8044148 <HAL_RCC_OscConfig+0x2b0>)
 804404a:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 804404c:	f013 0f02 	tst.w	r3, #2
 8044050:	d006      	beq.n	8044060 <HAL_RCC_OscConfig+0x1c8>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 8044052:	f7fd f835 	bl	80410c0 <HAL_GetTick>
 8044056:	1b40      	subs	r0, r0, r5
 8044058:	2802      	cmp	r0, #2
 804405a:	d9f5      	bls.n	8044048 <HAL_RCC_OscConfig+0x1b0>
        {
          return HAL_TIMEOUT;
 804405c:	2003      	movs	r0, #3
 804405e:	e0de      	b.n	804421e <HAL_RCC_OscConfig+0x386>
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 8044060:	6823      	ldr	r3, [r4, #0]
 8044062:	f013 0f04 	tst.w	r3, #4
 8044066:	d078      	beq.n	804415a <HAL_RCC_OscConfig+0x2c2>
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));

    /* Update LSE configuration in Backup Domain control register    */
    /* Requires to enable write access to Backup Domain of necessary */
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 8044068:	4b37      	ldr	r3, [pc, #220]	; (8044148 <HAL_RCC_OscConfig+0x2b0>)
 804406a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 804406c:	f013 5f80 	tst.w	r3, #268435456	; 0x10000000
 8044070:	d10d      	bne.n	804408e <HAL_RCC_OscConfig+0x1f6>
    {
      __HAL_RCC_PWR_CLK_ENABLE();
 8044072:	2300      	movs	r3, #0
 8044074:	9301      	str	r3, [sp, #4]
 8044076:	4b34      	ldr	r3, [pc, #208]	; (8044148 <HAL_RCC_OscConfig+0x2b0>)
 8044078:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 804407a:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 804407e:	641a      	str	r2, [r3, #64]	; 0x40
 8044080:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8044082:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8044086:	9301      	str	r3, [sp, #4]
 8044088:	9b01      	ldr	r3, [sp, #4]
      pwrclkchanged = SET;
 804408a:	2501      	movs	r5, #1
 804408c:	e000      	b.n	8044090 <HAL_RCC_OscConfig+0x1f8>
    FlagStatus       pwrclkchanged = RESET;
 804408e:	2500      	movs	r5, #0
    }

    if(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 8044090:	4b30      	ldr	r3, [pc, #192]	; (8044154 <HAL_RCC_OscConfig+0x2bc>)
 8044092:	681b      	ldr	r3, [r3, #0]
 8044094:	f413 7f80 	tst.w	r3, #256	; 0x100
 8044098:	d021      	beq.n	80440de <HAL_RCC_OscConfig+0x246>
        }
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 804409a:	68a3      	ldr	r3, [r4, #8]
 804409c:	2b01      	cmp	r3, #1
 804409e:	d032      	beq.n	8044106 <HAL_RCC_OscConfig+0x26e>
 80440a0:	2b05      	cmp	r3, #5
 80440a2:	d036      	beq.n	8044112 <HAL_RCC_OscConfig+0x27a>
 80440a4:	4b28      	ldr	r3, [pc, #160]	; (8044148 <HAL_RCC_OscConfig+0x2b0>)
 80440a6:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 80440a8:	f022 0201 	bic.w	r2, r2, #1
 80440ac:	671a      	str	r2, [r3, #112]	; 0x70
 80440ae:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 80440b0:	f022 0204 	bic.w	r2, r2, #4
 80440b4:	671a      	str	r2, [r3, #112]	; 0x70
    /* Check the LSE State */
    if((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
 80440b6:	68a3      	ldr	r3, [r4, #8]
 80440b8:	2b00      	cmp	r3, #0
 80440ba:	d034      	beq.n	8044126 <HAL_RCC_OscConfig+0x28e>
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 80440bc:	f7fd f800 	bl	80410c0 <HAL_GetTick>
 80440c0:	4606      	mov	r6, r0

      /* Wait till LSE is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 80440c2:	4b21      	ldr	r3, [pc, #132]	; (8044148 <HAL_RCC_OscConfig+0x2b0>)
 80440c4:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80440c6:	f013 0f02 	tst.w	r3, #2
 80440ca:	d145      	bne.n	8044158 <HAL_RCC_OscConfig+0x2c0>
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 80440cc:	f7fc fff8 	bl	80410c0 <HAL_GetTick>
 80440d0:	1b80      	subs	r0, r0, r6
 80440d2:	f241 3388 	movw	r3, #5000	; 0x1388
 80440d6:	4298      	cmp	r0, r3
 80440d8:	d9f3      	bls.n	80440c2 <HAL_RCC_OscConfig+0x22a>
        {
          return HAL_TIMEOUT;
 80440da:	2003      	movs	r0, #3
 80440dc:	e09f      	b.n	804421e <HAL_RCC_OscConfig+0x386>
      SET_BIT(PWR->CR, PWR_CR_DBP);
 80440de:	4a1d      	ldr	r2, [pc, #116]	; (8044154 <HAL_RCC_OscConfig+0x2bc>)
 80440e0:	6813      	ldr	r3, [r2, #0]
 80440e2:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80440e6:	6013      	str	r3, [r2, #0]
      tickstart = HAL_GetTick();
 80440e8:	f7fc ffea 	bl	80410c0 <HAL_GetTick>
 80440ec:	4606      	mov	r6, r0
      while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 80440ee:	4b19      	ldr	r3, [pc, #100]	; (8044154 <HAL_RCC_OscConfig+0x2bc>)
 80440f0:	681b      	ldr	r3, [r3, #0]
 80440f2:	f413 7f80 	tst.w	r3, #256	; 0x100
 80440f6:	d1d0      	bne.n	804409a <HAL_RCC_OscConfig+0x202>
        if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 80440f8:	f7fc ffe2 	bl	80410c0 <HAL_GetTick>
 80440fc:	1b80      	subs	r0, r0, r6
 80440fe:	2802      	cmp	r0, #2
 8044100:	d9f5      	bls.n	80440ee <HAL_RCC_OscConfig+0x256>
          return HAL_TIMEOUT;
 8044102:	2003      	movs	r0, #3
 8044104:	e08b      	b.n	804421e <HAL_RCC_OscConfig+0x386>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8044106:	4a10      	ldr	r2, [pc, #64]	; (8044148 <HAL_RCC_OscConfig+0x2b0>)
 8044108:	6f13      	ldr	r3, [r2, #112]	; 0x70
 804410a:	f043 0301 	orr.w	r3, r3, #1
 804410e:	6713      	str	r3, [r2, #112]	; 0x70
 8044110:	e7d1      	b.n	80440b6 <HAL_RCC_OscConfig+0x21e>
 8044112:	4b0d      	ldr	r3, [pc, #52]	; (8044148 <HAL_RCC_OscConfig+0x2b0>)
 8044114:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 8044116:	f042 0204 	orr.w	r2, r2, #4
 804411a:	671a      	str	r2, [r3, #112]	; 0x70
 804411c:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 804411e:	f042 0201 	orr.w	r2, r2, #1
 8044122:	671a      	str	r2, [r3, #112]	; 0x70
 8044124:	e7c7      	b.n	80440b6 <HAL_RCC_OscConfig+0x21e>
      }
    }
    else
    {
      /* Get Start Tick */
      tickstart = HAL_GetTick();
 8044126:	f7fc ffcb 	bl	80410c0 <HAL_GetTick>
 804412a:	4606      	mov	r6, r0

      /* Wait till LSE is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 804412c:	4b06      	ldr	r3, [pc, #24]	; (8044148 <HAL_RCC_OscConfig+0x2b0>)
 804412e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8044130:	f013 0f02 	tst.w	r3, #2
 8044134:	d010      	beq.n	8044158 <HAL_RCC_OscConfig+0x2c0>
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8044136:	f7fc ffc3 	bl	80410c0 <HAL_GetTick>
 804413a:	1b80      	subs	r0, r0, r6
 804413c:	f241 3388 	movw	r3, #5000	; 0x1388
 8044140:	4298      	cmp	r0, r3
 8044142:	d9f3      	bls.n	804412c <HAL_RCC_OscConfig+0x294>
        {
          return HAL_TIMEOUT;
 8044144:	2003      	movs	r0, #3
 8044146:	e06a      	b.n	804421e <HAL_RCC_OscConfig+0x386>
 8044148:	40023800 	.word	0x40023800
 804414c:	42470000 	.word	0x42470000
 8044150:	42470e80 	.word	0x42470e80
 8044154:	40007000 	.word	0x40007000
        }
      }
    }

    /* Restore clock configuration if changed */
    if(pwrclkchanged == SET)
 8044158:	b9e5      	cbnz	r5, 8044194 <HAL_RCC_OscConfig+0x2fc>
    }
  }
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 804415a:	69a3      	ldr	r3, [r4, #24]
 804415c:	2b00      	cmp	r3, #0
 804415e:	d05d      	beq.n	804421c <HAL_RCC_OscConfig+0x384>
  {
    /* Check if the PLL is used as system clock or not */
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
 8044160:	4a31      	ldr	r2, [pc, #196]	; (8044228 <HAL_RCC_OscConfig+0x390>)
 8044162:	6892      	ldr	r2, [r2, #8]
 8044164:	f002 020c 	and.w	r2, r2, #12
 8044168:	2a08      	cmp	r2, #8
 804416a:	d05a      	beq.n	8044222 <HAL_RCC_OscConfig+0x38a>
    {
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 804416c:	2b02      	cmp	r3, #2
 804416e:	d017      	beq.n	80441a0 <HAL_RCC_OscConfig+0x308>
        }
      }
      else
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 8044170:	4b2e      	ldr	r3, [pc, #184]	; (804422c <HAL_RCC_OscConfig+0x394>)
 8044172:	2200      	movs	r2, #0
 8044174:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8044176:	f7fc ffa3 	bl	80410c0 <HAL_GetTick>
 804417a:	4604      	mov	r4, r0

        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 804417c:	4b2a      	ldr	r3, [pc, #168]	; (8044228 <HAL_RCC_OscConfig+0x390>)
 804417e:	681b      	ldr	r3, [r3, #0]
 8044180:	f013 7f00 	tst.w	r3, #33554432	; 0x2000000
 8044184:	d042      	beq.n	804420c <HAL_RCC_OscConfig+0x374>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8044186:	f7fc ff9b 	bl	80410c0 <HAL_GetTick>
 804418a:	1b00      	subs	r0, r0, r4
 804418c:	2802      	cmp	r0, #2
 804418e:	d9f5      	bls.n	804417c <HAL_RCC_OscConfig+0x2e4>
          {
            return HAL_TIMEOUT;
 8044190:	2003      	movs	r0, #3
 8044192:	e044      	b.n	804421e <HAL_RCC_OscConfig+0x386>
      __HAL_RCC_PWR_CLK_DISABLE();
 8044194:	4a24      	ldr	r2, [pc, #144]	; (8044228 <HAL_RCC_OscConfig+0x390>)
 8044196:	6c13      	ldr	r3, [r2, #64]	; 0x40
 8044198:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 804419c:	6413      	str	r3, [r2, #64]	; 0x40
 804419e:	e7dc      	b.n	804415a <HAL_RCC_OscConfig+0x2c2>
        __HAL_RCC_PLL_DISABLE();
 80441a0:	4b22      	ldr	r3, [pc, #136]	; (804422c <HAL_RCC_OscConfig+0x394>)
 80441a2:	2200      	movs	r2, #0
 80441a4:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 80441a6:	f7fc ff8b 	bl	80410c0 <HAL_GetTick>
 80441aa:	4605      	mov	r5, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 80441ac:	4b1e      	ldr	r3, [pc, #120]	; (8044228 <HAL_RCC_OscConfig+0x390>)
 80441ae:	681b      	ldr	r3, [r3, #0]
 80441b0:	f013 7f00 	tst.w	r3, #33554432	; 0x2000000
 80441b4:	d006      	beq.n	80441c4 <HAL_RCC_OscConfig+0x32c>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 80441b6:	f7fc ff83 	bl	80410c0 <HAL_GetTick>
 80441ba:	1b40      	subs	r0, r0, r5
 80441bc:	2802      	cmp	r0, #2
 80441be:	d9f5      	bls.n	80441ac <HAL_RCC_OscConfig+0x314>
            return HAL_TIMEOUT;
 80441c0:	2003      	movs	r0, #3
 80441c2:	e02c      	b.n	804421e <HAL_RCC_OscConfig+0x386>
        WRITE_REG(RCC->PLLCFGR, (RCC_OscInitStruct->PLL.PLLSource                                            | \
 80441c4:	69e3      	ldr	r3, [r4, #28]
 80441c6:	6a22      	ldr	r2, [r4, #32]
 80441c8:	4313      	orrs	r3, r2
 80441ca:	6a62      	ldr	r2, [r4, #36]	; 0x24
 80441cc:	ea43 1382 	orr.w	r3, r3, r2, lsl #6
 80441d0:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 80441d2:	0852      	lsrs	r2, r2, #1
 80441d4:	3a01      	subs	r2, #1
 80441d6:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 80441da:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 80441dc:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 80441e0:	4a11      	ldr	r2, [pc, #68]	; (8044228 <HAL_RCC_OscConfig+0x390>)
 80441e2:	6053      	str	r3, [r2, #4]
        __HAL_RCC_PLL_ENABLE();
 80441e4:	4b11      	ldr	r3, [pc, #68]	; (804422c <HAL_RCC_OscConfig+0x394>)
 80441e6:	2201      	movs	r2, #1
 80441e8:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 80441ea:	f7fc ff69 	bl	80410c0 <HAL_GetTick>
 80441ee:	4604      	mov	r4, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 80441f0:	4b0d      	ldr	r3, [pc, #52]	; (8044228 <HAL_RCC_OscConfig+0x390>)
 80441f2:	681b      	ldr	r3, [r3, #0]
 80441f4:	f013 7f00 	tst.w	r3, #33554432	; 0x2000000
 80441f8:	d106      	bne.n	8044208 <HAL_RCC_OscConfig+0x370>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 80441fa:	f7fc ff61 	bl	80410c0 <HAL_GetTick>
 80441fe:	1b00      	subs	r0, r0, r4
 8044200:	2802      	cmp	r0, #2
 8044202:	d9f5      	bls.n	80441f0 <HAL_RCC_OscConfig+0x358>
            return HAL_TIMEOUT;
 8044204:	2003      	movs	r0, #3
 8044206:	e00a      	b.n	804421e <HAL_RCC_OscConfig+0x386>
    else
    {
      return HAL_ERROR;
    }
  }
  return HAL_OK;
 8044208:	2000      	movs	r0, #0
 804420a:	e008      	b.n	804421e <HAL_RCC_OscConfig+0x386>
 804420c:	2000      	movs	r0, #0
 804420e:	e006      	b.n	804421e <HAL_RCC_OscConfig+0x386>
    return HAL_ERROR;
 8044210:	2001      	movs	r0, #1
}
 8044212:	4770      	bx	lr
        return HAL_ERROR;
 8044214:	2001      	movs	r0, #1
 8044216:	e002      	b.n	804421e <HAL_RCC_OscConfig+0x386>
        return HAL_ERROR;
 8044218:	2001      	movs	r0, #1
 804421a:	e000      	b.n	804421e <HAL_RCC_OscConfig+0x386>
  return HAL_OK;
 804421c:	2000      	movs	r0, #0
}
 804421e:	b002      	add	sp, #8
 8044220:	bd70      	pop	{r4, r5, r6, pc}
      return HAL_ERROR;
 8044222:	2001      	movs	r0, #1
 8044224:	e7fb      	b.n	804421e <HAL_RCC_OscConfig+0x386>
 8044226:	bf00      	nop
 8044228:	40023800 	.word	0x40023800
 804422c:	42470060 	.word	0x42470060

08044230 <HAL_RCC_EnableCSS>:
  *         the Cortex-M4 NMI (Non-Maskable Interrupt) exception vector.
  * @retval None
  */
void HAL_RCC_EnableCSS(void)
{
  *(__IO uint32_t *) RCC_CR_CSSON_BB = (uint32_t)ENABLE;
 8044230:	4b01      	ldr	r3, [pc, #4]	; (8044238 <HAL_RCC_EnableCSS+0x8>)
 8044232:	2201      	movs	r2, #1
 8044234:	601a      	str	r2, [r3, #0]
}
 8044236:	4770      	bx	lr
 8044238:	4247004c 	.word	0x4247004c

0804423c <HAL_RCC_GetSysClockFreq>:
  *
  *
  * @retval SYSCLK frequency
  */
__weak uint32_t HAL_RCC_GetSysClockFreq(void)
{
 804423c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint32_t pllm = 0U, pllvco = 0U, pllp = 0U;
  uint32_t sysclockfreq = 0U;

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (RCC->CFGR & RCC_CFGR_SWS)
 804423e:	4b24      	ldr	r3, [pc, #144]	; (80442d0 <HAL_RCC_GetSysClockFreq+0x94>)
 8044240:	689b      	ldr	r3, [r3, #8]
 8044242:	f003 030c 	and.w	r3, r3, #12
 8044246:	2b04      	cmp	r3, #4
 8044248:	d03d      	beq.n	80442c6 <HAL_RCC_GetSysClockFreq+0x8a>
 804424a:	2b08      	cmp	r3, #8
 804424c:	d13d      	bne.n	80442ca <HAL_RCC_GetSysClockFreq+0x8e>
    }
    case RCC_CFGR_SWS_PLL:  /* PLL used as system clock  source */
    {
      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
      SYSCLK = PLL_VCO / PLLP */
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 804424e:	4b20      	ldr	r3, [pc, #128]	; (80442d0 <HAL_RCC_GetSysClockFreq+0x94>)
 8044250:	685a      	ldr	r2, [r3, #4]
 8044252:	f002 023f 	and.w	r2, r2, #63	; 0x3f
      if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_HSI)
 8044256:	685b      	ldr	r3, [r3, #4]
 8044258:	f413 0f80 	tst.w	r3, #4194304	; 0x400000
 804425c:	d012      	beq.n	8044284 <HAL_RCC_GetSysClockFreq+0x48>
      {
        /* HSE used as PLL clock source */
        pllvco = (uint32_t) ((((uint64_t) HSE_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 804425e:	4b1c      	ldr	r3, [pc, #112]	; (80442d0 <HAL_RCC_GetSysClockFreq+0x94>)
 8044260:	6859      	ldr	r1, [r3, #4]
 8044262:	f3c1 1188 	ubfx	r1, r1, #6, #9
 8044266:	2300      	movs	r3, #0
 8044268:	481a      	ldr	r0, [pc, #104]	; (80442d4 <HAL_RCC_GetSysClockFreq+0x98>)
 804426a:	fba1 0100 	umull	r0, r1, r1, r0
 804426e:	f7fc fd2b 	bl	8040cc8 <__aeabi_uldivmod>
      else
      {
        /* HSI used as PLL clock source */
        pllvco = (uint32_t) ((((uint64_t) HSI_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
      }
      pllp = ((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >> RCC_PLLCFGR_PLLP_Pos) + 1U) *2U);
 8044272:	4b17      	ldr	r3, [pc, #92]	; (80442d0 <HAL_RCC_GetSysClockFreq+0x94>)
 8044274:	685b      	ldr	r3, [r3, #4]
 8044276:	f3c3 4301 	ubfx	r3, r3, #16, #2
 804427a:	3301      	adds	r3, #1
 804427c:	005b      	lsls	r3, r3, #1

      sysclockfreq = pllvco/pllp;
 804427e:	fbb0 f0f3 	udiv	r0, r0, r3
      break;
 8044282:	e023      	b.n	80442cc <HAL_RCC_GetSysClockFreq+0x90>
        pllvco = (uint32_t) ((((uint64_t) HSI_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 8044284:	4b12      	ldr	r3, [pc, #72]	; (80442d0 <HAL_RCC_GetSysClockFreq+0x94>)
 8044286:	685b      	ldr	r3, [r3, #4]
 8044288:	f3c3 1388 	ubfx	r3, r3, #6, #9
 804428c:	015c      	lsls	r4, r3, #5
 804428e:	2500      	movs	r5, #0
 8044290:	1ae4      	subs	r4, r4, r3
 8044292:	f165 0500 	sbc.w	r5, r5, #0
 8044296:	01ae      	lsls	r6, r5, #6
 8044298:	ea46 6694 	orr.w	r6, r6, r4, lsr #26
 804429c:	01a7      	lsls	r7, r4, #6
 804429e:	1b38      	subs	r0, r7, r4
 80442a0:	eb66 0105 	sbc.w	r1, r6, r5
 80442a4:	00cc      	lsls	r4, r1, #3
 80442a6:	ea44 7450 	orr.w	r4, r4, r0, lsr #29
 80442aa:	00c5      	lsls	r5, r0, #3
 80442ac:	18e8      	adds	r0, r5, r3
 80442ae:	f144 0100 	adc.w	r1, r4, #0
 80442b2:	028b      	lsls	r3, r1, #10
 80442b4:	ea43 5390 	orr.w	r3, r3, r0, lsr #22
 80442b8:	0284      	lsls	r4, r0, #10
 80442ba:	4620      	mov	r0, r4
 80442bc:	4619      	mov	r1, r3
 80442be:	2300      	movs	r3, #0
 80442c0:	f7fc fd02 	bl	8040cc8 <__aeabi_uldivmod>
 80442c4:	e7d5      	b.n	8044272 <HAL_RCC_GetSysClockFreq+0x36>
      sysclockfreq = HSE_VALUE;
 80442c6:	4803      	ldr	r0, [pc, #12]	; (80442d4 <HAL_RCC_GetSysClockFreq+0x98>)
 80442c8:	e000      	b.n	80442cc <HAL_RCC_GetSysClockFreq+0x90>
  switch (RCC->CFGR & RCC_CFGR_SWS)
 80442ca:	4803      	ldr	r0, [pc, #12]	; (80442d8 <HAL_RCC_GetSysClockFreq+0x9c>)
      sysclockfreq = HSI_VALUE;
      break;
    }
  }
  return sysclockfreq;
}
 80442cc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80442ce:	bf00      	nop
 80442d0:	40023800 	.word	0x40023800
 80442d4:	017d7840 	.word	0x017d7840
 80442d8:	00f42400 	.word	0x00f42400

080442dc <HAL_RCC_ClockConfig>:
  if(RCC_ClkInitStruct == NULL)
 80442dc:	2800      	cmp	r0, #0
 80442de:	f000 809a 	beq.w	8044416 <HAL_RCC_ClockConfig+0x13a>
{
 80442e2:	b570      	push	{r4, r5, r6, lr}
 80442e4:	460d      	mov	r5, r1
 80442e6:	4604      	mov	r4, r0
  if(FLatency > __HAL_FLASH_GET_LATENCY())
 80442e8:	4b4f      	ldr	r3, [pc, #316]	; (8044428 <HAL_RCC_ClockConfig+0x14c>)
 80442ea:	681b      	ldr	r3, [r3, #0]
 80442ec:	f003 030f 	and.w	r3, r3, #15
 80442f0:	428b      	cmp	r3, r1
 80442f2:	d208      	bcs.n	8044306 <HAL_RCC_ClockConfig+0x2a>
    __HAL_FLASH_SET_LATENCY(FLatency);
 80442f4:	b2cb      	uxtb	r3, r1
 80442f6:	4a4c      	ldr	r2, [pc, #304]	; (8044428 <HAL_RCC_ClockConfig+0x14c>)
 80442f8:	7013      	strb	r3, [r2, #0]
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 80442fa:	6813      	ldr	r3, [r2, #0]
 80442fc:	f003 030f 	and.w	r3, r3, #15
 8044300:	428b      	cmp	r3, r1
 8044302:	f040 808a 	bne.w	804441a <HAL_RCC_ClockConfig+0x13e>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8044306:	6823      	ldr	r3, [r4, #0]
 8044308:	f013 0f02 	tst.w	r3, #2
 804430c:	d017      	beq.n	804433e <HAL_RCC_ClockConfig+0x62>
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 804430e:	f013 0f04 	tst.w	r3, #4
 8044312:	d004      	beq.n	804431e <HAL_RCC_ClockConfig+0x42>
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_HCLK_DIV16);
 8044314:	4a45      	ldr	r2, [pc, #276]	; (804442c <HAL_RCC_ClockConfig+0x150>)
 8044316:	6893      	ldr	r3, [r2, #8]
 8044318:	f443 53e0 	orr.w	r3, r3, #7168	; 0x1c00
 804431c:	6093      	str	r3, [r2, #8]
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 804431e:	6823      	ldr	r3, [r4, #0]
 8044320:	f013 0f08 	tst.w	r3, #8
 8044324:	d004      	beq.n	8044330 <HAL_RCC_ClockConfig+0x54>
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, (RCC_HCLK_DIV16 << 3));
 8044326:	4a41      	ldr	r2, [pc, #260]	; (804442c <HAL_RCC_ClockConfig+0x150>)
 8044328:	6893      	ldr	r3, [r2, #8]
 804432a:	f443 4360 	orr.w	r3, r3, #57344	; 0xe000
 804432e:	6093      	str	r3, [r2, #8]
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 8044330:	4a3e      	ldr	r2, [pc, #248]	; (804442c <HAL_RCC_ClockConfig+0x150>)
 8044332:	6893      	ldr	r3, [r2, #8]
 8044334:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 8044338:	68a1      	ldr	r1, [r4, #8]
 804433a:	430b      	orrs	r3, r1
 804433c:	6093      	str	r3, [r2, #8]
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 804433e:	6823      	ldr	r3, [r4, #0]
 8044340:	f013 0f01 	tst.w	r3, #1
 8044344:	d032      	beq.n	80443ac <HAL_RCC_ClockConfig+0xd0>
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8044346:	6863      	ldr	r3, [r4, #4]
 8044348:	2b01      	cmp	r3, #1
 804434a:	d021      	beq.n	8044390 <HAL_RCC_ClockConfig+0xb4>
    else if((RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)   ||
 804434c:	1e9a      	subs	r2, r3, #2
 804434e:	2a01      	cmp	r2, #1
 8044350:	d925      	bls.n	804439e <HAL_RCC_ClockConfig+0xc2>
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8044352:	4a36      	ldr	r2, [pc, #216]	; (804442c <HAL_RCC_ClockConfig+0x150>)
 8044354:	6812      	ldr	r2, [r2, #0]
 8044356:	f012 0f02 	tst.w	r2, #2
 804435a:	d060      	beq.n	804441e <HAL_RCC_ClockConfig+0x142>
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 804435c:	4933      	ldr	r1, [pc, #204]	; (804442c <HAL_RCC_ClockConfig+0x150>)
 804435e:	688a      	ldr	r2, [r1, #8]
 8044360:	f022 0203 	bic.w	r2, r2, #3
 8044364:	4313      	orrs	r3, r2
 8044366:	608b      	str	r3, [r1, #8]
    tickstart = HAL_GetTick();
 8044368:	f7fc feaa 	bl	80410c0 <HAL_GetTick>
 804436c:	4606      	mov	r6, r0
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 804436e:	4b2f      	ldr	r3, [pc, #188]	; (804442c <HAL_RCC_ClockConfig+0x150>)
 8044370:	689b      	ldr	r3, [r3, #8]
 8044372:	f003 030c 	and.w	r3, r3, #12
 8044376:	6862      	ldr	r2, [r4, #4]
 8044378:	ebb3 0f82 	cmp.w	r3, r2, lsl #2
 804437c:	d016      	beq.n	80443ac <HAL_RCC_ClockConfig+0xd0>
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 804437e:	f7fc fe9f 	bl	80410c0 <HAL_GetTick>
 8044382:	1b80      	subs	r0, r0, r6
 8044384:	f241 3388 	movw	r3, #5000	; 0x1388
 8044388:	4298      	cmp	r0, r3
 804438a:	d9f0      	bls.n	804436e <HAL_RCC_ClockConfig+0x92>
        return HAL_TIMEOUT;
 804438c:	2003      	movs	r0, #3
 804438e:	e041      	b.n	8044414 <HAL_RCC_ClockConfig+0x138>
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8044390:	4a26      	ldr	r2, [pc, #152]	; (804442c <HAL_RCC_ClockConfig+0x150>)
 8044392:	6812      	ldr	r2, [r2, #0]
 8044394:	f412 3f00 	tst.w	r2, #131072	; 0x20000
 8044398:	d1e0      	bne.n	804435c <HAL_RCC_ClockConfig+0x80>
        return HAL_ERROR;
 804439a:	2001      	movs	r0, #1
 804439c:	e03a      	b.n	8044414 <HAL_RCC_ClockConfig+0x138>
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 804439e:	4a23      	ldr	r2, [pc, #140]	; (804442c <HAL_RCC_ClockConfig+0x150>)
 80443a0:	6812      	ldr	r2, [r2, #0]
 80443a2:	f012 7f00 	tst.w	r2, #33554432	; 0x2000000
 80443a6:	d1d9      	bne.n	804435c <HAL_RCC_ClockConfig+0x80>
        return HAL_ERROR;
 80443a8:	2001      	movs	r0, #1
 80443aa:	e033      	b.n	8044414 <HAL_RCC_ClockConfig+0x138>
  if(FLatency < __HAL_FLASH_GET_LATENCY())
 80443ac:	4b1e      	ldr	r3, [pc, #120]	; (8044428 <HAL_RCC_ClockConfig+0x14c>)
 80443ae:	681b      	ldr	r3, [r3, #0]
 80443b0:	f003 030f 	and.w	r3, r3, #15
 80443b4:	42ab      	cmp	r3, r5
 80443b6:	d907      	bls.n	80443c8 <HAL_RCC_ClockConfig+0xec>
    __HAL_FLASH_SET_LATENCY(FLatency);
 80443b8:	b2ea      	uxtb	r2, r5
 80443ba:	4b1b      	ldr	r3, [pc, #108]	; (8044428 <HAL_RCC_ClockConfig+0x14c>)
 80443bc:	701a      	strb	r2, [r3, #0]
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 80443be:	681b      	ldr	r3, [r3, #0]
 80443c0:	f003 030f 	and.w	r3, r3, #15
 80443c4:	42ab      	cmp	r3, r5
 80443c6:	d12c      	bne.n	8044422 <HAL_RCC_ClockConfig+0x146>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 80443c8:	6823      	ldr	r3, [r4, #0]
 80443ca:	f013 0f04 	tst.w	r3, #4
 80443ce:	d006      	beq.n	80443de <HAL_RCC_ClockConfig+0x102>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 80443d0:	4a16      	ldr	r2, [pc, #88]	; (804442c <HAL_RCC_ClockConfig+0x150>)
 80443d2:	6893      	ldr	r3, [r2, #8]
 80443d4:	f423 53e0 	bic.w	r3, r3, #7168	; 0x1c00
 80443d8:	68e1      	ldr	r1, [r4, #12]
 80443da:	430b      	orrs	r3, r1
 80443dc:	6093      	str	r3, [r2, #8]
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 80443de:	6823      	ldr	r3, [r4, #0]
 80443e0:	f013 0f08 	tst.w	r3, #8
 80443e4:	d007      	beq.n	80443f6 <HAL_RCC_ClockConfig+0x11a>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3U));
 80443e6:	4a11      	ldr	r2, [pc, #68]	; (804442c <HAL_RCC_ClockConfig+0x150>)
 80443e8:	6893      	ldr	r3, [r2, #8]
 80443ea:	f423 4360 	bic.w	r3, r3, #57344	; 0xe000
 80443ee:	6921      	ldr	r1, [r4, #16]
 80443f0:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
 80443f4:	6093      	str	r3, [r2, #8]
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> RCC_CFGR_HPRE_Pos];
 80443f6:	f7ff ff21 	bl	804423c <HAL_RCC_GetSysClockFreq>
 80443fa:	4b0c      	ldr	r3, [pc, #48]	; (804442c <HAL_RCC_ClockConfig+0x150>)
 80443fc:	689b      	ldr	r3, [r3, #8]
 80443fe:	f3c3 1303 	ubfx	r3, r3, #4, #4
 8044402:	4a0b      	ldr	r2, [pc, #44]	; (8044430 <HAL_RCC_ClockConfig+0x154>)
 8044404:	5cd3      	ldrb	r3, [r2, r3]
 8044406:	40d8      	lsrs	r0, r3
 8044408:	4b0a      	ldr	r3, [pc, #40]	; (8044434 <HAL_RCC_ClockConfig+0x158>)
 804440a:	6018      	str	r0, [r3, #0]
  HAL_InitTick (TICK_INT_PRIORITY);
 804440c:	2000      	movs	r0, #0
 804440e:	f7fc fe0d 	bl	804102c <HAL_InitTick>
  return HAL_OK;
 8044412:	2000      	movs	r0, #0
}
 8044414:	bd70      	pop	{r4, r5, r6, pc}
    return HAL_ERROR;
 8044416:	2001      	movs	r0, #1
}
 8044418:	4770      	bx	lr
      return HAL_ERROR;
 804441a:	2001      	movs	r0, #1
 804441c:	e7fa      	b.n	8044414 <HAL_RCC_ClockConfig+0x138>
        return HAL_ERROR;
 804441e:	2001      	movs	r0, #1
 8044420:	e7f8      	b.n	8044414 <HAL_RCC_ClockConfig+0x138>
      return HAL_ERROR;
 8044422:	2001      	movs	r0, #1
 8044424:	e7f6      	b.n	8044414 <HAL_RCC_ClockConfig+0x138>
 8044426:	bf00      	nop
 8044428:	40023c00 	.word	0x40023c00
 804442c:	40023800 	.word	0x40023800
 8044430:	08058e6c 	.word	0x08058e6c
 8044434:	20003678 	.word	0x20003678

08044438 <HAL_RCC_GetHCLKFreq>:
  * @retval HCLK frequency
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
  return SystemCoreClock;
}
 8044438:	4b01      	ldr	r3, [pc, #4]	; (8044440 <HAL_RCC_GetHCLKFreq+0x8>)
 804443a:	6818      	ldr	r0, [r3, #0]
 804443c:	4770      	bx	lr
 804443e:	bf00      	nop
 8044440:	20003678 	.word	0x20003678

08044444 <HAL_RCC_GetPCLK1Freq>:
  * @note   Each time PCLK1 changes, this function must be called to update the
  *         right PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
 8044444:	b508      	push	{r3, lr}
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1)>> RCC_CFGR_PPRE1_Pos]);
 8044446:	f7ff fff7 	bl	8044438 <HAL_RCC_GetHCLKFreq>
 804444a:	4b04      	ldr	r3, [pc, #16]	; (804445c <HAL_RCC_GetPCLK1Freq+0x18>)
 804444c:	689b      	ldr	r3, [r3, #8]
 804444e:	f3c3 2382 	ubfx	r3, r3, #10, #3
 8044452:	4a03      	ldr	r2, [pc, #12]	; (8044460 <HAL_RCC_GetPCLK1Freq+0x1c>)
 8044454:	5cd3      	ldrb	r3, [r2, r3]
}
 8044456:	40d8      	lsrs	r0, r3
 8044458:	bd08      	pop	{r3, pc}
 804445a:	bf00      	nop
 804445c:	40023800 	.word	0x40023800
 8044460:	08058e7c 	.word	0x08058e7c

08044464 <HAL_RCC_CSSCallback>:
__weak void HAL_RCC_CSSCallback(void)
{
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_RCC_CSSCallback could be implemented in the user file
   */
}
 8044464:	4770      	bx	lr
	...

08044468 <HAL_RCC_NMI_IRQHandler>:
{
 8044468:	b508      	push	{r3, lr}
  if(__HAL_RCC_GET_IT(RCC_IT_CSS))
 804446a:	4b06      	ldr	r3, [pc, #24]	; (8044484 <HAL_RCC_NMI_IRQHandler+0x1c>)
 804446c:	68db      	ldr	r3, [r3, #12]
 804446e:	f013 0f80 	tst.w	r3, #128	; 0x80
 8044472:	d100      	bne.n	8044476 <HAL_RCC_NMI_IRQHandler+0xe>
}
 8044474:	bd08      	pop	{r3, pc}
    HAL_RCC_CSSCallback();
 8044476:	f7ff fff5 	bl	8044464 <HAL_RCC_CSSCallback>
    __HAL_RCC_CLEAR_IT(RCC_IT_CSS);
 804447a:	4b03      	ldr	r3, [pc, #12]	; (8044488 <HAL_RCC_NMI_IRQHandler+0x20>)
 804447c:	2280      	movs	r2, #128	; 0x80
 804447e:	701a      	strb	r2, [r3, #0]
}
 8044480:	e7f8      	b.n	8044474 <HAL_RCC_NMI_IRQHandler+0xc>
 8044482:	bf00      	nop
 8044484:	40023800 	.word	0x40023800
 8044488:	4002380e 	.word	0x4002380e

0804448c <HAL_RCCEx_PeriphCLKConfig>:
  *         the backup registers) and RCC_BDCR register are set to their reset values.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
 804448c:	b530      	push	{r4, r5, lr}
 804448e:	b083      	sub	sp, #12
 8044490:	4604      	mov	r4, r0

  /*----------------------- SAI/I2S Configuration (PLLI2S) -------------------*/
  /*----------------------- Common configuration SAI/I2S ---------------------*/
  /* In Case of SAI or I2S Clock Configuration through PLLI2S, PLLI2SN division
     factor is common parameters for both peripherals */
  if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == RCC_PERIPHCLK_I2S) ||
 8044492:	6803      	ldr	r3, [r0, #0]
 8044494:	f013 0f03 	tst.w	r3, #3
 8044498:	d114      	bne.n	80444c4 <HAL_RCCEx_PeriphCLKConfig+0x38>

  /*----------------------- SAI/LTDC Configuration (PLLSAI) ------------------*/
  /*----------------------- Common configuration SAI/LTDC --------------------*/
  /* In Case of SAI or LTDC Clock Configuration through PLLSAI, PLLSAIN division
     factor is common parameters for both peripherals */
  if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI_PLLSAI) == RCC_PERIPHCLK_SAI_PLLSAI) ||
 804449a:	6823      	ldr	r3, [r4, #0]
 804449c:	f013 0f0c 	tst.w	r3, #12
 80444a0:	d15a      	bne.n	8044558 <HAL_RCCEx_PeriphCLKConfig+0xcc>
    }
  }
  /*--------------------------------------------------------------------------*/

  /*---------------------------- RTC configuration ---------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == (RCC_PERIPHCLK_RTC))
 80444a2:	6823      	ldr	r3, [r4, #0]
 80444a4:	f013 0f20 	tst.w	r3, #32
 80444a8:	f040 80af 	bne.w	804460a <HAL_RCCEx_PeriphCLKConfig+0x17e>
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
  }
  /*--------------------------------------------------------------------------*/

  /*---------------------------- TIM configuration ---------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_TIM) == (RCC_PERIPHCLK_TIM))
 80444ac:	6823      	ldr	r3, [r4, #0]
 80444ae:	f013 0f10 	tst.w	r3, #16
 80444b2:	f000 8111 	beq.w	80446d8 <HAL_RCCEx_PeriphCLKConfig+0x24c>
  {
    __HAL_RCC_TIMCLKPRESCALER(PeriphClkInit->TIMPresSelection);
 80444b6:	f894 202c 	ldrb.w	r2, [r4, #44]	; 0x2c
 80444ba:	4b88      	ldr	r3, [pc, #544]	; (80446dc <HAL_RCCEx_PeriphCLKConfig+0x250>)
 80444bc:	601a      	str	r2, [r3, #0]
  }
  return HAL_OK;
 80444be:	2000      	movs	r0, #0
}
 80444c0:	b003      	add	sp, #12
 80444c2:	bd30      	pop	{r4, r5, pc}
    __HAL_RCC_PLLI2S_DISABLE();
 80444c4:	4b86      	ldr	r3, [pc, #536]	; (80446e0 <HAL_RCCEx_PeriphCLKConfig+0x254>)
 80444c6:	2200      	movs	r2, #0
 80444c8:	601a      	str	r2, [r3, #0]
    tickstart = HAL_GetTick();
 80444ca:	f7fc fdf9 	bl	80410c0 <HAL_GetTick>
 80444ce:	4605      	mov	r5, r0
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  != RESET)
 80444d0:	4b84      	ldr	r3, [pc, #528]	; (80446e4 <HAL_RCCEx_PeriphCLKConfig+0x258>)
 80444d2:	681b      	ldr	r3, [r3, #0]
 80444d4:	f013 6f00 	tst.w	r3, #134217728	; 0x8000000
 80444d8:	d006      	beq.n	80444e8 <HAL_RCCEx_PeriphCLKConfig+0x5c>
      if((HAL_GetTick() - tickstart ) > PLLI2S_TIMEOUT_VALUE)
 80444da:	f7fc fdf1 	bl	80410c0 <HAL_GetTick>
 80444de:	1b43      	subs	r3, r0, r5
 80444e0:	2b02      	cmp	r3, #2
 80444e2:	d9f5      	bls.n	80444d0 <HAL_RCCEx_PeriphCLKConfig+0x44>
        return HAL_TIMEOUT;
 80444e4:	2003      	movs	r0, #3
 80444e6:	e7eb      	b.n	80444c0 <HAL_RCCEx_PeriphCLKConfig+0x34>
    if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == (RCC_PERIPHCLK_I2S))
 80444e8:	6823      	ldr	r3, [r4, #0]
 80444ea:	f013 0f01 	tst.w	r3, #1
 80444ee:	d007      	beq.n	8044500 <HAL_RCCEx_PeriphCLKConfig+0x74>
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , PeriphClkInit->PLLI2S.PLLI2SR);
 80444f0:	6862      	ldr	r2, [r4, #4]
 80444f2:	68a3      	ldr	r3, [r4, #8]
 80444f4:	071b      	lsls	r3, r3, #28
 80444f6:	ea43 1382 	orr.w	r3, r3, r2, lsl #6
 80444fa:	4a7a      	ldr	r2, [pc, #488]	; (80446e4 <HAL_RCCEx_PeriphCLKConfig+0x258>)
 80444fc:	f8c2 3084 	str.w	r3, [r2, #132]	; 0x84
    if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI_PLLI2S) == (RCC_PERIPHCLK_SAI_PLLI2S))
 8044500:	6823      	ldr	r3, [r4, #0]
 8044502:	f013 0f02 	tst.w	r3, #2
 8044506:	d015      	beq.n	8044534 <HAL_RCCEx_PeriphCLKConfig+0xa8>
      tmpreg1 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> RCC_PLLI2SCFGR_PLLI2SR_Pos);
 8044508:	4a76      	ldr	r2, [pc, #472]	; (80446e4 <HAL_RCCEx_PeriphCLKConfig+0x258>)
 804450a:	f8d2 1084 	ldr.w	r1, [r2, #132]	; 0x84
      __HAL_RCC_PLLI2S_SAICLK_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , PeriphClkInit->PLLI2S.PLLI2SQ , tmpreg1);
 804450e:	6860      	ldr	r0, [r4, #4]
 8044510:	68e3      	ldr	r3, [r4, #12]
 8044512:	061b      	lsls	r3, r3, #24
 8044514:	ea43 1380 	orr.w	r3, r3, r0, lsl #6
 8044518:	f001 41e0 	and.w	r1, r1, #1879048192	; 0x70000000
 804451c:	430b      	orrs	r3, r1
 804451e:	f8c2 3084 	str.w	r3, [r2, #132]	; 0x84
      __HAL_RCC_PLLI2S_PLLSAICLKDIVQ_CONFIG(PeriphClkInit->PLLI2SDivQ);
 8044522:	f8d2 308c 	ldr.w	r3, [r2, #140]	; 0x8c
 8044526:	f023 031f 	bic.w	r3, r3, #31
 804452a:	69e1      	ldr	r1, [r4, #28]
 804452c:	3901      	subs	r1, #1
 804452e:	430b      	orrs	r3, r1
 8044530:	f8c2 308c 	str.w	r3, [r2, #140]	; 0x8c
    __HAL_RCC_PLLI2S_ENABLE();
 8044534:	4b6a      	ldr	r3, [pc, #424]	; (80446e0 <HAL_RCCEx_PeriphCLKConfig+0x254>)
 8044536:	2201      	movs	r2, #1
 8044538:	601a      	str	r2, [r3, #0]
    tickstart = HAL_GetTick();
 804453a:	f7fc fdc1 	bl	80410c0 <HAL_GetTick>
 804453e:	4605      	mov	r5, r0
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  == RESET)
 8044540:	4b68      	ldr	r3, [pc, #416]	; (80446e4 <HAL_RCCEx_PeriphCLKConfig+0x258>)
 8044542:	681b      	ldr	r3, [r3, #0]
 8044544:	f013 6f00 	tst.w	r3, #134217728	; 0x8000000
 8044548:	d1a7      	bne.n	804449a <HAL_RCCEx_PeriphCLKConfig+0xe>
      if((HAL_GetTick() - tickstart ) > PLLI2S_TIMEOUT_VALUE)
 804454a:	f7fc fdb9 	bl	80410c0 <HAL_GetTick>
 804454e:	1b40      	subs	r0, r0, r5
 8044550:	2802      	cmp	r0, #2
 8044552:	d9f5      	bls.n	8044540 <HAL_RCCEx_PeriphCLKConfig+0xb4>
        return HAL_TIMEOUT;
 8044554:	2003      	movs	r0, #3
 8044556:	e7b3      	b.n	80444c0 <HAL_RCCEx_PeriphCLKConfig+0x34>
    __HAL_RCC_PLLSAI_DISABLE();
 8044558:	4b63      	ldr	r3, [pc, #396]	; (80446e8 <HAL_RCCEx_PeriphCLKConfig+0x25c>)
 804455a:	2200      	movs	r2, #0
 804455c:	601a      	str	r2, [r3, #0]
    tickstart = HAL_GetTick();
 804455e:	f7fc fdaf 	bl	80410c0 <HAL_GetTick>
 8044562:	4605      	mov	r5, r0
    while(__HAL_RCC_PLLSAI_GET_FLAG() != RESET)
 8044564:	4b5f      	ldr	r3, [pc, #380]	; (80446e4 <HAL_RCCEx_PeriphCLKConfig+0x258>)
 8044566:	681b      	ldr	r3, [r3, #0]
 8044568:	f013 5f00 	tst.w	r3, #536870912	; 0x20000000
 804456c:	d006      	beq.n	804457c <HAL_RCCEx_PeriphCLKConfig+0xf0>
      if((HAL_GetTick() - tickstart ) > PLLSAI_TIMEOUT_VALUE)
 804456e:	f7fc fda7 	bl	80410c0 <HAL_GetTick>
 8044572:	1b43      	subs	r3, r0, r5
 8044574:	2b02      	cmp	r3, #2
 8044576:	d9f5      	bls.n	8044564 <HAL_RCCEx_PeriphCLKConfig+0xd8>
        return HAL_TIMEOUT;
 8044578:	2003      	movs	r0, #3
 804457a:	e7a1      	b.n	80444c0 <HAL_RCCEx_PeriphCLKConfig+0x34>
    if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI_PLLSAI) == (RCC_PERIPHCLK_SAI_PLLSAI))
 804457c:	6823      	ldr	r3, [r4, #0]
 804457e:	f013 0f04 	tst.w	r3, #4
 8044582:	d016      	beq.n	80445b2 <HAL_RCCEx_PeriphCLKConfig+0x126>
      tmpreg1 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIR) >> RCC_PLLSAICFGR_PLLSAIR_Pos);
 8044584:	4a57      	ldr	r2, [pc, #348]	; (80446e4 <HAL_RCCEx_PeriphCLKConfig+0x258>)
 8044586:	f8d2 1088 	ldr.w	r1, [r2, #136]	; 0x88
      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIN , PeriphClkInit->PLLSAI.PLLSAIQ, tmpreg1);
 804458a:	6920      	ldr	r0, [r4, #16]
 804458c:	6963      	ldr	r3, [r4, #20]
 804458e:	061b      	lsls	r3, r3, #24
 8044590:	ea43 1380 	orr.w	r3, r3, r0, lsl #6
 8044594:	f001 41e0 	and.w	r1, r1, #1879048192	; 0x70000000
 8044598:	430b      	orrs	r3, r1
 804459a:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
      __HAL_RCC_PLLSAI_PLLSAICLKDIVQ_CONFIG(PeriphClkInit->PLLSAIDivQ);
 804459e:	f8d2 308c 	ldr.w	r3, [r2, #140]	; 0x8c
 80445a2:	f423 53f8 	bic.w	r3, r3, #7936	; 0x1f00
 80445a6:	6a21      	ldr	r1, [r4, #32]
 80445a8:	3901      	subs	r1, #1
 80445aa:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 80445ae:	f8c2 308c 	str.w	r3, [r2, #140]	; 0x8c
    if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LTDC) == (RCC_PERIPHCLK_LTDC))
 80445b2:	6823      	ldr	r3, [r4, #0]
 80445b4:	f013 0f08 	tst.w	r3, #8
 80445b8:	d014      	beq.n	80445e4 <HAL_RCCEx_PeriphCLKConfig+0x158>
      tmpreg1 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIQ) >> RCC_PLLSAICFGR_PLLSAIQ_Pos);
 80445ba:	4a4a      	ldr	r2, [pc, #296]	; (80446e4 <HAL_RCCEx_PeriphCLKConfig+0x258>)
 80445bc:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIN , tmpreg1, PeriphClkInit->PLLSAI.PLLSAIR);
 80445c0:	6921      	ldr	r1, [r4, #16]
 80445c2:	f003 6370 	and.w	r3, r3, #251658240	; 0xf000000
 80445c6:	ea43 1381 	orr.w	r3, r3, r1, lsl #6
 80445ca:	69a1      	ldr	r1, [r4, #24]
 80445cc:	ea43 7301 	orr.w	r3, r3, r1, lsl #28
 80445d0:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
      __HAL_RCC_PLLSAI_PLLSAICLKDIVR_CONFIG(PeriphClkInit->PLLSAIDivR);
 80445d4:	f8d2 308c 	ldr.w	r3, [r2, #140]	; 0x8c
 80445d8:	f423 3340 	bic.w	r3, r3, #196608	; 0x30000
 80445dc:	6a61      	ldr	r1, [r4, #36]	; 0x24
 80445de:	430b      	orrs	r3, r1
 80445e0:	f8c2 308c 	str.w	r3, [r2, #140]	; 0x8c
    __HAL_RCC_PLLSAI_ENABLE();
 80445e4:	4b40      	ldr	r3, [pc, #256]	; (80446e8 <HAL_RCCEx_PeriphCLKConfig+0x25c>)
 80445e6:	2201      	movs	r2, #1
 80445e8:	601a      	str	r2, [r3, #0]
    tickstart = HAL_GetTick();
 80445ea:	f7fc fd69 	bl	80410c0 <HAL_GetTick>
 80445ee:	4605      	mov	r5, r0
    while(__HAL_RCC_PLLSAI_GET_FLAG() == RESET)
 80445f0:	4b3c      	ldr	r3, [pc, #240]	; (80446e4 <HAL_RCCEx_PeriphCLKConfig+0x258>)
 80445f2:	681b      	ldr	r3, [r3, #0]
 80445f4:	f013 5f00 	tst.w	r3, #536870912	; 0x20000000
 80445f8:	f47f af53 	bne.w	80444a2 <HAL_RCCEx_PeriphCLKConfig+0x16>
      if((HAL_GetTick() - tickstart ) > PLLSAI_TIMEOUT_VALUE)
 80445fc:	f7fc fd60 	bl	80410c0 <HAL_GetTick>
 8044600:	1b40      	subs	r0, r0, r5
 8044602:	2802      	cmp	r0, #2
 8044604:	d9f4      	bls.n	80445f0 <HAL_RCCEx_PeriphCLKConfig+0x164>
        return HAL_TIMEOUT;
 8044606:	2003      	movs	r0, #3
 8044608:	e75a      	b.n	80444c0 <HAL_RCCEx_PeriphCLKConfig+0x34>
    __HAL_RCC_PWR_CLK_ENABLE();
 804460a:	2300      	movs	r3, #0
 804460c:	9301      	str	r3, [sp, #4]
 804460e:	4b35      	ldr	r3, [pc, #212]	; (80446e4 <HAL_RCCEx_PeriphCLKConfig+0x258>)
 8044610:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8044612:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8044616:	641a      	str	r2, [r3, #64]	; 0x40
 8044618:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 804461a:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 804461e:	9301      	str	r3, [sp, #4]
 8044620:	9b01      	ldr	r3, [sp, #4]
    PWR->CR |= PWR_CR_DBP;
 8044622:	4a32      	ldr	r2, [pc, #200]	; (80446ec <HAL_RCCEx_PeriphCLKConfig+0x260>)
 8044624:	6813      	ldr	r3, [r2, #0]
 8044626:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 804462a:	6013      	str	r3, [r2, #0]
    tickstart = HAL_GetTick();
 804462c:	f7fc fd48 	bl	80410c0 <HAL_GetTick>
 8044630:	4605      	mov	r5, r0
    while((PWR->CR & PWR_CR_DBP) == RESET)
 8044632:	4b2e      	ldr	r3, [pc, #184]	; (80446ec <HAL_RCCEx_PeriphCLKConfig+0x260>)
 8044634:	681b      	ldr	r3, [r3, #0]
 8044636:	f413 7f80 	tst.w	r3, #256	; 0x100
 804463a:	d106      	bne.n	804464a <HAL_RCCEx_PeriphCLKConfig+0x1be>
      if((HAL_GetTick() - tickstart ) > RCC_DBP_TIMEOUT_VALUE)
 804463c:	f7fc fd40 	bl	80410c0 <HAL_GetTick>
 8044640:	1b40      	subs	r0, r0, r5
 8044642:	2802      	cmp	r0, #2
 8044644:	d9f5      	bls.n	8044632 <HAL_RCCEx_PeriphCLKConfig+0x1a6>
        return HAL_TIMEOUT;
 8044646:	2003      	movs	r0, #3
 8044648:	e73a      	b.n	80444c0 <HAL_RCCEx_PeriphCLKConfig+0x34>
    tmpreg1 = (RCC->BDCR & RCC_BDCR_RTCSEL);
 804464a:	4b26      	ldr	r3, [pc, #152]	; (80446e4 <HAL_RCCEx_PeriphCLKConfig+0x258>)
 804464c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    if((tmpreg1 != 0x00000000U) && ((tmpreg1) != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL)))
 804464e:	f413 7340 	ands.w	r3, r3, #768	; 0x300
 8044652:	d012      	beq.n	804467a <HAL_RCCEx_PeriphCLKConfig+0x1ee>
 8044654:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 8044656:	f402 7240 	and.w	r2, r2, #768	; 0x300
 804465a:	429a      	cmp	r2, r3
 804465c:	d00d      	beq.n	804467a <HAL_RCCEx_PeriphCLKConfig+0x1ee>
      tmpreg1 = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
 804465e:	4b21      	ldr	r3, [pc, #132]	; (80446e4 <HAL_RCCEx_PeriphCLKConfig+0x258>)
 8044660:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 8044662:	f422 7240 	bic.w	r2, r2, #768	; 0x300
      __HAL_RCC_BACKUPRESET_FORCE();
 8044666:	4922      	ldr	r1, [pc, #136]	; (80446f0 <HAL_RCCEx_PeriphCLKConfig+0x264>)
 8044668:	2001      	movs	r0, #1
 804466a:	6008      	str	r0, [r1, #0]
      __HAL_RCC_BACKUPRESET_RELEASE();
 804466c:	2000      	movs	r0, #0
 804466e:	6008      	str	r0, [r1, #0]
      RCC->BDCR = tmpreg1;
 8044670:	671a      	str	r2, [r3, #112]	; 0x70
      if(HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSEON))
 8044672:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8044674:	f013 0f01 	tst.w	r3, #1
 8044678:	d112      	bne.n	80446a0 <HAL_RCCEx_PeriphCLKConfig+0x214>
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 804467a:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 804467c:	f403 7240 	and.w	r2, r3, #768	; 0x300
 8044680:	f5b2 7f40 	cmp.w	r2, #768	; 0x300
 8044684:	d01d      	beq.n	80446c2 <HAL_RCCEx_PeriphCLKConfig+0x236>
 8044686:	4a17      	ldr	r2, [pc, #92]	; (80446e4 <HAL_RCCEx_PeriphCLKConfig+0x258>)
 8044688:	6893      	ldr	r3, [r2, #8]
 804468a:	f423 13f8 	bic.w	r3, r3, #2031616	; 0x1f0000
 804468e:	6093      	str	r3, [r2, #8]
 8044690:	4914      	ldr	r1, [pc, #80]	; (80446e4 <HAL_RCCEx_PeriphCLKConfig+0x258>)
 8044692:	6f0b      	ldr	r3, [r1, #112]	; 0x70
 8044694:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 8044696:	f3c2 020b 	ubfx	r2, r2, #0, #12
 804469a:	4313      	orrs	r3, r2
 804469c:	670b      	str	r3, [r1, #112]	; 0x70
 804469e:	e705      	b.n	80444ac <HAL_RCCEx_PeriphCLKConfig+0x20>
        tickstart = HAL_GetTick();
 80446a0:	f7fc fd0e 	bl	80410c0 <HAL_GetTick>
 80446a4:	4605      	mov	r5, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 80446a6:	4b0f      	ldr	r3, [pc, #60]	; (80446e4 <HAL_RCCEx_PeriphCLKConfig+0x258>)
 80446a8:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80446aa:	f013 0f02 	tst.w	r3, #2
 80446ae:	d1e4      	bne.n	804467a <HAL_RCCEx_PeriphCLKConfig+0x1ee>
          if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 80446b0:	f7fc fd06 	bl	80410c0 <HAL_GetTick>
 80446b4:	1b40      	subs	r0, r0, r5
 80446b6:	f241 3388 	movw	r3, #5000	; 0x1388
 80446ba:	4298      	cmp	r0, r3
 80446bc:	d9f3      	bls.n	80446a6 <HAL_RCCEx_PeriphCLKConfig+0x21a>
            return HAL_TIMEOUT;
 80446be:	2003      	movs	r0, #3
 80446c0:	e6fe      	b.n	80444c0 <HAL_RCCEx_PeriphCLKConfig+0x34>
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 80446c2:	4908      	ldr	r1, [pc, #32]	; (80446e4 <HAL_RCCEx_PeriphCLKConfig+0x258>)
 80446c4:	688a      	ldr	r2, [r1, #8]
 80446c6:	f422 12f8 	bic.w	r2, r2, #2031616	; 0x1f0000
 80446ca:	f023 4370 	bic.w	r3, r3, #4026531840	; 0xf0000000
 80446ce:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 80446d2:	4313      	orrs	r3, r2
 80446d4:	608b      	str	r3, [r1, #8]
 80446d6:	e7db      	b.n	8044690 <HAL_RCCEx_PeriphCLKConfig+0x204>
  return HAL_OK;
 80446d8:	2000      	movs	r0, #0
 80446da:	e6f1      	b.n	80444c0 <HAL_RCCEx_PeriphCLKConfig+0x34>
 80446dc:	424711e0 	.word	0x424711e0
 80446e0:	42470068 	.word	0x42470068
 80446e4:	40023800 	.word	0x40023800
 80446e8:	42470070 	.word	0x42470070
 80446ec:	40007000 	.word	0x40007000
 80446f0:	42470e40 	.word	0x42470e40

080446f4 <HAL_RTC_AlarmIRQHandler>:
  * @param  hrtc pointer to a RTC_HandleTypeDef structure that contains
  *                the configuration information for RTC.
  * @retval None
  */
void HAL_RTC_AlarmIRQHandler(RTC_HandleTypeDef* hrtc)
{
 80446f4:	b510      	push	{r4, lr}
 80446f6:	4604      	mov	r4, r0
  if(__HAL_RTC_ALARM_GET_IT(hrtc, RTC_IT_ALRA))
 80446f8:	6803      	ldr	r3, [r0, #0]
 80446fa:	68da      	ldr	r2, [r3, #12]
 80446fc:	f412 7f80 	tst.w	r2, #256	; 0x100
 8044700:	d003      	beq.n	804470a <HAL_RTC_AlarmIRQHandler+0x16>
  {
    /* Get the status of the Interrupt */
    if((uint32_t)(hrtc->Instance->CR & RTC_IT_ALRA) != (uint32_t)RESET)
 8044702:	689b      	ldr	r3, [r3, #8]
 8044704:	f413 5f80 	tst.w	r3, #4096	; 0x1000
 8044708:	d10f      	bne.n	804472a <HAL_RTC_AlarmIRQHandler+0x36>
      /* Clear the Alarm interrupt pending bit */
      __HAL_RTC_ALARM_CLEAR_FLAG(hrtc,RTC_FLAG_ALRAF);
    }
  }

  if(__HAL_RTC_ALARM_GET_IT(hrtc, RTC_IT_ALRB))
 804470a:	6823      	ldr	r3, [r4, #0]
 804470c:	68da      	ldr	r2, [r3, #12]
 804470e:	f412 7f00 	tst.w	r2, #512	; 0x200
 8044712:	d003      	beq.n	804471c <HAL_RTC_AlarmIRQHandler+0x28>
  {
    /* Get the status of the Interrupt */
    if((uint32_t)(hrtc->Instance->CR & RTC_IT_ALRB) != (uint32_t)RESET)
 8044714:	689b      	ldr	r3, [r3, #8]
 8044716:	f413 5f00 	tst.w	r3, #8192	; 0x2000
 804471a:	d10f      	bne.n	804473c <HAL_RTC_AlarmIRQHandler+0x48>
      __HAL_RTC_ALARM_CLEAR_FLAG(hrtc,RTC_FLAG_ALRBF);
    }
  }

  /* Clear the EXTI's line Flag for RTC Alarm */
  __HAL_RTC_ALARM_EXTI_CLEAR_FLAG();
 804471c:	4b0c      	ldr	r3, [pc, #48]	; (8044750 <HAL_RTC_AlarmIRQHandler+0x5c>)
 804471e:	f44f 3200 	mov.w	r2, #131072	; 0x20000
 8044722:	615a      	str	r2, [r3, #20]

  /* Change RTC state */
  hrtc->State = HAL_RTC_STATE_READY;
 8044724:	2301      	movs	r3, #1
 8044726:	7763      	strb	r3, [r4, #29]
}
 8044728:	bd10      	pop	{r4, pc}
      HAL_RTC_AlarmAEventCallback(hrtc);
 804472a:	f00c fd12 	bl	8051152 <HAL_RTC_AlarmAEventCallback>
      __HAL_RTC_ALARM_CLEAR_FLAG(hrtc,RTC_FLAG_ALRAF);
 804472e:	6822      	ldr	r2, [r4, #0]
 8044730:	68d3      	ldr	r3, [r2, #12]
 8044732:	b2db      	uxtb	r3, r3
 8044734:	f463 73c0 	orn	r3, r3, #384	; 0x180
 8044738:	60d3      	str	r3, [r2, #12]
 804473a:	e7e6      	b.n	804470a <HAL_RTC_AlarmIRQHandler+0x16>
      HAL_RTCEx_AlarmBEventCallback(hrtc);
 804473c:	4620      	mov	r0, r4
 804473e:	f000 fb64 	bl	8044e0a <HAL_RTCEx_AlarmBEventCallback>
      __HAL_RTC_ALARM_CLEAR_FLAG(hrtc,RTC_FLAG_ALRBF);
 8044742:	6822      	ldr	r2, [r4, #0]
 8044744:	68d3      	ldr	r3, [r2, #12]
 8044746:	b2db      	uxtb	r3, r3
 8044748:	f463 7320 	orn	r3, r3, #640	; 0x280
 804474c:	60d3      	str	r3, [r2, #12]
 804474e:	e7e5      	b.n	804471c <HAL_RTC_AlarmIRQHandler+0x28>
 8044750:	40013c00 	.word	0x40013c00

08044754 <HAL_RTC_WaitForSynchro>:
  * @param  hrtc pointer to a RTC_HandleTypeDef structure that contains
  *                the configuration information for RTC.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTC_WaitForSynchro(RTC_HandleTypeDef* hrtc)
{
 8044754:	b538      	push	{r3, r4, r5, lr}
 8044756:	4604      	mov	r4, r0
  uint32_t tickstart = 0U;

  /* Clear RSF flag */
  hrtc->Instance->ISR &= (uint32_t)RTC_RSF_MASK;
 8044758:	6802      	ldr	r2, [r0, #0]
 804475a:	68d3      	ldr	r3, [r2, #12]
 804475c:	f023 03a0 	bic.w	r3, r3, #160	; 0xa0
 8044760:	60d3      	str	r3, [r2, #12]

    /* Get tick */
    tickstart = HAL_GetTick();
 8044762:	f7fc fcad 	bl	80410c0 <HAL_GetTick>
 8044766:	4605      	mov	r5, r0

  /* Wait the registers to be synchronised */
  while((hrtc->Instance->ISR & RTC_ISR_RSF) == (uint32_t)RESET)
 8044768:	6823      	ldr	r3, [r4, #0]
 804476a:	68db      	ldr	r3, [r3, #12]
 804476c:	f013 0f20 	tst.w	r3, #32
 8044770:	d107      	bne.n	8044782 <HAL_RTC_WaitForSynchro+0x2e>
  {
    if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
 8044772:	f7fc fca5 	bl	80410c0 <HAL_GetTick>
 8044776:	1b40      	subs	r0, r0, r5
 8044778:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 804477c:	d9f4      	bls.n	8044768 <HAL_RTC_WaitForSynchro+0x14>
    {
      return HAL_TIMEOUT;
 804477e:	2003      	movs	r0, #3
 8044780:	e000      	b.n	8044784 <HAL_RTC_WaitForSynchro+0x30>
    }
  }

  return HAL_OK;
 8044782:	2000      	movs	r0, #0
}
 8044784:	bd38      	pop	{r3, r4, r5, pc}

08044786 <RTC_EnterInitMode>:
  * @param  hrtc pointer to a RTC_HandleTypeDef structure that contains
  *                the configuration information for RTC.
  * @retval HAL status
  */
HAL_StatusTypeDef RTC_EnterInitMode(RTC_HandleTypeDef* hrtc)
{
 8044786:	b538      	push	{r3, r4, r5, lr}
  uint32_t tickstart = 0U;

  /* Check if the Initialization mode is set */
  if((hrtc->Instance->ISR & RTC_ISR_INITF) == (uint32_t)RESET)
 8044788:	6803      	ldr	r3, [r0, #0]
 804478a:	68da      	ldr	r2, [r3, #12]
 804478c:	f012 0f40 	tst.w	r2, #64	; 0x40
 8044790:	d001      	beq.n	8044796 <RTC_EnterInitMode+0x10>
        return HAL_TIMEOUT;
      }
    }
  }

  return HAL_OK;
 8044792:	2000      	movs	r0, #0
}
 8044794:	bd38      	pop	{r3, r4, r5, pc}
 8044796:	4604      	mov	r4, r0
    hrtc->Instance->ISR = (uint32_t)RTC_INIT_MASK;
 8044798:	f04f 32ff 	mov.w	r2, #4294967295
 804479c:	60da      	str	r2, [r3, #12]
    tickstart = HAL_GetTick();
 804479e:	f7fc fc8f 	bl	80410c0 <HAL_GetTick>
 80447a2:	4605      	mov	r5, r0
    while((hrtc->Instance->ISR & RTC_ISR_INITF) == (uint32_t)RESET)
 80447a4:	6823      	ldr	r3, [r4, #0]
 80447a6:	68db      	ldr	r3, [r3, #12]
 80447a8:	f013 0f40 	tst.w	r3, #64	; 0x40
 80447ac:	d107      	bne.n	80447be <RTC_EnterInitMode+0x38>
      if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
 80447ae:	f7fc fc87 	bl	80410c0 <HAL_GetTick>
 80447b2:	1b43      	subs	r3, r0, r5
 80447b4:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 80447b8:	d9f4      	bls.n	80447a4 <RTC_EnterInitMode+0x1e>
        return HAL_TIMEOUT;
 80447ba:	2003      	movs	r0, #3
 80447bc:	e7ea      	b.n	8044794 <RTC_EnterInitMode+0xe>
  return HAL_OK;
 80447be:	2000      	movs	r0, #0
 80447c0:	e7e8      	b.n	8044794 <RTC_EnterInitMode+0xe>

080447c2 <HAL_RTC_Init>:
{
 80447c2:	b538      	push	{r3, r4, r5, lr}
  if(hrtc == NULL)
 80447c4:	2800      	cmp	r0, #0
 80447c6:	d05c      	beq.n	8044882 <HAL_RTC_Init+0xc0>
 80447c8:	4604      	mov	r4, r0
  if(hrtc->State == HAL_RTC_STATE_RESET)
 80447ca:	7f43      	ldrb	r3, [r0, #29]
 80447cc:	2b00      	cmp	r3, #0
 80447ce:	d041      	beq.n	8044854 <HAL_RTC_Init+0x92>
  hrtc->State = HAL_RTC_STATE_BUSY;
 80447d0:	2302      	movs	r3, #2
 80447d2:	7763      	strb	r3, [r4, #29]
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 80447d4:	6823      	ldr	r3, [r4, #0]
 80447d6:	22ca      	movs	r2, #202	; 0xca
 80447d8:	625a      	str	r2, [r3, #36]	; 0x24
 80447da:	6823      	ldr	r3, [r4, #0]
 80447dc:	2253      	movs	r2, #83	; 0x53
 80447de:	625a      	str	r2, [r3, #36]	; 0x24
  if(RTC_EnterInitMode(hrtc) != HAL_OK)
 80447e0:	4620      	mov	r0, r4
 80447e2:	f7ff ffd0 	bl	8044786 <RTC_EnterInitMode>
 80447e6:	4605      	mov	r5, r0
 80447e8:	2800      	cmp	r0, #0
 80447ea:	d137      	bne.n	804485c <HAL_RTC_Init+0x9a>
    hrtc->Instance->CR &= ((uint32_t)~(RTC_CR_FMT | RTC_CR_OSEL | RTC_CR_POL));
 80447ec:	6822      	ldr	r2, [r4, #0]
 80447ee:	6893      	ldr	r3, [r2, #8]
 80447f0:	f423 03e0 	bic.w	r3, r3, #7340032	; 0x700000
 80447f4:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 80447f8:	6093      	str	r3, [r2, #8]
    hrtc->Instance->CR |= (uint32_t)(hrtc->Init.HourFormat | hrtc->Init.OutPut | hrtc->Init.OutPutPolarity);
 80447fa:	6821      	ldr	r1, [r4, #0]
 80447fc:	688a      	ldr	r2, [r1, #8]
 80447fe:	6863      	ldr	r3, [r4, #4]
 8044800:	6920      	ldr	r0, [r4, #16]
 8044802:	4303      	orrs	r3, r0
 8044804:	6960      	ldr	r0, [r4, #20]
 8044806:	4303      	orrs	r3, r0
 8044808:	4313      	orrs	r3, r2
 804480a:	608b      	str	r3, [r1, #8]
    hrtc->Instance->PRER = (uint32_t)(hrtc->Init.SynchPrediv);
 804480c:	6823      	ldr	r3, [r4, #0]
 804480e:	68e2      	ldr	r2, [r4, #12]
 8044810:	611a      	str	r2, [r3, #16]
    hrtc->Instance->PRER |= (uint32_t)(hrtc->Init.AsynchPrediv << 16U);
 8044812:	6822      	ldr	r2, [r4, #0]
 8044814:	6913      	ldr	r3, [r2, #16]
 8044816:	68a1      	ldr	r1, [r4, #8]
 8044818:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 804481c:	6113      	str	r3, [r2, #16]
    hrtc->Instance->ISR &= (uint32_t)~RTC_ISR_INIT;
 804481e:	6822      	ldr	r2, [r4, #0]
 8044820:	68d3      	ldr	r3, [r2, #12]
 8044822:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8044826:	60d3      	str	r3, [r2, #12]
    if((hrtc->Instance->CR & RTC_CR_BYPSHAD) == RESET)
 8044828:	6823      	ldr	r3, [r4, #0]
 804482a:	689b      	ldr	r3, [r3, #8]
 804482c:	f013 0f20 	tst.w	r3, #32
 8044830:	d01b      	beq.n	804486a <HAL_RTC_Init+0xa8>
    hrtc->Instance->TAFCR &= (uint32_t)~RTC_TAFCR_ALARMOUTTYPE;
 8044832:	6822      	ldr	r2, [r4, #0]
 8044834:	6c13      	ldr	r3, [r2, #64]	; 0x40
 8044836:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 804483a:	6413      	str	r3, [r2, #64]	; 0x40
    hrtc->Instance->TAFCR |= (uint32_t)(hrtc->Init.OutPutType);
 804483c:	6822      	ldr	r2, [r4, #0]
 804483e:	6c13      	ldr	r3, [r2, #64]	; 0x40
 8044840:	69a1      	ldr	r1, [r4, #24]
 8044842:	430b      	orrs	r3, r1
 8044844:	6413      	str	r3, [r2, #64]	; 0x40
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8044846:	6823      	ldr	r3, [r4, #0]
 8044848:	22ff      	movs	r2, #255	; 0xff
 804484a:	625a      	str	r2, [r3, #36]	; 0x24
    hrtc->State = HAL_RTC_STATE_READY;
 804484c:	2301      	movs	r3, #1
 804484e:	7763      	strb	r3, [r4, #29]
}
 8044850:	4628      	mov	r0, r5
 8044852:	bd38      	pop	{r3, r4, r5, pc}
    hrtc->Lock = HAL_UNLOCKED;
 8044854:	7703      	strb	r3, [r0, #28]
    HAL_RTC_MspInit(hrtc);
 8044856:	f00b fd5b 	bl	8050310 <HAL_RTC_MspInit>
 804485a:	e7b9      	b.n	80447d0 <HAL_RTC_Init+0xe>
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 804485c:	6823      	ldr	r3, [r4, #0]
 804485e:	22ff      	movs	r2, #255	; 0xff
 8044860:	625a      	str	r2, [r3, #36]	; 0x24
    hrtc->State = HAL_RTC_STATE_ERROR;
 8044862:	2304      	movs	r3, #4
 8044864:	7763      	strb	r3, [r4, #29]
    return HAL_ERROR;
 8044866:	2501      	movs	r5, #1
 8044868:	e7f2      	b.n	8044850 <HAL_RTC_Init+0x8e>
      if(HAL_RTC_WaitForSynchro(hrtc) != HAL_OK)
 804486a:	4620      	mov	r0, r4
 804486c:	f7ff ff72 	bl	8044754 <HAL_RTC_WaitForSynchro>
 8044870:	2800      	cmp	r0, #0
 8044872:	d0de      	beq.n	8044832 <HAL_RTC_Init+0x70>
        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8044874:	6823      	ldr	r3, [r4, #0]
 8044876:	22ff      	movs	r2, #255	; 0xff
 8044878:	625a      	str	r2, [r3, #36]	; 0x24
        hrtc->State = HAL_RTC_STATE_ERROR;
 804487a:	2304      	movs	r3, #4
 804487c:	7763      	strb	r3, [r4, #29]
        return HAL_ERROR;
 804487e:	2501      	movs	r5, #1
 8044880:	e7e6      	b.n	8044850 <HAL_RTC_Init+0x8e>
     return HAL_ERROR;
 8044882:	2501      	movs	r5, #1
 8044884:	e7e4      	b.n	8044850 <HAL_RTC_Init+0x8e>

08044886 <RTC_ByteToBcd2>:
  * @param  Value Byte to be converted
  * @retval Converted byte
  */
uint8_t RTC_ByteToBcd2(uint8_t Value)
{
  uint32_t bcdhigh = 0U;
 8044886:	2300      	movs	r3, #0

  while(Value >= 10U)
 8044888:	2809      	cmp	r0, #9
 804488a:	d903      	bls.n	8044894 <RTC_ByteToBcd2+0xe>
  {
    bcdhigh++;
 804488c:	3301      	adds	r3, #1
    Value -= 10U;
 804488e:	380a      	subs	r0, #10
 8044890:	b2c0      	uxtb	r0, r0
 8044892:	e7f9      	b.n	8044888 <RTC_ByteToBcd2+0x2>
  }

  return  ((uint8_t)(bcdhigh << 4U) | Value);
 8044894:	011b      	lsls	r3, r3, #4
 8044896:	b2db      	uxtb	r3, r3
}
 8044898:	4318      	orrs	r0, r3
 804489a:	4770      	bx	lr

0804489c <HAL_RTC_SetTime>:
{
 804489c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  __HAL_LOCK(hrtc);
 804489e:	7f03      	ldrb	r3, [r0, #28]
 80448a0:	2b01      	cmp	r3, #1
 80448a2:	d078      	beq.n	8044996 <HAL_RTC_SetTime+0xfa>
 80448a4:	4604      	mov	r4, r0
 80448a6:	460e      	mov	r6, r1
 80448a8:	2301      	movs	r3, #1
 80448aa:	7703      	strb	r3, [r0, #28]
  hrtc->State = HAL_RTC_STATE_BUSY;
 80448ac:	2302      	movs	r3, #2
 80448ae:	7743      	strb	r3, [r0, #29]
  if(Format == RTC_FORMAT_BIN)
 80448b0:	2a00      	cmp	r2, #0
 80448b2:	d147      	bne.n	8044944 <HAL_RTC_SetTime+0xa8>
    if((hrtc->Instance->CR & RTC_CR_FMT) != (uint32_t)RESET)
 80448b4:	6803      	ldr	r3, [r0, #0]
 80448b6:	689b      	ldr	r3, [r3, #8]
 80448b8:	f013 0f40 	tst.w	r3, #64	; 0x40
 80448bc:	d101      	bne.n	80448c2 <HAL_RTC_SetTime+0x26>
      sTime->TimeFormat = 0x00U;
 80448be:	2300      	movs	r3, #0
 80448c0:	70cb      	strb	r3, [r1, #3]
    tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(sTime->Hours) << 16U) | \
 80448c2:	7830      	ldrb	r0, [r6, #0]
 80448c4:	f7ff ffdf 	bl	8044886 <RTC_ByteToBcd2>
 80448c8:	0405      	lsls	r5, r0, #16
                        ((uint32_t)RTC_ByteToBcd2(sTime->Minutes) << 8U) | \
 80448ca:	7870      	ldrb	r0, [r6, #1]
 80448cc:	f7ff ffdb 	bl	8044886 <RTC_ByteToBcd2>
    tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(sTime->Hours) << 16U) | \
 80448d0:	ea45 2500 	orr.w	r5, r5, r0, lsl #8
                        ((uint32_t)RTC_ByteToBcd2(sTime->Seconds)) | \
 80448d4:	78b0      	ldrb	r0, [r6, #2]
 80448d6:	f7ff ffd6 	bl	8044886 <RTC_ByteToBcd2>
                        ((uint32_t)RTC_ByteToBcd2(sTime->Minutes) << 8U) | \
 80448da:	4305      	orrs	r5, r0
                        (((uint32_t)sTime->TimeFormat) << 16U));
 80448dc:	78f0      	ldrb	r0, [r6, #3]
    tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(sTime->Hours) << 16U) | \
 80448de:	ea45 4500 	orr.w	r5, r5, r0, lsl #16
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 80448e2:	6823      	ldr	r3, [r4, #0]
 80448e4:	22ca      	movs	r2, #202	; 0xca
 80448e6:	625a      	str	r2, [r3, #36]	; 0x24
 80448e8:	6823      	ldr	r3, [r4, #0]
 80448ea:	2253      	movs	r2, #83	; 0x53
 80448ec:	625a      	str	r2, [r3, #36]	; 0x24
  if(RTC_EnterInitMode(hrtc) != HAL_OK)
 80448ee:	4620      	mov	r0, r4
 80448f0:	f7ff ff49 	bl	8044786 <RTC_EnterInitMode>
 80448f4:	4607      	mov	r7, r0
 80448f6:	2800      	cmp	r0, #0
 80448f8:	d136      	bne.n	8044968 <HAL_RTC_SetTime+0xcc>
    hrtc->Instance->TR = (uint32_t)(tmpreg & RTC_TR_RESERVED_MASK);
 80448fa:	6823      	ldr	r3, [r4, #0]
 80448fc:	f005 357f 	and.w	r5, r5, #2139062143	; 0x7f7f7f7f
 8044900:	f025 45fe 	bic.w	r5, r5, #2130706432	; 0x7f000000
 8044904:	601d      	str	r5, [r3, #0]
    hrtc->Instance->CR &= (uint32_t)~RTC_CR_BCK;
 8044906:	6822      	ldr	r2, [r4, #0]
 8044908:	6893      	ldr	r3, [r2, #8]
 804490a:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 804490e:	6093      	str	r3, [r2, #8]
    hrtc->Instance->CR |= (uint32_t)(sTime->DayLightSaving | sTime->StoreOperation);
 8044910:	6821      	ldr	r1, [r4, #0]
 8044912:	688b      	ldr	r3, [r1, #8]
 8044914:	68f2      	ldr	r2, [r6, #12]
 8044916:	6930      	ldr	r0, [r6, #16]
 8044918:	4302      	orrs	r2, r0
 804491a:	4313      	orrs	r3, r2
 804491c:	608b      	str	r3, [r1, #8]
    hrtc->Instance->ISR &= (uint32_t)~RTC_ISR_INIT;
 804491e:	6822      	ldr	r2, [r4, #0]
 8044920:	68d3      	ldr	r3, [r2, #12]
 8044922:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8044926:	60d3      	str	r3, [r2, #12]
    if((hrtc->Instance->CR & RTC_CR_BYPSHAD) == RESET)
 8044928:	6823      	ldr	r3, [r4, #0]
 804492a:	689b      	ldr	r3, [r3, #8]
 804492c:	f013 0f20 	tst.w	r3, #32
 8044930:	d023      	beq.n	804497a <HAL_RTC_SetTime+0xde>
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8044932:	6823      	ldr	r3, [r4, #0]
 8044934:	22ff      	movs	r2, #255	; 0xff
 8044936:	625a      	str	r2, [r3, #36]	; 0x24
   hrtc->State = HAL_RTC_STATE_READY;
 8044938:	2301      	movs	r3, #1
 804493a:	7763      	strb	r3, [r4, #29]
   __HAL_UNLOCK(hrtc);
 804493c:	2300      	movs	r3, #0
 804493e:	7723      	strb	r3, [r4, #28]
}
 8044940:	4638      	mov	r0, r7
 8044942:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if((hrtc->Instance->CR & RTC_CR_FMT) != (uint32_t)RESET)
 8044944:	6803      	ldr	r3, [r0, #0]
 8044946:	689b      	ldr	r3, [r3, #8]
 8044948:	f013 0f40 	tst.w	r3, #64	; 0x40
 804494c:	d101      	bne.n	8044952 <HAL_RTC_SetTime+0xb6>
      sTime->TimeFormat = 0x00U;
 804494e:	2300      	movs	r3, #0
 8044950:	70cb      	strb	r3, [r1, #3]
    tmpreg = (((uint32_t)(sTime->Hours) << 16U) | \
 8044952:	7835      	ldrb	r5, [r6, #0]
              ((uint32_t)(sTime->Minutes) << 8U) | \
 8044954:	7870      	ldrb	r0, [r6, #1]
 8044956:	0200      	lsls	r0, r0, #8
    tmpreg = (((uint32_t)(sTime->Hours) << 16U) | \
 8044958:	ea40 4005 	orr.w	r0, r0, r5, lsl #16
              ((uint32_t)sTime->Seconds) | \
 804495c:	78b5      	ldrb	r5, [r6, #2]
              ((uint32_t)(sTime->Minutes) << 8U) | \
 804495e:	4328      	orrs	r0, r5
              ((uint32_t)(sTime->TimeFormat) << 16U));
 8044960:	78f5      	ldrb	r5, [r6, #3]
    tmpreg = (((uint32_t)(sTime->Hours) << 16U) | \
 8044962:	ea40 4505 	orr.w	r5, r0, r5, lsl #16
 8044966:	e7bc      	b.n	80448e2 <HAL_RTC_SetTime+0x46>
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8044968:	6823      	ldr	r3, [r4, #0]
 804496a:	22ff      	movs	r2, #255	; 0xff
 804496c:	625a      	str	r2, [r3, #36]	; 0x24
    hrtc->State = HAL_RTC_STATE_ERROR;
 804496e:	2304      	movs	r3, #4
 8044970:	7763      	strb	r3, [r4, #29]
    __HAL_UNLOCK(hrtc);
 8044972:	2300      	movs	r3, #0
 8044974:	7723      	strb	r3, [r4, #28]
    return HAL_ERROR;
 8044976:	2701      	movs	r7, #1
 8044978:	e7e2      	b.n	8044940 <HAL_RTC_SetTime+0xa4>
      if(HAL_RTC_WaitForSynchro(hrtc) != HAL_OK)
 804497a:	4620      	mov	r0, r4
 804497c:	f7ff feea 	bl	8044754 <HAL_RTC_WaitForSynchro>
 8044980:	2800      	cmp	r0, #0
 8044982:	d0d6      	beq.n	8044932 <HAL_RTC_SetTime+0x96>
        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8044984:	6823      	ldr	r3, [r4, #0]
 8044986:	22ff      	movs	r2, #255	; 0xff
 8044988:	625a      	str	r2, [r3, #36]	; 0x24
        hrtc->State = HAL_RTC_STATE_ERROR;
 804498a:	2304      	movs	r3, #4
 804498c:	7763      	strb	r3, [r4, #29]
        __HAL_UNLOCK(hrtc);
 804498e:	2300      	movs	r3, #0
 8044990:	7723      	strb	r3, [r4, #28]
        return HAL_ERROR;
 8044992:	2701      	movs	r7, #1
 8044994:	e7d4      	b.n	8044940 <HAL_RTC_SetTime+0xa4>
  __HAL_LOCK(hrtc);
 8044996:	2702      	movs	r7, #2
 8044998:	e7d2      	b.n	8044940 <HAL_RTC_SetTime+0xa4>

0804499a <HAL_RTC_SetDate>:
{
 804499a:	b570      	push	{r4, r5, r6, lr}
 __HAL_LOCK(hrtc);
 804499c:	7f03      	ldrb	r3, [r0, #28]
 804499e:	2b01      	cmp	r3, #1
 80449a0:	d066      	beq.n	8044a70 <HAL_RTC_SetDate+0xd6>
 80449a2:	4604      	mov	r4, r0
 80449a4:	460e      	mov	r6, r1
 80449a6:	2301      	movs	r3, #1
 80449a8:	7703      	strb	r3, [r0, #28]
  hrtc->State = HAL_RTC_STATE_BUSY;
 80449aa:	2302      	movs	r3, #2
 80449ac:	7743      	strb	r3, [r0, #29]
  if((Format == RTC_FORMAT_BIN) && ((sDate->Month & 0x10U) == 0x10U))
 80449ae:	b93a      	cbnz	r2, 80449c0 <HAL_RTC_SetDate+0x26>
 80449b0:	784b      	ldrb	r3, [r1, #1]
 80449b2:	f013 0f10 	tst.w	r3, #16
 80449b6:	d003      	beq.n	80449c0 <HAL_RTC_SetDate+0x26>
    sDate->Month = (uint8_t)((sDate->Month & (uint8_t)~(0x10U)) + (uint8_t)0x0AU);
 80449b8:	f003 03ef 	and.w	r3, r3, #239	; 0xef
 80449bc:	330a      	adds	r3, #10
 80449be:	704b      	strb	r3, [r1, #1]
  if(Format == RTC_FORMAT_BIN)
 80449c0:	2a00      	cmp	r2, #0
 80449c2:	d133      	bne.n	8044a2c <HAL_RTC_SetDate+0x92>
   datetmpreg = (((uint32_t)RTC_ByteToBcd2(sDate->Year) << 16U) | \
 80449c4:	78f0      	ldrb	r0, [r6, #3]
 80449c6:	f7ff ff5e 	bl	8044886 <RTC_ByteToBcd2>
 80449ca:	0405      	lsls	r5, r0, #16
                 ((uint32_t)RTC_ByteToBcd2(sDate->Month) << 8U) | \
 80449cc:	7870      	ldrb	r0, [r6, #1]
 80449ce:	f7ff ff5a 	bl	8044886 <RTC_ByteToBcd2>
   datetmpreg = (((uint32_t)RTC_ByteToBcd2(sDate->Year) << 16U) | \
 80449d2:	ea45 2500 	orr.w	r5, r5, r0, lsl #8
                 ((uint32_t)RTC_ByteToBcd2(sDate->Date)) | \
 80449d6:	78b0      	ldrb	r0, [r6, #2]
 80449d8:	f7ff ff55 	bl	8044886 <RTC_ByteToBcd2>
                 ((uint32_t)RTC_ByteToBcd2(sDate->Month) << 8U) | \
 80449dc:	4305      	orrs	r5, r0
                 ((uint32_t)sDate->WeekDay << 13U));
 80449de:	7830      	ldrb	r0, [r6, #0]
   datetmpreg = (((uint32_t)RTC_ByteToBcd2(sDate->Year) << 16U) | \
 80449e0:	ea45 3540 	orr.w	r5, r5, r0, lsl #13
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 80449e4:	6823      	ldr	r3, [r4, #0]
 80449e6:	22ca      	movs	r2, #202	; 0xca
 80449e8:	625a      	str	r2, [r3, #36]	; 0x24
 80449ea:	6823      	ldr	r3, [r4, #0]
 80449ec:	2253      	movs	r2, #83	; 0x53
 80449ee:	625a      	str	r2, [r3, #36]	; 0x24
  if(RTC_EnterInitMode(hrtc) != HAL_OK)
 80449f0:	4620      	mov	r0, r4
 80449f2:	f7ff fec8 	bl	8044786 <RTC_EnterInitMode>
 80449f6:	4606      	mov	r6, r0
 80449f8:	bb18      	cbnz	r0, 8044a42 <HAL_RTC_SetDate+0xa8>
    hrtc->Instance->DR = (uint32_t)(datetmpreg & RTC_DR_RESERVED_MASK);
 80449fa:	6823      	ldr	r3, [r4, #0]
 80449fc:	f025 457f 	bic.w	r5, r5, #4278190080	; 0xff000000
 8044a00:	f025 05c0 	bic.w	r5, r5, #192	; 0xc0
 8044a04:	605d      	str	r5, [r3, #4]
    hrtc->Instance->ISR &= (uint32_t)~RTC_ISR_INIT;
 8044a06:	6822      	ldr	r2, [r4, #0]
 8044a08:	68d3      	ldr	r3, [r2, #12]
 8044a0a:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8044a0e:	60d3      	str	r3, [r2, #12]
    if((hrtc->Instance->CR & RTC_CR_BYPSHAD) == RESET)
 8044a10:	6823      	ldr	r3, [r4, #0]
 8044a12:	689b      	ldr	r3, [r3, #8]
 8044a14:	f013 0f20 	tst.w	r3, #32
 8044a18:	d01c      	beq.n	8044a54 <HAL_RTC_SetDate+0xba>
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8044a1a:	6823      	ldr	r3, [r4, #0]
 8044a1c:	22ff      	movs	r2, #255	; 0xff
 8044a1e:	625a      	str	r2, [r3, #36]	; 0x24
    hrtc->State = HAL_RTC_STATE_READY ;
 8044a20:	2301      	movs	r3, #1
 8044a22:	7763      	strb	r3, [r4, #29]
    __HAL_UNLOCK(hrtc);
 8044a24:	2300      	movs	r3, #0
 8044a26:	7723      	strb	r3, [r4, #28]
}
 8044a28:	4630      	mov	r0, r6
 8044a2a:	bd70      	pop	{r4, r5, r6, pc}
    datetmpreg = ((((uint32_t)sDate->Year) << 16U) | \
 8044a2c:	78f5      	ldrb	r5, [r6, #3]
                  (((uint32_t)sDate->Month) << 8U) | \
 8044a2e:	7870      	ldrb	r0, [r6, #1]
 8044a30:	0200      	lsls	r0, r0, #8
    datetmpreg = ((((uint32_t)sDate->Year) << 16U) | \
 8044a32:	ea40 4005 	orr.w	r0, r0, r5, lsl #16
                  ((uint32_t)sDate->Date) | \
 8044a36:	78b5      	ldrb	r5, [r6, #2]
                  (((uint32_t)sDate->Month) << 8U) | \
 8044a38:	4328      	orrs	r0, r5
                  (((uint32_t)sDate->WeekDay) << 13U));
 8044a3a:	7835      	ldrb	r5, [r6, #0]
    datetmpreg = ((((uint32_t)sDate->Year) << 16U) | \
 8044a3c:	ea40 3545 	orr.w	r5, r0, r5, lsl #13
 8044a40:	e7d0      	b.n	80449e4 <HAL_RTC_SetDate+0x4a>
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8044a42:	6823      	ldr	r3, [r4, #0]
 8044a44:	22ff      	movs	r2, #255	; 0xff
 8044a46:	625a      	str	r2, [r3, #36]	; 0x24
    hrtc->State = HAL_RTC_STATE_ERROR;
 8044a48:	2304      	movs	r3, #4
 8044a4a:	7763      	strb	r3, [r4, #29]
    __HAL_UNLOCK(hrtc);
 8044a4c:	2300      	movs	r3, #0
 8044a4e:	7723      	strb	r3, [r4, #28]
    return HAL_ERROR;
 8044a50:	2601      	movs	r6, #1
 8044a52:	e7e9      	b.n	8044a28 <HAL_RTC_SetDate+0x8e>
      if(HAL_RTC_WaitForSynchro(hrtc) != HAL_OK)
 8044a54:	4620      	mov	r0, r4
 8044a56:	f7ff fe7d 	bl	8044754 <HAL_RTC_WaitForSynchro>
 8044a5a:	2800      	cmp	r0, #0
 8044a5c:	d0dd      	beq.n	8044a1a <HAL_RTC_SetDate+0x80>
        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8044a5e:	6823      	ldr	r3, [r4, #0]
 8044a60:	22ff      	movs	r2, #255	; 0xff
 8044a62:	625a      	str	r2, [r3, #36]	; 0x24
        hrtc->State = HAL_RTC_STATE_ERROR;
 8044a64:	2304      	movs	r3, #4
 8044a66:	7763      	strb	r3, [r4, #29]
        __HAL_UNLOCK(hrtc);
 8044a68:	2300      	movs	r3, #0
 8044a6a:	7723      	strb	r3, [r4, #28]
        return HAL_ERROR;
 8044a6c:	2601      	movs	r6, #1
 8044a6e:	e7db      	b.n	8044a28 <HAL_RTC_SetDate+0x8e>
 __HAL_LOCK(hrtc);
 8044a70:	2602      	movs	r6, #2
 8044a72:	e7d9      	b.n	8044a28 <HAL_RTC_SetDate+0x8e>

08044a74 <HAL_RTC_SetAlarm_IT>:
{
 8044a74:	b5f0      	push	{r4, r5, r6, r7, lr}
 8044a76:	b083      	sub	sp, #12
 8044a78:	460d      	mov	r5, r1
  __IO uint32_t count = RTC_TIMEOUT_VALUE  * (SystemCoreClock / 32U / 1000U) ;
 8044a7a:	4b63      	ldr	r3, [pc, #396]	; (8044c08 <HAL_RTC_SetAlarm_IT+0x194>)
 8044a7c:	681b      	ldr	r3, [r3, #0]
 8044a7e:	4963      	ldr	r1, [pc, #396]	; (8044c0c <HAL_RTC_SetAlarm_IT+0x198>)
 8044a80:	fba1 1303 	umull	r1, r3, r1, r3
 8044a84:	0adb      	lsrs	r3, r3, #11
 8044a86:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 8044a8a:	fb01 f303 	mul.w	r3, r1, r3
 8044a8e:	9301      	str	r3, [sp, #4]
  __HAL_LOCK(hrtc);
 8044a90:	7f03      	ldrb	r3, [r0, #28]
 8044a92:	2b01      	cmp	r3, #1
 8044a94:	f000 80b5 	beq.w	8044c02 <HAL_RTC_SetAlarm_IT+0x18e>
 8044a98:	4604      	mov	r4, r0
 8044a9a:	2301      	movs	r3, #1
 8044a9c:	7703      	strb	r3, [r0, #28]
  hrtc->State = HAL_RTC_STATE_BUSY;
 8044a9e:	2302      	movs	r3, #2
 8044aa0:	7743      	strb	r3, [r0, #29]
  if(Format == RTC_FORMAT_BIN)
 8044aa2:	2a00      	cmp	r2, #0
 8044aa4:	d161      	bne.n	8044b6a <HAL_RTC_SetAlarm_IT+0xf6>
    if((hrtc->Instance->CR & RTC_CR_FMT) != (uint32_t)RESET)
 8044aa6:	6803      	ldr	r3, [r0, #0]
 8044aa8:	689b      	ldr	r3, [r3, #8]
 8044aaa:	f013 0f40 	tst.w	r3, #64	; 0x40
 8044aae:	d101      	bne.n	8044ab4 <HAL_RTC_SetAlarm_IT+0x40>
      sAlarm->AlarmTime.TimeFormat = 0x00U;
 8044ab0:	2300      	movs	r3, #0
 8044ab2:	70eb      	strb	r3, [r5, #3]
    if(sAlarm->AlarmDateWeekDaySel == RTC_ALARMDATEWEEKDAYSEL_DATE)
 8044ab4:	69ef      	ldr	r7, [r5, #28]
    tmpreg = (((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Hours) << 16U) | \
 8044ab6:	7828      	ldrb	r0, [r5, #0]
 8044ab8:	f7ff fee5 	bl	8044886 <RTC_ByteToBcd2>
 8044abc:	0406      	lsls	r6, r0, #16
              ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Minutes) << 8U) | \
 8044abe:	7868      	ldrb	r0, [r5, #1]
 8044ac0:	f7ff fee1 	bl	8044886 <RTC_ByteToBcd2>
    tmpreg = (((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Hours) << 16U) | \
 8044ac4:	ea46 2600 	orr.w	r6, r6, r0, lsl #8
              ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Seconds)) | \
 8044ac8:	78a8      	ldrb	r0, [r5, #2]
 8044aca:	f7ff fedc 	bl	8044886 <RTC_ByteToBcd2>
              ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Minutes) << 8U) | \
 8044ace:	4306      	orrs	r6, r0
              ((uint32_t)(sAlarm->AlarmTime.TimeFormat) << 16U) | \
 8044ad0:	78e8      	ldrb	r0, [r5, #3]
              ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Seconds)) | \
 8044ad2:	ea46 4600 	orr.w	r6, r6, r0, lsl #16
              ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmDateWeekDay) << 24U) | \
 8044ad6:	f895 0020 	ldrb.w	r0, [r5, #32]
 8044ada:	f7ff fed4 	bl	8044886 <RTC_ByteToBcd2>
              ((uint32_t)(sAlarm->AlarmTime.TimeFormat) << 16U) | \
 8044ade:	ea46 6600 	orr.w	r6, r6, r0, lsl #24
              ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmDateWeekDay) << 24U) | \
 8044ae2:	433e      	orrs	r6, r7
              ((uint32_t)sAlarm->AlarmMask));
 8044ae4:	696b      	ldr	r3, [r5, #20]
    tmpreg = (((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Hours) << 16U) | \
 8044ae6:	431e      	orrs	r6, r3
  subsecondtmpreg = (uint32_t)((uint32_t)(sAlarm->AlarmTime.SubSeconds) | (uint32_t)(sAlarm->AlarmSubSecondMask));
 8044ae8:	6868      	ldr	r0, [r5, #4]
 8044aea:	69ab      	ldr	r3, [r5, #24]
 8044aec:	4318      	orrs	r0, r3
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8044aee:	6823      	ldr	r3, [r4, #0]
 8044af0:	22ca      	movs	r2, #202	; 0xca
 8044af2:	625a      	str	r2, [r3, #36]	; 0x24
 8044af4:	6823      	ldr	r3, [r4, #0]
 8044af6:	2253      	movs	r2, #83	; 0x53
 8044af8:	625a      	str	r2, [r3, #36]	; 0x24
  if(sAlarm->Alarm == RTC_ALARM_A)
 8044afa:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 8044afc:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8044b00:	d04d      	beq.n	8044b9e <HAL_RTC_SetAlarm_IT+0x12a>
    __HAL_RTC_ALARMB_DISABLE(hrtc);
 8044b02:	6822      	ldr	r2, [r4, #0]
 8044b04:	6893      	ldr	r3, [r2, #8]
 8044b06:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 8044b0a:	6093      	str	r3, [r2, #8]
    __HAL_RTC_ALARM_CLEAR_FLAG(hrtc, RTC_FLAG_ALRBF);
 8044b0c:	6822      	ldr	r2, [r4, #0]
 8044b0e:	68d3      	ldr	r3, [r2, #12]
 8044b10:	b2db      	uxtb	r3, r3
 8044b12:	f463 7320 	orn	r3, r3, #640	; 0x280
 8044b16:	60d3      	str	r3, [r2, #12]
      if (count-- == 0U)
 8044b18:	9b01      	ldr	r3, [sp, #4]
 8044b1a:	1e5a      	subs	r2, r3, #1
 8044b1c:	9201      	str	r2, [sp, #4]
 8044b1e:	2b00      	cmp	r3, #0
 8044b20:	d067      	beq.n	8044bf2 <HAL_RTC_SetAlarm_IT+0x17e>
    while (__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRBWF) == RESET);
 8044b22:	6823      	ldr	r3, [r4, #0]
 8044b24:	68da      	ldr	r2, [r3, #12]
 8044b26:	f012 0f02 	tst.w	r2, #2
 8044b2a:	d0f5      	beq.n	8044b18 <HAL_RTC_SetAlarm_IT+0xa4>
    hrtc->Instance->ALRMBR = (uint32_t)tmpreg;
 8044b2c:	621e      	str	r6, [r3, #32]
    hrtc->Instance->ALRMBSSR = subsecondtmpreg;
 8044b2e:	6823      	ldr	r3, [r4, #0]
 8044b30:	6498      	str	r0, [r3, #72]	; 0x48
    __HAL_RTC_ALARMB_ENABLE(hrtc);
 8044b32:	6822      	ldr	r2, [r4, #0]
 8044b34:	6893      	ldr	r3, [r2, #8]
 8044b36:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8044b3a:	6093      	str	r3, [r2, #8]
    __HAL_RTC_ALARM_ENABLE_IT(hrtc, RTC_IT_ALRB);
 8044b3c:	6822      	ldr	r2, [r4, #0]
 8044b3e:	6893      	ldr	r3, [r2, #8]
 8044b40:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8044b44:	6093      	str	r3, [r2, #8]
  __HAL_RTC_ALARM_EXTI_ENABLE_IT();
 8044b46:	4b32      	ldr	r3, [pc, #200]	; (8044c10 <HAL_RTC_SetAlarm_IT+0x19c>)
 8044b48:	681a      	ldr	r2, [r3, #0]
 8044b4a:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
 8044b4e:	601a      	str	r2, [r3, #0]
  EXTI->RTSR |= RTC_EXTI_LINE_ALARM_EVENT;
 8044b50:	689a      	ldr	r2, [r3, #8]
 8044b52:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
 8044b56:	609a      	str	r2, [r3, #8]
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8044b58:	6823      	ldr	r3, [r4, #0]
 8044b5a:	22ff      	movs	r2, #255	; 0xff
 8044b5c:	625a      	str	r2, [r3, #36]	; 0x24
  hrtc->State = HAL_RTC_STATE_READY;
 8044b5e:	2301      	movs	r3, #1
 8044b60:	7763      	strb	r3, [r4, #29]
  __HAL_UNLOCK(hrtc);
 8044b62:	2000      	movs	r0, #0
 8044b64:	7720      	strb	r0, [r4, #28]
}
 8044b66:	b003      	add	sp, #12
 8044b68:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if((hrtc->Instance->CR & RTC_CR_FMT) != (uint32_t)RESET)
 8044b6a:	6803      	ldr	r3, [r0, #0]
 8044b6c:	689b      	ldr	r3, [r3, #8]
 8044b6e:	f013 0f40 	tst.w	r3, #64	; 0x40
 8044b72:	d101      	bne.n	8044b78 <HAL_RTC_SetAlarm_IT+0x104>
      sAlarm->AlarmTime.TimeFormat = 0x00U;
 8044b74:	2300      	movs	r3, #0
 8044b76:	70eb      	strb	r3, [r5, #3]
    if(sAlarm->AlarmDateWeekDaySel == RTC_ALARMDATEWEEKDAYSEL_DATE)
 8044b78:	69ea      	ldr	r2, [r5, #28]
    tmpreg = (((uint32_t)(sAlarm->AlarmTime.Hours) << 16U) | \
 8044b7a:	7829      	ldrb	r1, [r5, #0]
              ((uint32_t)(sAlarm->AlarmTime.Minutes) << 8U) | \
 8044b7c:	786b      	ldrb	r3, [r5, #1]
 8044b7e:	021b      	lsls	r3, r3, #8
    tmpreg = (((uint32_t)(sAlarm->AlarmTime.Hours) << 16U) | \
 8044b80:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
              ((uint32_t) sAlarm->AlarmTime.Seconds) | \
 8044b84:	78a9      	ldrb	r1, [r5, #2]
              ((uint32_t)(sAlarm->AlarmTime.Minutes) << 8U) | \
 8044b86:	430b      	orrs	r3, r1
              ((uint32_t)(sAlarm->AlarmTime.TimeFormat) << 16U) | \
 8044b88:	78e9      	ldrb	r1, [r5, #3]
              ((uint32_t) sAlarm->AlarmTime.Seconds) | \
 8044b8a:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
              ((uint32_t)(sAlarm->AlarmDateWeekDay) << 24U) | \
 8044b8e:	f895 1020 	ldrb.w	r1, [r5, #32]
              ((uint32_t)(sAlarm->AlarmTime.TimeFormat) << 16U) | \
 8044b92:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
              ((uint32_t)(sAlarm->AlarmDateWeekDay) << 24U) | \
 8044b96:	4313      	orrs	r3, r2
              ((uint32_t)sAlarm->AlarmMask));
 8044b98:	696e      	ldr	r6, [r5, #20]
    tmpreg = (((uint32_t)(sAlarm->AlarmTime.Hours) << 16U) | \
 8044b9a:	431e      	orrs	r6, r3
 8044b9c:	e7a4      	b.n	8044ae8 <HAL_RTC_SetAlarm_IT+0x74>
    __HAL_RTC_ALARMA_DISABLE(hrtc);
 8044b9e:	6822      	ldr	r2, [r4, #0]
 8044ba0:	6893      	ldr	r3, [r2, #8]
 8044ba2:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8044ba6:	6093      	str	r3, [r2, #8]
    __HAL_RTC_ALARM_CLEAR_FLAG(hrtc, RTC_FLAG_ALRAF);
 8044ba8:	6822      	ldr	r2, [r4, #0]
 8044baa:	68d3      	ldr	r3, [r2, #12]
 8044bac:	b2db      	uxtb	r3, r3
 8044bae:	f463 73c0 	orn	r3, r3, #384	; 0x180
 8044bb2:	60d3      	str	r3, [r2, #12]
      if (count-- == 0U)
 8044bb4:	9b01      	ldr	r3, [sp, #4]
 8044bb6:	1e5a      	subs	r2, r3, #1
 8044bb8:	9201      	str	r2, [sp, #4]
 8044bba:	b193      	cbz	r3, 8044be2 <HAL_RTC_SetAlarm_IT+0x16e>
    while (__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRAWF) == RESET);
 8044bbc:	6823      	ldr	r3, [r4, #0]
 8044bbe:	68d9      	ldr	r1, [r3, #12]
 8044bc0:	f011 0f01 	tst.w	r1, #1
 8044bc4:	d0f6      	beq.n	8044bb4 <HAL_RTC_SetAlarm_IT+0x140>
    hrtc->Instance->ALRMAR = (uint32_t)tmpreg;
 8044bc6:	61de      	str	r6, [r3, #28]
    hrtc->Instance->ALRMASSR = subsecondtmpreg;
 8044bc8:	6823      	ldr	r3, [r4, #0]
 8044bca:	6458      	str	r0, [r3, #68]	; 0x44
    __HAL_RTC_ALARMA_ENABLE(hrtc);
 8044bcc:	6822      	ldr	r2, [r4, #0]
 8044bce:	6893      	ldr	r3, [r2, #8]
 8044bd0:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8044bd4:	6093      	str	r3, [r2, #8]
    __HAL_RTC_ALARM_ENABLE_IT(hrtc,RTC_IT_ALRA);
 8044bd6:	6822      	ldr	r2, [r4, #0]
 8044bd8:	6893      	ldr	r3, [r2, #8]
 8044bda:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 8044bde:	6093      	str	r3, [r2, #8]
 8044be0:	e7b1      	b.n	8044b46 <HAL_RTC_SetAlarm_IT+0xd2>
        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8044be2:	6823      	ldr	r3, [r4, #0]
 8044be4:	22ff      	movs	r2, #255	; 0xff
 8044be6:	625a      	str	r2, [r3, #36]	; 0x24
        hrtc->State = HAL_RTC_STATE_TIMEOUT;
 8044be8:	2003      	movs	r0, #3
 8044bea:	7760      	strb	r0, [r4, #29]
        __HAL_UNLOCK(hrtc);
 8044bec:	2300      	movs	r3, #0
 8044bee:	7723      	strb	r3, [r4, #28]
        return HAL_TIMEOUT;
 8044bf0:	e7b9      	b.n	8044b66 <HAL_RTC_SetAlarm_IT+0xf2>
        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8044bf2:	6823      	ldr	r3, [r4, #0]
 8044bf4:	22ff      	movs	r2, #255	; 0xff
 8044bf6:	625a      	str	r2, [r3, #36]	; 0x24
        hrtc->State = HAL_RTC_STATE_TIMEOUT;
 8044bf8:	2003      	movs	r0, #3
 8044bfa:	7760      	strb	r0, [r4, #29]
        __HAL_UNLOCK(hrtc);
 8044bfc:	2300      	movs	r3, #0
 8044bfe:	7723      	strb	r3, [r4, #28]
        return HAL_TIMEOUT;
 8044c00:	e7b1      	b.n	8044b66 <HAL_RTC_SetAlarm_IT+0xf2>
  __HAL_LOCK(hrtc);
 8044c02:	2002      	movs	r0, #2
 8044c04:	e7af      	b.n	8044b66 <HAL_RTC_SetAlarm_IT+0xf2>
 8044c06:	bf00      	nop
 8044c08:	20003678 	.word	0x20003678
 8044c0c:	10624dd3 	.word	0x10624dd3
 8044c10:	40013c00 	.word	0x40013c00

08044c14 <RTC_Bcd2ToByte>:
  * @retval Converted word
  */
uint8_t RTC_Bcd2ToByte(uint8_t Value)
{
  uint32_t tmp = 0U;
  tmp = ((uint8_t)(Value & (uint8_t)0xF0) >> (uint8_t)0x4) * 10;
 8044c14:	0903      	lsrs	r3, r0, #4
 8044c16:	eb03 0383 	add.w	r3, r3, r3, lsl #2
  return (tmp + (Value & (uint8_t)0x0F));
 8044c1a:	f000 000f 	and.w	r0, r0, #15
 8044c1e:	eb00 0043 	add.w	r0, r0, r3, lsl #1
}
 8044c22:	b2c0      	uxtb	r0, r0
 8044c24:	4770      	bx	lr

08044c26 <HAL_RTC_GetTime>:
{
 8044c26:	b570      	push	{r4, r5, r6, lr}
 8044c28:	460c      	mov	r4, r1
  sTime->SubSeconds = (uint32_t)(hrtc->Instance->SSR);
 8044c2a:	6803      	ldr	r3, [r0, #0]
 8044c2c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8044c2e:	604b      	str	r3, [r1, #4]
  sTime->SecondFraction = (uint32_t)(hrtc->Instance->PRER & RTC_PRER_PREDIV_S);
 8044c30:	6803      	ldr	r3, [r0, #0]
 8044c32:	691b      	ldr	r3, [r3, #16]
 8044c34:	f3c3 030e 	ubfx	r3, r3, #0, #15
 8044c38:	608b      	str	r3, [r1, #8]
  tmpreg = (uint32_t)(hrtc->Instance->TR & RTC_TR_RESERVED_MASK);
 8044c3a:	6803      	ldr	r3, [r0, #0]
 8044c3c:	681d      	ldr	r5, [r3, #0]
  sTime->Hours = (uint8_t)((tmpreg & (RTC_TR_HT | RTC_TR_HU)) >> 16U);
 8044c3e:	f3c5 4106 	ubfx	r1, r5, #16, #7
 8044c42:	f3c5 4005 	ubfx	r0, r5, #16, #6
 8044c46:	7020      	strb	r0, [r4, #0]
  sTime->Minutes = (uint8_t)((tmpreg & (RTC_TR_MNT | RTC_TR_MNU)) >> 8U);
 8044c48:	f3c5 2606 	ubfx	r6, r5, #8, #7
 8044c4c:	7066      	strb	r6, [r4, #1]
  sTime->Seconds = (uint8_t)(tmpreg & (RTC_TR_ST | RTC_TR_SU));
 8044c4e:	f005 057f 	and.w	r5, r5, #127	; 0x7f
 8044c52:	70a5      	strb	r5, [r4, #2]
  sTime->TimeFormat = (uint8_t)((tmpreg & (RTC_TR_PM)) >> 16U);
 8044c54:	f001 0340 	and.w	r3, r1, #64	; 0x40
 8044c58:	70e3      	strb	r3, [r4, #3]
  if(Format == RTC_FORMAT_BIN)
 8044c5a:	b952      	cbnz	r2, 8044c72 <HAL_RTC_GetTime+0x4c>
    sTime->Hours = (uint8_t)RTC_Bcd2ToByte(sTime->Hours);
 8044c5c:	f7ff ffda 	bl	8044c14 <RTC_Bcd2ToByte>
 8044c60:	7020      	strb	r0, [r4, #0]
    sTime->Minutes = (uint8_t)RTC_Bcd2ToByte(sTime->Minutes);
 8044c62:	4630      	mov	r0, r6
 8044c64:	f7ff ffd6 	bl	8044c14 <RTC_Bcd2ToByte>
 8044c68:	7060      	strb	r0, [r4, #1]
    sTime->Seconds = (uint8_t)RTC_Bcd2ToByte(sTime->Seconds);
 8044c6a:	4628      	mov	r0, r5
 8044c6c:	f7ff ffd2 	bl	8044c14 <RTC_Bcd2ToByte>
 8044c70:	70a0      	strb	r0, [r4, #2]
}
 8044c72:	2000      	movs	r0, #0
 8044c74:	bd70      	pop	{r4, r5, r6, pc}

08044c76 <HAL_RTC_GetDate>:
{
 8044c76:	b570      	push	{r4, r5, r6, lr}
  datetmpreg = (uint32_t)(hrtc->Instance->DR & RTC_DR_RESERVED_MASK);
 8044c78:	6803      	ldr	r3, [r0, #0]
 8044c7a:	685b      	ldr	r3, [r3, #4]
  sDate->Year = (uint8_t)((datetmpreg & (RTC_DR_YT | RTC_DR_YU)) >> 16U);
 8044c7c:	f3c3 4007 	ubfx	r0, r3, #16, #8
 8044c80:	70c8      	strb	r0, [r1, #3]
  sDate->Month = (uint8_t)((datetmpreg & (RTC_DR_MT | RTC_DR_MU)) >> 8U);
 8044c82:	f3c3 2604 	ubfx	r6, r3, #8, #5
 8044c86:	704e      	strb	r6, [r1, #1]
  sDate->Date = (uint8_t)(datetmpreg & (RTC_DR_DT | RTC_DR_DU));
 8044c88:	f003 053f 	and.w	r5, r3, #63	; 0x3f
 8044c8c:	708d      	strb	r5, [r1, #2]
  sDate->WeekDay = (uint8_t)((datetmpreg & (RTC_DR_WDU)) >> 13U);
 8044c8e:	f3c3 3342 	ubfx	r3, r3, #13, #3
 8044c92:	700b      	strb	r3, [r1, #0]
  if(Format == RTC_FORMAT_BIN)
 8044c94:	b95a      	cbnz	r2, 8044cae <HAL_RTC_GetDate+0x38>
 8044c96:	460c      	mov	r4, r1
    sDate->Year = (uint8_t)RTC_Bcd2ToByte(sDate->Year);
 8044c98:	f7ff ffbc 	bl	8044c14 <RTC_Bcd2ToByte>
 8044c9c:	70e0      	strb	r0, [r4, #3]
    sDate->Month = (uint8_t)RTC_Bcd2ToByte(sDate->Month);
 8044c9e:	4630      	mov	r0, r6
 8044ca0:	f7ff ffb8 	bl	8044c14 <RTC_Bcd2ToByte>
 8044ca4:	7060      	strb	r0, [r4, #1]
    sDate->Date = (uint8_t)RTC_Bcd2ToByte(sDate->Date);
 8044ca6:	4628      	mov	r0, r5
 8044ca8:	f7ff ffb4 	bl	8044c14 <RTC_Bcd2ToByte>
 8044cac:	70a0      	strb	r0, [r4, #2]
}
 8044cae:	2000      	movs	r0, #0
 8044cb0:	bd70      	pop	{r4, r5, r6, pc}
	...

08044cb4 <HAL_RTCEx_SetWakeUpTimer_IT>:
  /* Check the parameters */
  assert_param(IS_RTC_WAKEUP_CLOCK(WakeUpClock));
  assert_param(IS_RTC_WAKEUP_COUNTER(WakeUpCounter));

  /* Process Locked */
  __HAL_LOCK(hrtc);
 8044cb4:	7f03      	ldrb	r3, [r0, #28]
 8044cb6:	2b01      	cmp	r3, #1
 8044cb8:	d07c      	beq.n	8044db4 <HAL_RTCEx_SetWakeUpTimer_IT+0x100>
{
 8044cba:	b430      	push	{r4, r5}
 8044cbc:	b082      	sub	sp, #8
  __HAL_LOCK(hrtc);
 8044cbe:	2301      	movs	r3, #1
 8044cc0:	7703      	strb	r3, [r0, #28]

  hrtc->State = HAL_RTC_STATE_BUSY;
 8044cc2:	2302      	movs	r3, #2
 8044cc4:	7743      	strb	r3, [r0, #29]

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8044cc6:	6803      	ldr	r3, [r0, #0]
 8044cc8:	24ca      	movs	r4, #202	; 0xca
 8044cca:	625c      	str	r4, [r3, #36]	; 0x24
 8044ccc:	6803      	ldr	r3, [r0, #0]
 8044cce:	2453      	movs	r4, #83	; 0x53
 8044cd0:	625c      	str	r4, [r3, #36]	; 0x24

  /* Check RTC WUTWF flag is reset only when wake up timer enabled */
  if((hrtc->Instance->CR & RTC_CR_WUTE) != RESET)
 8044cd2:	6805      	ldr	r5, [r0, #0]
 8044cd4:	68ab      	ldr	r3, [r5, #8]
 8044cd6:	f413 6f80 	tst.w	r3, #1024	; 0x400
 8044cda:	d013      	beq.n	8044d04 <HAL_RTCEx_SetWakeUpTimer_IT+0x50>
  {
    /* Wait till RTC WUTWF flag is reset and if Time out is reached exit */
    count = RTC_TIMEOUT_VALUE  * (SystemCoreClock / 32U / 1000U);
 8044cdc:	4b36      	ldr	r3, [pc, #216]	; (8044db8 <HAL_RTCEx_SetWakeUpTimer_IT+0x104>)
 8044cde:	681b      	ldr	r3, [r3, #0]
 8044ce0:	4c36      	ldr	r4, [pc, #216]	; (8044dbc <HAL_RTCEx_SetWakeUpTimer_IT+0x108>)
 8044ce2:	fba4 4303 	umull	r4, r3, r4, r3
 8044ce6:	0adb      	lsrs	r3, r3, #11
 8044ce8:	f44f 747a 	mov.w	r4, #1000	; 0x3e8
 8044cec:	fb04 f303 	mul.w	r3, r4, r3
 8044cf0:	9301      	str	r3, [sp, #4]
    do
    {
      if(count-- == 0U)
 8044cf2:	9b01      	ldr	r3, [sp, #4]
 8044cf4:	1e5c      	subs	r4, r3, #1
 8044cf6:	9401      	str	r4, [sp, #4]
 8044cf8:	2b00      	cmp	r3, #0
 8044cfa:	d048      	beq.n	8044d8e <HAL_RTCEx_SetWakeUpTimer_IT+0xda>
        __HAL_UNLOCK(hrtc);

        return HAL_TIMEOUT;
      }
    }
    while(__HAL_RTC_WAKEUPTIMER_GET_FLAG(hrtc, RTC_FLAG_WUTWF) == SET);
 8044cfc:	68eb      	ldr	r3, [r5, #12]
 8044cfe:	f013 0f04 	tst.w	r3, #4
 8044d02:	d1f6      	bne.n	8044cf2 <HAL_RTCEx_SetWakeUpTimer_IT+0x3e>
  }

  __HAL_RTC_WAKEUPTIMER_DISABLE(hrtc);
 8044d04:	68ab      	ldr	r3, [r5, #8]
 8044d06:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8044d0a:	60ab      	str	r3, [r5, #8]

  /* Wait till RTC WUTWF flag is set and if Time out is reached exit */
  count = RTC_TIMEOUT_VALUE  * (SystemCoreClock / 32U / 1000U);
 8044d0c:	4b2a      	ldr	r3, [pc, #168]	; (8044db8 <HAL_RTCEx_SetWakeUpTimer_IT+0x104>)
 8044d0e:	681b      	ldr	r3, [r3, #0]
 8044d10:	4c2a      	ldr	r4, [pc, #168]	; (8044dbc <HAL_RTCEx_SetWakeUpTimer_IT+0x108>)
 8044d12:	fba4 4303 	umull	r4, r3, r4, r3
 8044d16:	0adb      	lsrs	r3, r3, #11
 8044d18:	f44f 747a 	mov.w	r4, #1000	; 0x3e8
 8044d1c:	fb04 f303 	mul.w	r3, r4, r3
 8044d20:	9301      	str	r3, [sp, #4]
  do
  {
    if(count-- == 0U)
 8044d22:	9b01      	ldr	r3, [sp, #4]
 8044d24:	1e5c      	subs	r4, r3, #1
 8044d26:	9401      	str	r4, [sp, #4]
 8044d28:	2b00      	cmp	r3, #0
 8044d2a:	d038      	beq.n	8044d9e <HAL_RTCEx_SetWakeUpTimer_IT+0xea>
      __HAL_UNLOCK(hrtc);

      return HAL_TIMEOUT;
    }
  }
  while(__HAL_RTC_WAKEUPTIMER_GET_FLAG(hrtc, RTC_FLAG_WUTWF) == RESET);
 8044d2c:	6803      	ldr	r3, [r0, #0]
 8044d2e:	68dc      	ldr	r4, [r3, #12]
 8044d30:	f014 0f04 	tst.w	r4, #4
 8044d34:	d0f5      	beq.n	8044d22 <HAL_RTCEx_SetWakeUpTimer_IT+0x6e>

  /* Configure the Wake-up Timer counter */
  hrtc->Instance->WUTR = (uint32_t)WakeUpCounter;
 8044d36:	6159      	str	r1, [r3, #20]

  /* Clear the Wake-up Timer clock source bits in CR register */
  hrtc->Instance->CR &= (uint32_t)~RTC_CR_WUCKSEL;
 8044d38:	6801      	ldr	r1, [r0, #0]
 8044d3a:	688b      	ldr	r3, [r1, #8]
 8044d3c:	f023 0307 	bic.w	r3, r3, #7
 8044d40:	608b      	str	r3, [r1, #8]

  /* Configure the clock source */
  hrtc->Instance->CR |= (uint32_t)WakeUpClock;
 8044d42:	6801      	ldr	r1, [r0, #0]
 8044d44:	688b      	ldr	r3, [r1, #8]
 8044d46:	431a      	orrs	r2, r3
 8044d48:	608a      	str	r2, [r1, #8]

  /* RTC WakeUpTimer Interrupt Configuration: EXTI configuration */
  __HAL_RTC_WAKEUPTIMER_EXTI_ENABLE_IT();
 8044d4a:	4b1d      	ldr	r3, [pc, #116]	; (8044dc0 <HAL_RTCEx_SetWakeUpTimer_IT+0x10c>)
 8044d4c:	681a      	ldr	r2, [r3, #0]
 8044d4e:	f442 0280 	orr.w	r2, r2, #4194304	; 0x400000
 8044d52:	601a      	str	r2, [r3, #0]

  EXTI->RTSR |= RTC_EXTI_LINE_WAKEUPTIMER_EVENT;
 8044d54:	689a      	ldr	r2, [r3, #8]
 8044d56:	f442 0280 	orr.w	r2, r2, #4194304	; 0x400000
 8044d5a:	609a      	str	r2, [r3, #8]

  /* Clear RTC Wake Up timer Flag */
  __HAL_RTC_WAKEUPTIMER_CLEAR_FLAG(hrtc, RTC_FLAG_WUTF);
 8044d5c:	6802      	ldr	r2, [r0, #0]
 8044d5e:	68d3      	ldr	r3, [r2, #12]
 8044d60:	b2db      	uxtb	r3, r3
 8044d62:	f463 6390 	orn	r3, r3, #1152	; 0x480
 8044d66:	60d3      	str	r3, [r2, #12]

  /* Configure the Interrupt in the RTC_CR register */
  __HAL_RTC_WAKEUPTIMER_ENABLE_IT(hrtc,RTC_IT_WUT);
 8044d68:	6802      	ldr	r2, [r0, #0]
 8044d6a:	6893      	ldr	r3, [r2, #8]
 8044d6c:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8044d70:	6093      	str	r3, [r2, #8]

  /* Enable the Wake-up Timer */
  __HAL_RTC_WAKEUPTIMER_ENABLE(hrtc);
 8044d72:	6802      	ldr	r2, [r0, #0]
 8044d74:	6893      	ldr	r3, [r2, #8]
 8044d76:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8044d7a:	6093      	str	r3, [r2, #8]

  /* Enable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8044d7c:	6803      	ldr	r3, [r0, #0]
 8044d7e:	22ff      	movs	r2, #255	; 0xff
 8044d80:	625a      	str	r2, [r3, #36]	; 0x24

  hrtc->State = HAL_RTC_STATE_READY;
 8044d82:	2301      	movs	r3, #1
 8044d84:	7743      	strb	r3, [r0, #29]

  /* Process Unlocked */
  __HAL_UNLOCK(hrtc);
 8044d86:	2300      	movs	r3, #0
 8044d88:	7703      	strb	r3, [r0, #28]

  return HAL_OK;
 8044d8a:	4618      	mov	r0, r3
 8044d8c:	e00f      	b.n	8044dae <HAL_RTCEx_SetWakeUpTimer_IT+0xfa>
        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8044d8e:	23ff      	movs	r3, #255	; 0xff
 8044d90:	626b      	str	r3, [r5, #36]	; 0x24
        hrtc->State = HAL_RTC_STATE_TIMEOUT;
 8044d92:	2303      	movs	r3, #3
 8044d94:	7743      	strb	r3, [r0, #29]
        __HAL_UNLOCK(hrtc);
 8044d96:	2200      	movs	r2, #0
 8044d98:	7702      	strb	r2, [r0, #28]
        return HAL_TIMEOUT;
 8044d9a:	4618      	mov	r0, r3
 8044d9c:	e007      	b.n	8044dae <HAL_RTCEx_SetWakeUpTimer_IT+0xfa>
      __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8044d9e:	6803      	ldr	r3, [r0, #0]
 8044da0:	22ff      	movs	r2, #255	; 0xff
 8044da2:	625a      	str	r2, [r3, #36]	; 0x24
      hrtc->State = HAL_RTC_STATE_TIMEOUT;
 8044da4:	2303      	movs	r3, #3
 8044da6:	7743      	strb	r3, [r0, #29]
      __HAL_UNLOCK(hrtc);
 8044da8:	2200      	movs	r2, #0
 8044daa:	7702      	strb	r2, [r0, #28]
      return HAL_TIMEOUT;
 8044dac:	4618      	mov	r0, r3
}
 8044dae:	b002      	add	sp, #8
 8044db0:	bc30      	pop	{r4, r5}
 8044db2:	4770      	bx	lr
  __HAL_LOCK(hrtc);
 8044db4:	2002      	movs	r0, #2
}
 8044db6:	4770      	bx	lr
 8044db8:	20003678 	.word	0x20003678
 8044dbc:	10624dd3 	.word	0x10624dd3
 8044dc0:	40013c00 	.word	0x40013c00

08044dc4 <HAL_RTCEx_WakeUpTimerIRQHandler>:
  * @param  hrtc pointer to a RTC_HandleTypeDef structure that contains
  *                the configuration information for RTC.
  * @retval None
  */
void HAL_RTCEx_WakeUpTimerIRQHandler(RTC_HandleTypeDef *hrtc)
{
 8044dc4:	b510      	push	{r4, lr}
 8044dc6:	4604      	mov	r4, r0
  if(__HAL_RTC_WAKEUPTIMER_GET_IT(hrtc, RTC_IT_WUT))
 8044dc8:	6803      	ldr	r3, [r0, #0]
 8044dca:	68da      	ldr	r2, [r3, #12]
 8044dcc:	f412 6f80 	tst.w	r2, #1024	; 0x400
 8044dd0:	d003      	beq.n	8044dda <HAL_RTCEx_WakeUpTimerIRQHandler+0x16>
  {
    /* Get the status of the Interrupt */
    if((uint32_t)(hrtc->Instance->CR & RTC_IT_WUT) != (uint32_t)RESET)
 8044dd2:	689b      	ldr	r3, [r3, #8]
 8044dd4:	f413 4f80 	tst.w	r3, #16384	; 0x4000
 8044dd8:	d106      	bne.n	8044de8 <HAL_RTCEx_WakeUpTimerIRQHandler+0x24>
      __HAL_RTC_WAKEUPTIMER_CLEAR_FLAG(hrtc, RTC_FLAG_WUTF);
    }
  }

  /* Clear the EXTI's line Flag for RTC WakeUpTimer */
  __HAL_RTC_WAKEUPTIMER_EXTI_CLEAR_FLAG();
 8044dda:	4b08      	ldr	r3, [pc, #32]	; (8044dfc <HAL_RTCEx_WakeUpTimerIRQHandler+0x38>)
 8044ddc:	f44f 0280 	mov.w	r2, #4194304	; 0x400000
 8044de0:	615a      	str	r2, [r3, #20]

  /* Change RTC state */
  hrtc->State = HAL_RTC_STATE_READY;
 8044de2:	2301      	movs	r3, #1
 8044de4:	7763      	strb	r3, [r4, #29]
}
 8044de6:	bd10      	pop	{r4, pc}
      HAL_RTCEx_WakeUpTimerEventCallback(hrtc);
 8044de8:	f00c f9b2 	bl	8051150 <HAL_RTCEx_WakeUpTimerEventCallback>
      __HAL_RTC_WAKEUPTIMER_CLEAR_FLAG(hrtc, RTC_FLAG_WUTF);
 8044dec:	6822      	ldr	r2, [r4, #0]
 8044dee:	68d3      	ldr	r3, [r2, #12]
 8044df0:	b2db      	uxtb	r3, r3
 8044df2:	f463 6390 	orn	r3, r3, #1152	; 0x480
 8044df6:	60d3      	str	r3, [r2, #12]
 8044df8:	e7ef      	b.n	8044dda <HAL_RTCEx_WakeUpTimerIRQHandler+0x16>
 8044dfa:	bf00      	nop
 8044dfc:	40013c00 	.word	0x40013c00

08044e00 <HAL_RTCEx_BKUPRead>:
  uint32_t tmp = 0U;

  /* Check the parameters */
  assert_param(IS_RTC_BKP(BackupRegister));

  tmp = (uint32_t)&(hrtc->Instance->BKP0R);
 8044e00:	6803      	ldr	r3, [r0, #0]
 8044e02:	3350      	adds	r3, #80	; 0x50
  tmp += (BackupRegister * 4U);

  /* Read the specified register */
  return (*(__IO uint32_t *)tmp);
 8044e04:	f853 0021 	ldr.w	r0, [r3, r1, lsl #2]
}
 8044e08:	4770      	bx	lr

08044e0a <HAL_RTCEx_AlarmBEventCallback>:
  /* Prevent unused argument(s) compilation warning */
  UNUSED(hrtc);
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_RTC_AlarmBEventCallback could be implemented in the user file
   */
}
 8044e0a:	4770      	bx	lr

08044e0c <HAL_TIM_Base_Start_IT>:

  /* Check the parameters */
  assert_param(IS_TIM_INSTANCE(htim->Instance));

  /* Enable the TIM Update interrupt */
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
 8044e0c:	6802      	ldr	r2, [r0, #0]
 8044e0e:	68d3      	ldr	r3, [r2, #12]
 8044e10:	f043 0301 	orr.w	r3, r3, #1
 8044e14:	60d3      	str	r3, [r2, #12]

  /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
  tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 8044e16:	6802      	ldr	r2, [r0, #0]
 8044e18:	6893      	ldr	r3, [r2, #8]
 8044e1a:	f003 0307 	and.w	r3, r3, #7
  if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 8044e1e:	2b06      	cmp	r3, #6
 8044e20:	d003      	beq.n	8044e2a <HAL_TIM_Base_Start_IT+0x1e>
  {
    __HAL_TIM_ENABLE(htim);
 8044e22:	6813      	ldr	r3, [r2, #0]
 8044e24:	f043 0301 	orr.w	r3, r3, #1
 8044e28:	6013      	str	r3, [r2, #0]
  }

  /* Return function status */
  return HAL_OK;
}
 8044e2a:	2000      	movs	r0, #0
 8044e2c:	4770      	bx	lr

08044e2e <HAL_TIM_OC_DelayElapsedCallback>:
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_OC_DelayElapsedCallback could be implemented in the user file
   */
}
 8044e2e:	4770      	bx	lr

08044e30 <HAL_TIM_IC_CaptureCallback>:
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_IC_CaptureCallback could be implemented in the user file
   */
}
 8044e30:	4770      	bx	lr

08044e32 <HAL_TIM_PWM_PulseFinishedCallback>:
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_PWM_PulseFinishedCallback could be implemented in the user file
   */
}
 8044e32:	4770      	bx	lr

08044e34 <HAL_TIM_TriggerCallback>:
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_TriggerCallback could be implemented in the user file
   */
}
 8044e34:	4770      	bx	lr

08044e36 <HAL_TIM_IRQHandler>:
{
 8044e36:	b510      	push	{r4, lr}
 8044e38:	4604      	mov	r4, r0
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
 8044e3a:	6803      	ldr	r3, [r0, #0]
 8044e3c:	691a      	ldr	r2, [r3, #16]
 8044e3e:	f012 0f02 	tst.w	r2, #2
 8044e42:	d011      	beq.n	8044e68 <HAL_TIM_IRQHandler+0x32>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC1) != RESET)
 8044e44:	68da      	ldr	r2, [r3, #12]
 8044e46:	f012 0f02 	tst.w	r2, #2
 8044e4a:	d00d      	beq.n	8044e68 <HAL_TIM_IRQHandler+0x32>
        __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1);
 8044e4c:	f06f 0202 	mvn.w	r2, #2
 8044e50:	611a      	str	r2, [r3, #16]
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
 8044e52:	2301      	movs	r3, #1
 8044e54:	7703      	strb	r3, [r0, #28]
        if ((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00U)
 8044e56:	6803      	ldr	r3, [r0, #0]
 8044e58:	699b      	ldr	r3, [r3, #24]
 8044e5a:	f013 0f03 	tst.w	r3, #3
 8044e5e:	d070      	beq.n	8044f42 <HAL_TIM_IRQHandler+0x10c>
          HAL_TIM_IC_CaptureCallback(htim);
 8044e60:	f7ff ffe6 	bl	8044e30 <HAL_TIM_IC_CaptureCallback>
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8044e64:	2300      	movs	r3, #0
 8044e66:	7723      	strb	r3, [r4, #28]
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC2) != RESET)
 8044e68:	6823      	ldr	r3, [r4, #0]
 8044e6a:	691a      	ldr	r2, [r3, #16]
 8044e6c:	f012 0f04 	tst.w	r2, #4
 8044e70:	d012      	beq.n	8044e98 <HAL_TIM_IRQHandler+0x62>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC2) != RESET)
 8044e72:	68da      	ldr	r2, [r3, #12]
 8044e74:	f012 0f04 	tst.w	r2, #4
 8044e78:	d00e      	beq.n	8044e98 <HAL_TIM_IRQHandler+0x62>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
 8044e7a:	f06f 0204 	mvn.w	r2, #4
 8044e7e:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
 8044e80:	2302      	movs	r3, #2
 8044e82:	7723      	strb	r3, [r4, #28]
      if ((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
 8044e84:	6823      	ldr	r3, [r4, #0]
 8044e86:	699b      	ldr	r3, [r3, #24]
 8044e88:	f413 7f40 	tst.w	r3, #768	; 0x300
 8044e8c:	d05f      	beq.n	8044f4e <HAL_TIM_IRQHandler+0x118>
        HAL_TIM_IC_CaptureCallback(htim);
 8044e8e:	4620      	mov	r0, r4
 8044e90:	f7ff ffce 	bl	8044e30 <HAL_TIM_IC_CaptureCallback>
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8044e94:	2300      	movs	r3, #0
 8044e96:	7723      	strb	r3, [r4, #28]
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC3) != RESET)
 8044e98:	6823      	ldr	r3, [r4, #0]
 8044e9a:	691a      	ldr	r2, [r3, #16]
 8044e9c:	f012 0f08 	tst.w	r2, #8
 8044ea0:	d012      	beq.n	8044ec8 <HAL_TIM_IRQHandler+0x92>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC3) != RESET)
 8044ea2:	68da      	ldr	r2, [r3, #12]
 8044ea4:	f012 0f08 	tst.w	r2, #8
 8044ea8:	d00e      	beq.n	8044ec8 <HAL_TIM_IRQHandler+0x92>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
 8044eaa:	f06f 0208 	mvn.w	r2, #8
 8044eae:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
 8044eb0:	2304      	movs	r3, #4
 8044eb2:	7723      	strb	r3, [r4, #28]
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
 8044eb4:	6823      	ldr	r3, [r4, #0]
 8044eb6:	69db      	ldr	r3, [r3, #28]
 8044eb8:	f013 0f03 	tst.w	r3, #3
 8044ebc:	d04e      	beq.n	8044f5c <HAL_TIM_IRQHandler+0x126>
        HAL_TIM_IC_CaptureCallback(htim);
 8044ebe:	4620      	mov	r0, r4
 8044ec0:	f7ff ffb6 	bl	8044e30 <HAL_TIM_IC_CaptureCallback>
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8044ec4:	2300      	movs	r3, #0
 8044ec6:	7723      	strb	r3, [r4, #28]
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC4) != RESET)
 8044ec8:	6823      	ldr	r3, [r4, #0]
 8044eca:	691a      	ldr	r2, [r3, #16]
 8044ecc:	f012 0f10 	tst.w	r2, #16
 8044ed0:	d012      	beq.n	8044ef8 <HAL_TIM_IRQHandler+0xc2>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC4) != RESET)
 8044ed2:	68da      	ldr	r2, [r3, #12]
 8044ed4:	f012 0f10 	tst.w	r2, #16
 8044ed8:	d00e      	beq.n	8044ef8 <HAL_TIM_IRQHandler+0xc2>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
 8044eda:	f06f 0210 	mvn.w	r2, #16
 8044ede:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
 8044ee0:	2308      	movs	r3, #8
 8044ee2:	7723      	strb	r3, [r4, #28]
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
 8044ee4:	6823      	ldr	r3, [r4, #0]
 8044ee6:	69db      	ldr	r3, [r3, #28]
 8044ee8:	f413 7f40 	tst.w	r3, #768	; 0x300
 8044eec:	d03d      	beq.n	8044f6a <HAL_TIM_IRQHandler+0x134>
        HAL_TIM_IC_CaptureCallback(htim);
 8044eee:	4620      	mov	r0, r4
 8044ef0:	f7ff ff9e 	bl	8044e30 <HAL_TIM_IC_CaptureCallback>
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8044ef4:	2300      	movs	r3, #0
 8044ef6:	7723      	strb	r3, [r4, #28]
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_UPDATE) != RESET)
 8044ef8:	6823      	ldr	r3, [r4, #0]
 8044efa:	691a      	ldr	r2, [r3, #16]
 8044efc:	f012 0f01 	tst.w	r2, #1
 8044f00:	d003      	beq.n	8044f0a <HAL_TIM_IRQHandler+0xd4>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_UPDATE) != RESET)
 8044f02:	68da      	ldr	r2, [r3, #12]
 8044f04:	f012 0f01 	tst.w	r2, #1
 8044f08:	d136      	bne.n	8044f78 <HAL_TIM_IRQHandler+0x142>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK) != RESET)
 8044f0a:	6823      	ldr	r3, [r4, #0]
 8044f0c:	691a      	ldr	r2, [r3, #16]
 8044f0e:	f012 0f80 	tst.w	r2, #128	; 0x80
 8044f12:	d003      	beq.n	8044f1c <HAL_TIM_IRQHandler+0xe6>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) != RESET)
 8044f14:	68da      	ldr	r2, [r3, #12]
 8044f16:	f012 0f80 	tst.w	r2, #128	; 0x80
 8044f1a:	d134      	bne.n	8044f86 <HAL_TIM_IRQHandler+0x150>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_TRIGGER) != RESET)
 8044f1c:	6823      	ldr	r3, [r4, #0]
 8044f1e:	691a      	ldr	r2, [r3, #16]
 8044f20:	f012 0f40 	tst.w	r2, #64	; 0x40
 8044f24:	d003      	beq.n	8044f2e <HAL_TIM_IRQHandler+0xf8>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_TRIGGER) != RESET)
 8044f26:	68da      	ldr	r2, [r3, #12]
 8044f28:	f012 0f40 	tst.w	r2, #64	; 0x40
 8044f2c:	d132      	bne.n	8044f94 <HAL_TIM_IRQHandler+0x15e>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_COM) != RESET)
 8044f2e:	6823      	ldr	r3, [r4, #0]
 8044f30:	691a      	ldr	r2, [r3, #16]
 8044f32:	f012 0f20 	tst.w	r2, #32
 8044f36:	d003      	beq.n	8044f40 <HAL_TIM_IRQHandler+0x10a>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_COM) != RESET)
 8044f38:	68da      	ldr	r2, [r3, #12]
 8044f3a:	f012 0f20 	tst.w	r2, #32
 8044f3e:	d130      	bne.n	8044fa2 <HAL_TIM_IRQHandler+0x16c>
}
 8044f40:	bd10      	pop	{r4, pc}
          HAL_TIM_OC_DelayElapsedCallback(htim);
 8044f42:	f7ff ff74 	bl	8044e2e <HAL_TIM_OC_DelayElapsedCallback>
          HAL_TIM_PWM_PulseFinishedCallback(htim);
 8044f46:	4620      	mov	r0, r4
 8044f48:	f7ff ff73 	bl	8044e32 <HAL_TIM_PWM_PulseFinishedCallback>
 8044f4c:	e78a      	b.n	8044e64 <HAL_TIM_IRQHandler+0x2e>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8044f4e:	4620      	mov	r0, r4
 8044f50:	f7ff ff6d 	bl	8044e2e <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 8044f54:	4620      	mov	r0, r4
 8044f56:	f7ff ff6c 	bl	8044e32 <HAL_TIM_PWM_PulseFinishedCallback>
 8044f5a:	e79b      	b.n	8044e94 <HAL_TIM_IRQHandler+0x5e>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8044f5c:	4620      	mov	r0, r4
 8044f5e:	f7ff ff66 	bl	8044e2e <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 8044f62:	4620      	mov	r0, r4
 8044f64:	f7ff ff65 	bl	8044e32 <HAL_TIM_PWM_PulseFinishedCallback>
 8044f68:	e7ac      	b.n	8044ec4 <HAL_TIM_IRQHandler+0x8e>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8044f6a:	4620      	mov	r0, r4
 8044f6c:	f7ff ff5f 	bl	8044e2e <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 8044f70:	4620      	mov	r0, r4
 8044f72:	f7ff ff5e 	bl	8044e32 <HAL_TIM_PWM_PulseFinishedCallback>
 8044f76:	e7bd      	b.n	8044ef4 <HAL_TIM_IRQHandler+0xbe>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
 8044f78:	f06f 0201 	mvn.w	r2, #1
 8044f7c:	611a      	str	r2, [r3, #16]
      HAL_TIM_PeriodElapsedCallback(htim);
 8044f7e:	4620      	mov	r0, r4
 8044f80:	f00c f9a2 	bl	80512c8 <HAL_TIM_PeriodElapsedCallback>
 8044f84:	e7c1      	b.n	8044f0a <HAL_TIM_IRQHandler+0xd4>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
 8044f86:	f06f 0280 	mvn.w	r2, #128	; 0x80
 8044f8a:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_BreakCallback(htim);
 8044f8c:	4620      	mov	r0, r4
 8044f8e:	f000 f8b1 	bl	80450f4 <HAL_TIMEx_BreakCallback>
 8044f92:	e7c3      	b.n	8044f1c <HAL_TIM_IRQHandler+0xe6>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);
 8044f94:	f06f 0240 	mvn.w	r2, #64	; 0x40
 8044f98:	611a      	str	r2, [r3, #16]
      HAL_TIM_TriggerCallback(htim);
 8044f9a:	4620      	mov	r0, r4
 8044f9c:	f7ff ff4a 	bl	8044e34 <HAL_TIM_TriggerCallback>
 8044fa0:	e7c5      	b.n	8044f2e <HAL_TIM_IRQHandler+0xf8>
      __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);
 8044fa2:	f06f 0220 	mvn.w	r2, #32
 8044fa6:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_CommutCallback(htim);
 8044fa8:	4620      	mov	r0, r4
 8044faa:	f000 f8a2 	bl	80450f2 <HAL_TIMEx_CommutCallback>
}
 8044fae:	e7c7      	b.n	8044f40 <HAL_TIM_IRQHandler+0x10a>

08044fb0 <TIM_Base_SetConfig>:
  * @retval None
  */
void TIM_Base_SetConfig(TIM_TypeDef *TIMx, TIM_Base_InitTypeDef *Structure)
{
  uint32_t tmpcr1;
  tmpcr1 = TIMx->CR1;
 8044fb0:	6803      	ldr	r3, [r0, #0]

  /* Set TIM Time Base Unit parameters ---------------------------------------*/
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8044fb2:	4a30      	ldr	r2, [pc, #192]	; (8045074 <TIM_Base_SetConfig+0xc4>)
 8044fb4:	4290      	cmp	r0, r2
 8044fb6:	d012      	beq.n	8044fde <TIM_Base_SetConfig+0x2e>
 8044fb8:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
 8044fbc:	d00f      	beq.n	8044fde <TIM_Base_SetConfig+0x2e>
 8044fbe:	f5a2 427c 	sub.w	r2, r2, #64512	; 0xfc00
 8044fc2:	4290      	cmp	r0, r2
 8044fc4:	d00b      	beq.n	8044fde <TIM_Base_SetConfig+0x2e>
 8044fc6:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8044fca:	4290      	cmp	r0, r2
 8044fcc:	d007      	beq.n	8044fde <TIM_Base_SetConfig+0x2e>
 8044fce:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8044fd2:	4290      	cmp	r0, r2
 8044fd4:	d003      	beq.n	8044fde <TIM_Base_SetConfig+0x2e>
 8044fd6:	f502 4278 	add.w	r2, r2, #63488	; 0xf800
 8044fda:	4290      	cmp	r0, r2
 8044fdc:	d103      	bne.n	8044fe6 <TIM_Base_SetConfig+0x36>
  {
    /* Select the Counter Mode */
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 8044fde:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= Structure->CounterMode;
 8044fe2:	684a      	ldr	r2, [r1, #4]
 8044fe4:	4313      	orrs	r3, r2
  }

  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 8044fe6:	4a23      	ldr	r2, [pc, #140]	; (8045074 <TIM_Base_SetConfig+0xc4>)
 8044fe8:	4290      	cmp	r0, r2
 8044fea:	d02a      	beq.n	8045042 <TIM_Base_SetConfig+0x92>
 8044fec:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
 8044ff0:	d027      	beq.n	8045042 <TIM_Base_SetConfig+0x92>
 8044ff2:	f5a2 427c 	sub.w	r2, r2, #64512	; 0xfc00
 8044ff6:	4290      	cmp	r0, r2
 8044ff8:	d023      	beq.n	8045042 <TIM_Base_SetConfig+0x92>
 8044ffa:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8044ffe:	4290      	cmp	r0, r2
 8045000:	d01f      	beq.n	8045042 <TIM_Base_SetConfig+0x92>
 8045002:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8045006:	4290      	cmp	r0, r2
 8045008:	d01b      	beq.n	8045042 <TIM_Base_SetConfig+0x92>
 804500a:	f502 4278 	add.w	r2, r2, #63488	; 0xf800
 804500e:	4290      	cmp	r0, r2
 8045010:	d017      	beq.n	8045042 <TIM_Base_SetConfig+0x92>
 8045012:	f502 5270 	add.w	r2, r2, #15360	; 0x3c00
 8045016:	4290      	cmp	r0, r2
 8045018:	d013      	beq.n	8045042 <TIM_Base_SetConfig+0x92>
 804501a:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 804501e:	4290      	cmp	r0, r2
 8045020:	d00f      	beq.n	8045042 <TIM_Base_SetConfig+0x92>
 8045022:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8045026:	4290      	cmp	r0, r2
 8045028:	d00b      	beq.n	8045042 <TIM_Base_SetConfig+0x92>
 804502a:	f5a2 3298 	sub.w	r2, r2, #77824	; 0x13000
 804502e:	4290      	cmp	r0, r2
 8045030:	d007      	beq.n	8045042 <TIM_Base_SetConfig+0x92>
 8045032:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8045036:	4290      	cmp	r0, r2
 8045038:	d003      	beq.n	8045042 <TIM_Base_SetConfig+0x92>
 804503a:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 804503e:	4290      	cmp	r0, r2
 8045040:	d103      	bne.n	804504a <TIM_Base_SetConfig+0x9a>
  {
    /* Set the clock division */
    tmpcr1 &= ~TIM_CR1_CKD;
 8045042:	f423 7340 	bic.w	r3, r3, #768	; 0x300
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8045046:	68ca      	ldr	r2, [r1, #12]
 8045048:	4313      	orrs	r3, r2
  }

  /* Set the auto-reload preload */
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 804504a:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 804504e:	694a      	ldr	r2, [r1, #20]
 8045050:	4313      	orrs	r3, r2

  TIMx->CR1 = tmpcr1;
 8045052:	6003      	str	r3, [r0, #0]

  /* Set the Autoreload value */
  TIMx->ARR = (uint32_t)Structure->Period ;
 8045054:	688b      	ldr	r3, [r1, #8]
 8045056:	62c3      	str	r3, [r0, #44]	; 0x2c

  /* Set the Prescaler value */
  TIMx->PSC = Structure->Prescaler;
 8045058:	680b      	ldr	r3, [r1, #0]
 804505a:	6283      	str	r3, [r0, #40]	; 0x28

  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
 804505c:	4b05      	ldr	r3, [pc, #20]	; (8045074 <TIM_Base_SetConfig+0xc4>)
 804505e:	4298      	cmp	r0, r3
 8045060:	d003      	beq.n	804506a <TIM_Base_SetConfig+0xba>
 8045062:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8045066:	4298      	cmp	r0, r3
 8045068:	d101      	bne.n	804506e <TIM_Base_SetConfig+0xbe>
  {
    /* Set the Repetition Counter value */
    TIMx->RCR = Structure->RepetitionCounter;
 804506a:	690b      	ldr	r3, [r1, #16]
 804506c:	6303      	str	r3, [r0, #48]	; 0x30
  }

  /* Generate an update event to reload the Prescaler
     and the repetition counter (only for advanced timer) value immediately */
  TIMx->EGR = TIM_EGR_UG;
 804506e:	2301      	movs	r3, #1
 8045070:	6143      	str	r3, [r0, #20]
}
 8045072:	4770      	bx	lr
 8045074:	40010000 	.word	0x40010000

08045078 <HAL_TIM_Base_Init>:
  if (htim == NULL)
 8045078:	b1b0      	cbz	r0, 80450a8 <HAL_TIM_Base_Init+0x30>
{
 804507a:	b510      	push	{r4, lr}
 804507c:	4604      	mov	r4, r0
  if (htim->State == HAL_TIM_STATE_RESET)
 804507e:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 8045082:	b163      	cbz	r3, 804509e <HAL_TIM_Base_Init+0x26>
  htim->State = HAL_TIM_STATE_BUSY;
 8045084:	2302      	movs	r3, #2
 8045086:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 804508a:	4621      	mov	r1, r4
 804508c:	f851 0b04 	ldr.w	r0, [r1], #4
 8045090:	f7ff ff8e 	bl	8044fb0 <TIM_Base_SetConfig>
  htim->State = HAL_TIM_STATE_READY;
 8045094:	2301      	movs	r3, #1
 8045096:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  return HAL_OK;
 804509a:	2000      	movs	r0, #0
}
 804509c:	bd10      	pop	{r4, pc}
    htim->Lock = HAL_UNLOCKED;
 804509e:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
    HAL_TIM_Base_MspInit(htim);
 80450a2:	f00b fb45 	bl	8050730 <HAL_TIM_Base_MspInit>
 80450a6:	e7ed      	b.n	8045084 <HAL_TIM_Base_Init+0xc>
    return HAL_ERROR;
 80450a8:	2001      	movs	r0, #1
}
 80450aa:	4770      	bx	lr

080450ac <HAL_TIMEx_MasterConfigSynchronization>:
  assert_param(IS_TIM_SYNCHRO_INSTANCE(htim->Instance));
  assert_param(IS_TIM_TRGO_SOURCE(sMasterConfig->MasterOutputTrigger));
  assert_param(IS_TIM_MSM_STATE(sMasterConfig->MasterSlaveMode));

  /* Check input state */
  __HAL_LOCK(htim);
 80450ac:	f890 303c 	ldrb.w	r3, [r0, #60]	; 0x3c
 80450b0:	2b01      	cmp	r3, #1
 80450b2:	d01c      	beq.n	80450ee <HAL_TIMEx_MasterConfigSynchronization+0x42>
{
 80450b4:	b470      	push	{r4, r5, r6}
  __HAL_LOCK(htim);
 80450b6:	2601      	movs	r6, #1
 80450b8:	f880 603c 	strb.w	r6, [r0, #60]	; 0x3c

  /* Change the handler state */
  htim->State = HAL_TIM_STATE_BUSY;
 80450bc:	2302      	movs	r3, #2
 80450be:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d

  /* Get the TIMx CR2 register value */
  tmpcr2 = htim->Instance->CR2;
 80450c2:	6802      	ldr	r2, [r0, #0]
 80450c4:	6855      	ldr	r5, [r2, #4]

  /* Get the TIMx SMCR register value */
  tmpsmcr = htim->Instance->SMCR;
 80450c6:	6893      	ldr	r3, [r2, #8]

  /* Reset the MMS Bits */
  tmpcr2 &= ~TIM_CR2_MMS;
 80450c8:	f025 0570 	bic.w	r5, r5, #112	; 0x70
  /* Select the TRGO source */
  tmpcr2 |=  sMasterConfig->MasterOutputTrigger;
 80450cc:	680c      	ldr	r4, [r1, #0]
 80450ce:	432c      	orrs	r4, r5

  /* Reset the MSM Bit */
  tmpsmcr &= ~TIM_SMCR_MSM;
 80450d0:	f023 0580 	bic.w	r5, r3, #128	; 0x80
  /* Set master mode */
  tmpsmcr |= sMasterConfig->MasterSlaveMode;
 80450d4:	684b      	ldr	r3, [r1, #4]
 80450d6:	432b      	orrs	r3, r5

  /* Update TIMx CR2 */
  htim->Instance->CR2 = tmpcr2;
 80450d8:	6054      	str	r4, [r2, #4]

  /* Update TIMx SMCR */
  htim->Instance->SMCR = tmpsmcr;
 80450da:	6802      	ldr	r2, [r0, #0]
 80450dc:	6093      	str	r3, [r2, #8]

  /* Change the htim state */
  htim->State = HAL_TIM_STATE_READY;
 80450de:	f880 603d 	strb.w	r6, [r0, #61]	; 0x3d

  __HAL_UNLOCK(htim);
 80450e2:	2300      	movs	r3, #0
 80450e4:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c

  return HAL_OK;
 80450e8:	4618      	mov	r0, r3
}
 80450ea:	bc70      	pop	{r4, r5, r6}
 80450ec:	4770      	bx	lr
  __HAL_LOCK(htim);
 80450ee:	2002      	movs	r0, #2
}
 80450f0:	4770      	bx	lr

080450f2 <HAL_TIMEx_CommutCallback>:
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIMEx_CommutCallback could be implemented in the user file
   */
}
 80450f2:	4770      	bx	lr

080450f4 <HAL_TIMEx_BreakCallback>:
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIMEx_BreakCallback could be implemented in the user file
   */
}
 80450f4:	4770      	bx	lr

080450f6 <LL_GPIO_Init>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: GPIO registers are initialized according to GPIO_InitStruct content
  *          - ERROR:   Not applicable
  */
ErrorStatus LL_GPIO_Init(GPIO_TypeDef *GPIOx, LL_GPIO_InitTypeDef *GPIO_InitStruct)
{
 80450f6:	b4f0      	push	{r4, r5, r6, r7}
  assert_param(IS_LL_GPIO_MODE(GPIO_InitStruct->Mode));
  assert_param(IS_LL_GPIO_PULL(GPIO_InitStruct->Pull));

  /* ------------------------- Configure the port pins ---------------- */
  /* Initialize  pinpos on first pin set */
  pinpos = POSITION_VAL(GPIO_InitStruct->Pin);
 80450f8:	680c      	ldr	r4, [r1, #0]
  uint32_t result;

#if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
     (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
     (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80450fa:	fa94 f4a4 	rbit	r4, r4
 80450fe:	fab4 f484 	clz	r4, r4

  /* Configure the port pins */
  while (((GPIO_InitStruct->Pin) >> pinpos) != 0x00000000U)
 8045102:	e02c      	b.n	804515e <LL_GPIO_Init+0x68>
      {
        /* Check Speed mode parameters */
        assert_param(IS_LL_GPIO_SPEED(GPIO_InitStruct->Speed));

        /* Speed mode configuration */
        LL_GPIO_SetPinSpeed(GPIOx, currentpin, GPIO_InitStruct->Speed);
 8045104:	688e      	ldr	r6, [r1, #8]
  *         @arg @ref LL_GPIO_SPEED_FREQ_VERY_HIGH
  * @retval None
  */
__STATIC_INLINE void LL_GPIO_SetPinSpeed(GPIO_TypeDef *GPIOx, uint32_t Pin, uint32_t  Speed)
{
  MODIFY_REG(GPIOx->OSPEEDR, (GPIO_OSPEEDER_OSPEEDR0 << (POSITION_VAL(Pin) * 2U)),
 8045106:	6882      	ldr	r2, [r0, #8]
 8045108:	fa93 f5a3 	rbit	r5, r3
 804510c:	fab5 f585 	clz	r5, r5
 8045110:	006d      	lsls	r5, r5, #1
 8045112:	fa07 f505 	lsl.w	r5, r7, r5
 8045116:	ea22 0205 	bic.w	r2, r2, r5
 804511a:	fa93 f5a3 	rbit	r5, r3
 804511e:	fab5 f585 	clz	r5, r5
 8045122:	006d      	lsls	r5, r5, #1
 8045124:	fa06 f505 	lsl.w	r5, r6, r5
 8045128:	432a      	orrs	r2, r5
 804512a:	6082      	str	r2, [r0, #8]
      }

      /* Pull-up Pull down resistor configuration*/
      LL_GPIO_SetPinPull(GPIOx, currentpin, GPIO_InitStruct->Pull);
 804512c:	690e      	ldr	r6, [r1, #16]
  *         @arg @ref LL_GPIO_PULL_DOWN
  * @retval None
  */
__STATIC_INLINE void LL_GPIO_SetPinPull(GPIO_TypeDef *GPIOx, uint32_t Pin, uint32_t Pull)
{
  MODIFY_REG(GPIOx->PUPDR, (GPIO_PUPDR_PUPDR0 << (POSITION_VAL(Pin) * 2U)), (Pull << (POSITION_VAL(Pin) * 2U)));
 804512e:	68c2      	ldr	r2, [r0, #12]
 8045130:	fa93 f5a3 	rbit	r5, r3
 8045134:	fab5 f585 	clz	r5, r5
 8045138:	006d      	lsls	r5, r5, #1
 804513a:	2703      	movs	r7, #3
 804513c:	fa07 f505 	lsl.w	r5, r7, r5
 8045140:	ea22 0205 	bic.w	r2, r2, r5
 8045144:	fa93 f5a3 	rbit	r5, r3
 8045148:	fab5 f585 	clz	r5, r5
 804514c:	006d      	lsls	r5, r5, #1
 804514e:	fa06 f505 	lsl.w	r5, r6, r5
 8045152:	432a      	orrs	r2, r5
 8045154:	60c2      	str	r2, [r0, #12]

      if (GPIO_InitStruct->Mode == LL_GPIO_MODE_ALTERNATE)
 8045156:	684a      	ldr	r2, [r1, #4]
 8045158:	2a02      	cmp	r2, #2
 804515a:	d022      	beq.n	80451a2 <LL_GPIO_Init+0xac>
        {
          LL_GPIO_SetAFPin_8_15(GPIOx, currentpin, GPIO_InitStruct->Alternate);
        }
      }
    }
    pinpos++;
 804515c:	3401      	adds	r4, #1
  while (((GPIO_InitStruct->Pin) >> pinpos) != 0x00000000U)
 804515e:	680b      	ldr	r3, [r1, #0]
 8045160:	fa33 f204 	lsrs.w	r2, r3, r4
 8045164:	d050      	beq.n	8045208 <LL_GPIO_Init+0x112>
    currentpin = (GPIO_InitStruct->Pin) & (0x00000001U << pinpos);
 8045166:	2201      	movs	r2, #1
 8045168:	40a2      	lsls	r2, r4
    if (currentpin)
 804516a:	4013      	ands	r3, r2
 804516c:	d0f6      	beq.n	804515c <LL_GPIO_Init+0x66>
      LL_GPIO_SetPinMode(GPIOx, currentpin, GPIO_InitStruct->Mode);
 804516e:	684e      	ldr	r6, [r1, #4]
  MODIFY_REG(GPIOx->MODER, (GPIO_MODER_MODER0 << (POSITION_VAL(Pin) * 2U)), (Mode << (POSITION_VAL(Pin) * 2U)));
 8045170:	6802      	ldr	r2, [r0, #0]
 8045172:	fa93 f5a3 	rbit	r5, r3
 8045176:	fab5 f585 	clz	r5, r5
 804517a:	006d      	lsls	r5, r5, #1
 804517c:	2703      	movs	r7, #3
 804517e:	fa07 f505 	lsl.w	r5, r7, r5
 8045182:	ea22 0205 	bic.w	r2, r2, r5
 8045186:	fa93 f5a3 	rbit	r5, r3
 804518a:	fab5 f585 	clz	r5, r5
 804518e:	006d      	lsls	r5, r5, #1
 8045190:	fa06 f505 	lsl.w	r5, r6, r5
 8045194:	432a      	orrs	r2, r5
 8045196:	6002      	str	r2, [r0, #0]
      if ((GPIO_InitStruct->Mode == LL_GPIO_MODE_OUTPUT) || (GPIO_InitStruct->Mode == LL_GPIO_MODE_ALTERNATE))
 8045198:	684a      	ldr	r2, [r1, #4]
 804519a:	3a01      	subs	r2, #1
 804519c:	2a01      	cmp	r2, #1
 804519e:	d8c5      	bhi.n	804512c <LL_GPIO_Init+0x36>
 80451a0:	e7b0      	b.n	8045104 <LL_GPIO_Init+0xe>
 80451a2:	fa93 f2a3 	rbit	r2, r3
        if (POSITION_VAL(currentpin) < 0x00000008U)
 80451a6:	fab2 f282 	clz	r2, r2
 80451aa:	2a07      	cmp	r2, #7
 80451ac:	d815      	bhi.n	80451da <LL_GPIO_Init+0xe4>
          LL_GPIO_SetAFPin_0_7(GPIOx, currentpin, GPIO_InitStruct->Alternate);
 80451ae:	694d      	ldr	r5, [r1, #20]
  *         @arg @ref LL_GPIO_AF_15
  * @retval None
  */
__STATIC_INLINE void LL_GPIO_SetAFPin_0_7(GPIO_TypeDef *GPIOx, uint32_t Pin, uint32_t Alternate)
{
  MODIFY_REG(GPIOx->AFR[0], (GPIO_AFRL_AFSEL0 << (POSITION_VAL(Pin) * 4U)),
 80451b0:	6a02      	ldr	r2, [r0, #32]
 80451b2:	fa93 f6a3 	rbit	r6, r3
 80451b6:	fab6 f686 	clz	r6, r6
 80451ba:	00b6      	lsls	r6, r6, #2
 80451bc:	270f      	movs	r7, #15
 80451be:	fa07 f606 	lsl.w	r6, r7, r6
 80451c2:	ea22 0206 	bic.w	r2, r2, r6
 80451c6:	fa93 f3a3 	rbit	r3, r3
 80451ca:	fab3 f383 	clz	r3, r3
 80451ce:	009b      	lsls	r3, r3, #2
 80451d0:	fa05 f303 	lsl.w	r3, r5, r3
 80451d4:	4313      	orrs	r3, r2
 80451d6:	6203      	str	r3, [r0, #32]
             (Alternate << (POSITION_VAL(Pin) * 4U)));
}
 80451d8:	e7c0      	b.n	804515c <LL_GPIO_Init+0x66>
          LL_GPIO_SetAFPin_8_15(GPIOx, currentpin, GPIO_InitStruct->Alternate);
 80451da:	694a      	ldr	r2, [r1, #20]
  *         @arg @ref LL_GPIO_AF_15
  * @retval None
  */
__STATIC_INLINE void LL_GPIO_SetAFPin_8_15(GPIO_TypeDef *GPIOx, uint32_t Pin, uint32_t Alternate)
{
  MODIFY_REG(GPIOx->AFR[1], (GPIO_AFRH_AFSEL8 << (POSITION_VAL(Pin >> 8U) * 4U)),
 80451dc:	6a45      	ldr	r5, [r0, #36]	; 0x24
 80451de:	0a1b      	lsrs	r3, r3, #8
 80451e0:	fa93 f6a3 	rbit	r6, r3
 80451e4:	fab6 f686 	clz	r6, r6
 80451e8:	00b6      	lsls	r6, r6, #2
 80451ea:	270f      	movs	r7, #15
 80451ec:	fa07 f606 	lsl.w	r6, r7, r6
 80451f0:	ea25 0506 	bic.w	r5, r5, r6
 80451f4:	fa93 f3a3 	rbit	r3, r3
 80451f8:	fab3 f383 	clz	r3, r3
 80451fc:	009b      	lsls	r3, r3, #2
 80451fe:	fa02 f303 	lsl.w	r3, r2, r3
 8045202:	432b      	orrs	r3, r5
 8045204:	6243      	str	r3, [r0, #36]	; 0x24
             (Alternate << (POSITION_VAL(Pin >> 8U) * 4U)));
}
 8045206:	e7a9      	b.n	804515c <LL_GPIO_Init+0x66>
  }

  if ((GPIO_InitStruct->Mode == LL_GPIO_MODE_OUTPUT) || (GPIO_InitStruct->Mode == LL_GPIO_MODE_ALTERNATE))
 8045208:	684a      	ldr	r2, [r1, #4]
 804520a:	3a01      	subs	r2, #1
 804520c:	2a01      	cmp	r2, #1
 804520e:	d902      	bls.n	8045216 <LL_GPIO_Init+0x120>
    /* Output mode configuration*/
    LL_GPIO_SetPinOutputType(GPIOx, GPIO_InitStruct->Pin, GPIO_InitStruct->OutputType);

  }
  return (SUCCESS);
}
 8045210:	2000      	movs	r0, #0
 8045212:	bcf0      	pop	{r4, r5, r6, r7}
 8045214:	4770      	bx	lr
    LL_GPIO_SetPinOutputType(GPIOx, GPIO_InitStruct->Pin, GPIO_InitStruct->OutputType);
 8045216:	68c9      	ldr	r1, [r1, #12]
  MODIFY_REG(GPIOx->OTYPER, PinMask, (PinMask * OutputType));
 8045218:	6842      	ldr	r2, [r0, #4]
 804521a:	ea22 0203 	bic.w	r2, r2, r3
 804521e:	fb01 f303 	mul.w	r3, r1, r3
 8045222:	4313      	orrs	r3, r2
 8045224:	6043      	str	r3, [r0, #4]
}
 8045226:	e7f3      	b.n	8045210 <LL_GPIO_Init+0x11a>

08045228 <RCC_GetHCLKClockFreq>:
  *         @arg @ref LL_RCC_SYSCLK_DIV_256
  *         @arg @ref LL_RCC_SYSCLK_DIV_512
  */
__STATIC_INLINE uint32_t LL_RCC_GetAHBPrescaler(void)
{
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_HPRE));
 8045228:	4b03      	ldr	r3, [pc, #12]	; (8045238 <RCC_GetHCLKClockFreq+0x10>)
 804522a:	689b      	ldr	r3, [r3, #8]
  * @retval HCLK clock frequency (in Hz)
  */
uint32_t RCC_GetHCLKClockFreq(uint32_t SYSCLK_Frequency)
{
  /* HCLK clock frequency */
  return __LL_RCC_CALC_HCLK_FREQ(SYSCLK_Frequency, LL_RCC_GetAHBPrescaler());
 804522c:	f3c3 1303 	ubfx	r3, r3, #4, #4
 8045230:	4a02      	ldr	r2, [pc, #8]	; (804523c <RCC_GetHCLKClockFreq+0x14>)
 8045232:	5cd3      	ldrb	r3, [r2, r3]
}
 8045234:	40d8      	lsrs	r0, r3
 8045236:	4770      	bx	lr
 8045238:	40023800 	.word	0x40023800
 804523c:	08058e6c 	.word	0x08058e6c

08045240 <RCC_GetPCLK1ClockFreq>:
  *         @arg @ref LL_RCC_APB1_DIV_8
  *         @arg @ref LL_RCC_APB1_DIV_16
  */
__STATIC_INLINE uint32_t LL_RCC_GetAPB1Prescaler(void)
{
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_PPRE1));
 8045240:	4b03      	ldr	r3, [pc, #12]	; (8045250 <RCC_GetPCLK1ClockFreq+0x10>)
 8045242:	689b      	ldr	r3, [r3, #8]
  * @retval PCLK1 clock frequency (in Hz)
  */
uint32_t RCC_GetPCLK1ClockFreq(uint32_t HCLK_Frequency)
{
  /* PCLK1 clock frequency */
  return __LL_RCC_CALC_PCLK1_FREQ(HCLK_Frequency, LL_RCC_GetAPB1Prescaler());
 8045244:	f3c3 2382 	ubfx	r3, r3, #10, #3
 8045248:	4a02      	ldr	r2, [pc, #8]	; (8045254 <RCC_GetPCLK1ClockFreq+0x14>)
 804524a:	5cd3      	ldrb	r3, [r2, r3]
}
 804524c:	40d8      	lsrs	r0, r3
 804524e:	4770      	bx	lr
 8045250:	40023800 	.word	0x40023800
 8045254:	08058e7c 	.word	0x08058e7c

08045258 <RCC_GetPCLK2ClockFreq>:
  *         @arg @ref LL_RCC_APB2_DIV_8
  *         @arg @ref LL_RCC_APB2_DIV_16
  */
__STATIC_INLINE uint32_t LL_RCC_GetAPB2Prescaler(void)
{
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_PPRE2));
 8045258:	4b03      	ldr	r3, [pc, #12]	; (8045268 <RCC_GetPCLK2ClockFreq+0x10>)
 804525a:	689b      	ldr	r3, [r3, #8]
  * @retval PCLK2 clock frequency (in Hz)
  */
uint32_t RCC_GetPCLK2ClockFreq(uint32_t HCLK_Frequency)
{
  /* PCLK2 clock frequency */
  return __LL_RCC_CALC_PCLK2_FREQ(HCLK_Frequency, LL_RCC_GetAPB2Prescaler());
 804525c:	f3c3 3342 	ubfx	r3, r3, #13, #3
 8045260:	4a02      	ldr	r2, [pc, #8]	; (804526c <RCC_GetPCLK2ClockFreq+0x14>)
 8045262:	5cd3      	ldrb	r3, [r2, r3]
}
 8045264:	40d8      	lsrs	r0, r3
 8045266:	4770      	bx	lr
 8045268:	40023800 	.word	0x40023800
 804526c:	08058e7c 	.word	0x08058e7c

08045270 <RCC_PLL_GetFreqDomain_SYS>:
  *         @arg @ref LL_RCC_PLLSOURCE_HSI
  *         @arg @ref LL_RCC_PLLSOURCE_HSE
  */
__STATIC_INLINE uint32_t LL_RCC_PLL_GetMainSource(void)
{
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC));
 8045270:	4b0f      	ldr	r3, [pc, #60]	; (80452b0 <RCC_PLL_GetFreqDomain_SYS+0x40>)
 8045272:	685b      	ldr	r3, [r3, #4]
 8045274:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
  /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
     SYSCLK = PLL_VCO / (PLLP or PLLR)
  */
  pllsource = LL_RCC_PLL_GetMainSource();

  switch (pllsource)
 8045278:	b923      	cbnz	r3, 8045284 <RCC_PLL_GetFreqDomain_SYS+0x14>
  {
    case LL_RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */
      pllinputfreq = HSI_VALUE;
 804527a:	4b0e      	ldr	r3, [pc, #56]	; (80452b4 <RCC_PLL_GetFreqDomain_SYS+0x44>)
    default:
      pllinputfreq = HSI_VALUE;
      break;
  }

  if (SYSCLK_Source == LL_RCC_SYS_CLKSOURCE_STATUS_PLL)
 804527c:	2808      	cmp	r0, #8
 804527e:	d003      	beq.n	8045288 <RCC_PLL_GetFreqDomain_SYS+0x18>
  uint32_t pllinputfreq = 0U, pllsource = 0U, plloutputfreq = 0U;
 8045280:	2000      	movs	r0, #0
                                        LL_RCC_PLL_GetN(), LL_RCC_PLL_GetR());
  }
#endif /* RCC_PLLR_SYSCLK_SUPPORT */

  return plloutputfreq;
}
 8045282:	4770      	bx	lr
      pllinputfreq = HSE_VALUE;
 8045284:	4b0c      	ldr	r3, [pc, #48]	; (80452b8 <RCC_PLL_GetFreqDomain_SYS+0x48>)
 8045286:	e7f9      	b.n	804527c <RCC_PLL_GetFreqDomain_SYS+0xc>
  *         @arg @ref LL_RCC_PLLM_DIV_62
  *         @arg @ref LL_RCC_PLLM_DIV_63
  */
__STATIC_INLINE uint32_t LL_RCC_PLL_GetDivider(void)
{
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM));
 8045288:	4a09      	ldr	r2, [pc, #36]	; (80452b0 <RCC_PLL_GetFreqDomain_SYS+0x40>)
 804528a:	6850      	ldr	r0, [r2, #4]
 804528c:	f000 003f 	and.w	r0, r0, #63	; 0x3f
    plloutputfreq = __LL_RCC_CALC_PLLCLK_FREQ(pllinputfreq, LL_RCC_PLL_GetDivider(),
 8045290:	fbb3 f3f0 	udiv	r3, r3, r0
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >>  RCC_PLLCFGR_PLLN_Pos);
 8045294:	6850      	ldr	r0, [r2, #4]
 8045296:	f3c0 1088 	ubfx	r0, r0, #6, #9
 804529a:	fb00 f003 	mul.w	r0, r0, r3
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLP));
 804529e:	6853      	ldr	r3, [r2, #4]
 80452a0:	f3c3 4301 	ubfx	r3, r3, #16, #2
 80452a4:	3301      	adds	r3, #1
 80452a6:	005b      	lsls	r3, r3, #1
 80452a8:	fbb0 f0f3 	udiv	r0, r0, r3
 80452ac:	4770      	bx	lr
 80452ae:	bf00      	nop
 80452b0:	40023800 	.word	0x40023800
 80452b4:	00f42400 	.word	0x00f42400
 80452b8:	017d7840 	.word	0x017d7840

080452bc <RCC_GetSystemClockFreq>:
{
 80452bc:	b508      	push	{r3, lr}
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
 80452be:	4b08      	ldr	r3, [pc, #32]	; (80452e0 <RCC_GetSystemClockFreq+0x24>)
 80452c0:	689b      	ldr	r3, [r3, #8]
 80452c2:	f003 030c 	and.w	r3, r3, #12
  switch (LL_RCC_GetSysClkSource())
 80452c6:	2b04      	cmp	r3, #4
 80452c8:	d005      	beq.n	80452d6 <RCC_GetSystemClockFreq+0x1a>
 80452ca:	2b08      	cmp	r3, #8
 80452cc:	d105      	bne.n	80452da <RCC_GetSystemClockFreq+0x1e>
      frequency = RCC_PLL_GetFreqDomain_SYS(LL_RCC_SYS_CLKSOURCE_STATUS_PLL);
 80452ce:	2008      	movs	r0, #8
 80452d0:	f7ff ffce 	bl	8045270 <RCC_PLL_GetFreqDomain_SYS>
      break;
 80452d4:	e002      	b.n	80452dc <RCC_GetSystemClockFreq+0x20>
      frequency = HSE_VALUE;
 80452d6:	4803      	ldr	r0, [pc, #12]	; (80452e4 <RCC_GetSystemClockFreq+0x28>)
 80452d8:	e000      	b.n	80452dc <RCC_GetSystemClockFreq+0x20>
  switch (LL_RCC_GetSysClkSource())
 80452da:	4803      	ldr	r0, [pc, #12]	; (80452e8 <RCC_GetSystemClockFreq+0x2c>)
}
 80452dc:	bd08      	pop	{r3, pc}
 80452de:	bf00      	nop
 80452e0:	40023800 	.word	0x40023800
 80452e4:	017d7840 	.word	0x017d7840
 80452e8:	00f42400 	.word	0x00f42400

080452ec <LL_RCC_GetSystemClocksFreq>:
{
 80452ec:	b510      	push	{r4, lr}
 80452ee:	4604      	mov	r4, r0
  RCC_Clocks->SYSCLK_Frequency = RCC_GetSystemClockFreq();
 80452f0:	f7ff ffe4 	bl	80452bc <RCC_GetSystemClockFreq>
 80452f4:	6020      	str	r0, [r4, #0]
  RCC_Clocks->HCLK_Frequency   = RCC_GetHCLKClockFreq(RCC_Clocks->SYSCLK_Frequency);
 80452f6:	f7ff ff97 	bl	8045228 <RCC_GetHCLKClockFreq>
 80452fa:	6060      	str	r0, [r4, #4]
  RCC_Clocks->PCLK1_Frequency  = RCC_GetPCLK1ClockFreq(RCC_Clocks->HCLK_Frequency);
 80452fc:	f7ff ffa0 	bl	8045240 <RCC_GetPCLK1ClockFreq>
 8045300:	60a0      	str	r0, [r4, #8]
  RCC_Clocks->PCLK2_Frequency  = RCC_GetPCLK2ClockFreq(RCC_Clocks->HCLK_Frequency);
 8045302:	6860      	ldr	r0, [r4, #4]
 8045304:	f7ff ffa8 	bl	8045258 <RCC_GetPCLK2ClockFreq>
 8045308:	60e0      	str	r0, [r4, #12]
}
 804530a:	bd10      	pop	{r4, pc}

0804530c <LL_USART_Init>:
  * @param  USARTx USART Instance
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_USART_IsEnabled(USART_TypeDef *USARTx)
{
  return (READ_BIT(USARTx->CR1, USART_CR1_UE) == (USART_CR1_UE));
 804530c:	68c3      	ldr	r3, [r0, #12]
  assert_param(IS_LL_USART_HWCONTROL(USART_InitStruct->HardwareFlowControl));
  assert_param(IS_LL_USART_OVERSAMPLING(USART_InitStruct->OverSampling));

  /* USART needs to be in disabled state, in order to be able to configure some bits in
     CRx registers */
  if (LL_USART_IsEnabled(USARTx) == 0U)
 804530e:	f413 5f00 	tst.w	r3, #8192	; 0x2000
 8045312:	d001      	beq.n	8045318 <LL_USART_Init+0xc>
  ErrorStatus status = ERROR;
 8045314:	2001      	movs	r0, #1
    }
  }
  /* Endif (=> USART not in Disabled state => return ERROR) */

  return (status);
}
 8045316:	4770      	bx	lr
{
 8045318:	b530      	push	{r4, r5, lr}
 804531a:	b085      	sub	sp, #20
 804531c:	4604      	mov	r4, r0
 804531e:	460d      	mov	r5, r1
    MODIFY_REG(USARTx->CR1,
 8045320:	68c3      	ldr	r3, [r0, #12]
 8045322:	f423 4316 	bic.w	r3, r3, #38400	; 0x9600
 8045326:	f023 030c 	bic.w	r3, r3, #12
 804532a:	684a      	ldr	r2, [r1, #4]
 804532c:	68c9      	ldr	r1, [r1, #12]
 804532e:	430a      	orrs	r2, r1
 8045330:	6929      	ldr	r1, [r5, #16]
 8045332:	430a      	orrs	r2, r1
 8045334:	69a9      	ldr	r1, [r5, #24]
 8045336:	430a      	orrs	r2, r1
 8045338:	4313      	orrs	r3, r2
 804533a:	60c3      	str	r3, [r0, #12]
    LL_USART_SetStopBitsLength(USARTx, USART_InitStruct->StopBits);
 804533c:	68ab      	ldr	r3, [r5, #8]
  *         @arg @ref LL_USART_STOPBITS_2
  * @retval None
  */
__STATIC_INLINE void LL_USART_SetStopBitsLength(USART_TypeDef *USARTx, uint32_t StopBits)
{
  MODIFY_REG(USARTx->CR2, USART_CR2_STOP, StopBits);
 804533e:	6902      	ldr	r2, [r0, #16]
 8045340:	f422 5240 	bic.w	r2, r2, #12288	; 0x3000
 8045344:	4313      	orrs	r3, r2
 8045346:	6103      	str	r3, [r0, #16]
    LL_USART_SetHWFlowCtrl(USARTx, USART_InitStruct->HardwareFlowControl);
 8045348:	696b      	ldr	r3, [r5, #20]
  *         @arg @ref LL_USART_HWCONTROL_RTS_CTS
  * @retval None
  */
__STATIC_INLINE void LL_USART_SetHWFlowCtrl(USART_TypeDef *USARTx, uint32_t HardwareFlowControl)
{
  MODIFY_REG(USARTx->CR3, USART_CR3_RTSE | USART_CR3_CTSE, HardwareFlowControl);
 804534a:	6942      	ldr	r2, [r0, #20]
 804534c:	f422 7240 	bic.w	r2, r2, #768	; 0x300
 8045350:	4313      	orrs	r3, r2
 8045352:	6143      	str	r3, [r0, #20]
    LL_RCC_GetSystemClocksFreq(&rcc_clocks);
 8045354:	4668      	mov	r0, sp
 8045356:	f7ff ffc9 	bl	80452ec <LL_RCC_GetSystemClocksFreq>
    if (USARTx == USART1)
 804535a:	4b3c      	ldr	r3, [pc, #240]	; (804544c <LL_USART_Init+0x140>)
 804535c:	429c      	cmp	r4, r3
 804535e:	d016      	beq.n	804538e <LL_USART_Init+0x82>
    else if (USARTx == USART2)
 8045360:	4b3b      	ldr	r3, [pc, #236]	; (8045450 <LL_USART_Init+0x144>)
 8045362:	429c      	cmp	r4, r3
 8045364:	d01a      	beq.n	804539c <LL_USART_Init+0x90>
    else if (USARTx == USART3)
 8045366:	4b3b      	ldr	r3, [pc, #236]	; (8045454 <LL_USART_Init+0x148>)
 8045368:	429c      	cmp	r4, r3
 804536a:	d019      	beq.n	80453a0 <LL_USART_Init+0x94>
    else if (USARTx == USART6)
 804536c:	4b3a      	ldr	r3, [pc, #232]	; (8045458 <LL_USART_Init+0x14c>)
 804536e:	429c      	cmp	r4, r3
 8045370:	d018      	beq.n	80453a4 <LL_USART_Init+0x98>
    else if (USARTx == UART4)
 8045372:	4b3a      	ldr	r3, [pc, #232]	; (804545c <LL_USART_Init+0x150>)
 8045374:	429c      	cmp	r4, r3
 8045376:	d017      	beq.n	80453a8 <LL_USART_Init+0x9c>
    else if (USARTx == UART5)
 8045378:	4b39      	ldr	r3, [pc, #228]	; (8045460 <LL_USART_Init+0x154>)
 804537a:	429c      	cmp	r4, r3
 804537c:	d016      	beq.n	80453ac <LL_USART_Init+0xa0>
    else if (USARTx == UART7)
 804537e:	4b39      	ldr	r3, [pc, #228]	; (8045464 <LL_USART_Init+0x158>)
 8045380:	429c      	cmp	r4, r3
 8045382:	d015      	beq.n	80453b0 <LL_USART_Init+0xa4>
    else if (USARTx == UART8)
 8045384:	4b38      	ldr	r3, [pc, #224]	; (8045468 <LL_USART_Init+0x15c>)
 8045386:	429c      	cmp	r4, r3
 8045388:	d014      	beq.n	80453b4 <LL_USART_Init+0xa8>
  ErrorStatus status = ERROR;
 804538a:	2001      	movs	r0, #1
 804538c:	e05b      	b.n	8045446 <LL_USART_Init+0x13a>
      periphclk = rcc_clocks.PCLK2_Frequency;
 804538e:	9b03      	ldr	r3, [sp, #12]
    if ((periphclk != LL_RCC_PERIPH_FREQUENCY_NO)
 8045390:	2b00      	cmp	r3, #0
 8045392:	d057      	beq.n	8045444 <LL_USART_Init+0x138>
        && (USART_InitStruct->BaudRate != 0U))
 8045394:	682a      	ldr	r2, [r5, #0]
 8045396:	b97a      	cbnz	r2, 80453b8 <LL_USART_Init+0xac>
  ErrorStatus status = ERROR;
 8045398:	2001      	movs	r0, #1
 804539a:	e054      	b.n	8045446 <LL_USART_Init+0x13a>
      periphclk = rcc_clocks.PCLK1_Frequency;
 804539c:	9b02      	ldr	r3, [sp, #8]
 804539e:	e7f7      	b.n	8045390 <LL_USART_Init+0x84>
      periphclk = rcc_clocks.PCLK1_Frequency;
 80453a0:	9b02      	ldr	r3, [sp, #8]
 80453a2:	e7f5      	b.n	8045390 <LL_USART_Init+0x84>
      periphclk = rcc_clocks.PCLK2_Frequency;
 80453a4:	9b03      	ldr	r3, [sp, #12]
 80453a6:	e7f3      	b.n	8045390 <LL_USART_Init+0x84>
      periphclk = rcc_clocks.PCLK1_Frequency;
 80453a8:	9b02      	ldr	r3, [sp, #8]
 80453aa:	e7f1      	b.n	8045390 <LL_USART_Init+0x84>
      periphclk = rcc_clocks.PCLK1_Frequency;
 80453ac:	9b02      	ldr	r3, [sp, #8]
 80453ae:	e7ef      	b.n	8045390 <LL_USART_Init+0x84>
      periphclk = rcc_clocks.PCLK1_Frequency;
 80453b0:	9b02      	ldr	r3, [sp, #8]
 80453b2:	e7ed      	b.n	8045390 <LL_USART_Init+0x84>
      periphclk = rcc_clocks.PCLK1_Frequency;
 80453b4:	9b02      	ldr	r3, [sp, #8]
 80453b6:	e7eb      	b.n	8045390 <LL_USART_Init+0x84>
      LL_USART_SetBaudRate(USARTx,
 80453b8:	69a9      	ldr	r1, [r5, #24]
  * @retval None
  */
__STATIC_INLINE void LL_USART_SetBaudRate(USART_TypeDef *USARTx, uint32_t PeriphClk, uint32_t OverSampling,
                                          uint32_t BaudRate)
{
  if (OverSampling == LL_USART_OVERSAMPLING_8)
 80453ba:	f5b1 4f00 	cmp.w	r1, #32768	; 0x8000
 80453be:	d020      	beq.n	8045402 <LL_USART_Init+0xf6>
  {
    USARTx->BRR = (uint16_t)(__LL_USART_DIV_SAMPLING8(PeriphClk, BaudRate));
  }
  else
  {
    USARTx->BRR = (uint16_t)(__LL_USART_DIV_SAMPLING16(PeriphClk, BaudRate));
 80453c0:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 80453c4:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 80453c8:	0092      	lsls	r2, r2, #2
 80453ca:	fbb3 f3f2 	udiv	r3, r3, r2
 80453ce:	4827      	ldr	r0, [pc, #156]	; (804546c <LL_USART_Init+0x160>)
 80453d0:	fba0 1203 	umull	r1, r2, r0, r3
 80453d4:	0952      	lsrs	r2, r2, #5
 80453d6:	0111      	lsls	r1, r2, #4
 80453d8:	b289      	uxth	r1, r1
 80453da:	2564      	movs	r5, #100	; 0x64
 80453dc:	fb05 3312 	mls	r3, r5, r2, r3
 80453e0:	011b      	lsls	r3, r3, #4
 80453e2:	3332      	adds	r3, #50	; 0x32
 80453e4:	fba0 2303 	umull	r2, r3, r0, r3
 80453e8:	f3c3 134f 	ubfx	r3, r3, #5, #16
 80453ec:	f003 02f0 	and.w	r2, r3, #240	; 0xf0
 80453f0:	440a      	add	r2, r1
 80453f2:	b292      	uxth	r2, r2
 80453f4:	f003 030f 	and.w	r3, r3, #15
 80453f8:	4413      	add	r3, r2
 80453fa:	b29b      	uxth	r3, r3
 80453fc:	60a3      	str	r3, [r4, #8]
      status = SUCCESS;
 80453fe:	2000      	movs	r0, #0
  }
}
 8045400:	e021      	b.n	8045446 <LL_USART_Init+0x13a>
    USARTx->BRR = (uint16_t)(__LL_USART_DIV_SAMPLING8(PeriphClk, BaudRate));
 8045402:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8045406:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 804540a:	0052      	lsls	r2, r2, #1
 804540c:	fbb3 f3f2 	udiv	r3, r3, r2
 8045410:	4816      	ldr	r0, [pc, #88]	; (804546c <LL_USART_Init+0x160>)
 8045412:	fba0 1203 	umull	r1, r2, r0, r3
 8045416:	0952      	lsrs	r2, r2, #5
 8045418:	0111      	lsls	r1, r2, #4
 804541a:	b289      	uxth	r1, r1
 804541c:	2564      	movs	r5, #100	; 0x64
 804541e:	fb05 3312 	mls	r3, r5, r2, r3
 8045422:	00db      	lsls	r3, r3, #3
 8045424:	3332      	adds	r3, #50	; 0x32
 8045426:	fba0 2303 	umull	r2, r3, r0, r3
 804542a:	f3c3 134f 	ubfx	r3, r3, #5, #16
 804542e:	005a      	lsls	r2, r3, #1
 8045430:	f402 72f8 	and.w	r2, r2, #496	; 0x1f0
 8045434:	440a      	add	r2, r1
 8045436:	b292      	uxth	r2, r2
 8045438:	f003 0307 	and.w	r3, r3, #7
 804543c:	4413      	add	r3, r2
 804543e:	b29b      	uxth	r3, r3
 8045440:	60a3      	str	r3, [r4, #8]
 8045442:	e7dc      	b.n	80453fe <LL_USART_Init+0xf2>
  ErrorStatus status = ERROR;
 8045444:	2001      	movs	r0, #1
}
 8045446:	b005      	add	sp, #20
 8045448:	bd30      	pop	{r4, r5, pc}
 804544a:	bf00      	nop
 804544c:	40011000 	.word	0x40011000
 8045450:	40004400 	.word	0x40004400
 8045454:	40004800 	.word	0x40004800
 8045458:	40011400 	.word	0x40011400
 804545c:	40004c00 	.word	0x40004c00
 8045460:	40005000 	.word	0x40005000
 8045464:	40007800 	.word	0x40007800
 8045468:	40007c00 	.word	0x40007c00
 804546c:	51eb851f 	.word	0x51eb851f

08045470 <lwip_htons>:
 * @return n in network byte order
 */
u16_t
lwip_htons(u16_t n)
{
  return (u16_t)PP_HTONS(n);
 8045470:	ba40      	rev16	r0, r0
}
 8045472:	b280      	uxth	r0, r0
 8045474:	4770      	bx	lr

08045476 <lwip_htonl>:
 * @return n in network byte order
 */
u32_t
lwip_htonl(u32_t n)
{
  return (u32_t)PP_HTONL(n);
 8045476:	0203      	lsls	r3, r0, #8
 8045478:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
 804547c:	ea43 6300 	orr.w	r3, r3, r0, lsl #24
 8045480:	0a02      	lsrs	r2, r0, #8
 8045482:	f402 427f 	and.w	r2, r2, #65280	; 0xff00
 8045486:	4313      	orrs	r3, r2
}
 8045488:	ea43 6010 	orr.w	r0, r3, r0, lsr #24
 804548c:	4770      	bx	lr

0804548e <lwip_init>:
 * Initialize all modules.
 * Use this in NO_SYS mode. Use tcpip_init() otherwise.
 */
void
lwip_init(void)
{
 804548e:	b508      	push	{r3, lr}
  /* Modules initialization */
  stats_init();
#if !NO_SYS
  sys_init();
#endif /* !NO_SYS */
  mem_init();
 8045490:	f000 f878 	bl	8045584 <mem_init>
  memp_init();
 8045494:	f000 fa44 	bl	8045920 <memp_init>
  pbuf_init();
  netif_init();
 8045498:	f000 fa97 	bl	80459ca <netif_init>
#endif /* LWIP_IPV4 */
#if LWIP_RAW
  raw_init();
#endif /* LWIP_RAW */
#if LWIP_UDP
  udp_init();
 804549c:	f004 fbda 	bl	8049c54 <udp_init>
#endif /* LWIP_UDP */
#if LWIP_TCP
  tcp_init();
 80454a0:	f001 f830 	bl	8046504 <tcp_init>
#if PPP_SUPPORT
  ppp_init();
#endif
 
#if LWIP_TIMERS
  sys_timeouts_init();
 80454a4:	f004 fb5a 	bl	8049b5c <sys_timeouts_init>
#endif /* LWIP_TIMERS */
}
 80454a8:	bd08      	pop	{r3, pc}
	...

080454ac <plug_holes>:
 * This assumes access to the heap is protected by the calling function
 * already.
 */
static void
plug_holes(struct mem *mem)
{
 80454ac:	b510      	push	{r4, lr}
 80454ae:	4604      	mov	r4, r0
  struct mem *nmem;
  struct mem *pmem;

  LWIP_ASSERT("plug_holes: mem >= ram", (u8_t *)mem >= ram);
 80454b0:	4b2d      	ldr	r3, [pc, #180]	; (8045568 <plug_holes+0xbc>)
 80454b2:	681b      	ldr	r3, [r3, #0]
 80454b4:	4283      	cmp	r3, r0
 80454b6:	d831      	bhi.n	804551c <plug_holes+0x70>
  LWIP_ASSERT("plug_holes: mem < ram_end", (u8_t *)mem < (u8_t *)ram_end);
 80454b8:	4b2b      	ldr	r3, [pc, #172]	; (8045568 <plug_holes+0xbc>)
 80454ba:	685b      	ldr	r3, [r3, #4]
 80454bc:	42a3      	cmp	r3, r4
 80454be:	d935      	bls.n	804552c <plug_holes+0x80>
  LWIP_ASSERT("plug_holes: mem->used == 0", mem->used == 0);
 80454c0:	7923      	ldrb	r3, [r4, #4]
 80454c2:	2b00      	cmp	r3, #0
 80454c4:	d13a      	bne.n	804553c <plug_holes+0x90>

  /* plug hole forward */
  LWIP_ASSERT("plug_holes: mem->next <= MEM_SIZE_ALIGNED", mem->next <= MEM_SIZE_ALIGNED);
 80454c6:	8823      	ldrh	r3, [r4, #0]
 80454c8:	f5b3 6fc8 	cmp.w	r3, #1600	; 0x640
 80454cc:	d83e      	bhi.n	804554c <plug_holes+0xa0>

  nmem = (struct mem *)(void *)&ram[mem->next];
 80454ce:	4b26      	ldr	r3, [pc, #152]	; (8045568 <plug_holes+0xbc>)
 80454d0:	681b      	ldr	r3, [r3, #0]
 80454d2:	8821      	ldrh	r1, [r4, #0]
 80454d4:	185a      	adds	r2, r3, r1
  if (mem != nmem && nmem->used == 0 && (u8_t *)nmem != (u8_t *)ram_end) {
 80454d6:	4294      	cmp	r4, r2
 80454d8:	d00f      	beq.n	80454fa <plug_holes+0x4e>
 80454da:	7910      	ldrb	r0, [r2, #4]
 80454dc:	b968      	cbnz	r0, 80454fa <plug_holes+0x4e>
 80454de:	4822      	ldr	r0, [pc, #136]	; (8045568 <plug_holes+0xbc>)
 80454e0:	6840      	ldr	r0, [r0, #4]
 80454e2:	4290      	cmp	r0, r2
 80454e4:	d009      	beq.n	80454fa <plug_holes+0x4e>
    /* if mem->next is unused and not end of ram, combine mem and mem->next */
    if (lfree == nmem) {
 80454e6:	4820      	ldr	r0, [pc, #128]	; (8045568 <plug_holes+0xbc>)
 80454e8:	6880      	ldr	r0, [r0, #8]
 80454ea:	4290      	cmp	r0, r2
 80454ec:	d036      	beq.n	804555c <plug_holes+0xb0>
      lfree = mem;
    }
    mem->next = nmem->next;
 80454ee:	5a5a      	ldrh	r2, [r3, r1]
 80454f0:	8022      	strh	r2, [r4, #0]
    ((struct mem *)(void *)&ram[nmem->next])->prev = (mem_size_t)((u8_t *)mem - ram);
 80454f2:	1ae0      	subs	r0, r4, r3
 80454f4:	5a5a      	ldrh	r2, [r3, r1]
 80454f6:	441a      	add	r2, r3
 80454f8:	8050      	strh	r0, [r2, #2]
  }

  /* plug hole backward */
  pmem = (struct mem *)(void *)&ram[mem->prev];
 80454fa:	8861      	ldrh	r1, [r4, #2]
 80454fc:	185a      	adds	r2, r3, r1
  if (pmem != mem && pmem->used == 0) {
 80454fe:	4294      	cmp	r4, r2
 8045500:	d00b      	beq.n	804551a <plug_holes+0x6e>
 8045502:	7910      	ldrb	r0, [r2, #4]
 8045504:	b948      	cbnz	r0, 804551a <plug_holes+0x6e>
    /* if mem->prev is unused, combine mem and mem->prev */
    if (lfree == mem) {
 8045506:	4818      	ldr	r0, [pc, #96]	; (8045568 <plug_holes+0xbc>)
 8045508:	6880      	ldr	r0, [r0, #8]
 804550a:	42a0      	cmp	r0, r4
 804550c:	d029      	beq.n	8045562 <plug_holes+0xb6>
      lfree = pmem;
    }
    pmem->next = mem->next;
 804550e:	8820      	ldrh	r0, [r4, #0]
 8045510:	5258      	strh	r0, [r3, r1]
    ((struct mem *)(void *)&ram[mem->next])->prev = (mem_size_t)((u8_t *)pmem - ram);
 8045512:	1ad2      	subs	r2, r2, r3
 8045514:	8821      	ldrh	r1, [r4, #0]
 8045516:	440b      	add	r3, r1
 8045518:	805a      	strh	r2, [r3, #2]
  }
}
 804551a:	bd10      	pop	{r4, pc}
  LWIP_ASSERT("plug_holes: mem >= ram", (u8_t *)mem >= ram);
 804551c:	4b13      	ldr	r3, [pc, #76]	; (804556c <plug_holes+0xc0>)
 804551e:	f240 125d 	movw	r2, #349	; 0x15d
 8045522:	4913      	ldr	r1, [pc, #76]	; (8045570 <plug_holes+0xc4>)
 8045524:	4813      	ldr	r0, [pc, #76]	; (8045574 <plug_holes+0xc8>)
 8045526:	f00c fa8f 	bl	8051a48 <printf>
 804552a:	e7c5      	b.n	80454b8 <plug_holes+0xc>
  LWIP_ASSERT("plug_holes: mem < ram_end", (u8_t *)mem < (u8_t *)ram_end);
 804552c:	4b0f      	ldr	r3, [pc, #60]	; (804556c <plug_holes+0xc0>)
 804552e:	f44f 72af 	mov.w	r2, #350	; 0x15e
 8045532:	4911      	ldr	r1, [pc, #68]	; (8045578 <plug_holes+0xcc>)
 8045534:	480f      	ldr	r0, [pc, #60]	; (8045574 <plug_holes+0xc8>)
 8045536:	f00c fa87 	bl	8051a48 <printf>
 804553a:	e7c1      	b.n	80454c0 <plug_holes+0x14>
  LWIP_ASSERT("plug_holes: mem->used == 0", mem->used == 0);
 804553c:	4b0b      	ldr	r3, [pc, #44]	; (804556c <plug_holes+0xc0>)
 804553e:	f240 125f 	movw	r2, #351	; 0x15f
 8045542:	490e      	ldr	r1, [pc, #56]	; (804557c <plug_holes+0xd0>)
 8045544:	480b      	ldr	r0, [pc, #44]	; (8045574 <plug_holes+0xc8>)
 8045546:	f00c fa7f 	bl	8051a48 <printf>
 804554a:	e7bc      	b.n	80454c6 <plug_holes+0x1a>
  LWIP_ASSERT("plug_holes: mem->next <= MEM_SIZE_ALIGNED", mem->next <= MEM_SIZE_ALIGNED);
 804554c:	4b07      	ldr	r3, [pc, #28]	; (804556c <plug_holes+0xc0>)
 804554e:	f44f 72b1 	mov.w	r2, #354	; 0x162
 8045552:	490b      	ldr	r1, [pc, #44]	; (8045580 <plug_holes+0xd4>)
 8045554:	4807      	ldr	r0, [pc, #28]	; (8045574 <plug_holes+0xc8>)
 8045556:	f00c fa77 	bl	8051a48 <printf>
 804555a:	e7b8      	b.n	80454ce <plug_holes+0x22>
      lfree = mem;
 804555c:	4a02      	ldr	r2, [pc, #8]	; (8045568 <plug_holes+0xbc>)
 804555e:	6094      	str	r4, [r2, #8]
 8045560:	e7c5      	b.n	80454ee <plug_holes+0x42>
      lfree = pmem;
 8045562:	4801      	ldr	r0, [pc, #4]	; (8045568 <plug_holes+0xbc>)
 8045564:	6082      	str	r2, [r0, #8]
 8045566:	e7d2      	b.n	804550e <plug_holes+0x62>
 8045568:	200040a0 	.word	0x200040a0
 804556c:	08058e84 	.word	0x08058e84
 8045570:	08058eb4 	.word	0x08058eb4
 8045574:	08058ecc 	.word	0x08058ecc
 8045578:	08058ef4 	.word	0x08058ef4
 804557c:	08058f10 	.word	0x08058f10
 8045580:	08058f2c 	.word	0x08058f2c

08045584 <mem_init>:
/**
 * Zero the heap and initialize start, end and lowest-free
 */
void
mem_init(void)
{
 8045584:	b410      	push	{r4}

  LWIP_ASSERT("Sanity check alignment",
    (SIZEOF_STRUCT_MEM & (MEM_ALIGNMENT-1)) == 0);

  /* align the heap */
  ram = (u8_t *)LWIP_MEM_ALIGN(LWIP_RAM_HEAP_POINTER);
 8045586:	4b0b      	ldr	r3, [pc, #44]	; (80455b4 <mem_init+0x30>)
 8045588:	f023 0303 	bic.w	r3, r3, #3
 804558c:	4a0a      	ldr	r2, [pc, #40]	; (80455b8 <mem_init+0x34>)
 804558e:	6013      	str	r3, [r2, #0]
  /* initialize the start of the heap */
  mem = (struct mem *)(void *)ram;
  mem->next = MEM_SIZE_ALIGNED;
 8045590:	f44f 60c8 	mov.w	r0, #1600	; 0x640
 8045594:	8018      	strh	r0, [r3, #0]
  mem->prev = 0;
 8045596:	2100      	movs	r1, #0
 8045598:	8059      	strh	r1, [r3, #2]
  mem->used = 0;
 804559a:	7119      	strb	r1, [r3, #4]
  /* initialize the end of the heap */
  ram_end = (struct mem *)(void *)&ram[MEM_SIZE_ALIGNED];
 804559c:	1819      	adds	r1, r3, r0
 804559e:	6051      	str	r1, [r2, #4]
  ram_end->used = 1;
 80455a0:	2401      	movs	r4, #1
 80455a2:	710c      	strb	r4, [r1, #4]
  ram_end->next = MEM_SIZE_ALIGNED;
 80455a4:	f8a3 0640 	strh.w	r0, [r3, #1600]	; 0x640
  ram_end->prev = MEM_SIZE_ALIGNED;
 80455a8:	8048      	strh	r0, [r1, #2]

  /* initialize the lowest-free pointer to the start of the heap */
  lfree = (struct mem *)(void *)ram;
 80455aa:	6093      	str	r3, [r2, #8]
  MEM_STATS_AVAIL(avail, MEM_SIZE_ALIGNED);

  if (sys_mutex_new(&mem_mutex) != ERR_OK) {
    LWIP_ASSERT("failed to create mem_mutex", 0);
  }
}
 80455ac:	f85d 4b04 	ldr.w	r4, [sp], #4
 80455b0:	4770      	bx	lr
 80455b2:	bf00      	nop
 80455b4:	2000520b 	.word	0x2000520b
 80455b8:	200040a0 	.word	0x200040a0

080455bc <mem_free>:
mem_free(void *rmem)
{
  struct mem *mem;
  LWIP_MEM_FREE_DECL_PROTECT();

  if (rmem == NULL) {
 80455bc:	2800      	cmp	r0, #0
 80455be:	d03d      	beq.n	804563c <mem_free+0x80>
{
 80455c0:	b538      	push	{r3, r4, r5, lr}
 80455c2:	4604      	mov	r4, r0
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("mem_free(p == NULL) was called.\n"));
    return;
  }
  LWIP_ASSERT("mem_free: sanity check alignment", (((mem_ptr_t)rmem) & (MEM_ALIGNMENT-1)) == 0);
 80455c4:	f010 0f03 	tst.w	r0, #3
 80455c8:	d128      	bne.n	804561c <mem_free+0x60>

  LWIP_ASSERT("mem_free: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
 80455ca:	4b1d      	ldr	r3, [pc, #116]	; (8045640 <mem_free+0x84>)
 80455cc:	681b      	ldr	r3, [r3, #0]
 80455ce:	42a3      	cmp	r3, r4
 80455d0:	d803      	bhi.n	80455da <mem_free+0x1e>
 80455d2:	4b1b      	ldr	r3, [pc, #108]	; (8045640 <mem_free+0x84>)
 80455d4:	685b      	ldr	r3, [r3, #4]
 80455d6:	42a3      	cmp	r3, r4
 80455d8:	d806      	bhi.n	80455e8 <mem_free+0x2c>
 80455da:	4b1a      	ldr	r3, [pc, #104]	; (8045644 <mem_free+0x88>)
 80455dc:	f44f 72d7 	mov.w	r2, #430	; 0x1ae
 80455e0:	4919      	ldr	r1, [pc, #100]	; (8045648 <mem_free+0x8c>)
 80455e2:	481a      	ldr	r0, [pc, #104]	; (804564c <mem_free+0x90>)
 80455e4:	f00c fa30 	bl	8051a48 <printf>
    (u8_t *)rmem < (u8_t *)ram_end);

  if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
 80455e8:	4b15      	ldr	r3, [pc, #84]	; (8045640 <mem_free+0x84>)
 80455ea:	681b      	ldr	r3, [r3, #0]
 80455ec:	42a3      	cmp	r3, r4
 80455ee:	d814      	bhi.n	804561a <mem_free+0x5e>
 80455f0:	4b13      	ldr	r3, [pc, #76]	; (8045640 <mem_free+0x84>)
 80455f2:	685b      	ldr	r3, [r3, #4]
 80455f4:	42a3      	cmp	r3, r4
 80455f6:	d910      	bls.n	804561a <mem_free+0x5e>
  }
  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
  /* Get the corresponding struct mem ... */
  /* cast through void* to get rid of alignment warnings */
  mem = (struct mem *)(void *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
 80455f8:	f1a4 0508 	sub.w	r5, r4, #8
  /* ... which has to be in a used state ... */
  LWIP_ASSERT("mem_free: mem->used", mem->used);
 80455fc:	f814 3c04 	ldrb.w	r3, [r4, #-4]
 8045600:	b1a3      	cbz	r3, 804562c <mem_free+0x70>
  /* ... and is now unused. */
  mem->used = 0;
 8045602:	2300      	movs	r3, #0
 8045604:	f804 3c04 	strb.w	r3, [r4, #-4]

  if (mem < lfree) {
 8045608:	4b0d      	ldr	r3, [pc, #52]	; (8045640 <mem_free+0x84>)
 804560a:	689b      	ldr	r3, [r3, #8]
 804560c:	42ab      	cmp	r3, r5
 804560e:	d901      	bls.n	8045614 <mem_free+0x58>
    /* the newly freed struct is now the lowest */
    lfree = mem;
 8045610:	4b0b      	ldr	r3, [pc, #44]	; (8045640 <mem_free+0x84>)
 8045612:	609d      	str	r5, [r3, #8]
  }

  MEM_STATS_DEC_USED(used, mem->next - (mem_size_t)(((u8_t *)mem - ram)));

  /* finally, see if prev or next are free also */
  plug_holes(mem);
 8045614:	4628      	mov	r0, r5
 8045616:	f7ff ff49 	bl	80454ac <plug_holes>
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
}
 804561a:	bd38      	pop	{r3, r4, r5, pc}
  LWIP_ASSERT("mem_free: sanity check alignment", (((mem_ptr_t)rmem) & (MEM_ALIGNMENT-1)) == 0);
 804561c:	4b09      	ldr	r3, [pc, #36]	; (8045644 <mem_free+0x88>)
 804561e:	f44f 72d6 	mov.w	r2, #428	; 0x1ac
 8045622:	490b      	ldr	r1, [pc, #44]	; (8045650 <mem_free+0x94>)
 8045624:	4809      	ldr	r0, [pc, #36]	; (804564c <mem_free+0x90>)
 8045626:	f00c fa0f 	bl	8051a48 <printf>
 804562a:	e7ce      	b.n	80455ca <mem_free+0xe>
  LWIP_ASSERT("mem_free: mem->used", mem->used);
 804562c:	4b05      	ldr	r3, [pc, #20]	; (8045644 <mem_free+0x88>)
 804562e:	f44f 72e0 	mov.w	r2, #448	; 0x1c0
 8045632:	4908      	ldr	r1, [pc, #32]	; (8045654 <mem_free+0x98>)
 8045634:	4805      	ldr	r0, [pc, #20]	; (804564c <mem_free+0x90>)
 8045636:	f00c fa07 	bl	8051a48 <printf>
 804563a:	e7e2      	b.n	8045602 <mem_free+0x46>
 804563c:	4770      	bx	lr
 804563e:	bf00      	nop
 8045640:	200040a0 	.word	0x200040a0
 8045644:	08058e84 	.word	0x08058e84
 8045648:	08058f7c 	.word	0x08058f7c
 804564c:	08058ecc 	.word	0x08058ecc
 8045650:	08058f58 	.word	0x08058f58
 8045654:	08058f94 	.word	0x08058f94

08045658 <mem_trim>:
 *         or NULL if newsize is > old size, in which case rmem is NOT touched
 *         or freed!
 */
void *
mem_trim(void *rmem, mem_size_t newsize)
{
 8045658:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 804565a:	4605      	mov	r5, r0
  /* use the FREE_PROTECT here: it protects with sem OR SYS_ARCH_PROTECT */
  LWIP_MEM_FREE_DECL_PROTECT();

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  newsize = LWIP_MEM_ALIGN_SIZE(newsize);
 804565c:	1ccc      	adds	r4, r1, #3
 804565e:	b2a4      	uxth	r4, r4
 8045660:	f024 0403 	bic.w	r4, r4, #3
 8045664:	b2a4      	uxth	r4, r4

  if (newsize < MIN_SIZE_ALIGNED) {
 8045666:	2c0b      	cmp	r4, #11
 8045668:	d905      	bls.n	8045676 <mem_trim+0x1e>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    newsize = MIN_SIZE_ALIGNED;
  }

  if (newsize > MEM_SIZE_ALIGNED) {
 804566a:	f5b4 6fc8 	cmp.w	r4, #1600	; 0x640
 804566e:	d903      	bls.n	8045678 <mem_trim+0x20>
    return NULL;
 8045670:	2500      	movs	r5, #0
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  return rmem;
}
 8045672:	4628      	mov	r0, r5
 8045674:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    newsize = MIN_SIZE_ALIGNED;
 8045676:	240c      	movs	r4, #12
  LWIP_ASSERT("mem_trim: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
 8045678:	4b37      	ldr	r3, [pc, #220]	; (8045758 <mem_trim+0x100>)
 804567a:	681b      	ldr	r3, [r3, #0]
 804567c:	42ab      	cmp	r3, r5
 804567e:	d803      	bhi.n	8045688 <mem_trim+0x30>
 8045680:	4b35      	ldr	r3, [pc, #212]	; (8045758 <mem_trim+0x100>)
 8045682:	685b      	ldr	r3, [r3, #4]
 8045684:	42ab      	cmp	r3, r5
 8045686:	d806      	bhi.n	8045696 <mem_trim+0x3e>
 8045688:	4b34      	ldr	r3, [pc, #208]	; (804575c <mem_trim+0x104>)
 804568a:	f240 12f3 	movw	r2, #499	; 0x1f3
 804568e:	4934      	ldr	r1, [pc, #208]	; (8045760 <mem_trim+0x108>)
 8045690:	4834      	ldr	r0, [pc, #208]	; (8045764 <mem_trim+0x10c>)
 8045692:	f00c f9d9 	bl	8051a48 <printf>
  if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
 8045696:	4b30      	ldr	r3, [pc, #192]	; (8045758 <mem_trim+0x100>)
 8045698:	681b      	ldr	r3, [r3, #0]
 804569a:	42ab      	cmp	r3, r5
 804569c:	d8e9      	bhi.n	8045672 <mem_trim+0x1a>
 804569e:	4a2e      	ldr	r2, [pc, #184]	; (8045758 <mem_trim+0x100>)
 80456a0:	6852      	ldr	r2, [r2, #4]
 80456a2:	42aa      	cmp	r2, r5
 80456a4:	d9e5      	bls.n	8045672 <mem_trim+0x1a>
  mem = (struct mem *)(void *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
 80456a6:	f1a5 0708 	sub.w	r7, r5, #8
  ptr = (mem_size_t)((u8_t *)mem - ram);
 80456aa:	1aff      	subs	r7, r7, r3
 80456ac:	b2bf      	uxth	r7, r7
  size = mem->next - ptr - SIZEOF_STRUCT_MEM;
 80456ae:	f835 6c08 	ldrh.w	r6, [r5, #-8]
 80456b2:	1bf6      	subs	r6, r6, r7
 80456b4:	b2b6      	uxth	r6, r6
 80456b6:	3e08      	subs	r6, #8
 80456b8:	b2b6      	uxth	r6, r6
  LWIP_ASSERT("mem_trim can only shrink memory", newsize <= size);
 80456ba:	42b4      	cmp	r4, r6
 80456bc:	d820      	bhi.n	8045700 <mem_trim+0xa8>
  if (newsize > size) {
 80456be:	42b4      	cmp	r4, r6
 80456c0:	d848      	bhi.n	8045754 <mem_trim+0xfc>
  if (newsize == size) {
 80456c2:	d0d6      	beq.n	8045672 <mem_trim+0x1a>
  mem2 = (struct mem *)(void *)&ram[mem->next];
 80456c4:	4b24      	ldr	r3, [pc, #144]	; (8045758 <mem_trim+0x100>)
 80456c6:	681a      	ldr	r2, [r3, #0]
 80456c8:	f835 3c08 	ldrh.w	r3, [r5, #-8]
 80456cc:	18d1      	adds	r1, r2, r3
  if (mem2->used == 0) {
 80456ce:	7908      	ldrb	r0, [r1, #4]
 80456d0:	bb10      	cbnz	r0, 8045718 <mem_trim+0xc0>
    next = mem2->next;
 80456d2:	5ad0      	ldrh	r0, [r2, r3]
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
 80456d4:	19e3      	adds	r3, r4, r7
 80456d6:	b29b      	uxth	r3, r3
 80456d8:	3308      	adds	r3, #8
 80456da:	b29b      	uxth	r3, r3
    if (lfree == mem2) {
 80456dc:	4c1e      	ldr	r4, [pc, #120]	; (8045758 <mem_trim+0x100>)
 80456de:	68a4      	ldr	r4, [r4, #8]
 80456e0:	428c      	cmp	r4, r1
 80456e2:	d015      	beq.n	8045710 <mem_trim+0xb8>
    mem2 = (struct mem *)(void *)&ram[ptr2];
 80456e4:	18d1      	adds	r1, r2, r3
    mem2->used = 0;
 80456e6:	2400      	movs	r4, #0
 80456e8:	710c      	strb	r4, [r1, #4]
    mem2->next = next;
 80456ea:	52d0      	strh	r0, [r2, r3]
    mem2->prev = ptr;
 80456ec:	804f      	strh	r7, [r1, #2]
    mem->next = ptr2;
 80456ee:	f825 3c08 	strh.w	r3, [r5, #-8]
    if (mem2->next != MEM_SIZE_ALIGNED) {
 80456f2:	5ad1      	ldrh	r1, [r2, r3]
 80456f4:	f5b1 6fc8 	cmp.w	r1, #1600	; 0x640
 80456f8:	d0bb      	beq.n	8045672 <mem_trim+0x1a>
      ((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
 80456fa:	440a      	add	r2, r1
 80456fc:	8053      	strh	r3, [r2, #2]
 80456fe:	e7b8      	b.n	8045672 <mem_trim+0x1a>
  LWIP_ASSERT("mem_trim can only shrink memory", newsize <= size);
 8045700:	4b16      	ldr	r3, [pc, #88]	; (804575c <mem_trim+0x104>)
 8045702:	f240 2206 	movw	r2, #518	; 0x206
 8045706:	4918      	ldr	r1, [pc, #96]	; (8045768 <mem_trim+0x110>)
 8045708:	4816      	ldr	r0, [pc, #88]	; (8045764 <mem_trim+0x10c>)
 804570a:	f00c f99d 	bl	8051a48 <printf>
 804570e:	e7d6      	b.n	80456be <mem_trim+0x66>
      lfree = (struct mem *)(void *)&ram[ptr2];
 8045710:	18d1      	adds	r1, r2, r3
 8045712:	4c11      	ldr	r4, [pc, #68]	; (8045758 <mem_trim+0x100>)
 8045714:	60a1      	str	r1, [r4, #8]
 8045716:	e7e5      	b.n	80456e4 <mem_trim+0x8c>
  } else if (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED <= size) {
 8045718:	f104 0314 	add.w	r3, r4, #20
 804571c:	42b3      	cmp	r3, r6
 804571e:	d8a8      	bhi.n	8045672 <mem_trim+0x1a>
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
 8045720:	19e3      	adds	r3, r4, r7
 8045722:	b29b      	uxth	r3, r3
 8045724:	3308      	adds	r3, #8
 8045726:	b29b      	uxth	r3, r3
    mem2 = (struct mem *)(void *)&ram[ptr2];
 8045728:	18d1      	adds	r1, r2, r3
    if (mem2 < lfree) {
 804572a:	480b      	ldr	r0, [pc, #44]	; (8045758 <mem_trim+0x100>)
 804572c:	6880      	ldr	r0, [r0, #8]
 804572e:	4288      	cmp	r0, r1
 8045730:	d901      	bls.n	8045736 <mem_trim+0xde>
      lfree = mem2;
 8045732:	4809      	ldr	r0, [pc, #36]	; (8045758 <mem_trim+0x100>)
 8045734:	6081      	str	r1, [r0, #8]
    mem2->used = 0;
 8045736:	2000      	movs	r0, #0
 8045738:	7108      	strb	r0, [r1, #4]
    mem2->next = mem->next;
 804573a:	f835 0c08 	ldrh.w	r0, [r5, #-8]
 804573e:	52d0      	strh	r0, [r2, r3]
    mem2->prev = ptr;
 8045740:	804f      	strh	r7, [r1, #2]
    mem->next = ptr2;
 8045742:	f825 3c08 	strh.w	r3, [r5, #-8]
    if (mem2->next != MEM_SIZE_ALIGNED) {
 8045746:	5ad1      	ldrh	r1, [r2, r3]
 8045748:	f5b1 6fc8 	cmp.w	r1, #1600	; 0x640
 804574c:	d091      	beq.n	8045672 <mem_trim+0x1a>
      ((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
 804574e:	440a      	add	r2, r1
 8045750:	8053      	strh	r3, [r2, #2]
 8045752:	e78e      	b.n	8045672 <mem_trim+0x1a>
    return NULL;
 8045754:	2500      	movs	r5, #0
 8045756:	e78c      	b.n	8045672 <mem_trim+0x1a>
 8045758:	200040a0 	.word	0x200040a0
 804575c:	08058e84 	.word	0x08058e84
 8045760:	08058fa8 	.word	0x08058fa8
 8045764:	08058ecc 	.word	0x08058ecc
 8045768:	08058fc0 	.word	0x08058fc0

0804576c <mem_malloc>:
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  u8_t local_mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_ALLOC_DECL_PROTECT();

  if (size == 0) {
 804576c:	2800      	cmp	r0, #0
 804576e:	d07e      	beq.n	804586e <mem_malloc+0x102>
{
 8045770:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    return NULL;
  }

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  size = LWIP_MEM_ALIGN_SIZE(size);
 8045772:	1cc2      	adds	r2, r0, #3
 8045774:	b292      	uxth	r2, r2
 8045776:	f022 0203 	bic.w	r2, r2, #3
 804577a:	b292      	uxth	r2, r2

  if (size < MIN_SIZE_ALIGNED) {
 804577c:	2a0b      	cmp	r2, #11
 804577e:	d904      	bls.n	804578a <mem_malloc+0x1e>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    size = MIN_SIZE_ALIGNED;
  }

  if (size > MEM_SIZE_ALIGNED) {
 8045780:	f5b2 6fc8 	cmp.w	r2, #1600	; 0x640
 8045784:	d902      	bls.n	804578c <mem_malloc+0x20>
    return NULL;
 8045786:	2000      	movs	r0, #0
 8045788:	e070      	b.n	804586c <mem_malloc+0x100>
    size = MIN_SIZE_ALIGNED;
 804578a:	220c      	movs	r2, #12
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (mem_size_t)((u8_t *)lfree - ram); ptr < MEM_SIZE_ALIGNED - size;
 804578c:	4b39      	ldr	r3, [pc, #228]	; (8045874 <mem_malloc+0x108>)
 804578e:	689f      	ldr	r7, [r3, #8]
 8045790:	681e      	ldr	r6, [r3, #0]
 8045792:	1bbb      	subs	r3, r7, r6
 8045794:	b29b      	uxth	r3, r3
 8045796:	e040      	b.n	804581a <mem_malloc+0xae>
           * take care of this).
           * -> near fit or exact fit: do not split, no mem2 creation
           * also can't move mem->next directly behind mem, since mem->next
           * will always be used at this point!
           */
          mem->used = 1;
 8045798:	2301      	movs	r3, #1
 804579a:	7123      	strb	r3, [r4, #4]
          MEM_STATS_INC_USED(used, mem->next - (mem_size_t)((u8_t *)mem - ram));
        }
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
mem_malloc_adjust_lfree:
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
        if (mem == lfree) {
 804579c:	42a7      	cmp	r7, r4
 804579e:	d00e      	beq.n	80457be <mem_malloc+0x52>
          lfree = cur;
          LWIP_ASSERT("mem_malloc: !lfree->used", ((lfree == ram_end) || (!lfree->used)));
        }
        LWIP_MEM_ALLOC_UNPROTECT();
        sys_mutex_unlock(&mem_mutex);
        LWIP_ASSERT("mem_malloc: allocated memory not above ram_end.",
 80457a0:	4425      	add	r5, r4
 80457a2:	3508      	adds	r5, #8
 80457a4:	4b33      	ldr	r3, [pc, #204]	; (8045874 <mem_malloc+0x108>)
 80457a6:	685b      	ldr	r3, [r3, #4]
 80457a8:	429d      	cmp	r5, r3
 80457aa:	d81d      	bhi.n	80457e8 <mem_malloc+0x7c>
         (mem_ptr_t)mem + SIZEOF_STRUCT_MEM + size <= (mem_ptr_t)ram_end);
        LWIP_ASSERT("mem_malloc: allocated memory properly aligned.",
 80457ac:	f014 0503 	ands.w	r5, r4, #3
 80457b0:	d122      	bne.n	80457f8 <mem_malloc+0x8c>
         ((mem_ptr_t)mem + SIZEOF_STRUCT_MEM) % MEM_ALIGNMENT == 0);
        LWIP_ASSERT("mem_malloc: sanity check alignment",
 80457b2:	bb4d      	cbnz	r5, 8045808 <mem_malloc+0x9c>
          (((mem_ptr_t)mem) & (MEM_ALIGNMENT-1)) == 0);

        return (u8_t *)mem + SIZEOF_STRUCT_MEM;
 80457b4:	f104 0008 	add.w	r0, r4, #8
 80457b8:	e058      	b.n	804586c <mem_malloc+0x100>
            cur = (struct mem *)(void *)&ram[cur->next];
 80457ba:	883f      	ldrh	r7, [r7, #0]
 80457bc:	4437      	add	r7, r6
          while (cur->used && cur != ram_end) {
 80457be:	793b      	ldrb	r3, [r7, #4]
 80457c0:	b11b      	cbz	r3, 80457ca <mem_malloc+0x5e>
 80457c2:	4a2c      	ldr	r2, [pc, #176]	; (8045874 <mem_malloc+0x108>)
 80457c4:	6852      	ldr	r2, [r2, #4]
 80457c6:	42ba      	cmp	r2, r7
 80457c8:	d1f7      	bne.n	80457ba <mem_malloc+0x4e>
          lfree = cur;
 80457ca:	4a2a      	ldr	r2, [pc, #168]	; (8045874 <mem_malloc+0x108>)
 80457cc:	6097      	str	r7, [r2, #8]
          LWIP_ASSERT("mem_malloc: !lfree->used", ((lfree == ram_end) || (!lfree->used)));
 80457ce:	6852      	ldr	r2, [r2, #4]
 80457d0:	42ba      	cmp	r2, r7
 80457d2:	d0e5      	beq.n	80457a0 <mem_malloc+0x34>
 80457d4:	2b00      	cmp	r3, #0
 80457d6:	d0e3      	beq.n	80457a0 <mem_malloc+0x34>
 80457d8:	4b27      	ldr	r3, [pc, #156]	; (8045878 <mem_malloc+0x10c>)
 80457da:	f240 22cf 	movw	r2, #719	; 0x2cf
 80457de:	4927      	ldr	r1, [pc, #156]	; (804587c <mem_malloc+0x110>)
 80457e0:	4827      	ldr	r0, [pc, #156]	; (8045880 <mem_malloc+0x114>)
 80457e2:	f00c f931 	bl	8051a48 <printf>
 80457e6:	e7db      	b.n	80457a0 <mem_malloc+0x34>
        LWIP_ASSERT("mem_malloc: allocated memory not above ram_end.",
 80457e8:	4b23      	ldr	r3, [pc, #140]	; (8045878 <mem_malloc+0x10c>)
 80457ea:	f240 22d3 	movw	r2, #723	; 0x2d3
 80457ee:	4925      	ldr	r1, [pc, #148]	; (8045884 <mem_malloc+0x118>)
 80457f0:	4823      	ldr	r0, [pc, #140]	; (8045880 <mem_malloc+0x114>)
 80457f2:	f00c f929 	bl	8051a48 <printf>
 80457f6:	e7d9      	b.n	80457ac <mem_malloc+0x40>
        LWIP_ASSERT("mem_malloc: allocated memory properly aligned.",
 80457f8:	4b1f      	ldr	r3, [pc, #124]	; (8045878 <mem_malloc+0x10c>)
 80457fa:	f240 22d5 	movw	r2, #725	; 0x2d5
 80457fe:	4922      	ldr	r1, [pc, #136]	; (8045888 <mem_malloc+0x11c>)
 8045800:	481f      	ldr	r0, [pc, #124]	; (8045880 <mem_malloc+0x114>)
 8045802:	f00c f921 	bl	8051a48 <printf>
 8045806:	e7d4      	b.n	80457b2 <mem_malloc+0x46>
        LWIP_ASSERT("mem_malloc: sanity check alignment",
 8045808:	4b1b      	ldr	r3, [pc, #108]	; (8045878 <mem_malloc+0x10c>)
 804580a:	f240 22d7 	movw	r2, #727	; 0x2d7
 804580e:	491f      	ldr	r1, [pc, #124]	; (804588c <mem_malloc+0x120>)
 8045810:	481b      	ldr	r0, [pc, #108]	; (8045880 <mem_malloc+0x114>)
 8045812:	f00c f919 	bl	8051a48 <printf>
 8045816:	e7cd      	b.n	80457b4 <mem_malloc+0x48>
         ptr = ((struct mem *)(void *)&ram[ptr])->next) {
 8045818:	8823      	ldrh	r3, [r4, #0]
    for (ptr = (mem_size_t)((u8_t *)lfree - ram); ptr < MEM_SIZE_ALIGNED - size;
 804581a:	469c      	mov	ip, r3
 804581c:	4615      	mov	r5, r2
 804581e:	f5c2 60c8 	rsb	r0, r2, #1600	; 0x640
 8045822:	4283      	cmp	r3, r0
 8045824:	d221      	bcs.n	804586a <mem_malloc+0xfe>
      mem = (struct mem *)(void *)&ram[ptr];
 8045826:	18f4      	adds	r4, r6, r3
      if ((!mem->used) &&
 8045828:	7920      	ldrb	r0, [r4, #4]
 804582a:	2800      	cmp	r0, #0
 804582c:	d1f4      	bne.n	8045818 <mem_malloc+0xac>
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
 804582e:	5af1      	ldrh	r1, [r6, r3]
 8045830:	eba1 010c 	sub.w	r1, r1, ip
 8045834:	3908      	subs	r1, #8
      if ((!mem->used) &&
 8045836:	42a9      	cmp	r1, r5
 8045838:	d3ee      	bcc.n	8045818 <mem_malloc+0xac>
        if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >= (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED)) {
 804583a:	f105 0014 	add.w	r0, r5, #20
 804583e:	4281      	cmp	r1, r0
 8045840:	d3aa      	bcc.n	8045798 <mem_malloc+0x2c>
          ptr2 = ptr + SIZEOF_STRUCT_MEM + size;
 8045842:	441a      	add	r2, r3
 8045844:	b292      	uxth	r2, r2
 8045846:	3208      	adds	r2, #8
 8045848:	b292      	uxth	r2, r2
          mem2 = (struct mem *)(void *)&ram[ptr2];
 804584a:	18b1      	adds	r1, r6, r2
          mem2->used = 0;
 804584c:	2000      	movs	r0, #0
 804584e:	7108      	strb	r0, [r1, #4]
          mem2->next = mem->next;
 8045850:	8820      	ldrh	r0, [r4, #0]
 8045852:	52b0      	strh	r0, [r6, r2]
          mem2->prev = ptr;
 8045854:	804b      	strh	r3, [r1, #2]
          mem->next = ptr2;
 8045856:	8022      	strh	r2, [r4, #0]
          mem->used = 1;
 8045858:	2301      	movs	r3, #1
 804585a:	7123      	strb	r3, [r4, #4]
          if (mem2->next != MEM_SIZE_ALIGNED) {
 804585c:	5ab3      	ldrh	r3, [r6, r2]
 804585e:	f5b3 6fc8 	cmp.w	r3, #1600	; 0x640
 8045862:	d09b      	beq.n	804579c <mem_malloc+0x30>
            ((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
 8045864:	4433      	add	r3, r6
 8045866:	805a      	strh	r2, [r3, #2]
 8045868:	e798      	b.n	804579c <mem_malloc+0x30>
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
  MEM_STATS_INC(err);
  LWIP_MEM_ALLOC_UNPROTECT();
  sys_mutex_unlock(&mem_mutex);
  return NULL;
 804586a:	2000      	movs	r0, #0
}
 804586c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return NULL;
 804586e:	2000      	movs	r0, #0
}
 8045870:	4770      	bx	lr
 8045872:	bf00      	nop
 8045874:	200040a0 	.word	0x200040a0
 8045878:	08058e84 	.word	0x08058e84
 804587c:	08058fe0 	.word	0x08058fe0
 8045880:	08058ecc 	.word	0x08058ecc
 8045884:	08058ffc 	.word	0x08058ffc
 8045888:	0805902c 	.word	0x0805902c
 804588c:	0805905c 	.word	0x0805905c

08045890 <do_memp_malloc_pool>:
#if !MEMP_OVERFLOW_CHECK
do_memp_malloc_pool(const struct memp_desc *desc)
#else
do_memp_malloc_pool_fn(const struct memp_desc *desc, const char* file, const int line)
#endif
{
 8045890:	b510      	push	{r4, lr}
  memp = (struct memp *)mem_malloc(MEMP_SIZE + MEMP_ALIGN_SIZE(desc->size));
  SYS_ARCH_PROTECT(old_level);
#else /* MEMP_MEM_MALLOC */
  SYS_ARCH_PROTECT(old_level);

  memp = *desc->tab;
 8045892:	6883      	ldr	r3, [r0, #8]
 8045894:	681c      	ldr	r4, [r3, #0]
#endif /* MEMP_MEM_MALLOC */

  if (memp != NULL) {
 8045896:	b124      	cbz	r4, 80458a2 <do_memp_malloc_pool+0x12>
#if MEMP_OVERFLOW_CHECK == 1
    memp_overflow_check_element_overflow(memp, desc);
    memp_overflow_check_element_underflow(memp, desc);
#endif /* MEMP_OVERFLOW_CHECK */

    *desc->tab = memp->next;
 8045898:	6822      	ldr	r2, [r4, #0]
 804589a:	601a      	str	r2, [r3, #0]
    memp->line = line;
#if MEMP_MEM_MALLOC
    memp_overflow_init_element(memp, desc);
#endif /* MEMP_MEM_MALLOC */
#endif /* MEMP_OVERFLOW_CHECK */
    LWIP_ASSERT("memp_malloc: memp properly aligned",
 804589c:	f014 0f03 	tst.w	r4, #3
 80458a0:	d101      	bne.n	80458a6 <do_memp_malloc_pool+0x16>
#endif
  }

  SYS_ARCH_UNPROTECT(old_level);
  return NULL;
}
 80458a2:	4620      	mov	r0, r4
 80458a4:	bd10      	pop	{r4, pc}
    LWIP_ASSERT("memp_malloc: memp properly aligned",
 80458a6:	4b04      	ldr	r3, [pc, #16]	; (80458b8 <do_memp_malloc_pool+0x28>)
 80458a8:	f44f 72a4 	mov.w	r2, #328	; 0x148
 80458ac:	4903      	ldr	r1, [pc, #12]	; (80458bc <do_memp_malloc_pool+0x2c>)
 80458ae:	4804      	ldr	r0, [pc, #16]	; (80458c0 <do_memp_malloc_pool+0x30>)
 80458b0:	f00c f8ca 	bl	8051a48 <printf>
    return ((u8_t*)memp + MEMP_SIZE);
 80458b4:	e7f5      	b.n	80458a2 <do_memp_malloc_pool+0x12>
 80458b6:	bf00      	nop
 80458b8:	08059080 	.word	0x08059080
 80458bc:	080590b0 	.word	0x080590b0
 80458c0:	08058ecc 	.word	0x08058ecc

080458c4 <do_memp_free_pool>:
  return memp;
}

static void
do_memp_free_pool(const struct memp_desc* desc, void *mem)
{
 80458c4:	b538      	push	{r3, r4, r5, lr}
 80458c6:	4605      	mov	r5, r0
 80458c8:	460c      	mov	r4, r1
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);

  LWIP_ASSERT("memp_free: mem properly aligned",
 80458ca:	f011 0f03 	tst.w	r1, #3
 80458ce:	d105      	bne.n	80458dc <do_memp_free_pool+0x18>
#if MEMP_MEM_MALLOC
  LWIP_UNUSED_ARG(desc);
  SYS_ARCH_UNPROTECT(old_level);
  mem_free(memp);
#else /* MEMP_MEM_MALLOC */
  memp->next = *desc->tab;
 80458d0:	68ab      	ldr	r3, [r5, #8]
 80458d2:	681b      	ldr	r3, [r3, #0]
 80458d4:	6023      	str	r3, [r4, #0]
  *desc->tab = memp;
 80458d6:	68ab      	ldr	r3, [r5, #8]
 80458d8:	601c      	str	r4, [r3, #0]
  LWIP_ASSERT("memp sanity", memp_sanity(desc));
#endif /* MEMP_SANITY_CHECK */

  SYS_ARCH_UNPROTECT(old_level);
#endif /* !MEMP_MEM_MALLOC */
}
 80458da:	bd38      	pop	{r3, r4, r5, pc}
  LWIP_ASSERT("memp_free: mem properly aligned",
 80458dc:	4b03      	ldr	r3, [pc, #12]	; (80458ec <do_memp_free_pool+0x28>)
 80458de:	f44f 72ce 	mov.w	r2, #412	; 0x19c
 80458e2:	4903      	ldr	r1, [pc, #12]	; (80458f0 <do_memp_free_pool+0x2c>)
 80458e4:	4803      	ldr	r0, [pc, #12]	; (80458f4 <do_memp_free_pool+0x30>)
 80458e6:	f00c f8af 	bl	8051a48 <printf>
 80458ea:	e7f1      	b.n	80458d0 <do_memp_free_pool+0xc>
 80458ec:	08059080 	.word	0x08059080
 80458f0:	080590d4 	.word	0x080590d4
 80458f4:	08058ecc 	.word	0x08058ecc

080458f8 <memp_init_pool>:
  *desc->tab = NULL;
 80458f8:	6883      	ldr	r3, [r0, #8]
 80458fa:	2200      	movs	r2, #0
 80458fc:	601a      	str	r2, [r3, #0]
  memp = (struct memp*)LWIP_MEM_ALIGN(desc->base);
 80458fe:	6843      	ldr	r3, [r0, #4]
 8045900:	3303      	adds	r3, #3
 8045902:	f023 0303 	bic.w	r3, r3, #3
  for (i = 0; i < desc->num; ++i) {
 8045906:	8841      	ldrh	r1, [r0, #2]
 8045908:	4291      	cmp	r1, r2
 804590a:	dd08      	ble.n	804591e <memp_init_pool+0x26>
    memp->next = *desc->tab;
 804590c:	6881      	ldr	r1, [r0, #8]
 804590e:	6809      	ldr	r1, [r1, #0]
 8045910:	6019      	str	r1, [r3, #0]
    *desc->tab = memp;
 8045912:	6881      	ldr	r1, [r0, #8]
 8045914:	600b      	str	r3, [r1, #0]
   memp = (struct memp *)(void *)((u8_t *)memp + MEMP_SIZE + desc->size
 8045916:	8801      	ldrh	r1, [r0, #0]
 8045918:	440b      	add	r3, r1
  for (i = 0; i < desc->num; ++i) {
 804591a:	3201      	adds	r2, #1
 804591c:	e7f3      	b.n	8045906 <memp_init_pool+0xe>
}
 804591e:	4770      	bx	lr

08045920 <memp_init>:
{
 8045920:	b510      	push	{r4, lr}
  for (i = 0; i < LWIP_ARRAYSIZE(memp_pools); i++) {
 8045922:	2400      	movs	r4, #0
 8045924:	e006      	b.n	8045934 <memp_init+0x14>
    memp_init_pool(memp_pools[i]);
 8045926:	4b05      	ldr	r3, [pc, #20]	; (804593c <memp_init+0x1c>)
 8045928:	f853 0024 	ldr.w	r0, [r3, r4, lsl #2]
 804592c:	f7ff ffe4 	bl	80458f8 <memp_init_pool>
  for (i = 0; i < LWIP_ARRAYSIZE(memp_pools); i++) {
 8045930:	3401      	adds	r4, #1
 8045932:	b2a4      	uxth	r4, r4
 8045934:	2c08      	cmp	r4, #8
 8045936:	d9f6      	bls.n	8045926 <memp_init+0x6>
}
 8045938:	bd10      	pop	{r4, pc}
 804593a:	bf00      	nop
 804593c:	08058d58 	.word	0x08058d58

08045940 <memp_malloc>:
{
 8045940:	b508      	push	{r3, lr}
  LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
 8045942:	2808      	cmp	r0, #8
 8045944:	d805      	bhi.n	8045952 <memp_malloc+0x12>
  memp = do_memp_malloc_pool(memp_pools[type]);
 8045946:	4b07      	ldr	r3, [pc, #28]	; (8045964 <memp_malloc+0x24>)
 8045948:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
 804594c:	f7ff ffa0 	bl	8045890 <do_memp_malloc_pool>
}
 8045950:	bd08      	pop	{r3, pc}
  LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
 8045952:	4b05      	ldr	r3, [pc, #20]	; (8045968 <memp_malloc+0x28>)
 8045954:	f240 1287 	movw	r2, #391	; 0x187
 8045958:	4904      	ldr	r1, [pc, #16]	; (804596c <memp_malloc+0x2c>)
 804595a:	4805      	ldr	r0, [pc, #20]	; (8045970 <memp_malloc+0x30>)
 804595c:	f00c f874 	bl	8051a48 <printf>
 8045960:	2000      	movs	r0, #0
 8045962:	e7f5      	b.n	8045950 <memp_malloc+0x10>
 8045964:	08058d58 	.word	0x08058d58
 8045968:	08059080 	.word	0x08059080
 804596c:	08059108 	.word	0x08059108
 8045970:	08058ecc 	.word	0x08058ecc

08045974 <memp_free>:
 * @param type the pool where to put mem
 * @param mem the memp element to free
 */
void
memp_free(memp_t type, void *mem)
{
 8045974:	b508      	push	{r3, lr}
#ifdef LWIP_HOOK_MEMP_AVAILABLE
  struct memp *old_first;
#endif

  LWIP_ERROR("memp_free: type < MEMP_MAX", (type < MEMP_MAX), return;);
 8045976:	2808      	cmp	r0, #8
 8045978:	d806      	bhi.n	8045988 <memp_free+0x14>

  if (mem == NULL) {
 804597a:	b121      	cbz	r1, 8045986 <memp_free+0x12>

#ifdef LWIP_HOOK_MEMP_AVAILABLE
  old_first = *memp_pools[type]->tab;
#endif

  do_memp_free_pool(memp_pools[type], mem);
 804597c:	4b06      	ldr	r3, [pc, #24]	; (8045998 <memp_free+0x24>)
 804597e:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
 8045982:	f7ff ff9f 	bl	80458c4 <do_memp_free_pool>
#ifdef LWIP_HOOK_MEMP_AVAILABLE
  if (old_first == NULL) {
    LWIP_HOOK_MEMP_AVAILABLE(type);
  }
#endif
}
 8045986:	bd08      	pop	{r3, pc}
  LWIP_ERROR("memp_free: type < MEMP_MAX", (type < MEMP_MAX), return;);
 8045988:	4b04      	ldr	r3, [pc, #16]	; (804599c <memp_free+0x28>)
 804598a:	f240 12db 	movw	r2, #475	; 0x1db
 804598e:	4904      	ldr	r1, [pc, #16]	; (80459a0 <memp_free+0x2c>)
 8045990:	4804      	ldr	r0, [pc, #16]	; (80459a4 <memp_free+0x30>)
 8045992:	f00c f859 	bl	8051a48 <printf>
 8045996:	e7f6      	b.n	8045986 <memp_free+0x12>
 8045998:	08058d58 	.word	0x08058d58
 804599c:	08059080 	.word	0x08059080
 80459a0:	08059128 	.word	0x08059128
 80459a4:	08058ecc 	.word	0x08058ecc

080459a8 <netif_issue_reports>:
 */
static void
netif_issue_reports(struct netif* netif, u8_t report_type)
{
#if LWIP_IPV4
  if ((report_type & NETIF_REPORT_TYPE_IPV4) &&
 80459a8:	f011 0f01 	tst.w	r1, #1
 80459ac:	d00c      	beq.n	80459c8 <netif_issue_reports+0x20>
{
 80459ae:	b508      	push	{r3, lr}
      !ip4_addr_isany_val(*netif_ip4_addr(netif))) {
 80459b0:	6843      	ldr	r3, [r0, #4]
  if ((report_type & NETIF_REPORT_TYPE_IPV4) &&
 80459b2:	b123      	cbz	r3, 80459be <netif_issue_reports+0x16>
#if LWIP_ARP
    /* For Ethernet network interfaces, we would like to send a "gratuitous ARP" */
    if (netif->flags & (NETIF_FLAG_ETHARP)) {
 80459b4:	f890 302b 	ldrb.w	r3, [r0, #43]	; 0x2b
 80459b8:	f013 0f08 	tst.w	r3, #8
 80459bc:	d100      	bne.n	80459c0 <netif_issue_reports+0x18>
    /* Send Router Solicitation messages. */
    netif->rs_count = LWIP_ND6_MAX_MULTICAST_SOLICIT;
#endif /* LWIP_IPV6_SEND_ROUTER_SOLICIT */
  }
#endif /* LWIP_IPV6 */
}
 80459be:	bd08      	pop	{r3, pc}
      etharp_gratuitous(netif);
 80459c0:	1d01      	adds	r1, r0, #4
 80459c2:	f004 fc4b 	bl	804a25c <etharp_request>
}
 80459c6:	e7fa      	b.n	80459be <netif_issue_reports+0x16>
 80459c8:	4770      	bx	lr

080459ca <netif_init>:
}
 80459ca:	4770      	bx	lr

080459cc <netif_set_ipaddr>:
{
 80459cc:	b570      	push	{r4, r5, r6, lr}
 80459ce:	b082      	sub	sp, #8
 80459d0:	4604      	mov	r4, r0
  *ip_2_ip4(&new_addr) = (ipaddr ? *ipaddr : *IP4_ADDR_ANY4);
 80459d2:	460d      	mov	r5, r1
 80459d4:	b139      	cbz	r1, 80459e6 <netif_set_ipaddr+0x1a>
 80459d6:	680b      	ldr	r3, [r1, #0]
 80459d8:	9301      	str	r3, [sp, #4]
  if (ip4_addr_cmp(ip_2_ip4(&new_addr), netif_ip4_addr(netif)) == 0) {
 80459da:	6863      	ldr	r3, [r4, #4]
 80459dc:	9a01      	ldr	r2, [sp, #4]
 80459de:	429a      	cmp	r2, r3
 80459e0:	d105      	bne.n	80459ee <netif_set_ipaddr+0x22>
}
 80459e2:	b002      	add	sp, #8
 80459e4:	bd70      	pop	{r4, r5, r6, pc}
  *ip_2_ip4(&new_addr) = (ipaddr ? *ipaddr : *IP4_ADDR_ANY4);
 80459e6:	4b0b      	ldr	r3, [pc, #44]	; (8045a14 <netif_set_ipaddr+0x48>)
 80459e8:	681b      	ldr	r3, [r3, #0]
 80459ea:	9301      	str	r3, [sp, #4]
 80459ec:	e7f5      	b.n	80459da <netif_set_ipaddr+0xe>
    tcp_netif_ip_addr_changed(netif_ip_addr4(netif), &new_addr);
 80459ee:	1d26      	adds	r6, r4, #4
 80459f0:	a901      	add	r1, sp, #4
 80459f2:	4630      	mov	r0, r6
 80459f4:	f001 fcc6 	bl	8047384 <tcp_netif_ip_addr_changed>
    udp_netif_ip_addr_changed(netif_ip_addr4(netif), &new_addr);
 80459f8:	a901      	add	r1, sp, #4
 80459fa:	4630      	mov	r0, r6
 80459fc:	f004 f9c8 	bl	8049d90 <udp_netif_ip_addr_changed>
    ip4_addr_set(ip_2_ip4(&netif->ip_addr), ipaddr);
 8045a00:	b135      	cbz	r5, 8045a10 <netif_set_ipaddr+0x44>
 8045a02:	682b      	ldr	r3, [r5, #0]
 8045a04:	6063      	str	r3, [r4, #4]
    netif_issue_reports(netif, NETIF_REPORT_TYPE_IPV4);
 8045a06:	2101      	movs	r1, #1
 8045a08:	4620      	mov	r0, r4
 8045a0a:	f7ff ffcd 	bl	80459a8 <netif_issue_reports>
}
 8045a0e:	e7e8      	b.n	80459e2 <netif_set_ipaddr+0x16>
    ip4_addr_set(ip_2_ip4(&netif->ip_addr), ipaddr);
 8045a10:	2300      	movs	r3, #0
 8045a12:	e7f7      	b.n	8045a04 <netif_set_ipaddr+0x38>
 8045a14:	08058e58 	.word	0x08058e58

08045a18 <netif_set_gw>:
  ip4_addr_set(ip_2_ip4(&netif->gw), gw);
 8045a18:	b111      	cbz	r1, 8045a20 <netif_set_gw+0x8>
 8045a1a:	680b      	ldr	r3, [r1, #0]
 8045a1c:	60c3      	str	r3, [r0, #12]
}
 8045a1e:	4770      	bx	lr
  ip4_addr_set(ip_2_ip4(&netif->gw), gw);
 8045a20:	2300      	movs	r3, #0
 8045a22:	e7fb      	b.n	8045a1c <netif_set_gw+0x4>

08045a24 <netif_set_netmask>:
  ip4_addr_set(ip_2_ip4(&netif->netmask), netmask);
 8045a24:	b111      	cbz	r1, 8045a2c <netif_set_netmask+0x8>
 8045a26:	680b      	ldr	r3, [r1, #0]
 8045a28:	6083      	str	r3, [r0, #8]
}
 8045a2a:	4770      	bx	lr
  ip4_addr_set(ip_2_ip4(&netif->netmask), netmask);
 8045a2c:	2300      	movs	r3, #0
 8045a2e:	e7fb      	b.n	8045a28 <netif_set_netmask+0x4>

08045a30 <netif_set_addr>:
{
 8045a30:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8045a32:	4604      	mov	r4, r0
 8045a34:	4616      	mov	r6, r2
 8045a36:	461d      	mov	r5, r3
  if (ip4_addr_isany(ipaddr)) {
 8045a38:	460f      	mov	r7, r1
 8045a3a:	b109      	cbz	r1, 8045a40 <netif_set_addr+0x10>
 8045a3c:	680b      	ldr	r3, [r1, #0]
 8045a3e:	b963      	cbnz	r3, 8045a5a <netif_set_addr+0x2a>
    netif_set_ipaddr(netif, ipaddr);
 8045a40:	4639      	mov	r1, r7
 8045a42:	4620      	mov	r0, r4
 8045a44:	f7ff ffc2 	bl	80459cc <netif_set_ipaddr>
    netif_set_netmask(netif, netmask);
 8045a48:	4631      	mov	r1, r6
 8045a4a:	4620      	mov	r0, r4
 8045a4c:	f7ff ffea 	bl	8045a24 <netif_set_netmask>
    netif_set_gw(netif, gw);
 8045a50:	4629      	mov	r1, r5
 8045a52:	4620      	mov	r0, r4
 8045a54:	f7ff ffe0 	bl	8045a18 <netif_set_gw>
}
 8045a58:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    netif_set_netmask(netif, netmask);
 8045a5a:	4611      	mov	r1, r2
 8045a5c:	f7ff ffe2 	bl	8045a24 <netif_set_netmask>
    netif_set_gw(netif, gw);
 8045a60:	4629      	mov	r1, r5
 8045a62:	4620      	mov	r0, r4
 8045a64:	f7ff ffd8 	bl	8045a18 <netif_set_gw>
    netif_set_ipaddr(netif, ipaddr);
 8045a68:	4639      	mov	r1, r7
 8045a6a:	4620      	mov	r0, r4
 8045a6c:	f7ff ffae 	bl	80459cc <netif_set_ipaddr>
}
 8045a70:	e7f2      	b.n	8045a58 <netif_set_addr+0x28>
	...

08045a74 <netif_add>:
{
 8045a74:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8045a78:	4604      	mov	r4, r0
 8045a7a:	460d      	mov	r5, r1
 8045a7c:	4616      	mov	r6, r2
 8045a7e:	461f      	mov	r7, r3
 8045a80:	f8dd 801c 	ldr.w	r8, [sp, #28]
  LWIP_ASSERT("No init function given", init != NULL);
 8045a84:	f1b8 0f00 	cmp.w	r8, #0
 8045a88:	d022      	beq.n	8045ad0 <netif_add+0x5c>
  ip_addr_set_zero_ip4(&netif->ip_addr);
 8045a8a:	2000      	movs	r0, #0
 8045a8c:	6060      	str	r0, [r4, #4]
  ip_addr_set_zero_ip4(&netif->netmask);
 8045a8e:	60a0      	str	r0, [r4, #8]
  ip_addr_set_zero_ip4(&netif->gw);
 8045a90:	60e0      	str	r0, [r4, #12]
  netif->flags = 0;
 8045a92:	f884 002b 	strb.w	r0, [r4, #43]	; 0x2b
  netif->rs_count = LWIP_ND6_MAX_MULTICAST_SOLICIT;
 8045a96:	2303      	movs	r3, #3
 8045a98:	f884 3020 	strb.w	r3, [r4, #32]
  netif->state = state;
 8045a9c:	9b06      	ldr	r3, [sp, #24]
 8045a9e:	61e3      	str	r3, [r4, #28]
  netif->num = netif_num++;
 8045aa0:	4a10      	ldr	r2, [pc, #64]	; (8045ae4 <netif_add+0x70>)
 8045aa2:	7813      	ldrb	r3, [r2, #0]
 8045aa4:	1c59      	adds	r1, r3, #1
 8045aa6:	7011      	strb	r1, [r2, #0]
 8045aa8:	f884 302e 	strb.w	r3, [r4, #46]	; 0x2e
  netif->input = input;
 8045aac:	9b08      	ldr	r3, [sp, #32]
 8045aae:	6123      	str	r3, [r4, #16]
  netif_set_addr(netif, ipaddr, netmask, gw);
 8045ab0:	463b      	mov	r3, r7
 8045ab2:	4632      	mov	r2, r6
 8045ab4:	4629      	mov	r1, r5
 8045ab6:	4620      	mov	r0, r4
 8045ab8:	f7ff ffba 	bl	8045a30 <netif_set_addr>
  if (init(netif) != ERR_OK) {
 8045abc:	4620      	mov	r0, r4
 8045abe:	47c0      	blx	r8
 8045ac0:	b968      	cbnz	r0, 8045ade <netif_add+0x6a>
  netif->next = netif_list;
 8045ac2:	4b09      	ldr	r3, [pc, #36]	; (8045ae8 <netif_add+0x74>)
 8045ac4:	681a      	ldr	r2, [r3, #0]
 8045ac6:	6022      	str	r2, [r4, #0]
  netif_list = netif;
 8045ac8:	601c      	str	r4, [r3, #0]
  return netif;
 8045aca:	4620      	mov	r0, r4
}
 8045acc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  LWIP_ASSERT("No init function given", init != NULL);
 8045ad0:	4b06      	ldr	r3, [pc, #24]	; (8045aec <netif_add+0x78>)
 8045ad2:	22fb      	movs	r2, #251	; 0xfb
 8045ad4:	4906      	ldr	r1, [pc, #24]	; (8045af0 <netif_add+0x7c>)
 8045ad6:	4807      	ldr	r0, [pc, #28]	; (8045af4 <netif_add+0x80>)
 8045ad8:	f00b ffb6 	bl	8051a48 <printf>
 8045adc:	e7d5      	b.n	8045a8a <netif_add+0x16>
    return NULL;
 8045ade:	2000      	movs	r0, #0
 8045ae0:	e7f4      	b.n	8045acc <netif_add+0x58>
 8045ae2:	bf00      	nop
 8045ae4:	200040d0 	.word	0x200040d0
 8045ae8:	20008710 	.word	0x20008710
 8045aec:	08059144 	.word	0x08059144
 8045af0:	08059178 	.word	0x08059178
 8045af4:	08058ecc 	.word	0x08058ecc

08045af8 <netif_set_default>:
  netif_default = netif;
 8045af8:	4b01      	ldr	r3, [pc, #4]	; (8045b00 <netif_set_default+0x8>)
 8045afa:	6018      	str	r0, [r3, #0]
}
 8045afc:	4770      	bx	lr
 8045afe:	bf00      	nop
 8045b00:	20008714 	.word	0x20008714

08045b04 <netif_set_up>:
{
 8045b04:	b508      	push	{r3, lr}
  if (!(netif->flags & NETIF_FLAG_UP)) {
 8045b06:	f890 302b 	ldrb.w	r3, [r0, #43]	; 0x2b
 8045b0a:	f013 0f01 	tst.w	r3, #1
 8045b0e:	d106      	bne.n	8045b1e <netif_set_up+0x1a>
    netif->flags |= NETIF_FLAG_UP;
 8045b10:	f043 0301 	orr.w	r3, r3, #1
 8045b14:	f880 302b 	strb.w	r3, [r0, #43]	; 0x2b
    if (netif->flags & NETIF_FLAG_LINK_UP) {
 8045b18:	f013 0f04 	tst.w	r3, #4
 8045b1c:	d100      	bne.n	8045b20 <netif_set_up+0x1c>
}
 8045b1e:	bd08      	pop	{r3, pc}
      netif_issue_reports(netif, NETIF_REPORT_TYPE_IPV4|NETIF_REPORT_TYPE_IPV6);
 8045b20:	2103      	movs	r1, #3
 8045b22:	f7ff ff41 	bl	80459a8 <netif_issue_reports>
}
 8045b26:	e7fa      	b.n	8045b1e <netif_set_up+0x1a>

08045b28 <netif_set_down>:
 * @ingroup netif
 * Bring an interface down, disabling any traffic processing.
 */
void
netif_set_down(struct netif *netif)
{
 8045b28:	b508      	push	{r3, lr}
  if (netif->flags & NETIF_FLAG_UP) {
 8045b2a:	f890 302b 	ldrb.w	r3, [r0, #43]	; 0x2b
 8045b2e:	f013 0f01 	tst.w	r3, #1
 8045b32:	d006      	beq.n	8045b42 <netif_set_down+0x1a>
    netif->flags &= ~NETIF_FLAG_UP;
 8045b34:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
 8045b38:	f880 302b 	strb.w	r3, [r0, #43]	; 0x2b
    MIB2_COPY_SYSUPTIME_TO(&netif->ts);

#if LWIP_IPV4 && LWIP_ARP
    if (netif->flags & NETIF_FLAG_ETHARP) {
 8045b3c:	f013 0f08 	tst.w	r3, #8
 8045b40:	d100      	bne.n	8045b44 <netif_set_down+0x1c>
    nd6_cleanup_netif(netif);
#endif /* LWIP_IPV6 */

    NETIF_STATUS_CALLBACK(netif);
  }
}
 8045b42:	bd08      	pop	{r3, pc}
      etharp_cleanup_netif(netif);
 8045b44:	f004 fb10 	bl	804a168 <etharp_cleanup_netif>
}
 8045b48:	e7fb      	b.n	8045b42 <netif_set_down+0x1a>
	...

08045b4c <pbuf_pool_is_empty>:
/** Queue a call to pbuf_free_ooseq if not already queued. */
static void
pbuf_pool_is_empty(void)
{
#ifndef PBUF_POOL_FREE_OOSEQ_QUEUE_CALL
  SYS_ARCH_SET(pbuf_free_ooseq_pending, 1);
 8045b4c:	4b01      	ldr	r3, [pc, #4]	; (8045b54 <pbuf_pool_is_empty+0x8>)
 8045b4e:	2201      	movs	r2, #1
 8045b50:	701a      	strb	r2, [r3, #0]
  if (!queued) {
    /* queue a call to pbuf_free_ooseq if not already queued */
    PBUF_POOL_FREE_OOSEQ_QUEUE_CALL();
  }
#endif /* PBUF_POOL_FREE_OOSEQ_QUEUE_CALL */
}
 8045b52:	4770      	bx	lr
 8045b54:	20008718 	.word	0x20008718

08045b58 <pbuf_header_impl>:
 * @return non-zero on failure, zero on success.
 *
 */
static u8_t
pbuf_header_impl(struct pbuf *p, s16_t header_size_increment, u8_t force)
{
 8045b58:	b570      	push	{r4, r5, r6, lr}
 8045b5a:	460c      	mov	r4, r1
 8045b5c:	4616      	mov	r6, r2
  u16_t type;
  void *payload;
  u16_t increment_magnitude;

  LWIP_ASSERT("p != NULL", p != NULL);
 8045b5e:	4605      	mov	r5, r0
 8045b60:	b1c0      	cbz	r0, 8045b94 <pbuf_header_impl+0x3c>
  if ((header_size_increment == 0) || (p == NULL)) {
 8045b62:	2c00      	cmp	r4, #0
 8045b64:	d04e      	beq.n	8045c04 <pbuf_header_impl+0xac>
 8045b66:	2d00      	cmp	r5, #0
 8045b68:	d04e      	beq.n	8045c08 <pbuf_header_impl+0xb0>
    return 0;
  }

  if (header_size_increment < 0) {
 8045b6a:	2c00      	cmp	r4, #0
 8045b6c:	db1a      	blt.n	8045ba4 <pbuf_header_impl+0x4c>
    increment_magnitude = (u16_t)-header_size_increment;
    /* Check that we aren't going to move off the end of the pbuf */
    LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
  } else {
    increment_magnitude = (u16_t)header_size_increment;
 8045b6e:	b2a2      	uxth	r2, r4
    LWIP_ASSERT("p->payload - increment_magnitude >= p + SIZEOF_STRUCT_PBUF",
                (u8_t *)p->payload - increment_magnitude >= (u8_t *)p + SIZEOF_STRUCT_PBUF);
#endif
  }

  type = p->type;
 8045b70:	7b2b      	ldrb	r3, [r5, #12]
  /* remember current payload pointer */
  payload = p->payload;
 8045b72:	6869      	ldr	r1, [r5, #4]

  /* pbuf types containing payloads? */
  if (type == PBUF_RAM || type == PBUF_POOL) {
 8045b74:	b32b      	cbz	r3, 8045bc2 <pbuf_header_impl+0x6a>
 8045b76:	2b03      	cmp	r3, #3
 8045b78:	d023      	beq.n	8045bc2 <pbuf_header_impl+0x6a>
      p->payload = payload;
      /* bail out unsuccessfully */
      return 1;
    }
  /* pbuf types referring to external payloads? */
  } else if (type == PBUF_REF || type == PBUF_ROM) {
 8045b7a:	3b01      	subs	r3, #1
 8045b7c:	b29b      	uxth	r3, r3
 8045b7e:	2b01      	cmp	r3, #1
 8045b80:	d837      	bhi.n	8045bf2 <pbuf_header_impl+0x9a>
    /* hide a header in the payload? */
    if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
 8045b82:	2c00      	cmp	r4, #0
 8045b84:	db2f      	blt.n	8045be6 <pbuf_header_impl+0x8e>
      /* increase payload pointer */
      p->payload = (u8_t *)p->payload - header_size_increment;
    } else if ((header_size_increment > 0) && force) {
 8045b86:	2c00      	cmp	r4, #0
 8045b88:	dd40      	ble.n	8045c0c <pbuf_header_impl+0xb4>
 8045b8a:	2e00      	cmp	r6, #0
 8045b8c:	d040      	beq.n	8045c10 <pbuf_header_impl+0xb8>
      p->payload = (u8_t *)p->payload - header_size_increment;
 8045b8e:	1b09      	subs	r1, r1, r4
 8045b90:	6069      	str	r1, [r5, #4]
 8045b92:	e01c      	b.n	8045bce <pbuf_header_impl+0x76>
  LWIP_ASSERT("p != NULL", p != NULL);
 8045b94:	4b1f      	ldr	r3, [pc, #124]	; (8045c14 <pbuf_header_impl+0xbc>)
 8045b96:	f240 223f 	movw	r2, #575	; 0x23f
 8045b9a:	491f      	ldr	r1, [pc, #124]	; (8045c18 <pbuf_header_impl+0xc0>)
 8045b9c:	481f      	ldr	r0, [pc, #124]	; (8045c1c <pbuf_header_impl+0xc4>)
 8045b9e:	f00b ff53 	bl	8051a48 <printf>
 8045ba2:	e7de      	b.n	8045b62 <pbuf_header_impl+0xa>
    increment_magnitude = (u16_t)-header_size_increment;
 8045ba4:	b2a2      	uxth	r2, r4
 8045ba6:	4252      	negs	r2, r2
 8045ba8:	b292      	uxth	r2, r2
    LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
 8045baa:	896b      	ldrh	r3, [r5, #10]
 8045bac:	4293      	cmp	r3, r2
 8045bae:	d2df      	bcs.n	8045b70 <pbuf_header_impl+0x18>
 8045bb0:	4b18      	ldr	r3, [pc, #96]	; (8045c14 <pbuf_header_impl+0xbc>)
 8045bb2:	f240 2247 	movw	r2, #583	; 0x247
 8045bb6:	491a      	ldr	r1, [pc, #104]	; (8045c20 <pbuf_header_impl+0xc8>)
 8045bb8:	4818      	ldr	r0, [pc, #96]	; (8045c1c <pbuf_header_impl+0xc4>)
 8045bba:	f00b ff45 	bl	8051a48 <printf>
 8045bbe:	2001      	movs	r0, #1
 8045bc0:	e021      	b.n	8045c06 <pbuf_header_impl+0xae>
    p->payload = (u8_t *)p->payload - header_size_increment;
 8045bc2:	1b0b      	subs	r3, r1, r4
 8045bc4:	606b      	str	r3, [r5, #4]
    if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
 8045bc6:	f105 0210 	add.w	r2, r5, #16
 8045bca:	4293      	cmp	r3, r2
 8045bcc:	d308      	bcc.n	8045be0 <pbuf_header_impl+0x88>
    /* Unknown type */
    LWIP_ASSERT("bad pbuf type", 0);
    return 1;
  }
  /* modify pbuf length fields */
  p->len += header_size_increment;
 8045bce:	b2a4      	uxth	r4, r4
 8045bd0:	896b      	ldrh	r3, [r5, #10]
 8045bd2:	4423      	add	r3, r4
 8045bd4:	816b      	strh	r3, [r5, #10]
  p->tot_len += header_size_increment;
 8045bd6:	8929      	ldrh	r1, [r5, #8]
 8045bd8:	440c      	add	r4, r1
 8045bda:	812c      	strh	r4, [r5, #8]

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_header: old %p new %p (%"S16_F")\n",
    (void *)payload, (void *)p->payload, header_size_increment));

  return 0;
 8045bdc:	2000      	movs	r0, #0
 8045bde:	e012      	b.n	8045c06 <pbuf_header_impl+0xae>
      p->payload = payload;
 8045be0:	6069      	str	r1, [r5, #4]
      return 1;
 8045be2:	2001      	movs	r0, #1
 8045be4:	e00f      	b.n	8045c06 <pbuf_header_impl+0xae>
    if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
 8045be6:	896b      	ldrh	r3, [r5, #10]
 8045be8:	4293      	cmp	r3, r2
 8045bea:	d3cc      	bcc.n	8045b86 <pbuf_header_impl+0x2e>
      p->payload = (u8_t *)p->payload - header_size_increment;
 8045bec:	1b09      	subs	r1, r1, r4
 8045bee:	6069      	str	r1, [r5, #4]
 8045bf0:	e7ed      	b.n	8045bce <pbuf_header_impl+0x76>
    LWIP_ASSERT("bad pbuf type", 0);
 8045bf2:	4b08      	ldr	r3, [pc, #32]	; (8045c14 <pbuf_header_impl+0xbc>)
 8045bf4:	f240 2277 	movw	r2, #631	; 0x277
 8045bf8:	490a      	ldr	r1, [pc, #40]	; (8045c24 <pbuf_header_impl+0xcc>)
 8045bfa:	4808      	ldr	r0, [pc, #32]	; (8045c1c <pbuf_header_impl+0xc4>)
 8045bfc:	f00b ff24 	bl	8051a48 <printf>
    return 1;
 8045c00:	2001      	movs	r0, #1
 8045c02:	e000      	b.n	8045c06 <pbuf_header_impl+0xae>
    return 0;
 8045c04:	2000      	movs	r0, #0
}
 8045c06:	bd70      	pop	{r4, r5, r6, pc}
    return 0;
 8045c08:	2000      	movs	r0, #0
 8045c0a:	e7fc      	b.n	8045c06 <pbuf_header_impl+0xae>
      return 1;
 8045c0c:	2001      	movs	r0, #1
 8045c0e:	e7fa      	b.n	8045c06 <pbuf_header_impl+0xae>
 8045c10:	2001      	movs	r0, #1
 8045c12:	e7f8      	b.n	8045c06 <pbuf_header_impl+0xae>
 8045c14:	08059190 	.word	0x08059190
 8045c18:	080591c0 	.word	0x080591c0
 8045c1c:	08058ecc 	.word	0x08058ecc
 8045c20:	080591cc 	.word	0x080591cc
 8045c24:	080591ec 	.word	0x080591ec

08045c28 <pbuf_free_ooseq>:
{
 8045c28:	b510      	push	{r4, lr}
  SYS_ARCH_SET(pbuf_free_ooseq_pending, 0);
 8045c2a:	4b07      	ldr	r3, [pc, #28]	; (8045c48 <pbuf_free_ooseq+0x20>)
 8045c2c:	2200      	movs	r2, #0
 8045c2e:	701a      	strb	r2, [r3, #0]
  for (pcb = tcp_active_pcbs; NULL != pcb; pcb = pcb->next) {
 8045c30:	4b06      	ldr	r3, [pc, #24]	; (8045c4c <pbuf_free_ooseq+0x24>)
 8045c32:	681c      	ldr	r4, [r3, #0]
 8045c34:	b13c      	cbz	r4, 8045c46 <pbuf_free_ooseq+0x1e>
    if (NULL != pcb->ooseq) {
 8045c36:	6f20      	ldr	r0, [r4, #112]	; 0x70
 8045c38:	b908      	cbnz	r0, 8045c3e <pbuf_free_ooseq+0x16>
  for (pcb = tcp_active_pcbs; NULL != pcb; pcb = pcb->next) {
 8045c3a:	68e4      	ldr	r4, [r4, #12]
 8045c3c:	e7fa      	b.n	8045c34 <pbuf_free_ooseq+0xc>
      tcp_segs_free(pcb->ooseq);
 8045c3e:	f000 fd3e 	bl	80466be <tcp_segs_free>
      pcb->ooseq = NULL;
 8045c42:	2300      	movs	r3, #0
 8045c44:	6723      	str	r3, [r4, #112]	; 0x70
}
 8045c46:	bd10      	pop	{r4, pc}
 8045c48:	20008718 	.word	0x20008718
 8045c4c:	20008720 	.word	0x20008720

08045c50 <pbuf_alloced_custom>:
{
 8045c50:	b570      	push	{r4, r5, r6, lr}
 8045c52:	9c04      	ldr	r4, [sp, #16]
  switch (l) {
 8045c54:	2804      	cmp	r0, #4
 8045c56:	d80a      	bhi.n	8045c6e <pbuf_alloced_custom+0x1e>
 8045c58:	e8df f000 	tbb	[pc, r0]
 8045c5c:	05032912 	.word	0x05032912
 8045c60:	07          	.byte	0x07
 8045c61:	00          	.byte	0x00
    offset = PBUF_LINK_ENCAPSULATION_HLEN + PBUF_LINK_HLEN;
 8045c62:	200e      	movs	r0, #14
    break;
 8045c64:	e00d      	b.n	8045c82 <pbuf_alloced_custom+0x32>
    offset = PBUF_LINK_ENCAPSULATION_HLEN;
 8045c66:	2000      	movs	r0, #0
    break;
 8045c68:	e00b      	b.n	8045c82 <pbuf_alloced_custom+0x32>
    offset = 0;
 8045c6a:	2000      	movs	r0, #0
    break;
 8045c6c:	e009      	b.n	8045c82 <pbuf_alloced_custom+0x32>
    LWIP_ASSERT("pbuf_alloced_custom: bad pbuf layer", 0);
 8045c6e:	4b13      	ldr	r3, [pc, #76]	; (8045cbc <pbuf_alloced_custom+0x6c>)
 8045c70:	f240 12c5 	movw	r2, #453	; 0x1c5
 8045c74:	4912      	ldr	r1, [pc, #72]	; (8045cc0 <pbuf_alloced_custom+0x70>)
 8045c76:	4813      	ldr	r0, [pc, #76]	; (8045cc4 <pbuf_alloced_custom+0x74>)
 8045c78:	f00b fee6 	bl	8051a48 <printf>
    return NULL;
 8045c7c:	2000      	movs	r0, #0
 8045c7e:	e015      	b.n	8045cac <pbuf_alloced_custom+0x5c>
    offset = PBUF_LINK_ENCAPSULATION_HLEN;
 8045c80:	2036      	movs	r0, #54	; 0x36
  if (LWIP_MEM_ALIGN_SIZE(offset) + length > payload_mem_len) {
 8045c82:	3003      	adds	r0, #3
 8045c84:	f020 0003 	bic.w	r0, r0, #3
 8045c88:	180e      	adds	r6, r1, r0
 8045c8a:	f8bd 5014 	ldrh.w	r5, [sp, #20]
 8045c8e:	42ae      	cmp	r6, r5
 8045c90:	d812      	bhi.n	8045cb8 <pbuf_alloced_custom+0x68>
  p->pbuf.next = NULL;
 8045c92:	2500      	movs	r5, #0
 8045c94:	601d      	str	r5, [r3, #0]
  if (payload_mem != NULL) {
 8045c96:	b164      	cbz	r4, 8045cb2 <pbuf_alloced_custom+0x62>
    p->pbuf.payload = (u8_t *)payload_mem + LWIP_MEM_ALIGN_SIZE(offset);
 8045c98:	4420      	add	r0, r4
 8045c9a:	6058      	str	r0, [r3, #4]
  p->pbuf.flags = PBUF_FLAG_IS_CUSTOM;
 8045c9c:	2002      	movs	r0, #2
 8045c9e:	7358      	strb	r0, [r3, #13]
  p->pbuf.len = p->pbuf.tot_len = length;
 8045ca0:	8119      	strh	r1, [r3, #8]
 8045ca2:	8159      	strh	r1, [r3, #10]
  p->pbuf.type = type;
 8045ca4:	731a      	strb	r2, [r3, #12]
  p->pbuf.ref = 1;
 8045ca6:	2201      	movs	r2, #1
 8045ca8:	81da      	strh	r2, [r3, #14]
  return &p->pbuf;
 8045caa:	4618      	mov	r0, r3
}
 8045cac:	bd70      	pop	{r4, r5, r6, pc}
    offset = PBUF_LINK_ENCAPSULATION_HLEN + PBUF_LINK_HLEN + PBUF_IP_HLEN;
 8045cae:	2022      	movs	r0, #34	; 0x22
 8045cb0:	e7e7      	b.n	8045c82 <pbuf_alloced_custom+0x32>
    p->pbuf.payload = NULL;
 8045cb2:	2000      	movs	r0, #0
 8045cb4:	6058      	str	r0, [r3, #4]
 8045cb6:	e7f1      	b.n	8045c9c <pbuf_alloced_custom+0x4c>
    return NULL;
 8045cb8:	2000      	movs	r0, #0
 8045cba:	e7f7      	b.n	8045cac <pbuf_alloced_custom+0x5c>
 8045cbc:	08059190 	.word	0x08059190
 8045cc0:	080591fc 	.word	0x080591fc
 8045cc4:	08058ecc 	.word	0x08058ecc

08045cc8 <pbuf_header>:
 * @return non-zero on failure, zero on success.
 *
 */
u8_t
pbuf_header(struct pbuf *p, s16_t header_size_increment)
{
 8045cc8:	b508      	push	{r3, lr}
   return pbuf_header_impl(p, header_size_increment, 0);
 8045cca:	2200      	movs	r2, #0
 8045ccc:	f7ff ff44 	bl	8045b58 <pbuf_header_impl>
}
 8045cd0:	bd08      	pop	{r3, pc}

08045cd2 <pbuf_header_force>:
 * Same as pbuf_header but does not check if 'header_size > 0' is allowed.
 * This is used internally only, to allow PBUF_REF for RX.
 */
u8_t
pbuf_header_force(struct pbuf *p, s16_t header_size_increment)
{
 8045cd2:	b508      	push	{r3, lr}
   return pbuf_header_impl(p, header_size_increment, 1);
 8045cd4:	2201      	movs	r2, #1
 8045cd6:	f7ff ff3f 	bl	8045b58 <pbuf_header_impl>
}
 8045cda:	bd08      	pop	{r3, pc}

08045cdc <pbuf_free>:
 * 1->1->1 becomes .......
 *
 */
u8_t
pbuf_free(struct pbuf *p)
{
 8045cdc:	b570      	push	{r4, r5, r6, lr}
  u16_t type;
  struct pbuf *q;
  u8_t count;

  if (p == NULL) {
 8045cde:	b128      	cbz	r0, 8045cec <pbuf_free+0x10>
 8045ce0:	4604      	mov	r4, r0
  }
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free(%p)\n", (void *)p));

  PERF_START;

  LWIP_ASSERT("pbuf_free: sane type",
 8045ce2:	7b03      	ldrb	r3, [r0, #12]
 8045ce4:	2b03      	cmp	r3, #3
 8045ce6:	d80b      	bhi.n	8045d00 <pbuf_free+0x24>
{
 8045ce8:	2500      	movs	r5, #0
 8045cea:	e01f      	b.n	8045d2c <pbuf_free+0x50>
    LWIP_ASSERT("p != NULL", p != NULL);
 8045cec:	4b27      	ldr	r3, [pc, #156]	; (8045d8c <pbuf_free+0xb0>)
 8045cee:	f240 22d2 	movw	r2, #722	; 0x2d2
 8045cf2:	4927      	ldr	r1, [pc, #156]	; (8045d90 <pbuf_free+0xb4>)
 8045cf4:	4827      	ldr	r0, [pc, #156]	; (8045d94 <pbuf_free+0xb8>)
 8045cf6:	f00b fea7 	bl	8051a48 <printf>
    return 0;
 8045cfa:	2500      	movs	r5, #0
    }
  }
  PERF_STOP("pbuf_free");
  /* return number of de-allocated pbufs */
  return count;
}
 8045cfc:	4628      	mov	r0, r5
 8045cfe:	bd70      	pop	{r4, r5, r6, pc}
  LWIP_ASSERT("pbuf_free: sane type",
 8045d00:	4b22      	ldr	r3, [pc, #136]	; (8045d8c <pbuf_free+0xb0>)
 8045d02:	f44f 7237 	mov.w	r2, #732	; 0x2dc
 8045d06:	4924      	ldr	r1, [pc, #144]	; (8045d98 <pbuf_free+0xbc>)
 8045d08:	4822      	ldr	r0, [pc, #136]	; (8045d94 <pbuf_free+0xb8>)
 8045d0a:	f00b fe9d 	bl	8051a48 <printf>
 8045d0e:	e7eb      	b.n	8045ce8 <pbuf_free+0xc>
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
 8045d10:	4b1e      	ldr	r3, [pc, #120]	; (8045d8c <pbuf_free+0xb0>)
 8045d12:	f240 22eb 	movw	r2, #747	; 0x2eb
 8045d16:	4921      	ldr	r1, [pc, #132]	; (8045d9c <pbuf_free+0xc0>)
 8045d18:	481e      	ldr	r0, [pc, #120]	; (8045d94 <pbuf_free+0xb8>)
 8045d1a:	f00b fe95 	bl	8051a48 <printf>
 8045d1e:	e00a      	b.n	8045d36 <pbuf_free+0x5a>
        pc->custom_free_function(p);
 8045d20:	6923      	ldr	r3, [r4, #16]
 8045d22:	4620      	mov	r0, r4
 8045d24:	4798      	blx	r3
      count++;
 8045d26:	3501      	adds	r5, #1
 8045d28:	b2ed      	uxtb	r5, r5
      p = q;
 8045d2a:	4634      	mov	r4, r6
  while (p != NULL) {
 8045d2c:	2c00      	cmp	r4, #0
 8045d2e:	d0e5      	beq.n	8045cfc <pbuf_free+0x20>
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
 8045d30:	89e3      	ldrh	r3, [r4, #14]
 8045d32:	2b00      	cmp	r3, #0
 8045d34:	d0ec      	beq.n	8045d10 <pbuf_free+0x34>
    ref = --(p->ref);
 8045d36:	89e3      	ldrh	r3, [r4, #14]
 8045d38:	3b01      	subs	r3, #1
 8045d3a:	b29b      	uxth	r3, r3
 8045d3c:	81e3      	strh	r3, [r4, #14]
    if (ref == 0) {
 8045d3e:	2b00      	cmp	r3, #0
 8045d40:	d1dc      	bne.n	8045cfc <pbuf_free+0x20>
      q = p->next;
 8045d42:	6826      	ldr	r6, [r4, #0]
      type = p->type;
 8045d44:	7b23      	ldrb	r3, [r4, #12]
      if ((p->flags & PBUF_FLAG_IS_CUSTOM) != 0) {
 8045d46:	7b62      	ldrb	r2, [r4, #13]
 8045d48:	f012 0f02 	tst.w	r2, #2
 8045d4c:	d00a      	beq.n	8045d64 <pbuf_free+0x88>
        LWIP_ASSERT("pc->custom_free_function != NULL", pc->custom_free_function != NULL);
 8045d4e:	6923      	ldr	r3, [r4, #16]
 8045d50:	2b00      	cmp	r3, #0
 8045d52:	d1e5      	bne.n	8045d20 <pbuf_free+0x44>
 8045d54:	4b0d      	ldr	r3, [pc, #52]	; (8045d8c <pbuf_free+0xb0>)
 8045d56:	f240 22f9 	movw	r2, #761	; 0x2f9
 8045d5a:	4911      	ldr	r1, [pc, #68]	; (8045da0 <pbuf_free+0xc4>)
 8045d5c:	480d      	ldr	r0, [pc, #52]	; (8045d94 <pbuf_free+0xb8>)
 8045d5e:	f00b fe73 	bl	8051a48 <printf>
 8045d62:	e7dd      	b.n	8045d20 <pbuf_free+0x44>
        if (type == PBUF_POOL) {
 8045d64:	2b03      	cmp	r3, #3
 8045d66:	d007      	beq.n	8045d78 <pbuf_free+0x9c>
        } else if (type == PBUF_ROM || type == PBUF_REF) {
 8045d68:	3b01      	subs	r3, #1
 8045d6a:	b29b      	uxth	r3, r3
 8045d6c:	2b01      	cmp	r3, #1
 8045d6e:	d908      	bls.n	8045d82 <pbuf_free+0xa6>
          mem_free(p);
 8045d70:	4620      	mov	r0, r4
 8045d72:	f7ff fc23 	bl	80455bc <mem_free>
 8045d76:	e7d6      	b.n	8045d26 <pbuf_free+0x4a>
          memp_free(MEMP_PBUF_POOL, p);
 8045d78:	4621      	mov	r1, r4
 8045d7a:	2008      	movs	r0, #8
 8045d7c:	f7ff fdfa 	bl	8045974 <memp_free>
 8045d80:	e7d1      	b.n	8045d26 <pbuf_free+0x4a>
          memp_free(MEMP_PBUF, p);
 8045d82:	4621      	mov	r1, r4
 8045d84:	2007      	movs	r0, #7
 8045d86:	f7ff fdf5 	bl	8045974 <memp_free>
 8045d8a:	e7cc      	b.n	8045d26 <pbuf_free+0x4a>
 8045d8c:	08059190 	.word	0x08059190
 8045d90:	080591c0 	.word	0x080591c0
 8045d94:	08058ecc 	.word	0x08058ecc
 8045d98:	08059220 	.word	0x08059220
 8045d9c:	08059238 	.word	0x08059238
 8045da0:	08059250 	.word	0x08059250

08045da4 <pbuf_alloc>:
{
 8045da4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8045da8:	460d      	mov	r5, r1
 8045daa:	4617      	mov	r7, r2
  switch (layer) {
 8045dac:	2804      	cmp	r0, #4
 8045dae:	d80a      	bhi.n	8045dc6 <pbuf_alloc+0x22>
 8045db0:	e8df f000 	tbb	[pc, r0]
 8045db4:	05033f12 	.word	0x05033f12
 8045db8:	07          	.byte	0x07
 8045db9:	00          	.byte	0x00
    offset = PBUF_LINK_ENCAPSULATION_HLEN + PBUF_LINK_HLEN;
 8045dba:	240e      	movs	r4, #14
    break;
 8045dbc:	e00d      	b.n	8045dda <pbuf_alloc+0x36>
    offset = PBUF_LINK_ENCAPSULATION_HLEN;
 8045dbe:	2400      	movs	r4, #0
    break;
 8045dc0:	e00b      	b.n	8045dda <pbuf_alloc+0x36>
    offset = 0;
 8045dc2:	2400      	movs	r4, #0
    break;
 8045dc4:	e009      	b.n	8045dda <pbuf_alloc+0x36>
    LWIP_ASSERT("pbuf_alloc: bad pbuf layer", 0);
 8045dc6:	4b68      	ldr	r3, [pc, #416]	; (8045f68 <pbuf_alloc+0x1c4>)
 8045dc8:	f44f 728b 	mov.w	r2, #278	; 0x116
 8045dcc:	4967      	ldr	r1, [pc, #412]	; (8045f6c <pbuf_alloc+0x1c8>)
 8045dce:	4868      	ldr	r0, [pc, #416]	; (8045f70 <pbuf_alloc+0x1cc>)
 8045dd0:	f00b fe3a 	bl	8051a48 <printf>
    return NULL;
 8045dd4:	2600      	movs	r6, #0
 8045dd6:	e0b9      	b.n	8045f4c <pbuf_alloc+0x1a8>
    offset = PBUF_LINK_ENCAPSULATION_HLEN;
 8045dd8:	2436      	movs	r4, #54	; 0x36
  switch (type) {
 8045dda:	2f02      	cmp	r7, #2
 8045ddc:	d82b      	bhi.n	8045e36 <pbuf_alloc+0x92>
 8045dde:	b27b      	sxtb	r3, r7
 8045de0:	2b00      	cmp	r3, #0
 8045de2:	f040 80a4 	bne.w	8045f2e <pbuf_alloc+0x18a>
 8045de6:	2f00      	cmp	r7, #0
 8045de8:	f040 80b3 	bne.w	8045f52 <pbuf_alloc+0x1ae>
      mem_size_t alloc_len = LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF + offset) + LWIP_MEM_ALIGN_SIZE(length);
 8045dec:	f104 0013 	add.w	r0, r4, #19
 8045df0:	f020 0003 	bic.w	r0, r0, #3
 8045df4:	b283      	uxth	r3, r0
 8045df6:	1cea      	adds	r2, r5, #3
 8045df8:	b290      	uxth	r0, r2
 8045dfa:	f020 0003 	bic.w	r0, r0, #3
 8045dfe:	4418      	add	r0, r3
 8045e00:	b280      	uxth	r0, r0
      if (alloc_len < LWIP_MEM_ALIGN_SIZE(length)) {
 8045e02:	f022 0203 	bic.w	r2, r2, #3
 8045e06:	4290      	cmp	r0, r2
 8045e08:	f0c0 80ac 	bcc.w	8045f64 <pbuf_alloc+0x1c0>
      p = (struct pbuf*)mem_malloc(alloc_len);
 8045e0c:	f7ff fcae 	bl	804576c <mem_malloc>
    if (p == NULL) {
 8045e10:	4606      	mov	r6, r0
 8045e12:	2800      	cmp	r0, #0
 8045e14:	f000 809a 	beq.w	8045f4c <pbuf_alloc+0x1a8>
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + SIZEOF_STRUCT_PBUF + offset));
 8045e18:	f104 0310 	add.w	r3, r4, #16
 8045e1c:	4403      	add	r3, r0
 8045e1e:	3303      	adds	r3, #3
 8045e20:	f023 0303 	bic.w	r3, r3, #3
 8045e24:	6043      	str	r3, [r0, #4]
    p->len = p->tot_len = length;
 8045e26:	8105      	strh	r5, [r0, #8]
 8045e28:	8145      	strh	r5, [r0, #10]
    p->next = NULL;
 8045e2a:	2300      	movs	r3, #0
 8045e2c:	6003      	str	r3, [r0, #0]
    p->type = type;
 8045e2e:	7307      	strb	r7, [r0, #12]
    LWIP_ASSERT("pbuf_alloc: pbuf->payload properly aligned",
 8045e30:	e088      	b.n	8045f44 <pbuf_alloc+0x1a0>
    offset = PBUF_LINK_ENCAPSULATION_HLEN + PBUF_LINK_HLEN + PBUF_IP_HLEN;
 8045e32:	2422      	movs	r4, #34	; 0x22
 8045e34:	e7d1      	b.n	8045dda <pbuf_alloc+0x36>
  switch (type) {
 8045e36:	2f03      	cmp	r7, #3
 8045e38:	f040 808b 	bne.w	8045f52 <pbuf_alloc+0x1ae>
    p = (struct pbuf *)memp_malloc(MEMP_PBUF_POOL);
 8045e3c:	2008      	movs	r0, #8
 8045e3e:	f7ff fd7f 	bl	8045940 <memp_malloc>
    if (p == NULL) {
 8045e42:	4606      	mov	r6, r0
 8045e44:	b1f8      	cbz	r0, 8045e86 <pbuf_alloc+0xe2>
    p->type = type;
 8045e46:	7307      	strb	r7, [r0, #12]
    p->next = NULL;
 8045e48:	2300      	movs	r3, #0
 8045e4a:	6003      	str	r3, [r0, #0]
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + (SIZEOF_STRUCT_PBUF + offset)));
 8045e4c:	f104 0310 	add.w	r3, r4, #16
 8045e50:	4403      	add	r3, r0
 8045e52:	3303      	adds	r3, #3
 8045e54:	f023 0303 	bic.w	r3, r3, #3
 8045e58:	6043      	str	r3, [r0, #4]
    p->tot_len = length;
 8045e5a:	8105      	strh	r5, [r0, #8]
    p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
 8045e5c:	1ce2      	adds	r2, r4, #3
 8045e5e:	f022 0203 	bic.w	r2, r2, #3
 8045e62:	f5c2 7214 	rsb	r2, r2, #592	; 0x250
 8045e66:	42aa      	cmp	r2, r5
 8045e68:	bf28      	it	cs
 8045e6a:	462a      	movcs	r2, r5
 8045e6c:	b292      	uxth	r2, r2
 8045e6e:	8142      	strh	r2, [r0, #10]
    LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
 8045e70:	4413      	add	r3, r2
 8045e72:	f500 7818 	add.w	r8, r0, #608	; 0x260
 8045e76:	4543      	cmp	r3, r8
 8045e78:	d808      	bhi.n	8045e8c <pbuf_alloc+0xe8>
    p->ref = 1;
 8045e7a:	2301      	movs	r3, #1
 8045e7c:	81f3      	strh	r3, [r6, #14]
    rem_len = length - p->len;
 8045e7e:	8971      	ldrh	r1, [r6, #10]
 8045e80:	1a6d      	subs	r5, r5, r1
    r = p;
 8045e82:	46b1      	mov	r9, r6
    while (rem_len > 0) {
 8045e84:	e02d      	b.n	8045ee2 <pbuf_alloc+0x13e>
      PBUF_POOL_IS_EMPTY();
 8045e86:	f7ff fe61 	bl	8045b4c <pbuf_pool_is_empty>
      return NULL;
 8045e8a:	e05f      	b.n	8045f4c <pbuf_alloc+0x1a8>
    LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
 8045e8c:	4b36      	ldr	r3, [pc, #216]	; (8045f68 <pbuf_alloc+0x1c4>)
 8045e8e:	f44f 7297 	mov.w	r2, #302	; 0x12e
 8045e92:	4938      	ldr	r1, [pc, #224]	; (8045f74 <pbuf_alloc+0x1d0>)
 8045e94:	4836      	ldr	r0, [pc, #216]	; (8045f70 <pbuf_alloc+0x1cc>)
 8045e96:	f00b fdd7 	bl	8051a48 <printf>
    LWIP_ASSERT("PBUF_POOL_BUFSIZE must be bigger than MEM_ALIGNMENT",
 8045e9a:	e7ee      	b.n	8045e7a <pbuf_alloc+0xd6>
        PBUF_POOL_IS_EMPTY();
 8045e9c:	f7ff fe56 	bl	8045b4c <pbuf_pool_is_empty>
        pbuf_free(p);
 8045ea0:	4630      	mov	r0, r6
 8045ea2:	f7ff ff1b 	bl	8045cdc <pbuf_free>
        return NULL;
 8045ea6:	4626      	mov	r6, r4
 8045ea8:	e050      	b.n	8045f4c <pbuf_alloc+0x1a8>
      LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
 8045eaa:	4b2f      	ldr	r3, [pc, #188]	; (8045f68 <pbuf_alloc+0x1c4>)
 8045eac:	f44f 72a6 	mov.w	r2, #332	; 0x14c
 8045eb0:	4931      	ldr	r1, [pc, #196]	; (8045f78 <pbuf_alloc+0x1d4>)
 8045eb2:	482f      	ldr	r0, [pc, #188]	; (8045f70 <pbuf_alloc+0x1cc>)
 8045eb4:	f00b fdc8 	bl	8051a48 <printf>
 8045eb8:	e025      	b.n	8045f06 <pbuf_alloc+0x162>
      LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
 8045eba:	4b2b      	ldr	r3, [pc, #172]	; (8045f68 <pbuf_alloc+0x1c4>)
 8045ebc:	f240 1251 	movw	r2, #337	; 0x151
 8045ec0:	492e      	ldr	r1, [pc, #184]	; (8045f7c <pbuf_alloc+0x1d8>)
 8045ec2:	482b      	ldr	r0, [pc, #172]	; (8045f70 <pbuf_alloc+0x1cc>)
 8045ec4:	f00b fdc0 	bl	8051a48 <printf>
 8045ec8:	e02b      	b.n	8045f22 <pbuf_alloc+0x17e>
      LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
 8045eca:	4b27      	ldr	r3, [pc, #156]	; (8045f68 <pbuf_alloc+0x1c4>)
 8045ecc:	f240 1253 	movw	r2, #339	; 0x153
 8045ed0:	4928      	ldr	r1, [pc, #160]	; (8045f74 <pbuf_alloc+0x1d0>)
 8045ed2:	4827      	ldr	r0, [pc, #156]	; (8045f70 <pbuf_alloc+0x1cc>)
 8045ed4:	f00b fdb8 	bl	8051a48 <printf>
      q->ref = 1;
 8045ed8:	2301      	movs	r3, #1
 8045eda:	81e3      	strh	r3, [r4, #14]
      rem_len -= q->len;
 8045edc:	8963      	ldrh	r3, [r4, #10]
 8045ede:	1aed      	subs	r5, r5, r3
      r = q;
 8045ee0:	46a1      	mov	r9, r4
    while (rem_len > 0) {
 8045ee2:	2d00      	cmp	r5, #0
 8045ee4:	dd2e      	ble.n	8045f44 <pbuf_alloc+0x1a0>
      q = (struct pbuf *)memp_malloc(MEMP_PBUF_POOL);
 8045ee6:	2008      	movs	r0, #8
 8045ee8:	f7ff fd2a 	bl	8045940 <memp_malloc>
      if (q == NULL) {
 8045eec:	4604      	mov	r4, r0
 8045eee:	2800      	cmp	r0, #0
 8045ef0:	d0d4      	beq.n	8045e9c <pbuf_alloc+0xf8>
      q->type = type;
 8045ef2:	7307      	strb	r7, [r0, #12]
      q->flags = 0;
 8045ef4:	2300      	movs	r3, #0
 8045ef6:	7343      	strb	r3, [r0, #13]
      q->next = NULL;
 8045ef8:	6003      	str	r3, [r0, #0]
      r->next = q;
 8045efa:	f8c9 0000 	str.w	r0, [r9]
      LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
 8045efe:	f64f 73fe 	movw	r3, #65534	; 0xfffe
 8045f02:	429d      	cmp	r5, r3
 8045f04:	dcd1      	bgt.n	8045eaa <pbuf_alloc+0x106>
      q->tot_len = (u16_t)rem_len;
 8045f06:	b2ab      	uxth	r3, r5
 8045f08:	8123      	strh	r3, [r4, #8]
      q->len = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
 8045f0a:	f5b3 7f14 	cmp.w	r3, #592	; 0x250
 8045f0e:	bf28      	it	cs
 8045f10:	f44f 7314 	movcs.w	r3, #592	; 0x250
 8045f14:	8163      	strh	r3, [r4, #10]
      q->payload = (void *)((u8_t *)q + SIZEOF_STRUCT_PBUF);
 8045f16:	f104 0310 	add.w	r3, r4, #16
 8045f1a:	6063      	str	r3, [r4, #4]
      LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
 8045f1c:	f013 0f03 	tst.w	r3, #3
 8045f20:	d1cb      	bne.n	8045eba <pbuf_alloc+0x116>
      LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
 8045f22:	6873      	ldr	r3, [r6, #4]
 8045f24:	8972      	ldrh	r2, [r6, #10]
 8045f26:	4413      	add	r3, r2
 8045f28:	4598      	cmp	r8, r3
 8045f2a:	d2d5      	bcs.n	8045ed8 <pbuf_alloc+0x134>
 8045f2c:	e7cd      	b.n	8045eca <pbuf_alloc+0x126>
    p = (struct pbuf *)memp_malloc(MEMP_PBUF);
 8045f2e:	2007      	movs	r0, #7
 8045f30:	f7ff fd06 	bl	8045940 <memp_malloc>
    if (p == NULL) {
 8045f34:	4606      	mov	r6, r0
 8045f36:	b148      	cbz	r0, 8045f4c <pbuf_alloc+0x1a8>
    p->payload = NULL;
 8045f38:	2300      	movs	r3, #0
 8045f3a:	6043      	str	r3, [r0, #4]
    p->len = p->tot_len = length;
 8045f3c:	8105      	strh	r5, [r0, #8]
 8045f3e:	8145      	strh	r5, [r0, #10]
    p->next = NULL;
 8045f40:	6003      	str	r3, [r0, #0]
    p->type = type;
 8045f42:	7307      	strb	r7, [r0, #12]
  p->ref = 1;
 8045f44:	2301      	movs	r3, #1
 8045f46:	81f3      	strh	r3, [r6, #14]
  p->flags = 0;
 8045f48:	2300      	movs	r3, #0
 8045f4a:	7373      	strb	r3, [r6, #13]
}
 8045f4c:	4630      	mov	r0, r6
 8045f4e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    LWIP_ASSERT("pbuf_alloc: erroneous type", 0);
 8045f52:	4b05      	ldr	r3, [pc, #20]	; (8045f68 <pbuf_alloc+0x1c4>)
 8045f54:	f44f 72c6 	mov.w	r2, #396	; 0x18c
 8045f58:	4909      	ldr	r1, [pc, #36]	; (8045f80 <pbuf_alloc+0x1dc>)
 8045f5a:	4805      	ldr	r0, [pc, #20]	; (8045f70 <pbuf_alloc+0x1cc>)
 8045f5c:	f00b fd74 	bl	8051a48 <printf>
    return NULL;
 8045f60:	2600      	movs	r6, #0
 8045f62:	e7f3      	b.n	8045f4c <pbuf_alloc+0x1a8>
        return NULL;
 8045f64:	2600      	movs	r6, #0
 8045f66:	e7f1      	b.n	8045f4c <pbuf_alloc+0x1a8>
 8045f68:	08059190 	.word	0x08059190
 8045f6c:	08059274 	.word	0x08059274
 8045f70:	08058ecc 	.word	0x08058ecc
 8045f74:	08059290 	.word	0x08059290
 8045f78:	080592f8 	.word	0x080592f8
 8045f7c:	0805930c 	.word	0x0805930c
 8045f80:	0805933c 	.word	0x0805933c

08045f84 <pbuf_realloc>:
{
 8045f84:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8045f88:	460e      	mov	r6, r1
  LWIP_ASSERT("pbuf_realloc: p != NULL", p != NULL);
 8045f8a:	4604      	mov	r4, r0
 8045f8c:	b170      	cbz	r0, 8045fac <pbuf_realloc+0x28>
  LWIP_ASSERT("pbuf_realloc: sane p->type", p->type == PBUF_POOL ||
 8045f8e:	7b23      	ldrb	r3, [r4, #12]
 8045f90:	2b03      	cmp	r3, #3
 8045f92:	d004      	beq.n	8045f9e <pbuf_realloc+0x1a>
 8045f94:	2b01      	cmp	r3, #1
 8045f96:	d002      	beq.n	8045f9e <pbuf_realloc+0x1a>
 8045f98:	b10b      	cbz	r3, 8045f9e <pbuf_realloc+0x1a>
 8045f9a:	2b02      	cmp	r3, #2
 8045f9c:	d10e      	bne.n	8045fbc <pbuf_realloc+0x38>
  if (new_len >= p->tot_len) {
 8045f9e:	8927      	ldrh	r7, [r4, #8]
 8045fa0:	42b7      	cmp	r7, r6
 8045fa2:	d943      	bls.n	804602c <pbuf_realloc+0xa8>
  grow = new_len - p->tot_len;
 8045fa4:	eba6 0807 	sub.w	r8, r6, r7
  rem_len = new_len;
 8045fa8:	4635      	mov	r5, r6
  while (rem_len > q->len) {
 8045faa:	e01d      	b.n	8045fe8 <pbuf_realloc+0x64>
  LWIP_ASSERT("pbuf_realloc: p != NULL", p != NULL);
 8045fac:	4b2a      	ldr	r3, [pc, #168]	; (8046058 <pbuf_realloc+0xd4>)
 8045fae:	f240 12f3 	movw	r2, #499	; 0x1f3
 8045fb2:	492a      	ldr	r1, [pc, #168]	; (804605c <pbuf_realloc+0xd8>)
 8045fb4:	482a      	ldr	r0, [pc, #168]	; (8046060 <pbuf_realloc+0xdc>)
 8045fb6:	f00b fd47 	bl	8051a48 <printf>
 8045fba:	e7e8      	b.n	8045f8e <pbuf_realloc+0xa>
  LWIP_ASSERT("pbuf_realloc: sane p->type", p->type == PBUF_POOL ||
 8045fbc:	4b26      	ldr	r3, [pc, #152]	; (8046058 <pbuf_realloc+0xd4>)
 8045fbe:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
 8045fc2:	4928      	ldr	r1, [pc, #160]	; (8046064 <pbuf_realloc+0xe0>)
 8045fc4:	4826      	ldr	r0, [pc, #152]	; (8046060 <pbuf_realloc+0xdc>)
 8045fc6:	f00b fd3f 	bl	8051a48 <printf>
 8045fca:	e7e8      	b.n	8045f9e <pbuf_realloc+0x1a>
    LWIP_ASSERT("grow < max_u16_t", grow < 0xffff);
 8045fcc:	4b22      	ldr	r3, [pc, #136]	; (8046058 <pbuf_realloc+0xd4>)
 8045fce:	f240 220b 	movw	r2, #523	; 0x20b
 8045fd2:	4925      	ldr	r1, [pc, #148]	; (8046068 <pbuf_realloc+0xe4>)
 8045fd4:	4822      	ldr	r0, [pc, #136]	; (8046060 <pbuf_realloc+0xdc>)
 8045fd6:	f00b fd37 	bl	8051a48 <printf>
    q->tot_len += (u16_t)grow;
 8045fda:	1bf3      	subs	r3, r6, r7
 8045fdc:	8922      	ldrh	r2, [r4, #8]
 8045fde:	fa12 f383 	uxtah	r3, r2, r3
 8045fe2:	8123      	strh	r3, [r4, #8]
    q = q->next;
 8045fe4:	6824      	ldr	r4, [r4, #0]
    LWIP_ASSERT("pbuf_realloc: q != NULL", q != NULL);
 8045fe6:	b14c      	cbz	r4, 8045ffc <pbuf_realloc+0x78>
  while (rem_len > q->len) {
 8045fe8:	8963      	ldrh	r3, [r4, #10]
 8045fea:	42ab      	cmp	r3, r5
 8045fec:	d20e      	bcs.n	804600c <pbuf_realloc+0x88>
    rem_len -= q->len;
 8045fee:	1aed      	subs	r5, r5, r3
 8045ff0:	b2ad      	uxth	r5, r5
    LWIP_ASSERT("grow < max_u16_t", grow < 0xffff);
 8045ff2:	f64f 73fe 	movw	r3, #65534	; 0xfffe
 8045ff6:	4598      	cmp	r8, r3
 8045ff8:	ddef      	ble.n	8045fda <pbuf_realloc+0x56>
 8045ffa:	e7e7      	b.n	8045fcc <pbuf_realloc+0x48>
    LWIP_ASSERT("pbuf_realloc: q != NULL", q != NULL);
 8045ffc:	4b16      	ldr	r3, [pc, #88]	; (8046058 <pbuf_realloc+0xd4>)
 8045ffe:	f240 220f 	movw	r2, #527	; 0x20f
 8046002:	491a      	ldr	r1, [pc, #104]	; (804606c <pbuf_realloc+0xe8>)
 8046004:	4816      	ldr	r0, [pc, #88]	; (8046060 <pbuf_realloc+0xdc>)
 8046006:	f00b fd1f 	bl	8051a48 <printf>
 804600a:	e7ed      	b.n	8045fe8 <pbuf_realloc+0x64>
  if ((q->type == PBUF_RAM) && (rem_len != q->len)
 804600c:	7b22      	ldrb	r2, [r4, #12]
 804600e:	b92a      	cbnz	r2, 804601c <pbuf_realloc+0x98>
 8046010:	42ab      	cmp	r3, r5
 8046012:	d003      	beq.n	804601c <pbuf_realloc+0x98>
      && ((q->flags & PBUF_FLAG_IS_CUSTOM) == 0)
 8046014:	7b63      	ldrb	r3, [r4, #13]
 8046016:	f013 0f02 	tst.w	r3, #2
 804601a:	d009      	beq.n	8046030 <pbuf_realloc+0xac>
  q->len = rem_len;
 804601c:	8165      	strh	r5, [r4, #10]
  q->tot_len = q->len;
 804601e:	8125      	strh	r5, [r4, #8]
  if (q->next != NULL) {
 8046020:	6820      	ldr	r0, [r4, #0]
 8046022:	b108      	cbz	r0, 8046028 <pbuf_realloc+0xa4>
    pbuf_free(q->next);
 8046024:	f7ff fe5a 	bl	8045cdc <pbuf_free>
  q->next = NULL;
 8046028:	2300      	movs	r3, #0
 804602a:	6023      	str	r3, [r4, #0]
}
 804602c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    q = (struct pbuf *)mem_trim(q, (u16_t)((u8_t *)q->payload - (u8_t *)q) + rem_len);
 8046030:	6863      	ldr	r3, [r4, #4]
 8046032:	1b1b      	subs	r3, r3, r4
 8046034:	fa15 f183 	uxtah	r1, r5, r3
 8046038:	b289      	uxth	r1, r1
 804603a:	4620      	mov	r0, r4
 804603c:	f7ff fb0c 	bl	8045658 <mem_trim>
    LWIP_ASSERT("mem_trim returned q == NULL", q != NULL);
 8046040:	4604      	mov	r4, r0
 8046042:	2800      	cmp	r0, #0
 8046044:	d1ea      	bne.n	804601c <pbuf_realloc+0x98>
 8046046:	4b04      	ldr	r3, [pc, #16]	; (8046058 <pbuf_realloc+0xd4>)
 8046048:	f240 221d 	movw	r2, #541	; 0x21d
 804604c:	4908      	ldr	r1, [pc, #32]	; (8046070 <pbuf_realloc+0xec>)
 804604e:	4804      	ldr	r0, [pc, #16]	; (8046060 <pbuf_realloc+0xdc>)
 8046050:	f00b fcfa 	bl	8051a48 <printf>
 8046054:	e7e2      	b.n	804601c <pbuf_realloc+0x98>
 8046056:	bf00      	nop
 8046058:	08059190 	.word	0x08059190
 804605c:	08059358 	.word	0x08059358
 8046060:	08058ecc 	.word	0x08058ecc
 8046064:	08059370 	.word	0x08059370
 8046068:	0805938c 	.word	0x0805938c
 804606c:	080593a0 	.word	0x080593a0
 8046070:	080593b8 	.word	0x080593b8

08046074 <pbuf_clen>:
 * @param p first pbuf of chain
 * @return the number of pbufs in a chain
 */
u16_t
pbuf_clen(const struct pbuf *p)
{
 8046074:	4603      	mov	r3, r0
  u16_t len;

  len = 0;
 8046076:	2000      	movs	r0, #0
  while (p != NULL) {
 8046078:	b11b      	cbz	r3, 8046082 <pbuf_clen+0xe>
    ++len;
 804607a:	3001      	adds	r0, #1
 804607c:	b280      	uxth	r0, r0
    p = p->next;
 804607e:	681b      	ldr	r3, [r3, #0]
 8046080:	e7fa      	b.n	8046078 <pbuf_clen+0x4>
  }
  return len;
}
 8046082:	4770      	bx	lr

08046084 <pbuf_ref>:
 */
void
pbuf_ref(struct pbuf *p)
{
  /* pbuf given? */
  if (p != NULL) {
 8046084:	b170      	cbz	r0, 80460a4 <pbuf_ref+0x20>
{
 8046086:	b508      	push	{r3, lr}
    SYS_ARCH_INC(p->ref, 1);
 8046088:	89c3      	ldrh	r3, [r0, #14]
 804608a:	3301      	adds	r3, #1
 804608c:	b29b      	uxth	r3, r3
 804608e:	81c3      	strh	r3, [r0, #14]
    LWIP_ASSERT("pbuf ref overflow", p->ref > 0);
 8046090:	b103      	cbz	r3, 8046094 <pbuf_ref+0x10>
  }
}
 8046092:	bd08      	pop	{r3, pc}
    LWIP_ASSERT("pbuf ref overflow", p->ref > 0);
 8046094:	4b04      	ldr	r3, [pc, #16]	; (80460a8 <pbuf_ref+0x24>)
 8046096:	f240 3239 	movw	r2, #825	; 0x339
 804609a:	4904      	ldr	r1, [pc, #16]	; (80460ac <pbuf_ref+0x28>)
 804609c:	4804      	ldr	r0, [pc, #16]	; (80460b0 <pbuf_ref+0x2c>)
 804609e:	f00b fcd3 	bl	8051a48 <printf>
}
 80460a2:	e7f6      	b.n	8046092 <pbuf_ref+0xe>
 80460a4:	4770      	bx	lr
 80460a6:	bf00      	nop
 80460a8:	08059190 	.word	0x08059190
 80460ac:	080593d4 	.word	0x080593d4
 80460b0:	08058ecc 	.word	0x08058ecc

080460b4 <pbuf_cat>:
 *
 * @see pbuf_chain()
 */
void
pbuf_cat(struct pbuf *h, struct pbuf *t)
{
 80460b4:	b538      	push	{r3, r4, r5, lr}
  struct pbuf *p;

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
 80460b6:	b110      	cbz	r0, 80460be <pbuf_cat+0xa>
 80460b8:	460d      	mov	r5, r1
 80460ba:	4604      	mov	r4, r0
 80460bc:	b961      	cbnz	r1, 80460d8 <pbuf_cat+0x24>
 80460be:	4b15      	ldr	r3, [pc, #84]	; (8046114 <pbuf_cat+0x60>)
 80460c0:	f44f 7253 	mov.w	r2, #844	; 0x34c
 80460c4:	4914      	ldr	r1, [pc, #80]	; (8046118 <pbuf_cat+0x64>)
 80460c6:	4815      	ldr	r0, [pc, #84]	; (804611c <pbuf_cat+0x68>)
 80460c8:	f00b fcbe 	bl	8051a48 <printf>
 80460cc:	e019      	b.n	8046102 <pbuf_cat+0x4e>
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
    /* add total length of second chain to all totals of first chain */
    p->tot_len += t->tot_len;
 80460ce:	892b      	ldrh	r3, [r5, #8]
 80460d0:	8920      	ldrh	r0, [r4, #8]
 80460d2:	4403      	add	r3, r0
 80460d4:	8123      	strh	r3, [r4, #8]
  for (p = h; p->next != NULL; p = p->next) {
 80460d6:	4614      	mov	r4, r2
 80460d8:	6822      	ldr	r2, [r4, #0]
 80460da:	2a00      	cmp	r2, #0
 80460dc:	d1f7      	bne.n	80460ce <pbuf_cat+0x1a>
  }
  /* { p is last pbuf of first h chain, p->next == NULL } */
  LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
 80460de:	8922      	ldrh	r2, [r4, #8]
 80460e0:	8963      	ldrh	r3, [r4, #10]
 80460e2:	429a      	cmp	r2, r3
 80460e4:	d10e      	bne.n	8046104 <pbuf_cat+0x50>
  LWIP_ASSERT("p->next == NULL", p->next == NULL);
 80460e6:	6823      	ldr	r3, [r4, #0]
 80460e8:	b133      	cbz	r3, 80460f8 <pbuf_cat+0x44>
 80460ea:	4b0a      	ldr	r3, [pc, #40]	; (8046114 <pbuf_cat+0x60>)
 80460ec:	f240 3256 	movw	r2, #854	; 0x356
 80460f0:	490b      	ldr	r1, [pc, #44]	; (8046120 <pbuf_cat+0x6c>)
 80460f2:	480a      	ldr	r0, [pc, #40]	; (804611c <pbuf_cat+0x68>)
 80460f4:	f00b fca8 	bl	8051a48 <printf>
  /* add total length of second chain to last pbuf total of first chain */
  p->tot_len += t->tot_len;
 80460f8:	892b      	ldrh	r3, [r5, #8]
 80460fa:	8922      	ldrh	r2, [r4, #8]
 80460fc:	4413      	add	r3, r2
 80460fe:	8123      	strh	r3, [r4, #8]
  /* chain last pbuf of head (p) with first of tail (t) */
  p->next = t;
 8046100:	6025      	str	r5, [r4, #0]
  /* p->next now references t, but the caller will drop its reference to t,
   * so netto there is no change to the reference count of t.
   */
}
 8046102:	bd38      	pop	{r3, r4, r5, pc}
  LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
 8046104:	4b03      	ldr	r3, [pc, #12]	; (8046114 <pbuf_cat+0x60>)
 8046106:	f240 3255 	movw	r2, #853	; 0x355
 804610a:	4906      	ldr	r1, [pc, #24]	; (8046124 <pbuf_cat+0x70>)
 804610c:	4803      	ldr	r0, [pc, #12]	; (804611c <pbuf_cat+0x68>)
 804610e:	f00b fc9b 	bl	8051a48 <printf>
 8046112:	e7e8      	b.n	80460e6 <pbuf_cat+0x32>
 8046114:	08059190 	.word	0x08059190
 8046118:	080593e8 	.word	0x080593e8
 804611c:	08058ecc 	.word	0x08058ecc
 8046120:	08059450 	.word	0x08059450
 8046124:	08059420 	.word	0x08059420

08046128 <pbuf_copy>:
 *         ERR_ARG if one of the pbufs is NULL or p_to is not big
 *                 enough to hold p_from
 */
err_t
pbuf_copy(struct pbuf *p_to, const struct pbuf *p_from)
{
 8046128:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy(%p, %p)\n",
    (const void*)p_to, (const void*)p_from));

  /* is the target big enough to hold the source? */
  LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
 804612c:	b150      	cbz	r0, 8046144 <pbuf_copy+0x1c>
 804612e:	460d      	mov	r5, r1
 8046130:	4607      	mov	r7, r0
 8046132:	b139      	cbz	r1, 8046144 <pbuf_copy+0x1c>
 8046134:	8902      	ldrh	r2, [r0, #8]
 8046136:	890b      	ldrh	r3, [r1, #8]
 8046138:	429a      	cmp	r2, r3
 804613a:	d303      	bcc.n	8046144 <pbuf_copy+0x1c>
  u16_t offset_to=0, offset_from=0, len;
 804613c:	f04f 0800 	mov.w	r8, #0
 8046140:	4646      	mov	r6, r8
 8046142:	e03c      	b.n	80461be <pbuf_copy+0x96>
  LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
 8046144:	4b3d      	ldr	r3, [pc, #244]	; (804623c <pbuf_copy+0x114>)
 8046146:	f44f 726f 	mov.w	r2, #956	; 0x3bc
 804614a:	493d      	ldr	r1, [pc, #244]	; (8046240 <pbuf_copy+0x118>)
 804614c:	483d      	ldr	r0, [pc, #244]	; (8046244 <pbuf_copy+0x11c>)
 804614e:	f00b fc7b 	bl	8051a48 <printf>
 8046152:	f06f 000f 	mvn.w	r0, #15
 8046156:	e06e      	b.n	8046236 <pbuf_copy+0x10e>
    if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
      /* complete current p_from fits into current p_to */
      len = p_from->len - offset_from;
    } else {
      /* current p_from does not fit into current p_to */
      len = p_to->len - offset_to;
 8046158:	1b9b      	subs	r3, r3, r6
 804615a:	b29c      	uxth	r4, r3
 804615c:	e037      	b.n	80461ce <pbuf_copy+0xa6>
    }
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
    offset_to += len;
    offset_from += len;
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
 804615e:	4b37      	ldr	r3, [pc, #220]	; (804623c <pbuf_copy+0x114>)
 8046160:	f240 32cd 	movw	r2, #973	; 0x3cd
 8046164:	4938      	ldr	r1, [pc, #224]	; (8046248 <pbuf_copy+0x120>)
 8046166:	4837      	ldr	r0, [pc, #220]	; (8046244 <pbuf_copy+0x11c>)
 8046168:	f00b fc6e 	bl	8051a48 <printf>
 804616c:	e03e      	b.n	80461ec <pbuf_copy+0xc4>
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
 804616e:	4b33      	ldr	r3, [pc, #204]	; (804623c <pbuf_copy+0x114>)
 8046170:	f240 32ce 	movw	r2, #974	; 0x3ce
 8046174:	4935      	ldr	r1, [pc, #212]	; (804624c <pbuf_copy+0x124>)
 8046176:	4833      	ldr	r0, [pc, #204]	; (8046244 <pbuf_copy+0x11c>)
 8046178:	f00b fc66 	bl	8051a48 <printf>
 804617c:	e039      	b.n	80461f2 <pbuf_copy+0xca>
      p_from = p_from->next;
    }
    if (offset_to == p_to->len) {
      /* on to next p_to (if any) */
      offset_to = 0;
      p_to = p_to->next;
 804617e:	683f      	ldr	r7, [r7, #0]
      LWIP_ERROR("p_to != NULL", (p_to != NULL) || (p_from == NULL) , return ERR_ARG;);
 8046180:	b10f      	cbz	r7, 8046186 <pbuf_copy+0x5e>
      offset_to = 0;
 8046182:	2600      	movs	r6, #0
 8046184:	e03e      	b.n	8046204 <pbuf_copy+0xdc>
      LWIP_ERROR("p_to != NULL", (p_to != NULL) || (p_from == NULL) , return ERR_ARG;);
 8046186:	b90d      	cbnz	r5, 804618c <pbuf_copy+0x64>
      offset_to = 0;
 8046188:	2600      	movs	r6, #0
 804618a:	e03b      	b.n	8046204 <pbuf_copy+0xdc>
      LWIP_ERROR("p_to != NULL", (p_to != NULL) || (p_from == NULL) , return ERR_ARG;);
 804618c:	4b2b      	ldr	r3, [pc, #172]	; (804623c <pbuf_copy+0x114>)
 804618e:	f44f 7276 	mov.w	r2, #984	; 0x3d8
 8046192:	492f      	ldr	r1, [pc, #188]	; (8046250 <pbuf_copy+0x128>)
 8046194:	482b      	ldr	r0, [pc, #172]	; (8046244 <pbuf_copy+0x11c>)
 8046196:	f00b fc57 	bl	8051a48 <printf>
 804619a:	f06f 000f 	mvn.w	r0, #15
 804619e:	e04a      	b.n	8046236 <pbuf_copy+0x10e>
    }

    if ((p_from != NULL) && (p_from->len == p_from->tot_len)) {
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!",
 80461a0:	682b      	ldr	r3, [r5, #0]
 80461a2:	2b00      	cmp	r3, #0
 80461a4:	d033      	beq.n	804620e <pbuf_copy+0xe6>
 80461a6:	4b25      	ldr	r3, [pc, #148]	; (804623c <pbuf_copy+0x114>)
 80461a8:	f240 32dd 	movw	r2, #989	; 0x3dd
 80461ac:	4929      	ldr	r1, [pc, #164]	; (8046254 <pbuf_copy+0x12c>)
 80461ae:	4825      	ldr	r0, [pc, #148]	; (8046244 <pbuf_copy+0x11c>)
 80461b0:	f00b fc4a 	bl	8051a48 <printf>
 80461b4:	f06f 0005 	mvn.w	r0, #5
 80461b8:	e03d      	b.n	8046236 <pbuf_copy+0x10e>
    if ((p_to != NULL) && (p_to->len == p_to->tot_len)) {
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!",
                  (p_to->next == NULL), return ERR_VAL;);
    }
  } while (p_from);
 80461ba:	2d00      	cmp	r5, #0
 80461bc:	d03a      	beq.n	8046234 <pbuf_copy+0x10c>
    if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
 80461be:	897b      	ldrh	r3, [r7, #10]
 80461c0:	1b99      	subs	r1, r3, r6
 80461c2:	896c      	ldrh	r4, [r5, #10]
 80461c4:	eba4 0208 	sub.w	r2, r4, r8
 80461c8:	4291      	cmp	r1, r2
 80461ca:	dbc5      	blt.n	8046158 <pbuf_copy+0x30>
      len = p_from->len - offset_from;
 80461cc:	b294      	uxth	r4, r2
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
 80461ce:	6878      	ldr	r0, [r7, #4]
 80461d0:	6869      	ldr	r1, [r5, #4]
 80461d2:	4622      	mov	r2, r4
 80461d4:	4441      	add	r1, r8
 80461d6:	4430      	add	r0, r6
 80461d8:	f00b fc14 	bl	8051a04 <memcpy>
    offset_to += len;
 80461dc:	4426      	add	r6, r4
 80461de:	b2b6      	uxth	r6, r6
    offset_from += len;
 80461e0:	4444      	add	r4, r8
 80461e2:	fa1f f884 	uxth.w	r8, r4
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
 80461e6:	897b      	ldrh	r3, [r7, #10]
 80461e8:	42b3      	cmp	r3, r6
 80461ea:	d3b8      	bcc.n	804615e <pbuf_copy+0x36>
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
 80461ec:	896b      	ldrh	r3, [r5, #10]
 80461ee:	4543      	cmp	r3, r8
 80461f0:	d3bd      	bcc.n	804616e <pbuf_copy+0x46>
    if (offset_from >= p_from->len) {
 80461f2:	896b      	ldrh	r3, [r5, #10]
 80461f4:	4543      	cmp	r3, r8
 80461f6:	d802      	bhi.n	80461fe <pbuf_copy+0xd6>
      p_from = p_from->next;
 80461f8:	682d      	ldr	r5, [r5, #0]
      offset_from = 0;
 80461fa:	f04f 0800 	mov.w	r8, #0
    if (offset_to == p_to->len) {
 80461fe:	897b      	ldrh	r3, [r7, #10]
 8046200:	42b3      	cmp	r3, r6
 8046202:	d0bc      	beq.n	804617e <pbuf_copy+0x56>
    if ((p_from != NULL) && (p_from->len == p_from->tot_len)) {
 8046204:	b11d      	cbz	r5, 804620e <pbuf_copy+0xe6>
 8046206:	896a      	ldrh	r2, [r5, #10]
 8046208:	892b      	ldrh	r3, [r5, #8]
 804620a:	429a      	cmp	r2, r3
 804620c:	d0c8      	beq.n	80461a0 <pbuf_copy+0x78>
    if ((p_to != NULL) && (p_to->len == p_to->tot_len)) {
 804620e:	2f00      	cmp	r7, #0
 8046210:	d0d3      	beq.n	80461ba <pbuf_copy+0x92>
 8046212:	897a      	ldrh	r2, [r7, #10]
 8046214:	893b      	ldrh	r3, [r7, #8]
 8046216:	429a      	cmp	r2, r3
 8046218:	d1cf      	bne.n	80461ba <pbuf_copy+0x92>
      LWIP_ERROR("pbuf_copy() does not allow packet queues!",
 804621a:	683b      	ldr	r3, [r7, #0]
 804621c:	2b00      	cmp	r3, #0
 804621e:	d0cc      	beq.n	80461ba <pbuf_copy+0x92>
 8046220:	4b06      	ldr	r3, [pc, #24]	; (804623c <pbuf_copy+0x114>)
 8046222:	f240 32e2 	movw	r2, #994	; 0x3e2
 8046226:	490b      	ldr	r1, [pc, #44]	; (8046254 <pbuf_copy+0x12c>)
 8046228:	4806      	ldr	r0, [pc, #24]	; (8046244 <pbuf_copy+0x11c>)
 804622a:	f00b fc0d 	bl	8051a48 <printf>
 804622e:	f06f 0005 	mvn.w	r0, #5
 8046232:	e000      	b.n	8046236 <pbuf_copy+0x10e>
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy: end of chain reached.\n"));
  return ERR_OK;
 8046234:	2000      	movs	r0, #0
}
 8046236:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 804623a:	bf00      	nop
 804623c:	08059190 	.word	0x08059190
 8046240:	0805949c 	.word	0x0805949c
 8046244:	08058ecc 	.word	0x08058ecc
 8046248:	080594cc 	.word	0x080594cc
 804624c:	080594e4 	.word	0x080594e4
 8046250:	08059500 	.word	0x08059500
 8046254:	08059510 	.word	0x08059510

08046258 <pbuf_copy_partial>:
 * @param offset offset into the packet buffer from where to begin copying len bytes
 * @return the number of bytes copied, or 0 on failure
 */
u16_t
pbuf_copy_partial(const struct pbuf *buf, void *dataptr, u16_t len, u16_t offset)
{
 8046258:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  const struct pbuf *p;
  u16_t left;
  u16_t buf_copy_len;
  u16_t copied_total = 0;

  LWIP_ERROR("pbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
 804625c:	b130      	cbz	r0, 804626c <pbuf_copy_partial+0x14>
 804625e:	4688      	mov	r8, r1
 8046260:	4691      	mov	r9, r2
 8046262:	4605      	mov	r5, r0
  LWIP_ERROR("pbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
 8046264:	b169      	cbz	r1, 8046282 <pbuf_copy_partial+0x2a>
  u16_t copied_total = 0;
 8046266:	2700      	movs	r7, #0

  left = 0;
 8046268:	463e      	mov	r6, r7
 804626a:	e02a      	b.n	80462c2 <pbuf_copy_partial+0x6a>
  LWIP_ERROR("pbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
 804626c:	4b1b      	ldr	r3, [pc, #108]	; (80462dc <pbuf_copy_partial+0x84>)
 804626e:	f240 32fe 	movw	r2, #1022	; 0x3fe
 8046272:	491b      	ldr	r1, [pc, #108]	; (80462e0 <pbuf_copy_partial+0x88>)
 8046274:	481b      	ldr	r0, [pc, #108]	; (80462e4 <pbuf_copy_partial+0x8c>)
 8046276:	f00b fbe7 	bl	8051a48 <printf>
 804627a:	2700      	movs	r7, #0
      len -= buf_copy_len;
      offset = 0;
    }
  }
  return copied_total;
}
 804627c:	4638      	mov	r0, r7
 804627e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  LWIP_ERROR("pbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
 8046282:	4b16      	ldr	r3, [pc, #88]	; (80462dc <pbuf_copy_partial+0x84>)
 8046284:	f240 32ff 	movw	r2, #1023	; 0x3ff
 8046288:	4917      	ldr	r1, [pc, #92]	; (80462e8 <pbuf_copy_partial+0x90>)
 804628a:	4816      	ldr	r0, [pc, #88]	; (80462e4 <pbuf_copy_partial+0x8c>)
 804628c:	f00b fbdc 	bl	8051a48 <printf>
 8046290:	2700      	movs	r7, #0
 8046292:	e7f3      	b.n	804627c <pbuf_copy_partial+0x24>
      buf_copy_len = p->len - offset;
 8046294:	896c      	ldrh	r4, [r5, #10]
 8046296:	1ae4      	subs	r4, r4, r3
 8046298:	b2a4      	uxth	r4, r4
      if (buf_copy_len > len) {
 804629a:	45a1      	cmp	r9, r4
 804629c:	d200      	bcs.n	80462a0 <pbuf_copy_partial+0x48>
        buf_copy_len = len;
 804629e:	464c      	mov	r4, r9
      MEMCPY(&((char*)dataptr)[left], &((char*)p->payload)[offset], buf_copy_len);
 80462a0:	6869      	ldr	r1, [r5, #4]
 80462a2:	4622      	mov	r2, r4
 80462a4:	4419      	add	r1, r3
 80462a6:	eb08 0006 	add.w	r0, r8, r6
 80462aa:	f00b fbab 	bl	8051a04 <memcpy>
      copied_total += buf_copy_len;
 80462ae:	4427      	add	r7, r4
 80462b0:	b2bf      	uxth	r7, r7
      left += buf_copy_len;
 80462b2:	4426      	add	r6, r4
 80462b4:	b2b6      	uxth	r6, r6
      len -= buf_copy_len;
 80462b6:	eba9 0404 	sub.w	r4, r9, r4
 80462ba:	fa1f f984 	uxth.w	r9, r4
      offset = 0;
 80462be:	2300      	movs	r3, #0
  for (p = buf; len != 0 && p != NULL; p = p->next) {
 80462c0:	682d      	ldr	r5, [r5, #0]
 80462c2:	f1b9 0f00 	cmp.w	r9, #0
 80462c6:	d0d9      	beq.n	804627c <pbuf_copy_partial+0x24>
 80462c8:	2d00      	cmp	r5, #0
 80462ca:	d0d7      	beq.n	804627c <pbuf_copy_partial+0x24>
    if ((offset != 0) && (offset >= p->len)) {
 80462cc:	2b00      	cmp	r3, #0
 80462ce:	d0e1      	beq.n	8046294 <pbuf_copy_partial+0x3c>
 80462d0:	8969      	ldrh	r1, [r5, #10]
 80462d2:	4299      	cmp	r1, r3
 80462d4:	d8de      	bhi.n	8046294 <pbuf_copy_partial+0x3c>
      offset -= p->len;
 80462d6:	1a5b      	subs	r3, r3, r1
 80462d8:	b29b      	uxth	r3, r3
 80462da:	e7f1      	b.n	80462c0 <pbuf_copy_partial+0x68>
 80462dc:	08059190 	.word	0x08059190
 80462e0:	0805953c 	.word	0x0805953c
 80462e4:	08058ecc 	.word	0x08058ecc
 80462e8:	0805955c 	.word	0x0805955c

080462ec <pbuf_take>:
 *
 * @return ERR_OK if successful, ERR_MEM if the pbuf is not big enough
 */
err_t
pbuf_take(struct pbuf *buf, const void *dataptr, u16_t len)
{
 80462ec:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  struct pbuf *p;
  u16_t buf_copy_len;
  u16_t total_copy_len = len;
  u16_t copied_total = 0;

  LWIP_ERROR("pbuf_take: invalid buf", (buf != NULL), return ERR_ARG;);
 80462f0:	b148      	cbz	r0, 8046306 <pbuf_take+0x1a>
 80462f2:	4688      	mov	r8, r1
 80462f4:	4691      	mov	r9, r2
 80462f6:	4606      	mov	r6, r0
  LWIP_ERROR("pbuf_take: invalid dataptr", (dataptr != NULL), return ERR_ARG;);
 80462f8:	b179      	cbz	r1, 804631a <pbuf_take+0x2e>
  LWIP_ERROR("pbuf_take: buf not large enough", (buf->tot_len >= len), return ERR_MEM;);
 80462fa:	8903      	ldrh	r3, [r0, #8]
 80462fc:	4293      	cmp	r3, r2
 80462fe:	d316      	bcc.n	804632e <pbuf_take+0x42>
  u16_t total_copy_len = len;
 8046300:	4614      	mov	r4, r2
  u16_t copied_total = 0;
 8046302:	2700      	movs	r7, #0
 8046304:	e030      	b.n	8046368 <pbuf_take+0x7c>
  LWIP_ERROR("pbuf_take: invalid buf", (buf != NULL), return ERR_ARG;);
 8046306:	4b23      	ldr	r3, [pc, #140]	; (8046394 <pbuf_take+0xa8>)
 8046308:	f240 4284 	movw	r2, #1156	; 0x484
 804630c:	4922      	ldr	r1, [pc, #136]	; (8046398 <pbuf_take+0xac>)
 804630e:	4823      	ldr	r0, [pc, #140]	; (804639c <pbuf_take+0xb0>)
 8046310:	f00b fb9a 	bl	8051a48 <printf>
 8046314:	f06f 000f 	mvn.w	r0, #15
 8046318:	e031      	b.n	804637e <pbuf_take+0x92>
  LWIP_ERROR("pbuf_take: invalid dataptr", (dataptr != NULL), return ERR_ARG;);
 804631a:	4b1e      	ldr	r3, [pc, #120]	; (8046394 <pbuf_take+0xa8>)
 804631c:	f240 4285 	movw	r2, #1157	; 0x485
 8046320:	491f      	ldr	r1, [pc, #124]	; (80463a0 <pbuf_take+0xb4>)
 8046322:	481e      	ldr	r0, [pc, #120]	; (804639c <pbuf_take+0xb0>)
 8046324:	f00b fb90 	bl	8051a48 <printf>
 8046328:	f06f 000f 	mvn.w	r0, #15
 804632c:	e027      	b.n	804637e <pbuf_take+0x92>
  LWIP_ERROR("pbuf_take: buf not large enough", (buf->tot_len >= len), return ERR_MEM;);
 804632e:	4b19      	ldr	r3, [pc, #100]	; (8046394 <pbuf_take+0xa8>)
 8046330:	f240 4286 	movw	r2, #1158	; 0x486
 8046334:	491b      	ldr	r1, [pc, #108]	; (80463a4 <pbuf_take+0xb8>)
 8046336:	4819      	ldr	r0, [pc, #100]	; (804639c <pbuf_take+0xb0>)
 8046338:	f00b fb86 	bl	8051a48 <printf>
 804633c:	f04f 30ff 	mov.w	r0, #4294967295
 8046340:	e01d      	b.n	804637e <pbuf_take+0x92>
    return ERR_ARG;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for (p = buf; total_copy_len != 0; p = p->next) {
    LWIP_ASSERT("pbuf_take: invalid pbuf", p != NULL);
 8046342:	4b14      	ldr	r3, [pc, #80]	; (8046394 <pbuf_take+0xa8>)
 8046344:	f240 428e 	movw	r2, #1166	; 0x48e
 8046348:	4917      	ldr	r1, [pc, #92]	; (80463a8 <pbuf_take+0xbc>)
 804634a:	4814      	ldr	r0, [pc, #80]	; (804639c <pbuf_take+0xb0>)
 804634c:	f00b fb7c 	bl	8051a48 <printf>
 8046350:	e00d      	b.n	804636e <pbuf_take+0x82>
    if (buf_copy_len > p->len) {
      /* this pbuf cannot hold all remaining data */
      buf_copy_len = p->len;
    }
    /* copy the necessary parts of the buffer */
    MEMCPY(p->payload, &((const char*)dataptr)[copied_total], buf_copy_len);
 8046352:	462a      	mov	r2, r5
 8046354:	eb08 0107 	add.w	r1, r8, r7
 8046358:	6870      	ldr	r0, [r6, #4]
 804635a:	f00b fb53 	bl	8051a04 <memcpy>
    total_copy_len -= buf_copy_len;
 804635e:	1b64      	subs	r4, r4, r5
 8046360:	b2a4      	uxth	r4, r4
    copied_total += buf_copy_len;
 8046362:	442f      	add	r7, r5
 8046364:	b2bf      	uxth	r7, r7
  for (p = buf; total_copy_len != 0; p = p->next) {
 8046366:	6836      	ldr	r6, [r6, #0]
 8046368:	b134      	cbz	r4, 8046378 <pbuf_take+0x8c>
    LWIP_ASSERT("pbuf_take: invalid pbuf", p != NULL);
 804636a:	2e00      	cmp	r6, #0
 804636c:	d0e9      	beq.n	8046342 <pbuf_take+0x56>
    if (buf_copy_len > p->len) {
 804636e:	8975      	ldrh	r5, [r6, #10]
 8046370:	42a5      	cmp	r5, r4
 8046372:	d3ee      	bcc.n	8046352 <pbuf_take+0x66>
    buf_copy_len = total_copy_len;
 8046374:	4625      	mov	r5, r4
 8046376:	e7ec      	b.n	8046352 <pbuf_take+0x66>
  }
  LWIP_ASSERT("did not copy all data", total_copy_len == 0 && copied_total == len);
 8046378:	454f      	cmp	r7, r9
 804637a:	d102      	bne.n	8046382 <pbuf_take+0x96>
  return ERR_OK;
 804637c:	2000      	movs	r0, #0
}
 804637e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  LWIP_ASSERT("did not copy all data", total_copy_len == 0 && copied_total == len);
 8046382:	4b04      	ldr	r3, [pc, #16]	; (8046394 <pbuf_take+0xa8>)
 8046384:	f240 4299 	movw	r2, #1177	; 0x499
 8046388:	4908      	ldr	r1, [pc, #32]	; (80463ac <pbuf_take+0xc0>)
 804638a:	4804      	ldr	r0, [pc, #16]	; (804639c <pbuf_take+0xb0>)
 804638c:	f00b fb5c 	bl	8051a48 <printf>
  return ERR_OK;
 8046390:	2000      	movs	r0, #0
 8046392:	e7f4      	b.n	804637e <pbuf_take+0x92>
 8046394:	08059190 	.word	0x08059190
 8046398:	08059580 	.word	0x08059580
 804639c:	08058ecc 	.word	0x08058ecc
 80463a0:	08059598 	.word	0x08059598
 80463a4:	080595b4 	.word	0x080595b4
 80463a8:	080595d4 	.word	0x080595d4
 80463ac:	080595ec 	.word	0x080595ec

080463b0 <tcp_remove_listener>:
 */
static void
tcp_remove_listener(struct tcp_pcb *list, struct tcp_pcb_listen *lpcb)
{
   struct tcp_pcb *pcb;
   for (pcb = list; pcb != NULL; pcb = pcb->next) {
 80463b0:	e002      	b.n	80463b8 <tcp_remove_listener+0x8>
      if (pcb->listener == lpcb) {
         pcb->listener = NULL;
 80463b2:	2300      	movs	r3, #0
 80463b4:	6783      	str	r3, [r0, #120]	; 0x78
   for (pcb = list; pcb != NULL; pcb = pcb->next) {
 80463b6:	68c0      	ldr	r0, [r0, #12]
 80463b8:	b118      	cbz	r0, 80463c2 <tcp_remove_listener+0x12>
      if (pcb->listener == lpcb) {
 80463ba:	6f83      	ldr	r3, [r0, #120]	; 0x78
 80463bc:	428b      	cmp	r3, r1
 80463be:	d1fa      	bne.n	80463b6 <tcp_remove_listener+0x6>
 80463c0:	e7f7      	b.n	80463b2 <tcp_remove_listener+0x2>
      }
   }
}
 80463c2:	4770      	bx	lr

080463c4 <tcp_new_port>:
 *
 * @return a new (free) local TCP port number
 */
static u16_t
tcp_new_port(void)
{
 80463c4:	b410      	push	{r4}
  u8_t i;
  u16_t n = 0;
 80463c6:	2400      	movs	r4, #0
 80463c8:	e009      	b.n	80463de <tcp_new_port+0x1a>
  struct tcp_pcb *pcb;

again:
  if (tcp_port++ == TCP_LOCAL_PORT_RANGE_END) {
    tcp_port = TCP_LOCAL_PORT_RANGE_START;
 80463ca:	4b15      	ldr	r3, [pc, #84]	; (8046420 <tcp_new_port+0x5c>)
 80463cc:	f44f 4240 	mov.w	r2, #49152	; 0xc000
 80463d0:	801a      	strh	r2, [r3, #0]
 80463d2:	e00c      	b.n	80463ee <tcp_new_port+0x2a>
  }
  /* Check all PCB lists. */
  for (i = 0; i < NUM_TCP_PCB_LISTS; i++) {
    for (pcb = *tcp_pcb_lists[i]; pcb != NULL; pcb = pcb->next) {
      if (pcb->local_port == tcp_port) {
        if (++n > (TCP_LOCAL_PORT_RANGE_END - TCP_LOCAL_PORT_RANGE_START)) {
 80463d4:	3401      	adds	r4, #1
 80463d6:	b2a4      	uxth	r4, r4
 80463d8:	f5b4 4f80 	cmp.w	r4, #16384	; 0x4000
 80463dc:	d21e      	bcs.n	804641c <tcp_new_port+0x58>
  if (tcp_port++ == TCP_LOCAL_PORT_RANGE_END) {
 80463de:	4a10      	ldr	r2, [pc, #64]	; (8046420 <tcp_new_port+0x5c>)
 80463e0:	8813      	ldrh	r3, [r2, #0]
 80463e2:	1c59      	adds	r1, r3, #1
 80463e4:	8011      	strh	r1, [r2, #0]
 80463e6:	f64f 72ff 	movw	r2, #65535	; 0xffff
 80463ea:	4293      	cmp	r3, r2
 80463ec:	d0ed      	beq.n	80463ca <tcp_new_port+0x6>
  for (i = 0; i < NUM_TCP_PCB_LISTS; i++) {
 80463ee:	2000      	movs	r0, #0
 80463f0:	2803      	cmp	r0, #3
 80463f2:	d80e      	bhi.n	8046412 <tcp_new_port+0x4e>
    for (pcb = *tcp_pcb_lists[i]; pcb != NULL; pcb = pcb->next) {
 80463f4:	4b0b      	ldr	r3, [pc, #44]	; (8046424 <tcp_new_port+0x60>)
 80463f6:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
 80463fa:	681b      	ldr	r3, [r3, #0]
 80463fc:	b133      	cbz	r3, 804640c <tcp_new_port+0x48>
      if (pcb->local_port == tcp_port) {
 80463fe:	8ad9      	ldrh	r1, [r3, #22]
 8046400:	4a07      	ldr	r2, [pc, #28]	; (8046420 <tcp_new_port+0x5c>)
 8046402:	8812      	ldrh	r2, [r2, #0]
 8046404:	4291      	cmp	r1, r2
 8046406:	d0e5      	beq.n	80463d4 <tcp_new_port+0x10>
    for (pcb = *tcp_pcb_lists[i]; pcb != NULL; pcb = pcb->next) {
 8046408:	68db      	ldr	r3, [r3, #12]
 804640a:	e7f7      	b.n	80463fc <tcp_new_port+0x38>
  for (i = 0; i < NUM_TCP_PCB_LISTS; i++) {
 804640c:	3001      	adds	r0, #1
 804640e:	b2c0      	uxtb	r0, r0
 8046410:	e7ee      	b.n	80463f0 <tcp_new_port+0x2c>
        }
        goto again;
      }
    }
  }
  return tcp_port;
 8046412:	4b03      	ldr	r3, [pc, #12]	; (8046420 <tcp_new_port+0x5c>)
 8046414:	8818      	ldrh	r0, [r3, #0]
}
 8046416:	f85d 4b04 	ldr.w	r4, [sp], #4
 804641a:	4770      	bx	lr
          return 0;
 804641c:	2000      	movs	r0, #0
 804641e:	e7fa      	b.n	8046416 <tcp_new_port+0x52>
 8046420:	20000008 	.word	0x20000008
 8046424:	08058de8 	.word	0x08058de8

08046428 <tcp_listen_closed>:
{
 8046428:	b538      	push	{r3, r4, r5, lr}
  LWIP_ASSERT("pcb != NULL", pcb != NULL);
 804642a:	4605      	mov	r5, r0
 804642c:	b120      	cbz	r0, 8046438 <tcp_listen_closed+0x10>
  LWIP_ASSERT("pcb->state == LISTEN", pcb->state == LISTEN);
 804642e:	7d2b      	ldrb	r3, [r5, #20]
 8046430:	2b01      	cmp	r3, #1
 8046432:	d108      	bne.n	8046446 <tcp_listen_closed+0x1e>
{
 8046434:	2401      	movs	r4, #1
 8046436:	e015      	b.n	8046464 <tcp_listen_closed+0x3c>
  LWIP_ASSERT("pcb != NULL", pcb != NULL);
 8046438:	4b0c      	ldr	r3, [pc, #48]	; (804646c <tcp_listen_closed+0x44>)
 804643a:	22c0      	movs	r2, #192	; 0xc0
 804643c:	490c      	ldr	r1, [pc, #48]	; (8046470 <tcp_listen_closed+0x48>)
 804643e:	480d      	ldr	r0, [pc, #52]	; (8046474 <tcp_listen_closed+0x4c>)
 8046440:	f00b fb02 	bl	8051a48 <printf>
 8046444:	e7f3      	b.n	804642e <tcp_listen_closed+0x6>
  LWIP_ASSERT("pcb->state == LISTEN", pcb->state == LISTEN);
 8046446:	4b09      	ldr	r3, [pc, #36]	; (804646c <tcp_listen_closed+0x44>)
 8046448:	22c1      	movs	r2, #193	; 0xc1
 804644a:	490b      	ldr	r1, [pc, #44]	; (8046478 <tcp_listen_closed+0x50>)
 804644c:	4809      	ldr	r0, [pc, #36]	; (8046474 <tcp_listen_closed+0x4c>)
 804644e:	f00b fafb 	bl	8051a48 <printf>
 8046452:	e7ef      	b.n	8046434 <tcp_listen_closed+0xc>
    tcp_remove_listener(*tcp_pcb_lists[i], (struct tcp_pcb_listen*)pcb);
 8046454:	4b09      	ldr	r3, [pc, #36]	; (804647c <tcp_listen_closed+0x54>)
 8046456:	f853 3024 	ldr.w	r3, [r3, r4, lsl #2]
 804645a:	4629      	mov	r1, r5
 804645c:	6818      	ldr	r0, [r3, #0]
 804645e:	f7ff ffa7 	bl	80463b0 <tcp_remove_listener>
  for (i = 1; i < LWIP_ARRAYSIZE(tcp_pcb_lists); i++) {
 8046462:	3401      	adds	r4, #1
 8046464:	2c03      	cmp	r4, #3
 8046466:	d9f5      	bls.n	8046454 <tcp_listen_closed+0x2c>
}
 8046468:	bd38      	pop	{r3, r4, r5, pc}
 804646a:	bf00      	nop
 804646c:	08059618 	.word	0x08059618
 8046470:	08059648 	.word	0x08059648
 8046474:	08058ecc 	.word	0x08058ecc
 8046478:	08059654 	.word	0x08059654
 804647c:	08058de8 	.word	0x08058de8

08046480 <tcp_close_shutdown_fin>:
{
 8046480:	b538      	push	{r3, r4, r5, lr}
  LWIP_ASSERT("pcb != NULL", pcb != NULL);
 8046482:	4605      	mov	r5, r0
 8046484:	b148      	cbz	r0, 804649a <tcp_close_shutdown_fin+0x1a>
  switch (pcb->state) {
 8046486:	7d2b      	ldrb	r3, [r5, #20]
 8046488:	2b04      	cmp	r3, #4
 804648a:	d01f      	beq.n	80464cc <tcp_close_shutdown_fin+0x4c>
 804648c:	2b07      	cmp	r3, #7
 804648e:	d026      	beq.n	80464de <tcp_close_shutdown_fin+0x5e>
 8046490:	2b03      	cmp	r3, #3
 8046492:	d00a      	beq.n	80464aa <tcp_close_shutdown_fin+0x2a>
 8046494:	2400      	movs	r4, #0
}
 8046496:	4620      	mov	r0, r4
 8046498:	bd38      	pop	{r3, r4, r5, pc}
  LWIP_ASSERT("pcb != NULL", pcb != NULL);
 804649a:	4b17      	ldr	r3, [pc, #92]	; (80464f8 <tcp_close_shutdown_fin+0x78>)
 804649c:	f240 124d 	movw	r2, #333	; 0x14d
 80464a0:	4916      	ldr	r1, [pc, #88]	; (80464fc <tcp_close_shutdown_fin+0x7c>)
 80464a2:	4817      	ldr	r0, [pc, #92]	; (8046500 <tcp_close_shutdown_fin+0x80>)
 80464a4:	f00b fad0 	bl	8051a48 <printf>
 80464a8:	e7ed      	b.n	8046486 <tcp_close_shutdown_fin+0x6>
    err = tcp_send_fin(pcb);
 80464aa:	4628      	mov	r0, r5
 80464ac:	f002 ffc8 	bl	8049440 <tcp_send_fin>
    if (err == ERR_OK) {
 80464b0:	4604      	mov	r4, r0
 80464b2:	b908      	cbnz	r0, 80464b8 <tcp_close_shutdown_fin+0x38>
      pcb->state = FIN_WAIT_1;
 80464b4:	2305      	movs	r3, #5
 80464b6:	752b      	strb	r3, [r5, #20]
  if (err == ERR_OK) {
 80464b8:	b1d4      	cbz	r4, 80464f0 <tcp_close_shutdown_fin+0x70>
  } else if (err == ERR_MEM) {
 80464ba:	f1b4 3fff 	cmp.w	r4, #4294967295
 80464be:	d1ea      	bne.n	8046496 <tcp_close_shutdown_fin+0x16>
    pcb->flags |= TF_CLOSEPEND;
 80464c0:	7eab      	ldrb	r3, [r5, #26]
 80464c2:	f043 0308 	orr.w	r3, r3, #8
 80464c6:	76ab      	strb	r3, [r5, #26]
    return ERR_OK;
 80464c8:	2400      	movs	r4, #0
 80464ca:	e7e4      	b.n	8046496 <tcp_close_shutdown_fin+0x16>
    err = tcp_send_fin(pcb);
 80464cc:	4628      	mov	r0, r5
 80464ce:	f002 ffb7 	bl	8049440 <tcp_send_fin>
    if (err == ERR_OK) {
 80464d2:	4604      	mov	r4, r0
 80464d4:	2800      	cmp	r0, #0
 80464d6:	d1ef      	bne.n	80464b8 <tcp_close_shutdown_fin+0x38>
      pcb->state = FIN_WAIT_1;
 80464d8:	2305      	movs	r3, #5
 80464da:	752b      	strb	r3, [r5, #20]
 80464dc:	e7ec      	b.n	80464b8 <tcp_close_shutdown_fin+0x38>
    err = tcp_send_fin(pcb);
 80464de:	4628      	mov	r0, r5
 80464e0:	f002 ffae 	bl	8049440 <tcp_send_fin>
    if (err == ERR_OK) {
 80464e4:	4604      	mov	r4, r0
 80464e6:	2800      	cmp	r0, #0
 80464e8:	d1e6      	bne.n	80464b8 <tcp_close_shutdown_fin+0x38>
      pcb->state = LAST_ACK;
 80464ea:	2309      	movs	r3, #9
 80464ec:	752b      	strb	r3, [r5, #20]
 80464ee:	e7e3      	b.n	80464b8 <tcp_close_shutdown_fin+0x38>
    tcp_output(pcb);
 80464f0:	4628      	mov	r0, r5
 80464f2:	f003 f801 	bl	80494f8 <tcp_output>
 80464f6:	e7ce      	b.n	8046496 <tcp_close_shutdown_fin+0x16>
 80464f8:	08059618 	.word	0x08059618
 80464fc:	08059648 	.word	0x08059648
 8046500:	08058ecc 	.word	0x08058ecc

08046504 <tcp_init>:
}
 8046504:	4770      	bx	lr
	...

08046508 <tcp_bind>:
{
 8046508:	b570      	push	{r4, r5, r6, lr}
 804650a:	4606      	mov	r6, r0
  if (ipaddr == NULL) {
 804650c:	460d      	mov	r5, r1
 804650e:	b171      	cbz	r1, 804652e <tcp_bind+0x26>
  if ((pcb == NULL) || (ipaddr == NULL)) {
 8046510:	2e00      	cmp	r6, #0
 8046512:	d039      	beq.n	8046588 <tcp_bind+0x80>
 8046514:	2d00      	cmp	r5, #0
 8046516:	d03a      	beq.n	804658e <tcp_bind+0x86>
  LWIP_ERROR("tcp_bind: can only bind in state CLOSED", pcb->state == CLOSED, return ERR_VAL);
 8046518:	7d33      	ldrb	r3, [r6, #20]
 804651a:	b953      	cbnz	r3, 8046532 <tcp_bind+0x2a>
  if (port == 0) {
 804651c:	b19a      	cbz	r2, 8046546 <tcp_bind+0x3e>
    for (i = 0; i < max_pcb_list; i++) {
 804651e:	2000      	movs	r0, #0
 8046520:	2803      	cmp	r0, #3
 8046522:	dc14      	bgt.n	804654e <tcp_bind+0x46>
      for (cpcb = *tcp_pcb_lists[i]; cpcb != NULL; cpcb = cpcb->next) {
 8046524:	4b21      	ldr	r3, [pc, #132]	; (80465ac <tcp_bind+0xa4>)
 8046526:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
 804652a:	681b      	ldr	r3, [r3, #0]
 804652c:	e01c      	b.n	8046568 <tcp_bind+0x60>
    ipaddr = IP4_ADDR_ANY;
 804652e:	4d20      	ldr	r5, [pc, #128]	; (80465b0 <tcp_bind+0xa8>)
 8046530:	e7ee      	b.n	8046510 <tcp_bind+0x8>
  LWIP_ERROR("tcp_bind: can only bind in state CLOSED", pcb->state == CLOSED, return ERR_VAL);
 8046532:	4b20      	ldr	r3, [pc, #128]	; (80465b4 <tcp_bind+0xac>)
 8046534:	f44f 7211 	mov.w	r2, #580	; 0x244
 8046538:	491f      	ldr	r1, [pc, #124]	; (80465b8 <tcp_bind+0xb0>)
 804653a:	4820      	ldr	r0, [pc, #128]	; (80465bc <tcp_bind+0xb4>)
 804653c:	f00b fa84 	bl	8051a48 <printf>
 8046540:	f06f 0005 	mvn.w	r0, #5
 8046544:	e00e      	b.n	8046564 <tcp_bind+0x5c>
    port = tcp_new_port();
 8046546:	f7ff ff3d 	bl	80463c4 <tcp_new_port>
    if (port == 0) {
 804654a:	4602      	mov	r2, r0
 804654c:	b310      	cbz	r0, 8046594 <tcp_bind+0x8c>
  if (!ip_addr_isany(ipaddr)) {
 804654e:	682b      	ldr	r3, [r5, #0]
 8046550:	b103      	cbz	r3, 8046554 <tcp_bind+0x4c>
    ip_addr_set(&pcb->local_ip, ipaddr);
 8046552:	6033      	str	r3, [r6, #0]
  pcb->local_port = port;
 8046554:	82f2      	strh	r2, [r6, #22]
  TCP_REG(&tcp_bound_pcbs, pcb);
 8046556:	4b1a      	ldr	r3, [pc, #104]	; (80465c0 <tcp_bind+0xb8>)
 8046558:	681a      	ldr	r2, [r3, #0]
 804655a:	60f2      	str	r2, [r6, #12]
 804655c:	601e      	str	r6, [r3, #0]
 804655e:	f003 fac3 	bl	8049ae8 <tcp_timer_needed>
  return ERR_OK;
 8046562:	2000      	movs	r0, #0
}
 8046564:	bd70      	pop	{r4, r5, r6, pc}
      for (cpcb = *tcp_pcb_lists[i]; cpcb != NULL; cpcb = cpcb->next) {
 8046566:	68db      	ldr	r3, [r3, #12]
 8046568:	b163      	cbz	r3, 8046584 <tcp_bind+0x7c>
        if (cpcb->local_port == port) {
 804656a:	8ad9      	ldrh	r1, [r3, #22]
 804656c:	4291      	cmp	r1, r2
 804656e:	d1fa      	bne.n	8046566 <tcp_bind+0x5e>
            if ((IP_IS_V6(ipaddr) == IP_IS_V6_VAL(cpcb->local_ip)) &&
 8046570:	b19b      	cbz	r3, 804659a <tcp_bind+0x92>
                (ip_addr_isany(&cpcb->local_ip) ||
 8046572:	6819      	ldr	r1, [r3, #0]
 8046574:	b1a1      	cbz	r1, 80465a0 <tcp_bind+0x98>
                ip_addr_isany(ipaddr) ||
 8046576:	682c      	ldr	r4, [r5, #0]
 8046578:	b1ac      	cbz	r4, 80465a6 <tcp_bind+0x9e>
            if ((IP_IS_V6(ipaddr) == IP_IS_V6_VAL(cpcb->local_ip)) &&
 804657a:	42a1      	cmp	r1, r4
 804657c:	d1f3      	bne.n	8046566 <tcp_bind+0x5e>
              return ERR_USE;
 804657e:	f06f 0007 	mvn.w	r0, #7
 8046582:	e7ef      	b.n	8046564 <tcp_bind+0x5c>
    for (i = 0; i < max_pcb_list; i++) {
 8046584:	3001      	adds	r0, #1
 8046586:	e7cb      	b.n	8046520 <tcp_bind+0x18>
    return ERR_VAL;
 8046588:	f06f 0005 	mvn.w	r0, #5
 804658c:	e7ea      	b.n	8046564 <tcp_bind+0x5c>
 804658e:	f06f 0005 	mvn.w	r0, #5
 8046592:	e7e7      	b.n	8046564 <tcp_bind+0x5c>
      return ERR_BUF;
 8046594:	f06f 0001 	mvn.w	r0, #1
 8046598:	e7e4      	b.n	8046564 <tcp_bind+0x5c>
              return ERR_USE;
 804659a:	f06f 0007 	mvn.w	r0, #7
 804659e:	e7e1      	b.n	8046564 <tcp_bind+0x5c>
 80465a0:	f06f 0007 	mvn.w	r0, #7
 80465a4:	e7de      	b.n	8046564 <tcp_bind+0x5c>
 80465a6:	f06f 0007 	mvn.w	r0, #7
 80465aa:	e7db      	b.n	8046564 <tcp_bind+0x5c>
 80465ac:	08058de8 	.word	0x08058de8
 80465b0:	08058e58 	.word	0x08058e58
 80465b4:	08059618 	.word	0x08059618
 80465b8:	0805966c 	.word	0x0805966c
 80465bc:	08058ecc 	.word	0x08058ecc
 80465c0:	2000872c 	.word	0x2000872c

080465c4 <tcp_update_rcv_ann_wnd>:
{
 80465c4:	b538      	push	{r3, r4, r5, lr}
 80465c6:	4604      	mov	r4, r0
  u32_t new_right_edge = pcb->rcv_nxt + pcb->rcv_wnd;
 80465c8:	6a45      	ldr	r5, [r0, #36]	; 0x24
 80465ca:	8d01      	ldrh	r1, [r0, #40]	; 0x28
 80465cc:	1868      	adds	r0, r5, r1
  if (TCP_SEQ_GEQ(new_right_edge, pcb->rcv_ann_right_edge + LWIP_MIN((TCP_WND / 2), pcb->mss))) {
 80465ce:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 80465d0:	8e63      	ldrh	r3, [r4, #50]	; 0x32
 80465d2:	f5b3 6f86 	cmp.w	r3, #1072	; 0x430
 80465d6:	bf94      	ite	ls
 80465d8:	18d3      	addls	r3, r2, r3
 80465da:	f502 6386 	addhi.w	r3, r2, #1072	; 0x430
 80465de:	1ac3      	subs	r3, r0, r3
 80465e0:	2b00      	cmp	r3, #0
 80465e2:	db02      	blt.n	80465ea <tcp_update_rcv_ann_wnd+0x26>
    pcb->rcv_ann_wnd = pcb->rcv_wnd;
 80465e4:	8561      	strh	r1, [r4, #42]	; 0x2a
    return new_right_edge - pcb->rcv_ann_right_edge;
 80465e6:	1a80      	subs	r0, r0, r2
}
 80465e8:	bd38      	pop	{r3, r4, r5, pc}
    if (TCP_SEQ_GT(pcb->rcv_nxt, pcb->rcv_ann_right_edge)) {
 80465ea:	1aab      	subs	r3, r5, r2
 80465ec:	2b00      	cmp	r3, #0
 80465ee:	dd03      	ble.n	80465f8 <tcp_update_rcv_ann_wnd+0x34>
      pcb->rcv_ann_wnd = 0;
 80465f0:	2300      	movs	r3, #0
 80465f2:	8563      	strh	r3, [r4, #42]	; 0x2a
    return 0;
 80465f4:	2000      	movs	r0, #0
 80465f6:	e7f7      	b.n	80465e8 <tcp_update_rcv_ann_wnd+0x24>
      u32_t new_rcv_ann_wnd = pcb->rcv_ann_right_edge - pcb->rcv_nxt;
 80465f8:	1b55      	subs	r5, r2, r5
      LWIP_ASSERT("new_rcv_ann_wnd <= 0xffff", new_rcv_ann_wnd <= 0xffff);
 80465fa:	f5b5 3f80 	cmp.w	r5, #65536	; 0x10000
 80465fe:	d201      	bcs.n	8046604 <tcp_update_rcv_ann_wnd+0x40>
      pcb->rcv_ann_wnd = (tcpwnd_size_t)new_rcv_ann_wnd;
 8046600:	8565      	strh	r5, [r4, #42]	; 0x2a
 8046602:	e7f7      	b.n	80465f4 <tcp_update_rcv_ann_wnd+0x30>
      LWIP_ASSERT("new_rcv_ann_wnd <= 0xffff", new_rcv_ann_wnd <= 0xffff);
 8046604:	4b03      	ldr	r3, [pc, #12]	; (8046614 <tcp_update_rcv_ann_wnd+0x50>)
 8046606:	f44f 7242 	mov.w	r2, #776	; 0x308
 804660a:	4903      	ldr	r1, [pc, #12]	; (8046618 <tcp_update_rcv_ann_wnd+0x54>)
 804660c:	4803      	ldr	r0, [pc, #12]	; (804661c <tcp_update_rcv_ann_wnd+0x58>)
 804660e:	f00b fa1b 	bl	8051a48 <printf>
 8046612:	e7f5      	b.n	8046600 <tcp_update_rcv_ann_wnd+0x3c>
 8046614:	08059618 	.word	0x08059618
 8046618:	080596b8 	.word	0x080596b8
 804661c:	08058ecc 	.word	0x08058ecc

08046620 <tcp_recved>:
{
 8046620:	b538      	push	{r3, r4, r5, lr}
 8046622:	4605      	mov	r5, r0
 8046624:	460c      	mov	r4, r1
  LWIP_ASSERT("don't call tcp_recved for listen-pcbs",
 8046626:	7d03      	ldrb	r3, [r0, #20]
 8046628:	2b01      	cmp	r3, #1
 804662a:	d010      	beq.n	804664e <tcp_recved+0x2e>
  pcb->rcv_wnd += len;
 804662c:	8d29      	ldrh	r1, [r5, #40]	; 0x28
 804662e:	4421      	add	r1, r4
 8046630:	b289      	uxth	r1, r1
 8046632:	8529      	strh	r1, [r5, #40]	; 0x28
  if (pcb->rcv_wnd > TCP_WND_MAX(pcb)) {
 8046634:	f5b1 6f06 	cmp.w	r1, #2144	; 0x860
 8046638:	d911      	bls.n	804665e <tcp_recved+0x3e>
    pcb->rcv_wnd = TCP_WND_MAX(pcb);
 804663a:	f44f 6306 	mov.w	r3, #2144	; 0x860
 804663e:	852b      	strh	r3, [r5, #40]	; 0x28
  wnd_inflation = tcp_update_rcv_ann_wnd(pcb);
 8046640:	4628      	mov	r0, r5
 8046642:	f7ff ffbf 	bl	80465c4 <tcp_update_rcv_ann_wnd>
  if (wnd_inflation >= TCP_WND_UPDATE_THRESHOLD) {
 8046646:	f5b0 7f06 	cmp.w	r0, #536	; 0x218
 804664a:	da1b      	bge.n	8046684 <tcp_recved+0x64>
}
 804664c:	bd38      	pop	{r3, r4, r5, pc}
  LWIP_ASSERT("don't call tcp_recved for listen-pcbs",
 804664e:	4b11      	ldr	r3, [pc, #68]	; (8046694 <tcp_recved+0x74>)
 8046650:	f240 321f 	movw	r2, #799	; 0x31f
 8046654:	4910      	ldr	r1, [pc, #64]	; (8046698 <tcp_recved+0x78>)
 8046656:	4811      	ldr	r0, [pc, #68]	; (804669c <tcp_recved+0x7c>)
 8046658:	f00b f9f6 	bl	8051a48 <printf>
 804665c:	e7e6      	b.n	804662c <tcp_recved+0xc>
  } else if (pcb->rcv_wnd == 0) {
 804665e:	2900      	cmp	r1, #0
 8046660:	d1ee      	bne.n	8046640 <tcp_recved+0x20>
    if ((pcb->state == CLOSE_WAIT) || (pcb->state == LAST_ACK)) {
 8046662:	7d2b      	ldrb	r3, [r5, #20]
 8046664:	2b07      	cmp	r3, #7
 8046666:	d001      	beq.n	804666c <tcp_recved+0x4c>
 8046668:	2b09      	cmp	r3, #9
 804666a:	d103      	bne.n	8046674 <tcp_recved+0x54>
      pcb->rcv_wnd = TCP_WND_MAX(pcb);
 804666c:	f44f 6306 	mov.w	r3, #2144	; 0x860
 8046670:	852b      	strh	r3, [r5, #40]	; 0x28
 8046672:	e7e5      	b.n	8046640 <tcp_recved+0x20>
      LWIP_ASSERT("tcp_recved: len wrapped rcv_wnd\n", 0);
 8046674:	4b07      	ldr	r3, [pc, #28]	; (8046694 <tcp_recved+0x74>)
 8046676:	f240 322d 	movw	r2, #813	; 0x32d
 804667a:	4909      	ldr	r1, [pc, #36]	; (80466a0 <tcp_recved+0x80>)
 804667c:	4807      	ldr	r0, [pc, #28]	; (804669c <tcp_recved+0x7c>)
 804667e:	f00b f9e3 	bl	8051a48 <printf>
 8046682:	e7dd      	b.n	8046640 <tcp_recved+0x20>
    tcp_ack_now(pcb);
 8046684:	7eab      	ldrb	r3, [r5, #26]
 8046686:	f043 0302 	orr.w	r3, r3, #2
 804668a:	76ab      	strb	r3, [r5, #26]
    tcp_output(pcb);
 804668c:	4628      	mov	r0, r5
 804668e:	f002 ff33 	bl	80494f8 <tcp_output>
}
 8046692:	e7db      	b.n	804664c <tcp_recved+0x2c>
 8046694:	08059618 	.word	0x08059618
 8046698:	080596d4 	.word	0x080596d4
 804669c:	08058ecc 	.word	0x08058ecc
 80466a0:	080596fc 	.word	0x080596fc

080466a4 <tcp_seg_free>:
 * @param seg single tcp_seg to free
 */
void
tcp_seg_free(struct tcp_seg *seg)
{
  if (seg != NULL) {
 80466a4:	b150      	cbz	r0, 80466bc <tcp_seg_free+0x18>
{
 80466a6:	b510      	push	{r4, lr}
 80466a8:	4604      	mov	r4, r0
    if (seg->p != NULL) {
 80466aa:	6840      	ldr	r0, [r0, #4]
 80466ac:	b108      	cbz	r0, 80466b2 <tcp_seg_free+0xe>
      pbuf_free(seg->p);
 80466ae:	f7ff fb15 	bl	8045cdc <pbuf_free>
#if TCP_DEBUG
      seg->p = NULL;
#endif /* TCP_DEBUG */
    }
    memp_free(MEMP_TCP_SEG, seg);
 80466b2:	4621      	mov	r1, r4
 80466b4:	2003      	movs	r0, #3
 80466b6:	f7ff f95d 	bl	8045974 <memp_free>
  }
}
 80466ba:	bd10      	pop	{r4, pc}
 80466bc:	4770      	bx	lr

080466be <tcp_segs_free>:
  while (seg != NULL) {
 80466be:	b138      	cbz	r0, 80466d0 <tcp_segs_free+0x12>
{
 80466c0:	b510      	push	{r4, lr}
    struct tcp_seg *next = seg->next;
 80466c2:	6804      	ldr	r4, [r0, #0]
    tcp_seg_free(seg);
 80466c4:	f7ff ffee 	bl	80466a4 <tcp_seg_free>
    seg = next;
 80466c8:	4620      	mov	r0, r4
  while (seg != NULL) {
 80466ca:	2c00      	cmp	r4, #0
 80466cc:	d1f9      	bne.n	80466c2 <tcp_segs_free+0x4>
}
 80466ce:	bd10      	pop	{r4, pc}
 80466d0:	4770      	bx	lr

080466d2 <tcp_seg_copy>:
 * @param seg the old tcp_seg
 * @return a copy of seg
 */
struct tcp_seg *
tcp_seg_copy(struct tcp_seg *seg)
{
 80466d2:	b538      	push	{r3, r4, r5, lr}
 80466d4:	4604      	mov	r4, r0
  struct tcp_seg *cseg;

  cseg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG);
 80466d6:	2003      	movs	r0, #3
 80466d8:	f7ff f932 	bl	8045940 <memp_malloc>
  if (cseg == NULL) {
 80466dc:	4605      	mov	r5, r0
 80466de:	b150      	cbz	r0, 80466f6 <tcp_seg_copy+0x24>
    return NULL;
  }
  SMEMCPY((u8_t *)cseg, (const u8_t *)seg, sizeof(struct tcp_seg));
 80466e0:	6820      	ldr	r0, [r4, #0]
 80466e2:	6861      	ldr	r1, [r4, #4]
 80466e4:	68a2      	ldr	r2, [r4, #8]
 80466e6:	68e3      	ldr	r3, [r4, #12]
 80466e8:	6028      	str	r0, [r5, #0]
 80466ea:	6069      	str	r1, [r5, #4]
 80466ec:	60aa      	str	r2, [r5, #8]
 80466ee:	60eb      	str	r3, [r5, #12]
  pbuf_ref(cseg->p);
 80466f0:	6868      	ldr	r0, [r5, #4]
 80466f2:	f7ff fcc7 	bl	8046084 <pbuf_ref>
  return cseg;
}
 80466f6:	4628      	mov	r0, r5
 80466f8:	bd38      	pop	{r3, r4, r5, pc}

080466fa <tcp_arg>:
void
tcp_arg(struct tcp_pcb *pcb, void *arg)
{
  /* This function is allowed to be called for both listen pcbs and
     connection pcbs. */
  if (pcb != NULL) {
 80466fa:	b100      	cbz	r0, 80466fe <tcp_arg+0x4>
    pcb->callback_arg = arg;
 80466fc:	6101      	str	r1, [r0, #16]
  }
}
 80466fe:	4770      	bx	lr

08046700 <tcp_recv>:
 * @param recv callback function to call for this pcb when data is received
 */
void
tcp_recv(struct tcp_pcb *pcb, tcp_recv_fn recv)
{
  if (pcb != NULL) {
 8046700:	b180      	cbz	r0, 8046724 <tcp_recv+0x24>
{
 8046702:	b538      	push	{r3, r4, r5, lr}
 8046704:	460c      	mov	r4, r1
 8046706:	4605      	mov	r5, r0
    LWIP_ASSERT("invalid socket state for recv callback", pcb->state != LISTEN);
 8046708:	7d03      	ldrb	r3, [r0, #20]
 804670a:	2b01      	cmp	r3, #1
 804670c:	d002      	beq.n	8046714 <tcp_recv+0x14>
    pcb->recv = recv;
 804670e:	f8c5 4080 	str.w	r4, [r5, #128]	; 0x80
  }
}
 8046712:	bd38      	pop	{r3, r4, r5, pc}
    LWIP_ASSERT("invalid socket state for recv callback", pcb->state != LISTEN);
 8046714:	4b04      	ldr	r3, [pc, #16]	; (8046728 <tcp_recv+0x28>)
 8046716:	f240 62bb 	movw	r2, #1723	; 0x6bb
 804671a:	4904      	ldr	r1, [pc, #16]	; (804672c <tcp_recv+0x2c>)
 804671c:	4804      	ldr	r0, [pc, #16]	; (8046730 <tcp_recv+0x30>)
 804671e:	f00b f993 	bl	8051a48 <printf>
 8046722:	e7f4      	b.n	804670e <tcp_recv+0xe>
 8046724:	4770      	bx	lr
 8046726:	bf00      	nop
 8046728:	08059618 	.word	0x08059618
 804672c:	08059720 	.word	0x08059720
 8046730:	08058ecc 	.word	0x08058ecc

08046734 <tcp_sent>:
 * @param sent callback function to call for this pcb when data is successfully sent
 */
void
tcp_sent(struct tcp_pcb *pcb, tcp_sent_fn sent)
{
  if (pcb != NULL) {
 8046734:	b178      	cbz	r0, 8046756 <tcp_sent+0x22>
{
 8046736:	b538      	push	{r3, r4, r5, lr}
 8046738:	460c      	mov	r4, r1
 804673a:	4605      	mov	r5, r0
    LWIP_ASSERT("invalid socket state for sent callback", pcb->state != LISTEN);
 804673c:	7d03      	ldrb	r3, [r0, #20]
 804673e:	2b01      	cmp	r3, #1
 8046740:	d001      	beq.n	8046746 <tcp_sent+0x12>
    pcb->sent = sent;
 8046742:	67ec      	str	r4, [r5, #124]	; 0x7c
  }
}
 8046744:	bd38      	pop	{r3, r4, r5, pc}
    LWIP_ASSERT("invalid socket state for sent callback", pcb->state != LISTEN);
 8046746:	4b04      	ldr	r3, [pc, #16]	; (8046758 <tcp_sent+0x24>)
 8046748:	f240 62cc 	movw	r2, #1740	; 0x6cc
 804674c:	4903      	ldr	r1, [pc, #12]	; (804675c <tcp_sent+0x28>)
 804674e:	4804      	ldr	r0, [pc, #16]	; (8046760 <tcp_sent+0x2c>)
 8046750:	f00b f97a 	bl	8051a48 <printf>
 8046754:	e7f5      	b.n	8046742 <tcp_sent+0xe>
 8046756:	4770      	bx	lr
 8046758:	08059618 	.word	0x08059618
 804675c:	08059748 	.word	0x08059748
 8046760:	08058ecc 	.word	0x08058ecc

08046764 <tcp_err>:
 *        has occurred on the connection
 */
void
tcp_err(struct tcp_pcb *pcb, tcp_err_fn err)
{
  if (pcb != NULL) {
 8046764:	b180      	cbz	r0, 8046788 <tcp_err+0x24>
{
 8046766:	b538      	push	{r3, r4, r5, lr}
 8046768:	460c      	mov	r4, r1
 804676a:	4605      	mov	r5, r0
    LWIP_ASSERT("invalid socket state for err callback", pcb->state != LISTEN);
 804676c:	7d03      	ldrb	r3, [r0, #20]
 804676e:	2b01      	cmp	r3, #1
 8046770:	d002      	beq.n	8046778 <tcp_err+0x14>
    pcb->errf = err;
 8046772:	f8c5 408c 	str.w	r4, [r5, #140]	; 0x8c
  }
}
 8046776:	bd38      	pop	{r3, r4, r5, pc}
    LWIP_ASSERT("invalid socket state for err callback", pcb->state != LISTEN);
 8046778:	4b04      	ldr	r3, [pc, #16]	; (804678c <tcp_err+0x28>)
 804677a:	f44f 62dc 	mov.w	r2, #1760	; 0x6e0
 804677e:	4904      	ldr	r1, [pc, #16]	; (8046790 <tcp_err+0x2c>)
 8046780:	4804      	ldr	r0, [pc, #16]	; (8046794 <tcp_err+0x30>)
 8046782:	f00b f961 	bl	8051a48 <printf>
 8046786:	e7f4      	b.n	8046772 <tcp_err+0xe>
 8046788:	4770      	bx	lr
 804678a:	bf00      	nop
 804678c:	08059618 	.word	0x08059618
 8046790:	08059770 	.word	0x08059770
 8046794:	08058ecc 	.word	0x08058ecc

08046798 <tcp_poll>:
 * timer interval, which is called twice a second.
 *
 */
void
tcp_poll(struct tcp_pcb *pcb, tcp_poll_fn poll, u8_t interval)
{
 8046798:	b570      	push	{r4, r5, r6, lr}
 804679a:	4604      	mov	r4, r0
 804679c:	460e      	mov	r6, r1
 804679e:	4615      	mov	r5, r2
  LWIP_ASSERT("invalid socket state for poll", pcb->state != LISTEN);
 80467a0:	7d03      	ldrb	r3, [r0, #20]
 80467a2:	2b01      	cmp	r3, #1
 80467a4:	d003      	beq.n	80467ae <tcp_poll+0x16>
#if LWIP_CALLBACK_API
  pcb->poll = poll;
 80467a6:	f8c4 6088 	str.w	r6, [r4, #136]	; 0x88
#else /* LWIP_CALLBACK_API */
  LWIP_UNUSED_ARG(poll);
#endif /* LWIP_CALLBACK_API */
  pcb->pollinterval = interval;
 80467aa:	7725      	strb	r5, [r4, #28]
}
 80467ac:	bd70      	pop	{r4, r5, r6, pc}
  LWIP_ASSERT("invalid socket state for poll", pcb->state != LISTEN);
 80467ae:	4b04      	ldr	r3, [pc, #16]	; (80467c0 <tcp_poll+0x28>)
 80467b0:	f240 7203 	movw	r2, #1795	; 0x703
 80467b4:	4903      	ldr	r1, [pc, #12]	; (80467c4 <tcp_poll+0x2c>)
 80467b6:	4804      	ldr	r0, [pc, #16]	; (80467c8 <tcp_poll+0x30>)
 80467b8:	f00b f946 	bl	8051a48 <printf>
 80467bc:	e7f3      	b.n	80467a6 <tcp_poll+0xe>
 80467be:	bf00      	nop
 80467c0:	08059618 	.word	0x08059618
 80467c4:	08059798 	.word	0x08059798
 80467c8:	08058ecc 	.word	0x08058ecc

080467cc <tcp_pcb_purge>:
 *
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
 80467cc:	b538      	push	{r3, r4, r5, lr}
  if (pcb->state != CLOSED &&
 80467ce:	7d03      	ldrb	r3, [r0, #20]
 80467d0:	b1e3      	cbz	r3, 804680c <tcp_pcb_purge+0x40>
 80467d2:	4604      	mov	r4, r0
 80467d4:	2b0a      	cmp	r3, #10
 80467d6:	d019      	beq.n	804680c <tcp_pcb_purge+0x40>
     pcb->state != TIME_WAIT &&
 80467d8:	2b01      	cmp	r3, #1
 80467da:	d017      	beq.n	804680c <tcp_pcb_purge+0x40>

    LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge\n"));

    tcp_backlog_accepted(pcb);

    if (pcb->refused_data != NULL) {
 80467dc:	6f40      	ldr	r0, [r0, #116]	; 0x74
 80467de:	b118      	cbz	r0, 80467e8 <tcp_pcb_purge+0x1c>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->refused_data\n"));
      pbuf_free(pcb->refused_data);
 80467e0:	f7ff fa7c 	bl	8045cdc <pbuf_free>
      pcb->refused_data = NULL;
 80467e4:	2300      	movs	r3, #0
 80467e6:	6763      	str	r3, [r4, #116]	; 0x74
    }
#if TCP_QUEUE_OOSEQ
    if (pcb->ooseq != NULL) {
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->ooseq\n"));
    }
    tcp_segs_free(pcb->ooseq);
 80467e8:	6f20      	ldr	r0, [r4, #112]	; 0x70
 80467ea:	f7ff ff68 	bl	80466be <tcp_segs_free>
    pcb->ooseq = NULL;
 80467ee:	2500      	movs	r5, #0
 80467f0:	6725      	str	r5, [r4, #112]	; 0x70
#endif /* TCP_QUEUE_OOSEQ */

    /* Stop the retransmission timer as it will expect data on unacked
       queue if it fires */
    pcb->rtime = -1;
 80467f2:	f64f 73ff 	movw	r3, #65535	; 0xffff
 80467f6:	8623      	strh	r3, [r4, #48]	; 0x30

    tcp_segs_free(pcb->unsent);
 80467f8:	6ea0      	ldr	r0, [r4, #104]	; 0x68
 80467fa:	f7ff ff60 	bl	80466be <tcp_segs_free>
    tcp_segs_free(pcb->unacked);
 80467fe:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
 8046800:	f7ff ff5d 	bl	80466be <tcp_segs_free>
    pcb->unacked = pcb->unsent = NULL;
 8046804:	66a5      	str	r5, [r4, #104]	; 0x68
 8046806:	66e5      	str	r5, [r4, #108]	; 0x6c
#if TCP_OVERSIZE
    pcb->unsent_oversize = 0;
 8046808:	f8a4 5064 	strh.w	r5, [r4, #100]	; 0x64
#endif /* TCP_OVERSIZE */
  }
}
 804680c:	bd38      	pop	{r3, r4, r5, pc}
	...

08046810 <tcp_slowtmr>:
{
 8046810:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8046814:	b082      	sub	sp, #8
  ++tcp_ticks;
 8046816:	4aae      	ldr	r2, [pc, #696]	; (8046ad0 <tcp_slowtmr+0x2c0>)
 8046818:	6813      	ldr	r3, [r2, #0]
 804681a:	3301      	adds	r3, #1
 804681c:	6013      	str	r3, [r2, #0]
  ++tcp_timer_ctr;
 804681e:	4aad      	ldr	r2, [pc, #692]	; (8046ad4 <tcp_slowtmr+0x2c4>)
 8046820:	7813      	ldrb	r3, [r2, #0]
 8046822:	3301      	adds	r3, #1
 8046824:	7013      	strb	r3, [r2, #0]
  pcb = tcp_active_pcbs;
 8046826:	4bac      	ldr	r3, [pc, #688]	; (8046ad8 <tcp_slowtmr+0x2c8>)
 8046828:	681c      	ldr	r4, [r3, #0]
  prev = NULL;
 804682a:	2600      	movs	r6, #0
  while (pcb != NULL) {
 804682c:	e16e      	b.n	8046b0c <tcp_slowtmr+0x2fc>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
 804682e:	4bab      	ldr	r3, [pc, #684]	; (8046adc <tcp_slowtmr+0x2cc>)
 8046830:	f44f 727c 	mov.w	r2, #1008	; 0x3f0
 8046834:	49aa      	ldr	r1, [pc, #680]	; (8046ae0 <tcp_slowtmr+0x2d0>)
 8046836:	48ab      	ldr	r0, [pc, #684]	; (8046ae4 <tcp_slowtmr+0x2d4>)
 8046838:	f00b f906 	bl	8051a48 <printf>
 804683c:	e16b      	b.n	8046b16 <tcp_slowtmr+0x306>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
 804683e:	4ba7      	ldr	r3, [pc, #668]	; (8046adc <tcp_slowtmr+0x2cc>)
 8046840:	f240 32f1 	movw	r2, #1009	; 0x3f1
 8046844:	49a8      	ldr	r1, [pc, #672]	; (8046ae8 <tcp_slowtmr+0x2d8>)
 8046846:	48a7      	ldr	r0, [pc, #668]	; (8046ae4 <tcp_slowtmr+0x2d4>)
 8046848:	f00b f8fe 	bl	8051a48 <printf>
 804684c:	e167      	b.n	8046b1e <tcp_slowtmr+0x30e>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);
 804684e:	4ba3      	ldr	r3, [pc, #652]	; (8046adc <tcp_slowtmr+0x2cc>)
 8046850:	f240 32f2 	movw	r2, #1010	; 0x3f2
 8046854:	49a5      	ldr	r1, [pc, #660]	; (8046aec <tcp_slowtmr+0x2dc>)
 8046856:	48a3      	ldr	r0, [pc, #652]	; (8046ae4 <tcp_slowtmr+0x2d4>)
 8046858:	f00b f8f6 	bl	8051a48 <printf>
 804685c:	e163      	b.n	8046b26 <tcp_slowtmr+0x316>
      pcb = pcb->next;
 804685e:	68e4      	ldr	r4, [r4, #12]
      continue;
 8046860:	e154      	b.n	8046b0c <tcp_slowtmr+0x2fc>
    if (pcb->state == SYN_SENT && pcb->nrtx >= TCP_SYNMAXRTX) {
 8046862:	f894 2042 	ldrb.w	r2, [r4, #66]	; 0x42
 8046866:	2a05      	cmp	r2, #5
 8046868:	f240 8168 	bls.w	8046b3c <tcp_slowtmr+0x32c>
      ++pcb_remove;
 804686c:	2501      	movs	r5, #1
 804686e:	e04c      	b.n	804690a <tcp_slowtmr+0xfa>
          if (tcp_zero_window_probe(pcb) == ERR_OK) {
 8046870:	4620      	mov	r0, r4
 8046872:	f003 f879 	bl	8049968 <tcp_zero_window_probe>
 8046876:	2800      	cmp	r0, #0
 8046878:	f040 8087 	bne.w	804698a <tcp_slowtmr+0x17a>
            pcb->persist_cnt = 0;
 804687c:	2300      	movs	r3, #0
 804687e:	f884 3094 	strb.w	r3, [r4, #148]	; 0x94
            if (pcb->persist_backoff < sizeof(tcp_persist_backoff)) {
 8046882:	f894 3095 	ldrb.w	r3, [r4, #149]	; 0x95
 8046886:	2b06      	cmp	r3, #6
 8046888:	f200 8081 	bhi.w	804698e <tcp_slowtmr+0x17e>
              pcb->persist_backoff++;
 804688c:	3301      	adds	r3, #1
 804688e:	f884 3095 	strb.w	r3, [r4, #149]	; 0x95
    pcb_remove = 0;
 8046892:	2500      	movs	r5, #0
 8046894:	e039      	b.n	804690a <tcp_slowtmr+0xfa>
        if (pcb->rtime >= 0) {
 8046896:	f9b4 1030 	ldrsh.w	r1, [r4, #48]	; 0x30
 804689a:	2900      	cmp	r1, #0
 804689c:	db01      	blt.n	80468a2 <tcp_slowtmr+0x92>
          ++pcb->rtime;
 804689e:	3101      	adds	r1, #1
 80468a0:	8621      	strh	r1, [r4, #48]	; 0x30
        if (pcb->unacked != NULL && pcb->rtime >= pcb->rto) {
 80468a2:	6ee1      	ldr	r1, [r4, #108]	; 0x6c
 80468a4:	b389      	cbz	r1, 804690a <tcp_slowtmr+0xfa>
 80468a6:	f9b4 0030 	ldrsh.w	r0, [r4, #48]	; 0x30
 80468aa:	f9b4 1040 	ldrsh.w	r1, [r4, #64]	; 0x40
 80468ae:	4288      	cmp	r0, r1
 80468b0:	db2b      	blt.n	804690a <tcp_slowtmr+0xfa>
          if (pcb->state != SYN_SENT) {
 80468b2:	2b02      	cmp	r3, #2
 80468b4:	d00f      	beq.n	80468d6 <tcp_slowtmr+0xc6>
            pcb->rto = ((pcb->sa >> 3) + pcb->sv) << tcp_backoff[backoff_idx];
 80468b6:	f9b4 103c 	ldrsh.w	r1, [r4, #60]	; 0x3c
 80468ba:	f9b4 303e 	ldrsh.w	r3, [r4, #62]	; 0x3e
 80468be:	eb03 03e1 	add.w	r3, r3, r1, asr #3
 80468c2:	498b      	ldr	r1, [pc, #556]	; (8046af0 <tcp_slowtmr+0x2e0>)
 80468c4:	2a0c      	cmp	r2, #12
 80468c6:	bf94      	ite	ls
 80468c8:	188a      	addls	r2, r1, r2
 80468ca:	f101 020c 	addhi.w	r2, r1, #12
 80468ce:	7e12      	ldrb	r2, [r2, #24]
 80468d0:	4093      	lsls	r3, r2
 80468d2:	f8a4 3040 	strh.w	r3, [r4, #64]	; 0x40
          pcb->rtime = 0;
 80468d6:	2300      	movs	r3, #0
 80468d8:	8623      	strh	r3, [r4, #48]	; 0x30
          eff_wnd = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
 80468da:	f8b4 305c 	ldrh.w	r3, [r4, #92]	; 0x5c
 80468de:	f8b4 2048 	ldrh.w	r2, [r4, #72]	; 0x48
 80468e2:	4293      	cmp	r3, r2
 80468e4:	bf28      	it	cs
 80468e6:	4613      	movcs	r3, r2
          pcb->ssthresh = eff_wnd >> 1;
 80468e8:	085b      	lsrs	r3, r3, #1
 80468ea:	f8a4 304a 	strh.w	r3, [r4, #74]	; 0x4a
          if (pcb->ssthresh < (tcpwnd_size_t)(pcb->mss << 1)) {
 80468ee:	8e61      	ldrh	r1, [r4, #50]	; 0x32
 80468f0:	004a      	lsls	r2, r1, #1
 80468f2:	b292      	uxth	r2, r2
 80468f4:	4293      	cmp	r3, r2
 80468f6:	d201      	bcs.n	80468fc <tcp_slowtmr+0xec>
            pcb->ssthresh = (pcb->mss << 1);
 80468f8:	f8a4 204a 	strh.w	r2, [r4, #74]	; 0x4a
          pcb->cwnd = pcb->mss;
 80468fc:	f8a4 1048 	strh.w	r1, [r4, #72]	; 0x48
          tcp_rexmit_rto(pcb);
 8046900:	4620      	mov	r0, r4
 8046902:	f002 ff97 	bl	8049834 <tcp_rexmit_rto>
 8046906:	e000      	b.n	804690a <tcp_slowtmr+0xfa>
      ++pcb_remove;
 8046908:	2501      	movs	r5, #1
    if (pcb->state == FIN_WAIT_2) {
 804690a:	7d22      	ldrb	r2, [r4, #20]
 804690c:	2a06      	cmp	r2, #6
 804690e:	d040      	beq.n	8046992 <tcp_slowtmr+0x182>
    if (ip_get_option(pcb, SOF_KEEPALIVE) &&
 8046910:	7a23      	ldrb	r3, [r4, #8]
 8046912:	f013 0708 	ands.w	r7, r3, #8
 8046916:	d004      	beq.n	8046922 <tcp_slowtmr+0x112>
 8046918:	2a04      	cmp	r2, #4
 804691a:	d047      	beq.n	80469ac <tcp_slowtmr+0x19c>
       ((pcb->state == ESTABLISHED) ||
 804691c:	2a07      	cmp	r2, #7
 804691e:	d045      	beq.n	80469ac <tcp_slowtmr+0x19c>
    pcb_reset = 0;
 8046920:	2700      	movs	r7, #0
    if (pcb->ooseq != NULL &&
 8046922:	6f20      	ldr	r0, [r4, #112]	; 0x70
 8046924:	b150      	cbz	r0, 804693c <tcp_slowtmr+0x12c>
        (u32_t)tcp_ticks - pcb->tmr >= pcb->rto * TCP_OOSEQ_TIMEOUT) {
 8046926:	4b6a      	ldr	r3, [pc, #424]	; (8046ad0 <tcp_slowtmr+0x2c0>)
 8046928:	681a      	ldr	r2, [r3, #0]
 804692a:	6a23      	ldr	r3, [r4, #32]
 804692c:	1ad2      	subs	r2, r2, r3
 804692e:	f9b4 3040 	ldrsh.w	r3, [r4, #64]	; 0x40
 8046932:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    if (pcb->ooseq != NULL &&
 8046936:	ebb2 0f43 	cmp.w	r2, r3, lsl #1
 804693a:	d265      	bcs.n	8046a08 <tcp_slowtmr+0x1f8>
    if (pcb->state == SYN_RCVD) {
 804693c:	7d23      	ldrb	r3, [r4, #20]
 804693e:	2b03      	cmp	r3, #3
 8046940:	d067      	beq.n	8046a12 <tcp_slowtmr+0x202>
    if (pcb->state == LAST_ACK) {
 8046942:	2b09      	cmp	r3, #9
 8046944:	d06e      	beq.n	8046a24 <tcp_slowtmr+0x214>
    if (pcb_remove) {
 8046946:	2d00      	cmp	r5, #0
 8046948:	d175      	bne.n	8046a36 <tcp_slowtmr+0x226>
      pcb = pcb->next;
 804694a:	68e5      	ldr	r5, [r4, #12]
      ++prev->polltmr;
 804694c:	7ee3      	ldrb	r3, [r4, #27]
 804694e:	3301      	adds	r3, #1
 8046950:	b2db      	uxtb	r3, r3
 8046952:	76e3      	strb	r3, [r4, #27]
      if (prev->polltmr >= prev->pollinterval) {
 8046954:	7f22      	ldrb	r2, [r4, #28]
 8046956:	4293      	cmp	r3, r2
 8046958:	f0c0 80d6 	bcc.w	8046b08 <tcp_slowtmr+0x2f8>
        prev->polltmr = 0;
 804695c:	2300      	movs	r3, #0
 804695e:	76e3      	strb	r3, [r4, #27]
        tcp_active_pcbs_changed = 0;
 8046960:	4a64      	ldr	r2, [pc, #400]	; (8046af4 <tcp_slowtmr+0x2e4>)
 8046962:	7013      	strb	r3, [r2, #0]
        TCP_EVENT_POLL(prev, err);
 8046964:	f8d4 3088 	ldr.w	r3, [r4, #136]	; 0x88
 8046968:	2b00      	cmp	r3, #0
 804696a:	f000 80a9 	beq.w	8046ac0 <tcp_slowtmr+0x2b0>
 804696e:	4621      	mov	r1, r4
 8046970:	6920      	ldr	r0, [r4, #16]
 8046972:	4798      	blx	r3
        if (tcp_active_pcbs_changed) {
 8046974:	4b5f      	ldr	r3, [pc, #380]	; (8046af4 <tcp_slowtmr+0x2e4>)
 8046976:	781b      	ldrb	r3, [r3, #0]
 8046978:	2b00      	cmp	r3, #0
 804697a:	f47f af54 	bne.w	8046826 <tcp_slowtmr+0x16>
        if (err == ERR_OK) {
 804697e:	2800      	cmp	r0, #0
 8046980:	f000 80a0 	beq.w	8046ac4 <tcp_slowtmr+0x2b4>
      prev = pcb;
 8046984:	4626      	mov	r6, r4
      pcb = pcb->next;
 8046986:	462c      	mov	r4, r5
 8046988:	e0c0      	b.n	8046b0c <tcp_slowtmr+0x2fc>
    pcb_remove = 0;
 804698a:	2500      	movs	r5, #0
 804698c:	e7bd      	b.n	804690a <tcp_slowtmr+0xfa>
 804698e:	2500      	movs	r5, #0
 8046990:	e7bb      	b.n	804690a <tcp_slowtmr+0xfa>
      if (pcb->flags & TF_RXCLOSED) {
 8046992:	7ea3      	ldrb	r3, [r4, #26]
 8046994:	f013 0f10 	tst.w	r3, #16
 8046998:	d0ba      	beq.n	8046910 <tcp_slowtmr+0x100>
        if ((u32_t)(tcp_ticks - pcb->tmr) >
 804699a:	6a21      	ldr	r1, [r4, #32]
 804699c:	4b4c      	ldr	r3, [pc, #304]	; (8046ad0 <tcp_slowtmr+0x2c0>)
 804699e:	681b      	ldr	r3, [r3, #0]
 80469a0:	1a5b      	subs	r3, r3, r1
 80469a2:	2b28      	cmp	r3, #40	; 0x28
 80469a4:	d9b4      	bls.n	8046910 <tcp_slowtmr+0x100>
          ++pcb_remove;
 80469a6:	3501      	adds	r5, #1
 80469a8:	b2ed      	uxtb	r5, r5
 80469aa:	e7b1      	b.n	8046910 <tcp_slowtmr+0x100>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
 80469ac:	4b48      	ldr	r3, [pc, #288]	; (8046ad0 <tcp_slowtmr+0x2c0>)
 80469ae:	681a      	ldr	r2, [r3, #0]
 80469b0:	6a23      	ldr	r3, [r4, #32]
 80469b2:	1ad2      	subs	r2, r2, r3
         (pcb->keep_idle + TCP_KEEP_DUR(pcb)) / TCP_SLOW_INTERVAL)
 80469b4:	f8d4 1090 	ldr.w	r1, [r4, #144]	; 0x90
 80469b8:	f501 2324 	add.w	r3, r1, #671744	; 0xa4000
 80469bc:	f603 43b8 	addw	r3, r3, #3256	; 0xcb8
 80469c0:	484d      	ldr	r0, [pc, #308]	; (8046af8 <tcp_slowtmr+0x2e8>)
 80469c2:	fba0 0303 	umull	r0, r3, r0, r3
      if ((u32_t)(tcp_ticks - pcb->tmr) >
 80469c6:	ebb2 1f53 	cmp.w	r2, r3, lsr #5
 80469ca:	d903      	bls.n	80469d4 <tcp_slowtmr+0x1c4>
        ++pcb_remove;
 80469cc:	3501      	adds	r5, #1
 80469ce:	b2ed      	uxtb	r5, r5
        ++pcb_reset;
 80469d0:	2701      	movs	r7, #1
 80469d2:	e7a6      	b.n	8046922 <tcp_slowtmr+0x112>
                (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEP_INTVL(pcb))
 80469d4:	f894 3096 	ldrb.w	r3, [r4, #150]	; 0x96
 80469d8:	4848      	ldr	r0, [pc, #288]	; (8046afc <tcp_slowtmr+0x2ec>)
 80469da:	fb00 1303 	mla	r3, r0, r3, r1
                / TCP_SLOW_INTERVAL)
 80469de:	4946      	ldr	r1, [pc, #280]	; (8046af8 <tcp_slowtmr+0x2e8>)
 80469e0:	fba1 1303 	umull	r1, r3, r1, r3
      } else if ((u32_t)(tcp_ticks - pcb->tmr) >
 80469e4:	ebb2 1f53 	cmp.w	r2, r3, lsr #5
 80469e8:	d801      	bhi.n	80469ee <tcp_slowtmr+0x1de>
    pcb_reset = 0;
 80469ea:	2700      	movs	r7, #0
 80469ec:	e799      	b.n	8046922 <tcp_slowtmr+0x112>
        err = tcp_keepalive(pcb);
 80469ee:	4620      	mov	r0, r4
 80469f0:	f002 ff8e 	bl	8049910 <tcp_keepalive>
        if (err == ERR_OK) {
 80469f4:	b930      	cbnz	r0, 8046a04 <tcp_slowtmr+0x1f4>
          pcb->keep_cnt_sent++;
 80469f6:	f894 3096 	ldrb.w	r3, [r4, #150]	; 0x96
 80469fa:	3301      	adds	r3, #1
 80469fc:	f884 3096 	strb.w	r3, [r4, #150]	; 0x96
    pcb_reset = 0;
 8046a00:	2700      	movs	r7, #0
 8046a02:	e78e      	b.n	8046922 <tcp_slowtmr+0x112>
 8046a04:	2700      	movs	r7, #0
 8046a06:	e78c      	b.n	8046922 <tcp_slowtmr+0x112>
      tcp_segs_free(pcb->ooseq);
 8046a08:	f7ff fe59 	bl	80466be <tcp_segs_free>
      pcb->ooseq = NULL;
 8046a0c:	2300      	movs	r3, #0
 8046a0e:	6723      	str	r3, [r4, #112]	; 0x70
 8046a10:	e794      	b.n	804693c <tcp_slowtmr+0x12c>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
 8046a12:	6a21      	ldr	r1, [r4, #32]
 8046a14:	4a2e      	ldr	r2, [pc, #184]	; (8046ad0 <tcp_slowtmr+0x2c0>)
 8046a16:	6812      	ldr	r2, [r2, #0]
 8046a18:	1a52      	subs	r2, r2, r1
 8046a1a:	2a28      	cmp	r2, #40	; 0x28
 8046a1c:	d991      	bls.n	8046942 <tcp_slowtmr+0x132>
        ++pcb_remove;
 8046a1e:	3501      	adds	r5, #1
 8046a20:	b2ed      	uxtb	r5, r5
 8046a22:	e78e      	b.n	8046942 <tcp_slowtmr+0x132>
      if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
 8046a24:	6a22      	ldr	r2, [r4, #32]
 8046a26:	4b2a      	ldr	r3, [pc, #168]	; (8046ad0 <tcp_slowtmr+0x2c0>)
 8046a28:	681b      	ldr	r3, [r3, #0]
 8046a2a:	1a9b      	subs	r3, r3, r2
 8046a2c:	2bf0      	cmp	r3, #240	; 0xf0
 8046a2e:	d98a      	bls.n	8046946 <tcp_slowtmr+0x136>
        ++pcb_remove;
 8046a30:	3501      	adds	r5, #1
 8046a32:	b2ed      	uxtb	r5, r5
 8046a34:	e787      	b.n	8046946 <tcp_slowtmr+0x136>
      tcp_err_fn err_fn = pcb->errf;
 8046a36:	f8d4 508c 	ldr.w	r5, [r4, #140]	; 0x8c
      tcp_pcb_purge(pcb);
 8046a3a:	4620      	mov	r0, r4
 8046a3c:	f7ff fec6 	bl	80467cc <tcp_pcb_purge>
      if (prev != NULL) {
 8046a40:	b326      	cbz	r6, 8046a8c <tcp_slowtmr+0x27c>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
 8046a42:	4b25      	ldr	r3, [pc, #148]	; (8046ad8 <tcp_slowtmr+0x2c8>)
 8046a44:	681b      	ldr	r3, [r3, #0]
 8046a46:	42a3      	cmp	r3, r4
 8046a48:	d018      	beq.n	8046a7c <tcp_slowtmr+0x26c>
        prev->next = pcb->next;
 8046a4a:	68e3      	ldr	r3, [r4, #12]
 8046a4c:	60f3      	str	r3, [r6, #12]
      if (pcb_reset) {
 8046a4e:	bb67      	cbnz	r7, 8046aaa <tcp_slowtmr+0x29a>
      err_arg = pcb->callback_arg;
 8046a50:	f8d4 8010 	ldr.w	r8, [r4, #16]
      pcb = pcb->next;
 8046a54:	68e7      	ldr	r7, [r4, #12]
      memp_free(MEMP_TCP_PCB, pcb2);
 8046a56:	4621      	mov	r1, r4
 8046a58:	2001      	movs	r0, #1
 8046a5a:	f7fe ff8b 	bl	8045974 <memp_free>
      tcp_active_pcbs_changed = 0;
 8046a5e:	4b25      	ldr	r3, [pc, #148]	; (8046af4 <tcp_slowtmr+0x2e4>)
 8046a60:	2200      	movs	r2, #0
 8046a62:	701a      	strb	r2, [r3, #0]
      TCP_EVENT_ERR(last_state, err_fn, err_arg, ERR_ABRT);
 8046a64:	b11d      	cbz	r5, 8046a6e <tcp_slowtmr+0x25e>
 8046a66:	f06f 010c 	mvn.w	r1, #12
 8046a6a:	4640      	mov	r0, r8
 8046a6c:	47a8      	blx	r5
      if (tcp_active_pcbs_changed) {
 8046a6e:	4b21      	ldr	r3, [pc, #132]	; (8046af4 <tcp_slowtmr+0x2e4>)
 8046a70:	781b      	ldrb	r3, [r3, #0]
 8046a72:	2b00      	cmp	r3, #0
 8046a74:	f47f aed7 	bne.w	8046826 <tcp_slowtmr+0x16>
      pcb = pcb->next;
 8046a78:	463c      	mov	r4, r7
 8046a7a:	e047      	b.n	8046b0c <tcp_slowtmr+0x2fc>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
 8046a7c:	4b17      	ldr	r3, [pc, #92]	; (8046adc <tcp_slowtmr+0x2cc>)
 8046a7e:	f240 4289 	movw	r2, #1161	; 0x489
 8046a82:	491f      	ldr	r1, [pc, #124]	; (8046b00 <tcp_slowtmr+0x2f0>)
 8046a84:	4817      	ldr	r0, [pc, #92]	; (8046ae4 <tcp_slowtmr+0x2d4>)
 8046a86:	f00a ffdf 	bl	8051a48 <printf>
 8046a8a:	e7de      	b.n	8046a4a <tcp_slowtmr+0x23a>
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
 8046a8c:	4b12      	ldr	r3, [pc, #72]	; (8046ad8 <tcp_slowtmr+0x2c8>)
 8046a8e:	681b      	ldr	r3, [r3, #0]
 8046a90:	42a3      	cmp	r3, r4
 8046a92:	d006      	beq.n	8046aa2 <tcp_slowtmr+0x292>
 8046a94:	4b11      	ldr	r3, [pc, #68]	; (8046adc <tcp_slowtmr+0x2cc>)
 8046a96:	f240 428d 	movw	r2, #1165	; 0x48d
 8046a9a:	491a      	ldr	r1, [pc, #104]	; (8046b04 <tcp_slowtmr+0x2f4>)
 8046a9c:	4811      	ldr	r0, [pc, #68]	; (8046ae4 <tcp_slowtmr+0x2d4>)
 8046a9e:	f00a ffd3 	bl	8051a48 <printf>
        tcp_active_pcbs = pcb->next;
 8046aa2:	68e2      	ldr	r2, [r4, #12]
 8046aa4:	4b0c      	ldr	r3, [pc, #48]	; (8046ad8 <tcp_slowtmr+0x2c8>)
 8046aa6:	601a      	str	r2, [r3, #0]
 8046aa8:	e7d1      	b.n	8046a4e <tcp_slowtmr+0x23e>
        tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
 8046aaa:	6a61      	ldr	r1, [r4, #36]	; 0x24
 8046aac:	6ce0      	ldr	r0, [r4, #76]	; 0x4c
 8046aae:	8b23      	ldrh	r3, [r4, #24]
 8046ab0:	9301      	str	r3, [sp, #4]
 8046ab2:	8ae3      	ldrh	r3, [r4, #22]
 8046ab4:	9300      	str	r3, [sp, #0]
 8046ab6:	1d23      	adds	r3, r4, #4
 8046ab8:	4622      	mov	r2, r4
 8046aba:	f002 fe65 	bl	8049788 <tcp_rst>
 8046abe:	e7c7      	b.n	8046a50 <tcp_slowtmr+0x240>
        TCP_EVENT_POLL(prev, err);
 8046ac0:	2000      	movs	r0, #0
 8046ac2:	e757      	b.n	8046974 <tcp_slowtmr+0x164>
          tcp_output(prev);
 8046ac4:	4620      	mov	r0, r4
 8046ac6:	f002 fd17 	bl	80494f8 <tcp_output>
      prev = pcb;
 8046aca:	4626      	mov	r6, r4
      pcb = pcb->next;
 8046acc:	462c      	mov	r4, r5
 8046ace:	e01d      	b.n	8046b0c <tcp_slowtmr+0x2fc>
 8046ad0:	20008724 	.word	0x20008724
 8046ad4:	200040d1 	.word	0x200040d1
 8046ad8:	20008720 	.word	0x20008720
 8046adc:	08059618 	.word	0x08059618
 8046ae0:	080597b8 	.word	0x080597b8
 8046ae4:	08058ecc 	.word	0x08058ecc
 8046ae8:	080597e4 	.word	0x080597e4
 8046aec:	08059810 	.word	0x08059810
 8046af0:	08058de8 	.word	0x08058de8
 8046af4:	2000871c 	.word	0x2000871c
 8046af8:	10624dd3 	.word	0x10624dd3
 8046afc:	000124f8 	.word	0x000124f8
 8046b00:	08059840 	.word	0x08059840
 8046b04:	0805986c 	.word	0x0805986c
      prev = pcb;
 8046b08:	4626      	mov	r6, r4
      pcb = pcb->next;
 8046b0a:	462c      	mov	r4, r5
  while (pcb != NULL) {
 8046b0c:	b394      	cbz	r4, 8046b74 <tcp_slowtmr+0x364>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
 8046b0e:	7d23      	ldrb	r3, [r4, #20]
 8046b10:	2b00      	cmp	r3, #0
 8046b12:	f43f ae8c 	beq.w	804682e <tcp_slowtmr+0x1e>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
 8046b16:	7d23      	ldrb	r3, [r4, #20]
 8046b18:	2b01      	cmp	r3, #1
 8046b1a:	f43f ae90 	beq.w	804683e <tcp_slowtmr+0x2e>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);
 8046b1e:	7d23      	ldrb	r3, [r4, #20]
 8046b20:	2b0a      	cmp	r3, #10
 8046b22:	f43f ae94 	beq.w	804684e <tcp_slowtmr+0x3e>
    if (pcb->last_timer == tcp_timer_ctr) {
 8046b26:	7f62      	ldrb	r2, [r4, #29]
 8046b28:	4b33      	ldr	r3, [pc, #204]	; (8046bf8 <tcp_slowtmr+0x3e8>)
 8046b2a:	781b      	ldrb	r3, [r3, #0]
 8046b2c:	429a      	cmp	r2, r3
 8046b2e:	f43f ae96 	beq.w	804685e <tcp_slowtmr+0x4e>
    pcb->last_timer = tcp_timer_ctr;
 8046b32:	7763      	strb	r3, [r4, #29]
    if (pcb->state == SYN_SENT && pcb->nrtx >= TCP_SYNMAXRTX) {
 8046b34:	7d23      	ldrb	r3, [r4, #20]
 8046b36:	2b02      	cmp	r3, #2
 8046b38:	f43f ae93 	beq.w	8046862 <tcp_slowtmr+0x52>
    else if (pcb->nrtx >= TCP_MAXRTX) {
 8046b3c:	f894 2042 	ldrb.w	r2, [r4, #66]	; 0x42
 8046b40:	2a0b      	cmp	r2, #11
 8046b42:	f63f aee1 	bhi.w	8046908 <tcp_slowtmr+0xf8>
      if (pcb->persist_backoff > 0) {
 8046b46:	f894 5095 	ldrb.w	r5, [r4, #149]	; 0x95
 8046b4a:	2d00      	cmp	r5, #0
 8046b4c:	f43f aea3 	beq.w	8046896 <tcp_slowtmr+0x86>
        u8_t backoff_cnt = tcp_persist_backoff[pcb->persist_backoff-1];
 8046b50:	3d01      	subs	r5, #1
 8046b52:	4b2a      	ldr	r3, [pc, #168]	; (8046bfc <tcp_slowtmr+0x3ec>)
 8046b54:	441d      	add	r5, r3
 8046b56:	7c2a      	ldrb	r2, [r5, #16]
        if (pcb->persist_cnt < backoff_cnt) {
 8046b58:	f894 3094 	ldrb.w	r3, [r4, #148]	; 0x94
 8046b5c:	4293      	cmp	r3, r2
 8046b5e:	d202      	bcs.n	8046b66 <tcp_slowtmr+0x356>
          pcb->persist_cnt++;
 8046b60:	3301      	adds	r3, #1
 8046b62:	f884 3094 	strb.w	r3, [r4, #148]	; 0x94
        if (pcb->persist_cnt >= backoff_cnt) {
 8046b66:	f894 3094 	ldrb.w	r3, [r4, #148]	; 0x94
 8046b6a:	4293      	cmp	r3, r2
 8046b6c:	f4bf ae80 	bcs.w	8046870 <tcp_slowtmr+0x60>
    pcb_remove = 0;
 8046b70:	2500      	movs	r5, #0
 8046b72:	e6ca      	b.n	804690a <tcp_slowtmr+0xfa>
  pcb = tcp_tw_pcbs;
 8046b74:	4b22      	ldr	r3, [pc, #136]	; (8046c00 <tcp_slowtmr+0x3f0>)
 8046b76:	681d      	ldr	r5, [r3, #0]
  while (pcb != NULL) {
 8046b78:	e00e      	b.n	8046b98 <tcp_slowtmr+0x388>
    LWIP_ASSERT("tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
 8046b7a:	4b22      	ldr	r3, [pc, #136]	; (8046c04 <tcp_slowtmr+0x3f4>)
 8046b7c:	f240 42bd 	movw	r2, #1213	; 0x4bd
 8046b80:	4921      	ldr	r1, [pc, #132]	; (8046c08 <tcp_slowtmr+0x3f8>)
 8046b82:	4822      	ldr	r0, [pc, #136]	; (8046c0c <tcp_slowtmr+0x3fc>)
 8046b84:	f00a ff60 	bl	8051a48 <printf>
    if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
 8046b88:	6a2a      	ldr	r2, [r5, #32]
 8046b8a:	4b21      	ldr	r3, [pc, #132]	; (8046c10 <tcp_slowtmr+0x400>)
 8046b8c:	681b      	ldr	r3, [r3, #0]
 8046b8e:	1a9b      	subs	r3, r3, r2
 8046b90:	2bf0      	cmp	r3, #240	; 0xf0
 8046b92:	d806      	bhi.n	8046ba2 <tcp_slowtmr+0x392>
      prev = pcb;
 8046b94:	462c      	mov	r4, r5
      pcb = pcb->next;
 8046b96:	68ed      	ldr	r5, [r5, #12]
  while (pcb != NULL) {
 8046b98:	b35d      	cbz	r5, 8046bf2 <tcp_slowtmr+0x3e2>
    LWIP_ASSERT("tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
 8046b9a:	7d2b      	ldrb	r3, [r5, #20]
 8046b9c:	2b0a      	cmp	r3, #10
 8046b9e:	d0f3      	beq.n	8046b88 <tcp_slowtmr+0x378>
 8046ba0:	e7eb      	b.n	8046b7a <tcp_slowtmr+0x36a>
      tcp_pcb_purge(pcb);
 8046ba2:	4628      	mov	r0, r5
 8046ba4:	f7ff fe12 	bl	80467cc <tcp_pcb_purge>
      if (prev != NULL) {
 8046ba8:	b1a4      	cbz	r4, 8046bd4 <tcp_slowtmr+0x3c4>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_tw_pcbs", pcb != tcp_tw_pcbs);
 8046baa:	4b15      	ldr	r3, [pc, #84]	; (8046c00 <tcp_slowtmr+0x3f0>)
 8046bac:	681b      	ldr	r3, [r3, #0]
 8046bae:	42ab      	cmp	r3, r5
 8046bb0:	d008      	beq.n	8046bc4 <tcp_slowtmr+0x3b4>
        prev->next = pcb->next;
 8046bb2:	68eb      	ldr	r3, [r5, #12]
 8046bb4:	60e3      	str	r3, [r4, #12]
      pcb = pcb->next;
 8046bb6:	68ee      	ldr	r6, [r5, #12]
      memp_free(MEMP_TCP_PCB, pcb2);
 8046bb8:	4629      	mov	r1, r5
 8046bba:	2001      	movs	r0, #1
 8046bbc:	f7fe feda 	bl	8045974 <memp_free>
      pcb = pcb->next;
 8046bc0:	4635      	mov	r5, r6
 8046bc2:	e7e9      	b.n	8046b98 <tcp_slowtmr+0x388>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_tw_pcbs", pcb != tcp_tw_pcbs);
 8046bc4:	4b0f      	ldr	r3, [pc, #60]	; (8046c04 <tcp_slowtmr+0x3f4>)
 8046bc6:	f240 42cb 	movw	r2, #1227	; 0x4cb
 8046bca:	4912      	ldr	r1, [pc, #72]	; (8046c14 <tcp_slowtmr+0x404>)
 8046bcc:	480f      	ldr	r0, [pc, #60]	; (8046c0c <tcp_slowtmr+0x3fc>)
 8046bce:	f00a ff3b 	bl	8051a48 <printf>
 8046bd2:	e7ee      	b.n	8046bb2 <tcp_slowtmr+0x3a2>
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_tw_pcbs", tcp_tw_pcbs == pcb);
 8046bd4:	4b0a      	ldr	r3, [pc, #40]	; (8046c00 <tcp_slowtmr+0x3f0>)
 8046bd6:	681b      	ldr	r3, [r3, #0]
 8046bd8:	42ab      	cmp	r3, r5
 8046bda:	d006      	beq.n	8046bea <tcp_slowtmr+0x3da>
 8046bdc:	4b09      	ldr	r3, [pc, #36]	; (8046c04 <tcp_slowtmr+0x3f4>)
 8046bde:	f240 42cf 	movw	r2, #1231	; 0x4cf
 8046be2:	490d      	ldr	r1, [pc, #52]	; (8046c18 <tcp_slowtmr+0x408>)
 8046be4:	4809      	ldr	r0, [pc, #36]	; (8046c0c <tcp_slowtmr+0x3fc>)
 8046be6:	f00a ff2f 	bl	8051a48 <printf>
        tcp_tw_pcbs = pcb->next;
 8046bea:	68ea      	ldr	r2, [r5, #12]
 8046bec:	4b04      	ldr	r3, [pc, #16]	; (8046c00 <tcp_slowtmr+0x3f0>)
 8046bee:	601a      	str	r2, [r3, #0]
 8046bf0:	e7e1      	b.n	8046bb6 <tcp_slowtmr+0x3a6>
}
 8046bf2:	b002      	add	sp, #8
 8046bf4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8046bf8:	200040d1 	.word	0x200040d1
 8046bfc:	08058de8 	.word	0x08058de8
 8046c00:	20008730 	.word	0x20008730
 8046c04:	08059618 	.word	0x08059618
 8046c08:	08059898 	.word	0x08059898
 8046c0c:	08058ecc 	.word	0x08058ecc
 8046c10:	20008724 	.word	0x20008724
 8046c14:	080598c8 	.word	0x080598c8
 8046c18:	080598f0 	.word	0x080598f0

08046c1c <tcp_pcb_remove>:
 * @param pcblist PCB list to purge.
 * @param pcb tcp_pcb to purge. The pcb itself is NOT deallocated!
 */
void
tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
{
 8046c1c:	b510      	push	{r4, lr}
 8046c1e:	460c      	mov	r4, r1
  TCP_RMV(pcblist, pcb);
 8046c20:	6803      	ldr	r3, [r0, #0]
 8046c22:	428b      	cmp	r3, r1
 8046c24:	d005      	beq.n	8046c32 <tcp_pcb_remove+0x16>
 8046c26:	b14b      	cbz	r3, 8046c3c <tcp_pcb_remove+0x20>
 8046c28:	68da      	ldr	r2, [r3, #12]
 8046c2a:	42a2      	cmp	r2, r4
 8046c2c:	d004      	beq.n	8046c38 <tcp_pcb_remove+0x1c>
 8046c2e:	4613      	mov	r3, r2
 8046c30:	e7f9      	b.n	8046c26 <tcp_pcb_remove+0xa>
 8046c32:	68db      	ldr	r3, [r3, #12]
 8046c34:	6003      	str	r3, [r0, #0]
 8046c36:	e001      	b.n	8046c3c <tcp_pcb_remove+0x20>
 8046c38:	68e2      	ldr	r2, [r4, #12]
 8046c3a:	60da      	str	r2, [r3, #12]
 8046c3c:	2300      	movs	r3, #0
 8046c3e:	60e3      	str	r3, [r4, #12]

  tcp_pcb_purge(pcb);
 8046c40:	4620      	mov	r0, r4
 8046c42:	f7ff fdc3 	bl	80467cc <tcp_pcb_purge>

  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
 8046c46:	7d23      	ldrb	r3, [r4, #20]
 8046c48:	2b0a      	cmp	r3, #10
 8046c4a:	d005      	beq.n	8046c58 <tcp_pcb_remove+0x3c>
 8046c4c:	2b01      	cmp	r3, #1
 8046c4e:	d003      	beq.n	8046c58 <tcp_pcb_remove+0x3c>
     pcb->state != LISTEN &&
     pcb->flags & TF_ACK_DELAY) {
 8046c50:	7ea3      	ldrb	r3, [r4, #26]
     pcb->state != LISTEN &&
 8046c52:	f013 0f01 	tst.w	r3, #1
 8046c56:	d121      	bne.n	8046c9c <tcp_pcb_remove+0x80>
    pcb->flags |= TF_ACK_NOW;
    tcp_output(pcb);
  }

  if (pcb->state != LISTEN) {
 8046c58:	7d23      	ldrb	r3, [r4, #20]
 8046c5a:	2b01      	cmp	r3, #1
 8046c5c:	d01a      	beq.n	8046c94 <tcp_pcb_remove+0x78>
    LWIP_ASSERT("unsent segments leaking", pcb->unsent == NULL);
 8046c5e:	6ea3      	ldr	r3, [r4, #104]	; 0x68
 8046c60:	b133      	cbz	r3, 8046c70 <tcp_pcb_remove+0x54>
 8046c62:	4b12      	ldr	r3, [pc, #72]	; (8046cac <tcp_pcb_remove+0x90>)
 8046c64:	f240 7253 	movw	r2, #1875	; 0x753
 8046c68:	4911      	ldr	r1, [pc, #68]	; (8046cb0 <tcp_pcb_remove+0x94>)
 8046c6a:	4812      	ldr	r0, [pc, #72]	; (8046cb4 <tcp_pcb_remove+0x98>)
 8046c6c:	f00a feec 	bl	8051a48 <printf>
    LWIP_ASSERT("unacked segments leaking", pcb->unacked == NULL);
 8046c70:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 8046c72:	b133      	cbz	r3, 8046c82 <tcp_pcb_remove+0x66>
 8046c74:	4b0d      	ldr	r3, [pc, #52]	; (8046cac <tcp_pcb_remove+0x90>)
 8046c76:	f240 7254 	movw	r2, #1876	; 0x754
 8046c7a:	490f      	ldr	r1, [pc, #60]	; (8046cb8 <tcp_pcb_remove+0x9c>)
 8046c7c:	480d      	ldr	r0, [pc, #52]	; (8046cb4 <tcp_pcb_remove+0x98>)
 8046c7e:	f00a fee3 	bl	8051a48 <printf>
#if TCP_QUEUE_OOSEQ
    LWIP_ASSERT("ooseq segments leaking", pcb->ooseq == NULL);
 8046c82:	6f23      	ldr	r3, [r4, #112]	; 0x70
 8046c84:	b133      	cbz	r3, 8046c94 <tcp_pcb_remove+0x78>
 8046c86:	4b09      	ldr	r3, [pc, #36]	; (8046cac <tcp_pcb_remove+0x90>)
 8046c88:	f240 7256 	movw	r2, #1878	; 0x756
 8046c8c:	490b      	ldr	r1, [pc, #44]	; (8046cbc <tcp_pcb_remove+0xa0>)
 8046c8e:	4809      	ldr	r0, [pc, #36]	; (8046cb4 <tcp_pcb_remove+0x98>)
 8046c90:	f00a feda 	bl	8051a48 <printf>
#endif /* TCP_QUEUE_OOSEQ */
  }

  pcb->state = CLOSED;
 8046c94:	2300      	movs	r3, #0
 8046c96:	7523      	strb	r3, [r4, #20]
  /* reset the local port to prevent the pcb from being 'bound' */
  pcb->local_port = 0;
 8046c98:	82e3      	strh	r3, [r4, #22]

  LWIP_ASSERT("tcp_pcb_remove: tcp_pcbs_sane()", tcp_pcbs_sane());
}
 8046c9a:	bd10      	pop	{r4, pc}
    pcb->flags |= TF_ACK_NOW;
 8046c9c:	f043 0302 	orr.w	r3, r3, #2
 8046ca0:	76a3      	strb	r3, [r4, #26]
    tcp_output(pcb);
 8046ca2:	4620      	mov	r0, r4
 8046ca4:	f002 fc28 	bl	80494f8 <tcp_output>
 8046ca8:	e7d6      	b.n	8046c58 <tcp_pcb_remove+0x3c>
 8046caa:	bf00      	nop
 8046cac:	08059618 	.word	0x08059618
 8046cb0:	08059918 	.word	0x08059918
 8046cb4:	08058ecc 	.word	0x08058ecc
 8046cb8:	08059930 	.word	0x08059930
 8046cbc:	0805994c 	.word	0x0805994c

08046cc0 <tcp_close_shutdown>:
{
 8046cc0:	b510      	push	{r4, lr}
 8046cc2:	b082      	sub	sp, #8
 8046cc4:	4604      	mov	r4, r0
  if (rst_on_unacked_data && ((pcb->state == ESTABLISHED) || (pcb->state == CLOSE_WAIT))) {
 8046cc6:	b121      	cbz	r1, 8046cd2 <tcp_close_shutdown+0x12>
 8046cc8:	7d03      	ldrb	r3, [r0, #20]
 8046cca:	2b04      	cmp	r3, #4
 8046ccc:	d00c      	beq.n	8046ce8 <tcp_close_shutdown+0x28>
 8046cce:	2b07      	cmp	r3, #7
 8046cd0:	d00a      	beq.n	8046ce8 <tcp_close_shutdown+0x28>
  switch (pcb->state) {
 8046cd2:	7d23      	ldrb	r3, [r4, #20]
 8046cd4:	2b01      	cmp	r3, #1
 8046cd6:	d070      	beq.n	8046dba <tcp_close_shutdown+0xfa>
 8046cd8:	2b02      	cmp	r3, #2
 8046cda:	d07b      	beq.n	8046dd4 <tcp_close_shutdown+0x114>
 8046cdc:	2b00      	cmp	r3, #0
 8046cde:	d052      	beq.n	8046d86 <tcp_close_shutdown+0xc6>
    return tcp_close_shutdown_fin(pcb);
 8046ce0:	4620      	mov	r0, r4
 8046ce2:	f7ff fbcd 	bl	8046480 <tcp_close_shutdown_fin>
 8046ce6:	e040      	b.n	8046d6a <tcp_close_shutdown+0xaa>
    if ((pcb->refused_data != NULL) || (pcb->rcv_wnd != TCP_WND_MAX(pcb))) {
 8046ce8:	6f63      	ldr	r3, [r4, #116]	; 0x74
 8046cea:	b1d3      	cbz	r3, 8046d22 <tcp_close_shutdown+0x62>
      LWIP_ASSERT("pcb->flags & TF_RXCLOSED", pcb->flags & TF_RXCLOSED);
 8046cec:	7ea3      	ldrb	r3, [r4, #26]
 8046cee:	f013 0f10 	tst.w	r3, #16
 8046cf2:	d01b      	beq.n	8046d2c <tcp_close_shutdown+0x6c>
      tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
 8046cf4:	8b23      	ldrh	r3, [r4, #24]
 8046cf6:	9301      	str	r3, [sp, #4]
 8046cf8:	8ae3      	ldrh	r3, [r4, #22]
 8046cfa:	9300      	str	r3, [sp, #0]
 8046cfc:	1d23      	adds	r3, r4, #4
 8046cfe:	4622      	mov	r2, r4
 8046d00:	6a61      	ldr	r1, [r4, #36]	; 0x24
 8046d02:	6ce0      	ldr	r0, [r4, #76]	; 0x4c
 8046d04:	f002 fd40 	bl	8049788 <tcp_rst>
      tcp_pcb_purge(pcb);
 8046d08:	4620      	mov	r0, r4
 8046d0a:	f7ff fd5f 	bl	80467cc <tcp_pcb_purge>
      TCP_RMV_ACTIVE(pcb);
 8046d0e:	4b37      	ldr	r3, [pc, #220]	; (8046dec <tcp_close_shutdown+0x12c>)
 8046d10:	681b      	ldr	r3, [r3, #0]
 8046d12:	42a3      	cmp	r3, r4
 8046d14:	d012      	beq.n	8046d3c <tcp_close_shutdown+0x7c>
 8046d16:	b1bb      	cbz	r3, 8046d48 <tcp_close_shutdown+0x88>
 8046d18:	68da      	ldr	r2, [r3, #12]
 8046d1a:	42a2      	cmp	r2, r4
 8046d1c:	d012      	beq.n	8046d44 <tcp_close_shutdown+0x84>
 8046d1e:	4613      	mov	r3, r2
 8046d20:	e7f9      	b.n	8046d16 <tcp_close_shutdown+0x56>
    if ((pcb->refused_data != NULL) || (pcb->rcv_wnd != TCP_WND_MAX(pcb))) {
 8046d22:	8d23      	ldrh	r3, [r4, #40]	; 0x28
 8046d24:	f5b3 6f06 	cmp.w	r3, #2144	; 0x860
 8046d28:	d0d3      	beq.n	8046cd2 <tcp_close_shutdown+0x12>
 8046d2a:	e7df      	b.n	8046cec <tcp_close_shutdown+0x2c>
      LWIP_ASSERT("pcb->flags & TF_RXCLOSED", pcb->flags & TF_RXCLOSED);
 8046d2c:	4b30      	ldr	r3, [pc, #192]	; (8046df0 <tcp_close_shutdown+0x130>)
 8046d2e:	f240 120f 	movw	r2, #271	; 0x10f
 8046d32:	4930      	ldr	r1, [pc, #192]	; (8046df4 <tcp_close_shutdown+0x134>)
 8046d34:	4830      	ldr	r0, [pc, #192]	; (8046df8 <tcp_close_shutdown+0x138>)
 8046d36:	f00a fe87 	bl	8051a48 <printf>
 8046d3a:	e7db      	b.n	8046cf4 <tcp_close_shutdown+0x34>
      TCP_RMV_ACTIVE(pcb);
 8046d3c:	68da      	ldr	r2, [r3, #12]
 8046d3e:	4b2b      	ldr	r3, [pc, #172]	; (8046dec <tcp_close_shutdown+0x12c>)
 8046d40:	601a      	str	r2, [r3, #0]
 8046d42:	e001      	b.n	8046d48 <tcp_close_shutdown+0x88>
 8046d44:	68e2      	ldr	r2, [r4, #12]
 8046d46:	60da      	str	r2, [r3, #12]
 8046d48:	2300      	movs	r3, #0
 8046d4a:	60e3      	str	r3, [r4, #12]
 8046d4c:	4b2b      	ldr	r3, [pc, #172]	; (8046dfc <tcp_close_shutdown+0x13c>)
 8046d4e:	2201      	movs	r2, #1
 8046d50:	701a      	strb	r2, [r3, #0]
      if (pcb->state == ESTABLISHED) {
 8046d52:	7d23      	ldrb	r3, [r4, #20]
 8046d54:	2b04      	cmp	r3, #4
 8046d56:	d00a      	beq.n	8046d6e <tcp_close_shutdown+0xae>
        if (tcp_input_pcb == pcb) {
 8046d58:	4b29      	ldr	r3, [pc, #164]	; (8046e00 <tcp_close_shutdown+0x140>)
 8046d5a:	681b      	ldr	r3, [r3, #0]
 8046d5c:	42a3      	cmp	r3, r4
 8046d5e:	d00f      	beq.n	8046d80 <tcp_close_shutdown+0xc0>
          memp_free(MEMP_TCP_PCB, pcb);
 8046d60:	4621      	mov	r1, r4
 8046d62:	2001      	movs	r0, #1
 8046d64:	f7fe fe06 	bl	8045974 <memp_free>
      return ERR_OK;
 8046d68:	2000      	movs	r0, #0
}
 8046d6a:	b002      	add	sp, #8
 8046d6c:	bd10      	pop	{r4, pc}
        pcb->state = TIME_WAIT;
 8046d6e:	230a      	movs	r3, #10
 8046d70:	7523      	strb	r3, [r4, #20]
        TCP_REG(&tcp_tw_pcbs, pcb);
 8046d72:	4b24      	ldr	r3, [pc, #144]	; (8046e04 <tcp_close_shutdown+0x144>)
 8046d74:	681a      	ldr	r2, [r3, #0]
 8046d76:	60e2      	str	r2, [r4, #12]
 8046d78:	601c      	str	r4, [r3, #0]
 8046d7a:	f002 feb5 	bl	8049ae8 <tcp_timer_needed>
 8046d7e:	e7f3      	b.n	8046d68 <tcp_close_shutdown+0xa8>
          tcp_trigger_input_pcb_close();
 8046d80:	f001 fe64 	bl	8048a4c <tcp_trigger_input_pcb_close>
 8046d84:	e7f0      	b.n	8046d68 <tcp_close_shutdown+0xa8>
    if (pcb->local_port != 0) {
 8046d86:	8ae3      	ldrh	r3, [r4, #22]
 8046d88:	b18b      	cbz	r3, 8046dae <tcp_close_shutdown+0xee>
      TCP_RMV(&tcp_bound_pcbs, pcb);
 8046d8a:	4b1f      	ldr	r3, [pc, #124]	; (8046e08 <tcp_close_shutdown+0x148>)
 8046d8c:	681b      	ldr	r3, [r3, #0]
 8046d8e:	42a3      	cmp	r3, r4
 8046d90:	d005      	beq.n	8046d9e <tcp_close_shutdown+0xde>
 8046d92:	b153      	cbz	r3, 8046daa <tcp_close_shutdown+0xea>
 8046d94:	68da      	ldr	r2, [r3, #12]
 8046d96:	42a2      	cmp	r2, r4
 8046d98:	d005      	beq.n	8046da6 <tcp_close_shutdown+0xe6>
 8046d9a:	4613      	mov	r3, r2
 8046d9c:	e7f9      	b.n	8046d92 <tcp_close_shutdown+0xd2>
 8046d9e:	68da      	ldr	r2, [r3, #12]
 8046da0:	4b19      	ldr	r3, [pc, #100]	; (8046e08 <tcp_close_shutdown+0x148>)
 8046da2:	601a      	str	r2, [r3, #0]
 8046da4:	e001      	b.n	8046daa <tcp_close_shutdown+0xea>
 8046da6:	68e2      	ldr	r2, [r4, #12]
 8046da8:	60da      	str	r2, [r3, #12]
 8046daa:	2300      	movs	r3, #0
 8046dac:	60e3      	str	r3, [r4, #12]
    memp_free(MEMP_TCP_PCB, pcb);
 8046dae:	4621      	mov	r1, r4
 8046db0:	2001      	movs	r0, #1
 8046db2:	f7fe fddf 	bl	8045974 <memp_free>
  return ERR_OK;
 8046db6:	2000      	movs	r0, #0
    break;
 8046db8:	e7d7      	b.n	8046d6a <tcp_close_shutdown+0xaa>
    tcp_listen_closed(pcb);
 8046dba:	4620      	mov	r0, r4
 8046dbc:	f7ff fb34 	bl	8046428 <tcp_listen_closed>
    tcp_pcb_remove(&tcp_listen_pcbs.pcbs, pcb);
 8046dc0:	4621      	mov	r1, r4
 8046dc2:	4812      	ldr	r0, [pc, #72]	; (8046e0c <tcp_close_shutdown+0x14c>)
 8046dc4:	f7ff ff2a 	bl	8046c1c <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB_LISTEN, pcb);
 8046dc8:	4621      	mov	r1, r4
 8046dca:	2002      	movs	r0, #2
 8046dcc:	f7fe fdd2 	bl	8045974 <memp_free>
  return ERR_OK;
 8046dd0:	2000      	movs	r0, #0
    break;
 8046dd2:	e7ca      	b.n	8046d6a <tcp_close_shutdown+0xaa>
    TCP_PCB_REMOVE_ACTIVE(pcb);
 8046dd4:	4621      	mov	r1, r4
 8046dd6:	4805      	ldr	r0, [pc, #20]	; (8046dec <tcp_close_shutdown+0x12c>)
 8046dd8:	f7ff ff20 	bl	8046c1c <tcp_pcb_remove>
 8046ddc:	2001      	movs	r0, #1
 8046dde:	4b07      	ldr	r3, [pc, #28]	; (8046dfc <tcp_close_shutdown+0x13c>)
 8046de0:	7018      	strb	r0, [r3, #0]
    memp_free(MEMP_TCP_PCB, pcb);
 8046de2:	4621      	mov	r1, r4
 8046de4:	f7fe fdc6 	bl	8045974 <memp_free>
  return ERR_OK;
 8046de8:	2000      	movs	r0, #0
    break;
 8046dea:	e7be      	b.n	8046d6a <tcp_close_shutdown+0xaa>
 8046dec:	20008720 	.word	0x20008720
 8046df0:	08059618 	.word	0x08059618
 8046df4:	08059964 	.word	0x08059964
 8046df8:	08058ecc 	.word	0x08058ecc
 8046dfc:	2000871c 	.word	0x2000871c
 8046e00:	20008734 	.word	0x20008734
 8046e04:	20008730 	.word	0x20008730
 8046e08:	2000872c 	.word	0x2000872c
 8046e0c:	20008728 	.word	0x20008728

08046e10 <tcp_close>:
{
 8046e10:	b508      	push	{r3, lr}
  if (pcb->state != LISTEN) {
 8046e12:	7d03      	ldrb	r3, [r0, #20]
 8046e14:	2b01      	cmp	r3, #1
 8046e16:	d003      	beq.n	8046e20 <tcp_close+0x10>
    pcb->flags |= TF_RXCLOSED;
 8046e18:	7e83      	ldrb	r3, [r0, #26]
 8046e1a:	f043 0310 	orr.w	r3, r3, #16
 8046e1e:	7683      	strb	r3, [r0, #26]
  return tcp_close_shutdown(pcb, 1);
 8046e20:	2101      	movs	r1, #1
 8046e22:	f7ff ff4d 	bl	8046cc0 <tcp_close_shutdown>
}
 8046e26:	bd08      	pop	{r3, pc}

08046e28 <tcp_recv_null>:
{
 8046e28:	b510      	push	{r4, lr}
 8046e2a:	4608      	mov	r0, r1
  if (p != NULL) {
 8046e2c:	b142      	cbz	r2, 8046e40 <tcp_recv_null+0x18>
 8046e2e:	4614      	mov	r4, r2
    tcp_recved(pcb, p->tot_len);
 8046e30:	8911      	ldrh	r1, [r2, #8]
 8046e32:	f7ff fbf5 	bl	8046620 <tcp_recved>
    pbuf_free(p);
 8046e36:	4620      	mov	r0, r4
 8046e38:	f7fe ff50 	bl	8045cdc <pbuf_free>
  return ERR_OK;
 8046e3c:	2000      	movs	r0, #0
}
 8046e3e:	bd10      	pop	{r4, pc}
  } else if (err == ERR_OK) {
 8046e40:	b10b      	cbz	r3, 8046e46 <tcp_recv_null+0x1e>
  return ERR_OK;
 8046e42:	2000      	movs	r0, #0
 8046e44:	e7fb      	b.n	8046e3e <tcp_recv_null+0x16>
    return tcp_close(pcb);
 8046e46:	f7ff ffe3 	bl	8046e10 <tcp_close>
 8046e4a:	e7f8      	b.n	8046e3e <tcp_recv_null+0x16>

08046e4c <tcp_process_refused_data>:
{
 8046e4c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8046e4e:	4604      	mov	r4, r0
    u8_t refused_flags = pcb->refused_data->flags;
 8046e50:	6f46      	ldr	r6, [r0, #116]	; 0x74
 8046e52:	7b77      	ldrb	r7, [r6, #13]
    pcb->refused_data = NULL;
 8046e54:	2300      	movs	r3, #0
 8046e56:	6743      	str	r3, [r0, #116]	; 0x74
    TCP_EVENT_RECV(pcb, refused_data, ERR_OK, err);
 8046e58:	f8d0 5080 	ldr.w	r5, [r0, #128]	; 0x80
 8046e5c:	b1dd      	cbz	r5, 8046e96 <tcp_process_refused_data+0x4a>
 8046e5e:	4632      	mov	r2, r6
 8046e60:	4601      	mov	r1, r0
 8046e62:	6900      	ldr	r0, [r0, #16]
 8046e64:	47a8      	blx	r5
 8046e66:	4605      	mov	r5, r0
    if (err == ERR_OK) {
 8046e68:	b9ed      	cbnz	r5, 8046ea6 <tcp_process_refused_data+0x5a>
      if (refused_flags & PBUF_FLAG_TCP_FIN
 8046e6a:	f017 0f20 	tst.w	r7, #32
 8046e6e:	d020      	beq.n	8046eb2 <tcp_process_refused_data+0x66>
        if (pcb->rcv_wnd != TCP_WND_MAX(pcb)) {
 8046e70:	8d23      	ldrh	r3, [r4, #40]	; 0x28
 8046e72:	f5b3 6f06 	cmp.w	r3, #2144	; 0x860
 8046e76:	d001      	beq.n	8046e7c <tcp_process_refused_data+0x30>
          pcb->rcv_wnd++;
 8046e78:	3301      	adds	r3, #1
 8046e7a:	8523      	strh	r3, [r4, #40]	; 0x28
        TCP_EVENT_CLOSED(pcb, err);
 8046e7c:	f8d4 6080 	ldr.w	r6, [r4, #128]	; 0x80
 8046e80:	b1be      	cbz	r6, 8046eb2 <tcp_process_refused_data+0x66>
 8046e82:	2300      	movs	r3, #0
 8046e84:	461a      	mov	r2, r3
 8046e86:	4621      	mov	r1, r4
 8046e88:	6920      	ldr	r0, [r4, #16]
 8046e8a:	47b0      	blx	r6
        if (err == ERR_ABRT) {
 8046e8c:	f110 0f0d 	cmn.w	r0, #13
 8046e90:	d10f      	bne.n	8046eb2 <tcp_process_refused_data+0x66>
          return ERR_ABRT;
 8046e92:	4605      	mov	r5, r0
 8046e94:	e00d      	b.n	8046eb2 <tcp_process_refused_data+0x66>
    TCP_EVENT_RECV(pcb, refused_data, ERR_OK, err);
 8046e96:	2300      	movs	r3, #0
 8046e98:	4632      	mov	r2, r6
 8046e9a:	4601      	mov	r1, r0
 8046e9c:	4618      	mov	r0, r3
 8046e9e:	f7ff ffc3 	bl	8046e28 <tcp_recv_null>
 8046ea2:	4605      	mov	r5, r0
 8046ea4:	e7e0      	b.n	8046e68 <tcp_process_refused_data+0x1c>
    } else if (err == ERR_ABRT) {
 8046ea6:	f115 0f0d 	cmn.w	r5, #13
 8046eaa:	d002      	beq.n	8046eb2 <tcp_process_refused_data+0x66>
      pcb->refused_data = refused_data;
 8046eac:	6766      	str	r6, [r4, #116]	; 0x74
      return ERR_INPROGRESS;
 8046eae:	f06f 0504 	mvn.w	r5, #4
}
 8046eb2:	4628      	mov	r0, r5
 8046eb4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

08046eb8 <tcp_fasttmr>:
{
 8046eb8:	b570      	push	{r4, r5, r6, lr}
  ++tcp_timer_ctr;
 8046eba:	4a1c      	ldr	r2, [pc, #112]	; (8046f2c <tcp_fasttmr+0x74>)
 8046ebc:	7813      	ldrb	r3, [r2, #0]
 8046ebe:	3301      	adds	r3, #1
 8046ec0:	7013      	strb	r3, [r2, #0]
  pcb = tcp_active_pcbs;
 8046ec2:	4b1b      	ldr	r3, [pc, #108]	; (8046f30 <tcp_fasttmr+0x78>)
 8046ec4:	681c      	ldr	r4, [r3, #0]
  while (pcb != NULL) {
 8046ec6:	e013      	b.n	8046ef0 <tcp_fasttmr+0x38>
        tcp_ack_now(pcb);
 8046ec8:	f043 0302 	orr.w	r3, r3, #2
 8046ecc:	76a3      	strb	r3, [r4, #26]
        tcp_output(pcb);
 8046ece:	4620      	mov	r0, r4
 8046ed0:	f002 fb12 	bl	80494f8 <tcp_output>
        pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
 8046ed4:	7ea3      	ldrb	r3, [r4, #26]
 8046ed6:	f023 0303 	bic.w	r3, r3, #3
 8046eda:	76a3      	strb	r3, [r4, #26]
 8046edc:	e013      	b.n	8046f06 <tcp_fasttmr+0x4e>
        pcb->flags &= ~(TF_CLOSEPEND);
 8046ede:	f023 0308 	bic.w	r3, r3, #8
 8046ee2:	76a3      	strb	r3, [r4, #26]
        tcp_close_shutdown_fin(pcb);
 8046ee4:	4620      	mov	r0, r4
 8046ee6:	f7ff facb 	bl	8046480 <tcp_close_shutdown_fin>
 8046eea:	e010      	b.n	8046f0e <tcp_fasttmr+0x56>
      pcb = pcb->next;
 8046eec:	68e5      	ldr	r5, [r4, #12]
{
 8046eee:	462c      	mov	r4, r5
  while (pcb != NULL) {
 8046ef0:	b1dc      	cbz	r4, 8046f2a <tcp_fasttmr+0x72>
    if (pcb->last_timer != tcp_timer_ctr) {
 8046ef2:	7f62      	ldrb	r2, [r4, #29]
 8046ef4:	4b0d      	ldr	r3, [pc, #52]	; (8046f2c <tcp_fasttmr+0x74>)
 8046ef6:	781b      	ldrb	r3, [r3, #0]
 8046ef8:	429a      	cmp	r2, r3
 8046efa:	d0f7      	beq.n	8046eec <tcp_fasttmr+0x34>
      pcb->last_timer = tcp_timer_ctr;
 8046efc:	7763      	strb	r3, [r4, #29]
      if (pcb->flags & TF_ACK_DELAY) {
 8046efe:	7ea3      	ldrb	r3, [r4, #26]
 8046f00:	f013 0f01 	tst.w	r3, #1
 8046f04:	d1e0      	bne.n	8046ec8 <tcp_fasttmr+0x10>
      if (pcb->flags & TF_CLOSEPEND) {
 8046f06:	7ea3      	ldrb	r3, [r4, #26]
 8046f08:	f013 0f08 	tst.w	r3, #8
 8046f0c:	d1e7      	bne.n	8046ede <tcp_fasttmr+0x26>
      next = pcb->next;
 8046f0e:	68e5      	ldr	r5, [r4, #12]
      if (pcb->refused_data != NULL) {
 8046f10:	6f63      	ldr	r3, [r4, #116]	; 0x74
 8046f12:	2b00      	cmp	r3, #0
 8046f14:	d0eb      	beq.n	8046eee <tcp_fasttmr+0x36>
        tcp_active_pcbs_changed = 0;
 8046f16:	4e07      	ldr	r6, [pc, #28]	; (8046f34 <tcp_fasttmr+0x7c>)
 8046f18:	2300      	movs	r3, #0
 8046f1a:	7033      	strb	r3, [r6, #0]
        tcp_process_refused_data(pcb);
 8046f1c:	4620      	mov	r0, r4
 8046f1e:	f7ff ff95 	bl	8046e4c <tcp_process_refused_data>
        if (tcp_active_pcbs_changed) {
 8046f22:	7833      	ldrb	r3, [r6, #0]
 8046f24:	2b00      	cmp	r3, #0
 8046f26:	d0e2      	beq.n	8046eee <tcp_fasttmr+0x36>
 8046f28:	e7cb      	b.n	8046ec2 <tcp_fasttmr+0xa>
}
 8046f2a:	bd70      	pop	{r4, r5, r6, pc}
 8046f2c:	200040d1 	.word	0x200040d1
 8046f30:	20008720 	.word	0x20008720
 8046f34:	2000871c 	.word	0x2000871c

08046f38 <tcp_tmr>:
{
 8046f38:	b508      	push	{r3, lr}
  tcp_fasttmr();
 8046f3a:	f7ff ffbd 	bl	8046eb8 <tcp_fasttmr>
  if (++tcp_timer & 1) {
 8046f3e:	4a06      	ldr	r2, [pc, #24]	; (8046f58 <tcp_tmr+0x20>)
 8046f40:	7853      	ldrb	r3, [r2, #1]
 8046f42:	3301      	adds	r3, #1
 8046f44:	b2db      	uxtb	r3, r3
 8046f46:	7053      	strb	r3, [r2, #1]
 8046f48:	f013 0f01 	tst.w	r3, #1
 8046f4c:	d100      	bne.n	8046f50 <tcp_tmr+0x18>
}
 8046f4e:	bd08      	pop	{r3, pc}
    tcp_slowtmr();
 8046f50:	f7ff fc5e 	bl	8046810 <tcp_slowtmr>
}
 8046f54:	e7fb      	b.n	8046f4e <tcp_tmr+0x16>
 8046f56:	bf00      	nop
 8046f58:	200040d1 	.word	0x200040d1

08046f5c <tcp_abandon>:
{
 8046f5c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8046f60:	b082      	sub	sp, #8
 8046f62:	4604      	mov	r4, r0
 8046f64:	460d      	mov	r5, r1
  LWIP_ASSERT("don't call tcp_abort/tcp_abandon for listen-pcbs",
 8046f66:	7d03      	ldrb	r3, [r0, #20]
 8046f68:	2b01      	cmp	r3, #1
 8046f6a:	d01a      	beq.n	8046fa2 <tcp_abandon+0x46>
  if (pcb->state == TIME_WAIT) {
 8046f6c:	7d23      	ldrb	r3, [r4, #20]
 8046f6e:	2b0a      	cmp	r3, #10
 8046f70:	d01f      	beq.n	8046fb2 <tcp_abandon+0x56>
    seqno = pcb->snd_nxt;
 8046f72:	f8d4 804c 	ldr.w	r8, [r4, #76]	; 0x4c
    ackno = pcb->rcv_nxt;
 8046f76:	f8d4 9024 	ldr.w	r9, [r4, #36]	; 0x24
    errf = pcb->errf;
 8046f7a:	f8d4 608c 	ldr.w	r6, [r4, #140]	; 0x8c
    errf_arg = pcb->callback_arg;
 8046f7e:	6927      	ldr	r7, [r4, #16]
    if (pcb->state == CLOSED) {
 8046f80:	2b00      	cmp	r3, #0
 8046f82:	d141      	bne.n	8047008 <tcp_abandon+0xac>
      if (pcb->local_port != 0) {
 8046f84:	f8b4 a016 	ldrh.w	sl, [r4, #22]
 8046f88:	f1ba 0f00 	cmp.w	sl, #0
 8046f8c:	d046      	beq.n	804701c <tcp_abandon+0xc0>
        TCP_RMV(&tcp_bound_pcbs, pcb);
 8046f8e:	4b2a      	ldr	r3, [pc, #168]	; (8047038 <tcp_abandon+0xdc>)
 8046f90:	681b      	ldr	r3, [r3, #0]
 8046f92:	42a3      	cmp	r3, r4
 8046f94:	d016      	beq.n	8046fc4 <tcp_abandon+0x68>
 8046f96:	b1db      	cbz	r3, 8046fd0 <tcp_abandon+0x74>
 8046f98:	68da      	ldr	r2, [r3, #12]
 8046f9a:	42a2      	cmp	r2, r4
 8046f9c:	d016      	beq.n	8046fcc <tcp_abandon+0x70>
 8046f9e:	4613      	mov	r3, r2
 8046fa0:	e7f9      	b.n	8046f96 <tcp_abandon+0x3a>
  LWIP_ASSERT("don't call tcp_abort/tcp_abandon for listen-pcbs",
 8046fa2:	4b26      	ldr	r3, [pc, #152]	; (804703c <tcp_abandon+0xe0>)
 8046fa4:	f240 12df 	movw	r2, #479	; 0x1df
 8046fa8:	4925      	ldr	r1, [pc, #148]	; (8047040 <tcp_abandon+0xe4>)
 8046faa:	4826      	ldr	r0, [pc, #152]	; (8047044 <tcp_abandon+0xe8>)
 8046fac:	f00a fd4c 	bl	8051a48 <printf>
 8046fb0:	e7dc      	b.n	8046f6c <tcp_abandon+0x10>
    tcp_pcb_remove(&tcp_tw_pcbs, pcb);
 8046fb2:	4621      	mov	r1, r4
 8046fb4:	4824      	ldr	r0, [pc, #144]	; (8047048 <tcp_abandon+0xec>)
 8046fb6:	f7ff fe31 	bl	8046c1c <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB, pcb);
 8046fba:	4621      	mov	r1, r4
 8046fbc:	2001      	movs	r0, #1
 8046fbe:	f7fe fcd9 	bl	8045974 <memp_free>
 8046fc2:	e01e      	b.n	8047002 <tcp_abandon+0xa6>
        TCP_RMV(&tcp_bound_pcbs, pcb);
 8046fc4:	68da      	ldr	r2, [r3, #12]
 8046fc6:	4b1c      	ldr	r3, [pc, #112]	; (8047038 <tcp_abandon+0xdc>)
 8046fc8:	601a      	str	r2, [r3, #0]
 8046fca:	e001      	b.n	8046fd0 <tcp_abandon+0x74>
 8046fcc:	68e2      	ldr	r2, [r4, #12]
 8046fce:	60da      	str	r2, [r3, #12]
 8046fd0:	2500      	movs	r5, #0
 8046fd2:	60e5      	str	r5, [r4, #12]
    u16_t local_port = 0;
 8046fd4:	46aa      	mov	sl, r5
    if (pcb->unacked != NULL) {
 8046fd6:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
 8046fd8:	b108      	cbz	r0, 8046fde <tcp_abandon+0x82>
      tcp_segs_free(pcb->unacked);
 8046fda:	f7ff fb70 	bl	80466be <tcp_segs_free>
    if (pcb->unsent != NULL) {
 8046fde:	6ea0      	ldr	r0, [r4, #104]	; 0x68
 8046fe0:	b108      	cbz	r0, 8046fe6 <tcp_abandon+0x8a>
      tcp_segs_free(pcb->unsent);
 8046fe2:	f7ff fb6c 	bl	80466be <tcp_segs_free>
    if (pcb->ooseq != NULL) {
 8046fe6:	6f20      	ldr	r0, [r4, #112]	; 0x70
 8046fe8:	b108      	cbz	r0, 8046fee <tcp_abandon+0x92>
      tcp_segs_free(pcb->ooseq);
 8046fea:	f7ff fb68 	bl	80466be <tcp_segs_free>
    if (send_rst) {
 8046fee:	b9bd      	cbnz	r5, 8047020 <tcp_abandon+0xc4>
    memp_free(MEMP_TCP_PCB, pcb);
 8046ff0:	4621      	mov	r1, r4
 8046ff2:	2001      	movs	r0, #1
 8046ff4:	f7fe fcbe 	bl	8045974 <memp_free>
    TCP_EVENT_ERR(last_state, errf, errf_arg, ERR_ABRT);
 8046ff8:	b11e      	cbz	r6, 8047002 <tcp_abandon+0xa6>
 8046ffa:	f06f 010c 	mvn.w	r1, #12
 8046ffe:	4638      	mov	r0, r7
 8047000:	47b0      	blx	r6
}
 8047002:	b002      	add	sp, #8
 8047004:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      local_port = pcb->local_port;
 8047008:	f8b4 a016 	ldrh.w	sl, [r4, #22]
      TCP_PCB_REMOVE_ACTIVE(pcb);
 804700c:	4621      	mov	r1, r4
 804700e:	480f      	ldr	r0, [pc, #60]	; (804704c <tcp_abandon+0xf0>)
 8047010:	f7ff fe04 	bl	8046c1c <tcp_pcb_remove>
 8047014:	4b0e      	ldr	r3, [pc, #56]	; (8047050 <tcp_abandon+0xf4>)
 8047016:	2201      	movs	r2, #1
 8047018:	701a      	strb	r2, [r3, #0]
 804701a:	e7dc      	b.n	8046fd6 <tcp_abandon+0x7a>
    int send_rst = 0;
 804701c:	2500      	movs	r5, #0
 804701e:	e7da      	b.n	8046fd6 <tcp_abandon+0x7a>
      tcp_rst(seqno, ackno, &pcb->local_ip, &pcb->remote_ip, local_port, pcb->remote_port);
 8047020:	8b23      	ldrh	r3, [r4, #24]
 8047022:	9301      	str	r3, [sp, #4]
 8047024:	f8cd a000 	str.w	sl, [sp]
 8047028:	1d23      	adds	r3, r4, #4
 804702a:	4622      	mov	r2, r4
 804702c:	4649      	mov	r1, r9
 804702e:	4640      	mov	r0, r8
 8047030:	f002 fbaa 	bl	8049788 <tcp_rst>
 8047034:	e7dc      	b.n	8046ff0 <tcp_abandon+0x94>
 8047036:	bf00      	nop
 8047038:	2000872c 	.word	0x2000872c
 804703c:	08059618 	.word	0x08059618
 8047040:	08059980 	.word	0x08059980
 8047044:	08058ecc 	.word	0x08058ecc
 8047048:	20008730 	.word	0x20008730
 804704c:	20008720 	.word	0x20008720
 8047050:	2000871c 	.word	0x2000871c

08047054 <tcp_abort>:
{
 8047054:	b508      	push	{r3, lr}
  tcp_abandon(pcb, 1);
 8047056:	2101      	movs	r1, #1
 8047058:	f7ff ff80 	bl	8046f5c <tcp_abandon>
}
 804705c:	bd08      	pop	{r3, pc}
	...

08047060 <tcp_kill_timewait>:
{
 8047060:	b510      	push	{r4, lr}
  for (pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
 8047062:	4b0a      	ldr	r3, [pc, #40]	; (804708c <tcp_kill_timewait+0x2c>)
 8047064:	681b      	ldr	r3, [r3, #0]
  inactivity = 0;
 8047066:	2400      	movs	r4, #0
  inactive = NULL;
 8047068:	4620      	mov	r0, r4
  for (pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
 804706a:	e000      	b.n	804706e <tcp_kill_timewait+0xe>
 804706c:	68db      	ldr	r3, [r3, #12]
 804706e:	b143      	cbz	r3, 8047082 <tcp_kill_timewait+0x22>
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
 8047070:	6a19      	ldr	r1, [r3, #32]
 8047072:	4a07      	ldr	r2, [pc, #28]	; (8047090 <tcp_kill_timewait+0x30>)
 8047074:	6812      	ldr	r2, [r2, #0]
 8047076:	1a52      	subs	r2, r2, r1
 8047078:	42a2      	cmp	r2, r4
 804707a:	d3f7      	bcc.n	804706c <tcp_kill_timewait+0xc>
      inactivity = tcp_ticks - pcb->tmr;
 804707c:	4614      	mov	r4, r2
      inactive = pcb;
 804707e:	4618      	mov	r0, r3
 8047080:	e7f4      	b.n	804706c <tcp_kill_timewait+0xc>
  if (inactive != NULL) {
 8047082:	b108      	cbz	r0, 8047088 <tcp_kill_timewait+0x28>
    tcp_abort(inactive);
 8047084:	f7ff ffe6 	bl	8047054 <tcp_abort>
}
 8047088:	bd10      	pop	{r4, pc}
 804708a:	bf00      	nop
 804708c:	20008730 	.word	0x20008730
 8047090:	20008724 	.word	0x20008724

08047094 <tcp_kill_prio>:
{
 8047094:	b570      	push	{r4, r5, r6, lr}
 8047096:	4604      	mov	r4, r0
  mprio = LWIP_MIN(TCP_PRIO_MAX, prio);
 8047098:	f010 0f80 	tst.w	r0, #128	; 0x80
 804709c:	d104      	bne.n	80470a8 <tcp_kill_prio+0x14>
  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 804709e:	4b0d      	ldr	r3, [pc, #52]	; (80470d4 <tcp_kill_prio+0x40>)
 80470a0:	681b      	ldr	r3, [r3, #0]
  inactivity = 0;
 80470a2:	2600      	movs	r6, #0
  inactive = NULL;
 80470a4:	4630      	mov	r0, r6
  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 80470a6:	e002      	b.n	80470ae <tcp_kill_prio+0x1a>
  mprio = LWIP_MIN(TCP_PRIO_MAX, prio);
 80470a8:	247f      	movs	r4, #127	; 0x7f
 80470aa:	e7f8      	b.n	804709e <tcp_kill_prio+0xa>
  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 80470ac:	68db      	ldr	r3, [r3, #12]
 80470ae:	b163      	cbz	r3, 80470ca <tcp_kill_prio+0x36>
    if (pcb->prio <= mprio &&
 80470b0:	7d59      	ldrb	r1, [r3, #21]
 80470b2:	42a1      	cmp	r1, r4
 80470b4:	d8fa      	bhi.n	80470ac <tcp_kill_prio+0x18>
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
 80470b6:	6a1d      	ldr	r5, [r3, #32]
 80470b8:	4a07      	ldr	r2, [pc, #28]	; (80470d8 <tcp_kill_prio+0x44>)
 80470ba:	6812      	ldr	r2, [r2, #0]
 80470bc:	1b52      	subs	r2, r2, r5
    if (pcb->prio <= mprio &&
 80470be:	42b2      	cmp	r2, r6
 80470c0:	d3f4      	bcc.n	80470ac <tcp_kill_prio+0x18>
      mprio = pcb->prio;
 80470c2:	460c      	mov	r4, r1
      inactivity = tcp_ticks - pcb->tmr;
 80470c4:	4616      	mov	r6, r2
      inactive = pcb;
 80470c6:	4618      	mov	r0, r3
 80470c8:	e7f0      	b.n	80470ac <tcp_kill_prio+0x18>
  if (inactive != NULL) {
 80470ca:	b108      	cbz	r0, 80470d0 <tcp_kill_prio+0x3c>
    tcp_abort(inactive);
 80470cc:	f7ff ffc2 	bl	8047054 <tcp_abort>
}
 80470d0:	bd70      	pop	{r4, r5, r6, pc}
 80470d2:	bf00      	nop
 80470d4:	20008720 	.word	0x20008720
 80470d8:	20008724 	.word	0x20008724

080470dc <tcp_netif_ip_addr_changed_pcblist>:
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

/** Helper function for tcp_netif_ip_addr_changed() that iterates a pcb list */
static void
tcp_netif_ip_addr_changed_pcblist(const ip_addr_t* old_addr, struct tcp_pcb* pcb_list)
{
 80470dc:	b538      	push	{r3, r4, r5, lr}
 80470de:	4604      	mov	r4, r0
 80470e0:	4608      	mov	r0, r1
  struct tcp_pcb *pcb;
  pcb = pcb_list;
  while (pcb != NULL) {
 80470e2:	e003      	b.n	80470ec <tcp_netif_ip_addr_changed_pcblist+0x10>
      /* connections to link-local addresses must persist (RFC3927 ch. 1.9) */
      && (!IP_IS_V4_VAL(pcb->local_ip) || !ip4_addr_islinklocal(ip_2_ip4(&pcb->local_ip)))
#endif /* LWIP_AUTOIP */
      ) {
      /* this connection must be aborted */
      struct tcp_pcb *next = pcb->next;
 80470e4:	68c5      	ldr	r5, [r0, #12]
      LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("netif_set_ipaddr: aborting TCP pcb %p\n", (void *)pcb));
      tcp_abort(pcb);
 80470e6:	f7ff ffb5 	bl	8047054 <tcp_abort>
      pcb = next;
 80470ea:	4628      	mov	r0, r5
  while (pcb != NULL) {
 80470ec:	b128      	cbz	r0, 80470fa <tcp_netif_ip_addr_changed_pcblist+0x1e>
    if (ip_addr_cmp(&pcb->local_ip, old_addr)
 80470ee:	6802      	ldr	r2, [r0, #0]
 80470f0:	6823      	ldr	r3, [r4, #0]
 80470f2:	429a      	cmp	r2, r3
 80470f4:	d0f6      	beq.n	80470e4 <tcp_netif_ip_addr_changed_pcblist+0x8>
    } else {
      pcb = pcb->next;
 80470f6:	68c0      	ldr	r0, [r0, #12]
 80470f8:	e7f8      	b.n	80470ec <tcp_netif_ip_addr_changed_pcblist+0x10>
    }
  }
}
 80470fa:	bd38      	pop	{r3, r4, r5, pc}

080470fc <tcp_kill_state>:
{
 80470fc:	b538      	push	{r3, r4, r5, lr}
 80470fe:	4604      	mov	r4, r0
  LWIP_ASSERT("invalid state", (state == CLOSING) || (state == LAST_ACK));
 8047100:	f1a0 0308 	sub.w	r3, r0, #8
 8047104:	b2db      	uxtb	r3, r3
 8047106:	2b01      	cmp	r3, #1
 8047108:	d804      	bhi.n	8047114 <tcp_kill_state+0x18>
  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 804710a:	4b10      	ldr	r3, [pc, #64]	; (804714c <tcp_kill_state+0x50>)
 804710c:	681b      	ldr	r3, [r3, #0]
  inactivity = 0;
 804710e:	2100      	movs	r1, #0
  inactive = NULL;
 8047110:	4608      	mov	r0, r1
  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 8047112:	e008      	b.n	8047126 <tcp_kill_state+0x2a>
  LWIP_ASSERT("invalid state", (state == CLOSING) || (state == LAST_ACK));
 8047114:	4b0e      	ldr	r3, [pc, #56]	; (8047150 <tcp_kill_state+0x54>)
 8047116:	f240 52dc 	movw	r2, #1500	; 0x5dc
 804711a:	490e      	ldr	r1, [pc, #56]	; (8047154 <tcp_kill_state+0x58>)
 804711c:	480e      	ldr	r0, [pc, #56]	; (8047158 <tcp_kill_state+0x5c>)
 804711e:	f00a fc93 	bl	8051a48 <printf>
 8047122:	e7f2      	b.n	804710a <tcp_kill_state+0xe>
  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 8047124:	68db      	ldr	r3, [r3, #12]
 8047126:	b15b      	cbz	r3, 8047140 <tcp_kill_state+0x44>
    if (pcb->state == state) {
 8047128:	7d1a      	ldrb	r2, [r3, #20]
 804712a:	42a2      	cmp	r2, r4
 804712c:	d1fa      	bne.n	8047124 <tcp_kill_state+0x28>
      if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
 804712e:	6a1d      	ldr	r5, [r3, #32]
 8047130:	4a0a      	ldr	r2, [pc, #40]	; (804715c <tcp_kill_state+0x60>)
 8047132:	6812      	ldr	r2, [r2, #0]
 8047134:	1b52      	subs	r2, r2, r5
 8047136:	428a      	cmp	r2, r1
 8047138:	d3f4      	bcc.n	8047124 <tcp_kill_state+0x28>
        inactivity = tcp_ticks - pcb->tmr;
 804713a:	4611      	mov	r1, r2
        inactive = pcb;
 804713c:	4618      	mov	r0, r3
 804713e:	e7f1      	b.n	8047124 <tcp_kill_state+0x28>
  if (inactive != NULL) {
 8047140:	b110      	cbz	r0, 8047148 <tcp_kill_state+0x4c>
    tcp_abandon(inactive, 0);
 8047142:	2100      	movs	r1, #0
 8047144:	f7ff ff0a 	bl	8046f5c <tcp_abandon>
}
 8047148:	bd38      	pop	{r3, r4, r5, pc}
 804714a:	bf00      	nop
 804714c:	20008720 	.word	0x20008720
 8047150:	08059618 	.word	0x08059618
 8047154:	080599b4 	.word	0x080599b4
 8047158:	08058ecc 	.word	0x08058ecc
 804715c:	20008724 	.word	0x20008724

08047160 <tcp_alloc>:
{
 8047160:	b538      	push	{r3, r4, r5, lr}
 8047162:	4605      	mov	r5, r0
  pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
 8047164:	2001      	movs	r0, #1
 8047166:	f7fe fbeb 	bl	8045940 <memp_malloc>
  if (pcb == NULL) {
 804716a:	4604      	mov	r4, r0
 804716c:	b368      	cbz	r0, 80471ca <tcp_alloc+0x6a>
  if (pcb != NULL) {
 804716e:	b354      	cbz	r4, 80471c6 <tcp_alloc+0x66>
    memset(pcb, 0, sizeof(struct tcp_pcb));
 8047170:	2298      	movs	r2, #152	; 0x98
 8047172:	2100      	movs	r1, #0
 8047174:	4620      	mov	r0, r4
 8047176:	f00a fc53 	bl	8051a20 <memset>
    pcb->prio = prio;
 804717a:	7565      	strb	r5, [r4, #21]
    pcb->snd_buf = TCP_SND_BUF;
 804717c:	f44f 6386 	mov.w	r3, #1072	; 0x430
 8047180:	f8a4 3060 	strh.w	r3, [r4, #96]	; 0x60
    pcb->rcv_wnd = pcb->rcv_ann_wnd = TCPWND_MIN16(TCP_WND);
 8047184:	f44f 6206 	mov.w	r2, #2144	; 0x860
 8047188:	8562      	strh	r2, [r4, #42]	; 0x2a
 804718a:	8522      	strh	r2, [r4, #40]	; 0x28
    pcb->ttl = TCP_TTL;
 804718c:	22ff      	movs	r2, #255	; 0xff
 804718e:	72a2      	strb	r2, [r4, #10]
    pcb->mss = INITIAL_MSS;
 8047190:	f44f 7206 	mov.w	r2, #536	; 0x218
 8047194:	8662      	strh	r2, [r4, #50]	; 0x32
    pcb->rto = 3000 / TCP_SLOW_INTERVAL;
 8047196:	2206      	movs	r2, #6
 8047198:	f8a4 2040 	strh.w	r2, [r4, #64]	; 0x40
    pcb->sv = 3000 / TCP_SLOW_INTERVAL;
 804719c:	87e2      	strh	r2, [r4, #62]	; 0x3e
    pcb->rtime = -1;
 804719e:	f64f 72ff 	movw	r2, #65535	; 0xffff
 80471a2:	8622      	strh	r2, [r4, #48]	; 0x30
    pcb->cwnd = 1;
 80471a4:	2201      	movs	r2, #1
 80471a6:	f8a4 2048 	strh.w	r2, [r4, #72]	; 0x48
    pcb->tmr = tcp_ticks;
 80471aa:	4a19      	ldr	r2, [pc, #100]	; (8047210 <tcp_alloc+0xb0>)
 80471ac:	6812      	ldr	r2, [r2, #0]
 80471ae:	6222      	str	r2, [r4, #32]
    pcb->last_timer = tcp_timer_ctr;
 80471b0:	4a18      	ldr	r2, [pc, #96]	; (8047214 <tcp_alloc+0xb4>)
 80471b2:	7812      	ldrb	r2, [r2, #0]
 80471b4:	7762      	strb	r2, [r4, #29]
    pcb->ssthresh = TCP_SND_BUF;
 80471b6:	f8a4 304a 	strh.w	r3, [r4, #74]	; 0x4a
    pcb->recv = tcp_recv_null;
 80471ba:	4b17      	ldr	r3, [pc, #92]	; (8047218 <tcp_alloc+0xb8>)
 80471bc:	f8c4 3080 	str.w	r3, [r4, #128]	; 0x80
    pcb->keep_idle  = TCP_KEEPIDLE_DEFAULT;
 80471c0:	4b16      	ldr	r3, [pc, #88]	; (804721c <tcp_alloc+0xbc>)
 80471c2:	f8c4 3090 	str.w	r3, [r4, #144]	; 0x90
}
 80471c6:	4620      	mov	r0, r4
 80471c8:	bd38      	pop	{r3, r4, r5, pc}
    tcp_kill_timewait();
 80471ca:	f7ff ff49 	bl	8047060 <tcp_kill_timewait>
    pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
 80471ce:	2001      	movs	r0, #1
 80471d0:	f7fe fbb6 	bl	8045940 <memp_malloc>
    if (pcb == NULL) {
 80471d4:	4604      	mov	r4, r0
 80471d6:	2800      	cmp	r0, #0
 80471d8:	d1c9      	bne.n	804716e <tcp_alloc+0xe>
      tcp_kill_state(LAST_ACK);
 80471da:	2009      	movs	r0, #9
 80471dc:	f7ff ff8e 	bl	80470fc <tcp_kill_state>
      pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
 80471e0:	2001      	movs	r0, #1
 80471e2:	f7fe fbad 	bl	8045940 <memp_malloc>
      if (pcb == NULL) {
 80471e6:	4604      	mov	r4, r0
 80471e8:	2800      	cmp	r0, #0
 80471ea:	d1c0      	bne.n	804716e <tcp_alloc+0xe>
        tcp_kill_state(CLOSING);
 80471ec:	2008      	movs	r0, #8
 80471ee:	f7ff ff85 	bl	80470fc <tcp_kill_state>
        pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
 80471f2:	2001      	movs	r0, #1
 80471f4:	f7fe fba4 	bl	8045940 <memp_malloc>
        if (pcb == NULL) {
 80471f8:	4604      	mov	r4, r0
 80471fa:	2800      	cmp	r0, #0
 80471fc:	d1b7      	bne.n	804716e <tcp_alloc+0xe>
          tcp_kill_prio(prio);
 80471fe:	4628      	mov	r0, r5
 8047200:	f7ff ff48 	bl	8047094 <tcp_kill_prio>
          pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
 8047204:	2001      	movs	r0, #1
 8047206:	f7fe fb9b 	bl	8045940 <memp_malloc>
 804720a:	4604      	mov	r4, r0
          if (pcb != NULL) {
 804720c:	e7af      	b.n	804716e <tcp_alloc+0xe>
 804720e:	bf00      	nop
 8047210:	20008724 	.word	0x20008724
 8047214:	200040d1 	.word	0x200040d1
 8047218:	08046e29 	.word	0x08046e29
 804721c:	006ddd00 	.word	0x006ddd00

08047220 <tcp_new>:
{
 8047220:	b508      	push	{r3, lr}
  return tcp_alloc(TCP_PRIO_NORMAL);
 8047222:	2040      	movs	r0, #64	; 0x40
 8047224:	f7ff ff9c 	bl	8047160 <tcp_alloc>
}
 8047228:	bd08      	pop	{r3, pc}
	...

0804722c <tcp_next_iss>:
  iss += tcp_ticks;       /* XXX */
 804722c:	4b03      	ldr	r3, [pc, #12]	; (804723c <tcp_next_iss+0x10>)
 804722e:	6858      	ldr	r0, [r3, #4]
 8047230:	4a03      	ldr	r2, [pc, #12]	; (8047240 <tcp_next_iss+0x14>)
 8047232:	6812      	ldr	r2, [r2, #0]
 8047234:	4410      	add	r0, r2
 8047236:	6058      	str	r0, [r3, #4]
}
 8047238:	4770      	bx	lr
 804723a:	bf00      	nop
 804723c:	20000008 	.word	0x20000008
 8047240:	20008724 	.word	0x20008724

08047244 <tcp_eff_send_mss_impl>:
{
 8047244:	b510      	push	{r4, lr}
 8047246:	4604      	mov	r4, r0
  outif = ip_route(src, dest);
 8047248:	4608      	mov	r0, r1
 804724a:	f003 fb51 	bl	804a8f0 <ip4_route>
    if (outif == NULL) {
 804724e:	b130      	cbz	r0, 804725e <tcp_eff_send_mss_impl+0x1a>
    mtu = outif->mtu;
 8047250:	8c43      	ldrh	r3, [r0, #34]	; 0x22
  if (mtu != 0) {
 8047252:	b123      	cbz	r3, 804725e <tcp_eff_send_mss_impl+0x1a>
      mss_s = mtu - IP_HLEN - TCP_HLEN;
 8047254:	3b28      	subs	r3, #40	; 0x28
 8047256:	b29b      	uxth	r3, r3
    sendmss = LWIP_MIN(sendmss, mss_s);
 8047258:	429c      	cmp	r4, r3
 804725a:	bf28      	it	cs
 804725c:	461c      	movcs	r4, r3
}
 804725e:	4620      	mov	r0, r4
 8047260:	bd10      	pop	{r4, pc}
	...

08047264 <tcp_connect>:
{
 8047264:	b570      	push	{r4, r5, r6, lr}
  if ((pcb == NULL) || (ipaddr == NULL)) {
 8047266:	2800      	cmp	r0, #0
 8047268:	d070      	beq.n	804734c <tcp_connect+0xe8>
 804726a:	461d      	mov	r5, r3
 804726c:	4604      	mov	r4, r0
 804726e:	2900      	cmp	r1, #0
 8047270:	d06f      	beq.n	8047352 <tcp_connect+0xee>
  LWIP_ERROR("tcp_connect: can only connect from state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
 8047272:	7d03      	ldrb	r3, [r0, #20]
 8047274:	2b00      	cmp	r3, #0
 8047276:	d149      	bne.n	804730c <tcp_connect+0xa8>
  ip_addr_set(&pcb->remote_ip, ipaddr);
 8047278:	680b      	ldr	r3, [r1, #0]
 804727a:	6043      	str	r3, [r0, #4]
  pcb->remote_port = port;
 804727c:	8302      	strh	r2, [r0, #24]
  if (ip_addr_isany(&pcb->local_ip)) {
 804727e:	b108      	cbz	r0, 8047284 <tcp_connect+0x20>
 8047280:	6803      	ldr	r3, [r0, #0]
 8047282:	b963      	cbnz	r3, 804729e <tcp_connect+0x3a>
    ip_route_get_local_ip(&pcb->local_ip, &pcb->remote_ip, netif, local_ip);
 8047284:	1d20      	adds	r0, r4, #4
 8047286:	f003 fb33 	bl	804a8f0 <ip4_route>
 804728a:	4603      	mov	r3, r0
 804728c:	2800      	cmp	r0, #0
 804728e:	d047      	beq.n	8047320 <tcp_connect+0xbc>
 8047290:	1d02      	adds	r2, r0, #4
    if ((netif == NULL) || (local_ip == NULL)) {
 8047292:	2b00      	cmp	r3, #0
 8047294:	d060      	beq.n	8047358 <tcp_connect+0xf4>
 8047296:	2a00      	cmp	r2, #0
 8047298:	d061      	beq.n	804735e <tcp_connect+0xfa>
    ip_addr_copy(pcb->local_ip, *local_ip);
 804729a:	6813      	ldr	r3, [r2, #0]
 804729c:	6023      	str	r3, [r4, #0]
  old_local_port = pcb->local_port;
 804729e:	8ae6      	ldrh	r6, [r4, #22]
  if (pcb->local_port == 0) {
 80472a0:	b926      	cbnz	r6, 80472ac <tcp_connect+0x48>
    pcb->local_port = tcp_new_port();
 80472a2:	f7ff f88f 	bl	80463c4 <tcp_new_port>
 80472a6:	82e0      	strh	r0, [r4, #22]
    if (pcb->local_port == 0) {
 80472a8:	2800      	cmp	r0, #0
 80472aa:	d05b      	beq.n	8047364 <tcp_connect+0x100>
  iss = tcp_next_iss(pcb);
 80472ac:	4620      	mov	r0, r4
 80472ae:	f7ff ffbd 	bl	804722c <tcp_next_iss>
  pcb->rcv_nxt = 0;
 80472b2:	2200      	movs	r2, #0
 80472b4:	6262      	str	r2, [r4, #36]	; 0x24
  pcb->snd_nxt = iss;
 80472b6:	64e0      	str	r0, [r4, #76]	; 0x4c
  pcb->lastack = iss - 1;
 80472b8:	3801      	subs	r0, #1
 80472ba:	6460      	str	r0, [r4, #68]	; 0x44
  pcb->snd_wl2 = iss - 1;
 80472bc:	6560      	str	r0, [r4, #84]	; 0x54
  pcb->snd_lbb = iss - 1;
 80472be:	65a0      	str	r0, [r4, #88]	; 0x58
  pcb->rcv_wnd = pcb->rcv_ann_wnd = TCPWND_MIN16(TCP_WND);
 80472c0:	f44f 6306 	mov.w	r3, #2144	; 0x860
 80472c4:	8563      	strh	r3, [r4, #42]	; 0x2a
 80472c6:	8523      	strh	r3, [r4, #40]	; 0x28
  pcb->rcv_ann_right_edge = pcb->rcv_nxt;
 80472c8:	62e2      	str	r2, [r4, #44]	; 0x2c
  pcb->snd_wnd = TCP_WND;
 80472ca:	f8a4 305c 	strh.w	r3, [r4, #92]	; 0x5c
  pcb->mss = INITIAL_MSS;
 80472ce:	f44f 7006 	mov.w	r0, #536	; 0x218
 80472d2:	8660      	strh	r0, [r4, #50]	; 0x32
  pcb->mss = tcp_eff_send_mss(pcb->mss, &pcb->local_ip, &pcb->remote_ip);
 80472d4:	1d21      	adds	r1, r4, #4
 80472d6:	f7ff ffb5 	bl	8047244 <tcp_eff_send_mss_impl>
 80472da:	8660      	strh	r0, [r4, #50]	; 0x32
  pcb->cwnd = 1;
 80472dc:	2301      	movs	r3, #1
 80472de:	f8a4 3048 	strh.w	r3, [r4, #72]	; 0x48
  pcb->connected = connected;
 80472e2:	f8c4 5084 	str.w	r5, [r4, #132]	; 0x84
  ret = tcp_enqueue_flags(pcb, TCP_SYN);
 80472e6:	2102      	movs	r1, #2
 80472e8:	4620      	mov	r0, r4
 80472ea:	f001 fff7 	bl	80492dc <tcp_enqueue_flags>
  if (ret == ERR_OK) {
 80472ee:	4605      	mov	r5, r0
 80472f0:	bb50      	cbnz	r0, 8047348 <tcp_connect+0xe4>
    pcb->state = SYN_SENT;
 80472f2:	2302      	movs	r3, #2
 80472f4:	7523      	strb	r3, [r4, #20]
    if (old_local_port != 0) {
 80472f6:	b1de      	cbz	r6, 8047330 <tcp_connect+0xcc>
      TCP_RMV(&tcp_bound_pcbs, pcb);
 80472f8:	4b1c      	ldr	r3, [pc, #112]	; (804736c <tcp_connect+0x108>)
 80472fa:	681b      	ldr	r3, [r3, #0]
 80472fc:	42a3      	cmp	r3, r4
 80472fe:	d011      	beq.n	8047324 <tcp_connect+0xc0>
 8047300:	b1b3      	cbz	r3, 8047330 <tcp_connect+0xcc>
 8047302:	68da      	ldr	r2, [r3, #12]
 8047304:	42a2      	cmp	r2, r4
 8047306:	d011      	beq.n	804732c <tcp_connect+0xc8>
 8047308:	4613      	mov	r3, r2
 804730a:	e7f9      	b.n	8047300 <tcp_connect+0x9c>
  LWIP_ERROR("tcp_connect: can only connect from state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
 804730c:	4b18      	ldr	r3, [pc, #96]	; (8047370 <tcp_connect+0x10c>)
 804730e:	f44f 725e 	mov.w	r2, #888	; 0x378
 8047312:	4918      	ldr	r1, [pc, #96]	; (8047374 <tcp_connect+0x110>)
 8047314:	4818      	ldr	r0, [pc, #96]	; (8047378 <tcp_connect+0x114>)
 8047316:	f00a fb97 	bl	8051a48 <printf>
 804731a:	f06f 0509 	mvn.w	r5, #9
 804731e:	e013      	b.n	8047348 <tcp_connect+0xe4>
    ip_route_get_local_ip(&pcb->local_ip, &pcb->remote_ip, netif, local_ip);
 8047320:	4602      	mov	r2, r0
 8047322:	e7b6      	b.n	8047292 <tcp_connect+0x2e>
      TCP_RMV(&tcp_bound_pcbs, pcb);
 8047324:	68da      	ldr	r2, [r3, #12]
 8047326:	4b11      	ldr	r3, [pc, #68]	; (804736c <tcp_connect+0x108>)
 8047328:	601a      	str	r2, [r3, #0]
 804732a:	e001      	b.n	8047330 <tcp_connect+0xcc>
 804732c:	68e2      	ldr	r2, [r4, #12]
 804732e:	60da      	str	r2, [r3, #12]
    TCP_REG_ACTIVE(pcb);
 8047330:	4b12      	ldr	r3, [pc, #72]	; (804737c <tcp_connect+0x118>)
 8047332:	681a      	ldr	r2, [r3, #0]
 8047334:	60e2      	str	r2, [r4, #12]
 8047336:	601c      	str	r4, [r3, #0]
 8047338:	f002 fbd6 	bl	8049ae8 <tcp_timer_needed>
 804733c:	4b10      	ldr	r3, [pc, #64]	; (8047380 <tcp_connect+0x11c>)
 804733e:	2201      	movs	r2, #1
 8047340:	701a      	strb	r2, [r3, #0]
    tcp_output(pcb);
 8047342:	4620      	mov	r0, r4
 8047344:	f002 f8d8 	bl	80494f8 <tcp_output>
}
 8047348:	4628      	mov	r0, r5
 804734a:	bd70      	pop	{r4, r5, r6, pc}
    return ERR_VAL;
 804734c:	f06f 0505 	mvn.w	r5, #5
 8047350:	e7fa      	b.n	8047348 <tcp_connect+0xe4>
 8047352:	f06f 0505 	mvn.w	r5, #5
 8047356:	e7f7      	b.n	8047348 <tcp_connect+0xe4>
      return ERR_RTE;
 8047358:	f06f 0503 	mvn.w	r5, #3
 804735c:	e7f4      	b.n	8047348 <tcp_connect+0xe4>
 804735e:	f06f 0503 	mvn.w	r5, #3
 8047362:	e7f1      	b.n	8047348 <tcp_connect+0xe4>
      return ERR_BUF;
 8047364:	f06f 0501 	mvn.w	r5, #1
 8047368:	e7ee      	b.n	8047348 <tcp_connect+0xe4>
 804736a:	bf00      	nop
 804736c:	2000872c 	.word	0x2000872c
 8047370:	08059618 	.word	0x08059618
 8047374:	080599c4 	.word	0x080599c4
 8047378:	08058ecc 	.word	0x08058ecc
 804737c:	20008720 	.word	0x20008720
 8047380:	2000871c 	.word	0x2000871c

08047384 <tcp_netif_ip_addr_changed>:
void
tcp_netif_ip_addr_changed(const ip_addr_t* old_addr, const ip_addr_t* new_addr)
{
  struct tcp_pcb_listen *lpcb, *next;

  if (!ip_addr_isany(old_addr)) {
 8047384:	b308      	cbz	r0, 80473ca <tcp_netif_ip_addr_changed+0x46>
{
 8047386:	b538      	push	{r3, r4, r5, lr}
 8047388:	460d      	mov	r5, r1
 804738a:	4604      	mov	r4, r0
  if (!ip_addr_isany(old_addr)) {
 804738c:	6803      	ldr	r3, [r0, #0]
 804738e:	b903      	cbnz	r3, 8047392 <tcp_netif_ip_addr_changed+0xe>
          ip_addr_copy(lpcb->local_ip, *new_addr);
        }
      }
    }
  }
}
 8047390:	bd38      	pop	{r3, r4, r5, pc}
    tcp_netif_ip_addr_changed_pcblist(old_addr, tcp_active_pcbs);
 8047392:	4b0e      	ldr	r3, [pc, #56]	; (80473cc <tcp_netif_ip_addr_changed+0x48>)
 8047394:	6819      	ldr	r1, [r3, #0]
 8047396:	f7ff fea1 	bl	80470dc <tcp_netif_ip_addr_changed_pcblist>
    tcp_netif_ip_addr_changed_pcblist(old_addr, tcp_bound_pcbs);
 804739a:	4b0d      	ldr	r3, [pc, #52]	; (80473d0 <tcp_netif_ip_addr_changed+0x4c>)
 804739c:	6819      	ldr	r1, [r3, #0]
 804739e:	4620      	mov	r0, r4
 80473a0:	f7ff fe9c 	bl	80470dc <tcp_netif_ip_addr_changed_pcblist>
    if (!ip_addr_isany(new_addr)) {
 80473a4:	2d00      	cmp	r5, #0
 80473a6:	d0f3      	beq.n	8047390 <tcp_netif_ip_addr_changed+0xc>
 80473a8:	682b      	ldr	r3, [r5, #0]
 80473aa:	2b00      	cmp	r3, #0
 80473ac:	d0f0      	beq.n	8047390 <tcp_netif_ip_addr_changed+0xc>
      for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = next) {
 80473ae:	4b09      	ldr	r3, [pc, #36]	; (80473d4 <tcp_netif_ip_addr_changed+0x50>)
 80473b0:	681b      	ldr	r3, [r3, #0]
 80473b2:	e000      	b.n	80473b6 <tcp_netif_ip_addr_changed+0x32>
{
 80473b4:	4613      	mov	r3, r2
      for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = next) {
 80473b6:	2b00      	cmp	r3, #0
 80473b8:	d0ea      	beq.n	8047390 <tcp_netif_ip_addr_changed+0xc>
        next = lpcb->next;
 80473ba:	68da      	ldr	r2, [r3, #12]
        if (ip_addr_cmp(&lpcb->local_ip, old_addr)) {
 80473bc:	6818      	ldr	r0, [r3, #0]
 80473be:	6821      	ldr	r1, [r4, #0]
 80473c0:	4288      	cmp	r0, r1
 80473c2:	d1f7      	bne.n	80473b4 <tcp_netif_ip_addr_changed+0x30>
          ip_addr_copy(lpcb->local_ip, *new_addr);
 80473c4:	6829      	ldr	r1, [r5, #0]
 80473c6:	6019      	str	r1, [r3, #0]
 80473c8:	e7f4      	b.n	80473b4 <tcp_netif_ip_addr_changed+0x30>
 80473ca:	4770      	bx	lr
 80473cc:	20008720 	.word	0x20008720
 80473d0:	2000872c 	.word	0x2000872c
 80473d4:	20008728 	.word	0x20008728

080473d8 <tcp_getoptbyte>:
}

static u8_t
tcp_getoptbyte(void)
{
  if ((tcphdr_opt2 == NULL) || (tcp_optidx < tcphdr_opt1len)) {
 80473d8:	4b0d      	ldr	r3, [pc, #52]	; (8047410 <tcp_getoptbyte+0x38>)
 80473da:	6819      	ldr	r1, [r3, #0]
 80473dc:	b121      	cbz	r1, 80473e8 <tcp_getoptbyte+0x10>
 80473de:	461a      	mov	r2, r3
 80473e0:	889b      	ldrh	r3, [r3, #4]
 80473e2:	88d2      	ldrh	r2, [r2, #6]
 80473e4:	4293      	cmp	r3, r2
 80473e6:	d207      	bcs.n	80473f8 <tcp_getoptbyte+0x20>
    u8_t* opts = (u8_t *)tcphdr + TCP_HLEN;
 80473e8:	4a09      	ldr	r2, [pc, #36]	; (8047410 <tcp_getoptbyte+0x38>)
 80473ea:	6893      	ldr	r3, [r2, #8]
    return opts[tcp_optidx++];
 80473ec:	8891      	ldrh	r1, [r2, #4]
 80473ee:	1c48      	adds	r0, r1, #1
 80473f0:	8090      	strh	r0, [r2, #4]
 80473f2:	440b      	add	r3, r1
 80473f4:	7d18      	ldrb	r0, [r3, #20]
  } else {
    u8_t idx = (u8_t)(tcp_optidx++ - tcphdr_opt1len);
    return tcphdr_opt2[idx];
  }
}
 80473f6:	4770      	bx	lr
{
 80473f8:	b410      	push	{r4}
    u8_t idx = (u8_t)(tcp_optidx++ - tcphdr_opt1len);
 80473fa:	1c5c      	adds	r4, r3, #1
 80473fc:	4804      	ldr	r0, [pc, #16]	; (8047410 <tcp_getoptbyte+0x38>)
 80473fe:	8084      	strh	r4, [r0, #4]
 8047400:	b2db      	uxtb	r3, r3
 8047402:	b2d2      	uxtb	r2, r2
 8047404:	1a9b      	subs	r3, r3, r2
 8047406:	b2db      	uxtb	r3, r3
    return tcphdr_opt2[idx];
 8047408:	5cc8      	ldrb	r0, [r1, r3]
}
 804740a:	f85d 4b04 	ldr.w	r4, [sp], #4
 804740e:	4770      	bx	lr
 8047410:	200040d4 	.word	0x200040d4

08047414 <tcp_parseopt>:
 *
 * @param pcb the tcp_pcb for which a segment arrived
 */
static void
tcp_parseopt(struct tcp_pcb *pcb)
{
 8047414:	b538      	push	{r3, r4, r5, lr}
#if LWIP_TCP_TIMESTAMPS
  u32_t tsval;
#endif

  /* Parse the TCP MSS option, if present. */
  if (tcphdr_optlen != 0) {
 8047416:	4b1e      	ldr	r3, [pc, #120]	; (8047490 <tcp_parseopt+0x7c>)
 8047418:	899b      	ldrh	r3, [r3, #12]
 804741a:	2b00      	cmp	r3, #0
 804741c:	d036      	beq.n	804748c <tcp_parseopt+0x78>
 804741e:	4604      	mov	r4, r0
    for (tcp_optidx = 0; tcp_optidx < tcphdr_optlen; ) {
 8047420:	4b1b      	ldr	r3, [pc, #108]	; (8047490 <tcp_parseopt+0x7c>)
 8047422:	2200      	movs	r2, #0
 8047424:	809a      	strh	r2, [r3, #4]
 8047426:	4b1a      	ldr	r3, [pc, #104]	; (8047490 <tcp_parseopt+0x7c>)
 8047428:	889a      	ldrh	r2, [r3, #4]
 804742a:	899b      	ldrh	r3, [r3, #12]
 804742c:	429a      	cmp	r2, r3
 804742e:	d22d      	bcs.n	804748c <tcp_parseopt+0x78>
      u8_t opt = tcp_getoptbyte();
 8047430:	f7ff ffd2 	bl	80473d8 <tcp_getoptbyte>
      switch (opt) {
 8047434:	2801      	cmp	r0, #1
 8047436:	d0f6      	beq.n	8047426 <tcp_parseopt+0x12>
 8047438:	2802      	cmp	r0, #2
 804743a:	d00b      	beq.n	8047454 <tcp_parseopt+0x40>
 804743c:	b330      	cbz	r0, 804748c <tcp_parseopt+0x78>
        tcp_optidx += LWIP_TCP_OPT_LEN_TS - 6;
        break;
#endif
      default:
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: other\n"));
        data = tcp_getoptbyte();
 804743e:	f7ff ffcb 	bl	80473d8 <tcp_getoptbyte>
 8047442:	4603      	mov	r3, r0
        if (data < 2) {
 8047444:	2801      	cmp	r0, #1
 8047446:	d921      	bls.n	804748c <tcp_parseopt+0x78>
             and we don't process them further. */
          return;
        }
        /* All other options have a length field, so that we easily
           can skip past them. */
        tcp_optidx += data - 2;
 8047448:	4a11      	ldr	r2, [pc, #68]	; (8047490 <tcp_parseopt+0x7c>)
 804744a:	8890      	ldrh	r0, [r2, #4]
 804744c:	4403      	add	r3, r0
 804744e:	3b02      	subs	r3, #2
 8047450:	8093      	strh	r3, [r2, #4]
 8047452:	e7e8      	b.n	8047426 <tcp_parseopt+0x12>
        if (tcp_getoptbyte() != LWIP_TCP_OPT_LEN_MSS || (tcp_optidx - 2 + LWIP_TCP_OPT_LEN_MSS) > tcphdr_optlen) {
 8047454:	f7ff ffc0 	bl	80473d8 <tcp_getoptbyte>
 8047458:	2804      	cmp	r0, #4
 804745a:	d117      	bne.n	804748c <tcp_parseopt+0x78>
 804745c:	4a0c      	ldr	r2, [pc, #48]	; (8047490 <tcp_parseopt+0x7c>)
 804745e:	8893      	ldrh	r3, [r2, #4]
 8047460:	3301      	adds	r3, #1
 8047462:	8992      	ldrh	r2, [r2, #12]
 8047464:	4293      	cmp	r3, r2
 8047466:	da11      	bge.n	804748c <tcp_parseopt+0x78>
        mss = (tcp_getoptbyte() << 8);
 8047468:	f7ff ffb6 	bl	80473d8 <tcp_getoptbyte>
 804746c:	b285      	uxth	r5, r0
 804746e:	022d      	lsls	r5, r5, #8
 8047470:	b2ad      	uxth	r5, r5
        mss |= tcp_getoptbyte();
 8047472:	f7ff ffb1 	bl	80473d8 <tcp_getoptbyte>
 8047476:	b280      	uxth	r0, r0
 8047478:	4305      	orrs	r5, r0
        pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
 804747a:	1e6b      	subs	r3, r5, #1
 804747c:	b29b      	uxth	r3, r3
 804747e:	f5b3 7f06 	cmp.w	r3, #536	; 0x218
 8047482:	d301      	bcc.n	8047488 <tcp_parseopt+0x74>
 8047484:	f44f 7506 	mov.w	r5, #536	; 0x218
 8047488:	8665      	strh	r5, [r4, #50]	; 0x32
        break;
 804748a:	e7cc      	b.n	8047426 <tcp_parseopt+0x12>
      }
    }
  }
}
 804748c:	bd38      	pop	{r3, r4, r5, pc}
 804748e:	bf00      	nop
 8047490:	200040d4 	.word	0x200040d4

08047494 <tcp_input_delayed_close>:
  if (recv_flags & TF_CLOSED) {
 8047494:	4b0e      	ldr	r3, [pc, #56]	; (80474d0 <tcp_input_delayed_close+0x3c>)
 8047496:	7b9b      	ldrb	r3, [r3, #14]
 8047498:	f013 0f10 	tst.w	r3, #16
 804749c:	d101      	bne.n	80474a2 <tcp_input_delayed_close+0xe>
  return 0;
 804749e:	2000      	movs	r0, #0
}
 80474a0:	4770      	bx	lr
{
 80474a2:	b510      	push	{r4, lr}
 80474a4:	4604      	mov	r4, r0
    if (!(pcb->flags & TF_RXCLOSED)) {
 80474a6:	7e83      	ldrb	r3, [r0, #26]
 80474a8:	f013 0f10 	tst.w	r3, #16
 80474ac:	d106      	bne.n	80474bc <tcp_input_delayed_close+0x28>
      TCP_EVENT_ERR(pcb->state, pcb->errf, pcb->callback_arg, ERR_CLSD);
 80474ae:	f8d0 308c 	ldr.w	r3, [r0, #140]	; 0x8c
 80474b2:	b11b      	cbz	r3, 80474bc <tcp_input_delayed_close+0x28>
 80474b4:	f06f 010e 	mvn.w	r1, #14
 80474b8:	6900      	ldr	r0, [r0, #16]
 80474ba:	4798      	blx	r3
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
 80474bc:	4621      	mov	r1, r4
 80474be:	4805      	ldr	r0, [pc, #20]	; (80474d4 <tcp_input_delayed_close+0x40>)
 80474c0:	f7ff fbac 	bl	8046c1c <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB, pcb);
 80474c4:	4621      	mov	r1, r4
 80474c6:	2001      	movs	r0, #1
 80474c8:	f7fe fa54 	bl	8045974 <memp_free>
    return 1;
 80474cc:	2001      	movs	r0, #1
}
 80474ce:	bd10      	pop	{r4, pc}
 80474d0:	200040d4 	.word	0x200040d4
 80474d4:	20008720 	.word	0x20008720

080474d8 <tcp_timewait_input>:
  if (flags & TCP_RST) {
 80474d8:	4b1b      	ldr	r3, [pc, #108]	; (8047548 <tcp_timewait_input+0x70>)
 80474da:	7bdb      	ldrb	r3, [r3, #15]
 80474dc:	f013 0f04 	tst.w	r3, #4
 80474e0:	d130      	bne.n	8047544 <tcp_timewait_input+0x6c>
{
 80474e2:	b530      	push	{r4, r5, lr}
 80474e4:	b083      	sub	sp, #12
  if (flags & TCP_SYN) {
 80474e6:	f013 0f02 	tst.w	r3, #2
 80474ea:	d01d      	beq.n	8047528 <tcp_timewait_input+0x50>
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd)) {
 80474ec:	4b16      	ldr	r3, [pc, #88]	; (8047548 <tcp_timewait_input+0x70>)
 80474ee:	6919      	ldr	r1, [r3, #16]
 80474f0:	6a43      	ldr	r3, [r0, #36]	; 0x24
 80474f2:	1aca      	subs	r2, r1, r3
 80474f4:	2a00      	cmp	r2, #0
 80474f6:	db04      	blt.n	8047502 <tcp_timewait_input+0x2a>
 80474f8:	8d02      	ldrh	r2, [r0, #40]	; 0x28
 80474fa:	4413      	add	r3, r2
 80474fc:	1acb      	subs	r3, r1, r3
 80474fe:	2b00      	cmp	r3, #0
 8047500:	dd04      	ble.n	804750c <tcp_timewait_input+0x34>
  if ((tcplen > 0)) {
 8047502:	4b11      	ldr	r3, [pc, #68]	; (8047548 <tcp_timewait_input+0x70>)
 8047504:	8a9b      	ldrh	r3, [r3, #20]
 8047506:	b9b3      	cbnz	r3, 8047536 <tcp_timewait_input+0x5e>
}
 8047508:	b003      	add	sp, #12
 804750a:	bd30      	pop	{r4, r5, pc}
        ip_current_src_addr(), tcphdr->dest, tcphdr->src);
 804750c:	480e      	ldr	r0, [pc, #56]	; (8047548 <tcp_timewait_input+0x70>)
 804750e:	6882      	ldr	r2, [r0, #8]
      tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(),
 8047510:	4b0e      	ldr	r3, [pc, #56]	; (804754c <tcp_timewait_input+0x74>)
 8047512:	8a84      	ldrh	r4, [r0, #20]
 8047514:	8815      	ldrh	r5, [r2, #0]
 8047516:	9501      	str	r5, [sp, #4]
 8047518:	8852      	ldrh	r2, [r2, #2]
 804751a:	9200      	str	r2, [sp, #0]
 804751c:	1d1a      	adds	r2, r3, #4
 804751e:	4421      	add	r1, r4
 8047520:	6980      	ldr	r0, [r0, #24]
 8047522:	f002 f931 	bl	8049788 <tcp_rst>
      return;
 8047526:	e7ef      	b.n	8047508 <tcp_timewait_input+0x30>
  } else if (flags & TCP_FIN) {
 8047528:	f013 0f01 	tst.w	r3, #1
 804752c:	d0e9      	beq.n	8047502 <tcp_timewait_input+0x2a>
    pcb->tmr = tcp_ticks;
 804752e:	4b08      	ldr	r3, [pc, #32]	; (8047550 <tcp_timewait_input+0x78>)
 8047530:	681b      	ldr	r3, [r3, #0]
 8047532:	6203      	str	r3, [r0, #32]
 8047534:	e7e5      	b.n	8047502 <tcp_timewait_input+0x2a>
    pcb->flags |= TF_ACK_NOW;
 8047536:	7e83      	ldrb	r3, [r0, #26]
 8047538:	f043 0302 	orr.w	r3, r3, #2
 804753c:	7683      	strb	r3, [r0, #26]
    tcp_output(pcb);
 804753e:	f001 ffdb 	bl	80494f8 <tcp_output>
 8047542:	e7e1      	b.n	8047508 <tcp_timewait_input+0x30>
 8047544:	4770      	bx	lr
 8047546:	bf00      	nop
 8047548:	200040d4 	.word	0x200040d4
 804754c:	20005200 	.word	0x20005200
 8047550:	20008724 	.word	0x20008724

08047554 <tcp_listen_input>:
  if (flags & TCP_RST) {
 8047554:	4b3a      	ldr	r3, [pc, #232]	; (8047640 <tcp_listen_input+0xec>)
 8047556:	7bdb      	ldrb	r3, [r3, #15]
 8047558:	f013 0f04 	tst.w	r3, #4
 804755c:	d16e      	bne.n	804763c <tcp_listen_input+0xe8>
{
 804755e:	b570      	push	{r4, r5, r6, lr}
 8047560:	b082      	sub	sp, #8
 8047562:	4605      	mov	r5, r0
  if (flags & TCP_ACK) {
 8047564:	f013 0f10 	tst.w	r3, #16
 8047568:	d104      	bne.n	8047574 <tcp_listen_input+0x20>
  } else if (flags & TCP_SYN) {
 804756a:	f013 0f02 	tst.w	r3, #2
 804756e:	d110      	bne.n	8047592 <tcp_listen_input+0x3e>
}
 8047570:	b002      	add	sp, #8
 8047572:	bd70      	pop	{r4, r5, r6, pc}
      ip_current_src_addr(), tcphdr->dest, tcphdr->src);
 8047574:	4832      	ldr	r0, [pc, #200]	; (8047640 <tcp_listen_input+0xec>)
 8047576:	6882      	ldr	r2, [r0, #8]
    tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(),
 8047578:	4b32      	ldr	r3, [pc, #200]	; (8047644 <tcp_listen_input+0xf0>)
 804757a:	8a84      	ldrh	r4, [r0, #20]
 804757c:	6901      	ldr	r1, [r0, #16]
 804757e:	8815      	ldrh	r5, [r2, #0]
 8047580:	9501      	str	r5, [sp, #4]
 8047582:	8852      	ldrh	r2, [r2, #2]
 8047584:	9200      	str	r2, [sp, #0]
 8047586:	1d1a      	adds	r2, r3, #4
 8047588:	4421      	add	r1, r4
 804758a:	6980      	ldr	r0, [r0, #24]
 804758c:	f002 f8fc 	bl	8049788 <tcp_rst>
 8047590:	e7ee      	b.n	8047570 <tcp_listen_input+0x1c>
    npcb = tcp_alloc(pcb->prio);
 8047592:	7d40      	ldrb	r0, [r0, #21]
 8047594:	f7ff fde4 	bl	8047160 <tcp_alloc>
    if (npcb == NULL) {
 8047598:	4604      	mov	r4, r0
 804759a:	2800      	cmp	r0, #0
 804759c:	d040      	beq.n	8047620 <tcp_listen_input+0xcc>
    ip_addr_copy(npcb->local_ip, *ip_current_dest_addr());
 804759e:	4b2a      	ldr	r3, [pc, #168]	; (8047648 <tcp_listen_input+0xf4>)
 80475a0:	695a      	ldr	r2, [r3, #20]
 80475a2:	6002      	str	r2, [r0, #0]
    ip_addr_copy(npcb->remote_ip, *ip_current_src_addr());
 80475a4:	691b      	ldr	r3, [r3, #16]
 80475a6:	6043      	str	r3, [r0, #4]
    npcb->local_port = pcb->local_port;
 80475a8:	8aeb      	ldrh	r3, [r5, #22]
 80475aa:	82c3      	strh	r3, [r0, #22]
    npcb->remote_port = tcphdr->src;
 80475ac:	4e24      	ldr	r6, [pc, #144]	; (8047640 <tcp_listen_input+0xec>)
 80475ae:	68b3      	ldr	r3, [r6, #8]
 80475b0:	881b      	ldrh	r3, [r3, #0]
 80475b2:	8303      	strh	r3, [r0, #24]
    npcb->state = SYN_RCVD;
 80475b4:	2303      	movs	r3, #3
 80475b6:	7503      	strb	r3, [r0, #20]
    npcb->rcv_nxt = seqno + 1;
 80475b8:	6933      	ldr	r3, [r6, #16]
 80475ba:	3301      	adds	r3, #1
 80475bc:	6243      	str	r3, [r0, #36]	; 0x24
    npcb->rcv_ann_right_edge = npcb->rcv_nxt;
 80475be:	62c3      	str	r3, [r0, #44]	; 0x2c
    iss = tcp_next_iss(npcb);
 80475c0:	f7ff fe34 	bl	804722c <tcp_next_iss>
    npcb->snd_wl2 = iss;
 80475c4:	6560      	str	r0, [r4, #84]	; 0x54
    npcb->snd_nxt = iss;
 80475c6:	64e0      	str	r0, [r4, #76]	; 0x4c
    npcb->lastack = iss;
 80475c8:	6460      	str	r0, [r4, #68]	; 0x44
    npcb->snd_lbb = iss;
 80475ca:	65a0      	str	r0, [r4, #88]	; 0x58
    npcb->snd_wl1 = seqno - 1;/* initialise to seqno-1 to force window update */
 80475cc:	6933      	ldr	r3, [r6, #16]
 80475ce:	3b01      	subs	r3, #1
 80475d0:	6523      	str	r3, [r4, #80]	; 0x50
    npcb->callback_arg = pcb->callback_arg;
 80475d2:	692b      	ldr	r3, [r5, #16]
 80475d4:	6123      	str	r3, [r4, #16]
    npcb->listener = pcb;
 80475d6:	67a5      	str	r5, [r4, #120]	; 0x78
    npcb->so_options = pcb->so_options & SOF_INHERITED;
 80475d8:	7a2b      	ldrb	r3, [r5, #8]
 80475da:	f003 030c 	and.w	r3, r3, #12
 80475de:	7223      	strb	r3, [r4, #8]
    TCP_REG_ACTIVE(npcb);
 80475e0:	4b1a      	ldr	r3, [pc, #104]	; (804764c <tcp_listen_input+0xf8>)
 80475e2:	681a      	ldr	r2, [r3, #0]
 80475e4:	60e2      	str	r2, [r4, #12]
 80475e6:	601c      	str	r4, [r3, #0]
 80475e8:	f002 fa7e 	bl	8049ae8 <tcp_timer_needed>
 80475ec:	4b18      	ldr	r3, [pc, #96]	; (8047650 <tcp_listen_input+0xfc>)
 80475ee:	2201      	movs	r2, #1
 80475f0:	701a      	strb	r2, [r3, #0]
    tcp_parseopt(npcb);
 80475f2:	4620      	mov	r0, r4
 80475f4:	f7ff ff0e 	bl	8047414 <tcp_parseopt>
    npcb->snd_wnd = tcphdr->wnd;
 80475f8:	68b3      	ldr	r3, [r6, #8]
 80475fa:	89db      	ldrh	r3, [r3, #14]
 80475fc:	f8a4 305c 	strh.w	r3, [r4, #92]	; 0x5c
    npcb->snd_wnd_max = npcb->snd_wnd;
 8047600:	f8a4 305e 	strh.w	r3, [r4, #94]	; 0x5e
    npcb->mss = tcp_eff_send_mss(npcb->mss, &npcb->local_ip, &npcb->remote_ip);
 8047604:	1d21      	adds	r1, r4, #4
 8047606:	8e60      	ldrh	r0, [r4, #50]	; 0x32
 8047608:	f7ff fe1c 	bl	8047244 <tcp_eff_send_mss_impl>
 804760c:	8660      	strh	r0, [r4, #50]	; 0x32
    rc = tcp_enqueue_flags(npcb, TCP_SYN | TCP_ACK);
 804760e:	2112      	movs	r1, #18
 8047610:	4620      	mov	r0, r4
 8047612:	f001 fe63 	bl	80492dc <tcp_enqueue_flags>
    if (rc != ERR_OK) {
 8047616:	b960      	cbnz	r0, 8047632 <tcp_listen_input+0xde>
    tcp_output(npcb);
 8047618:	4620      	mov	r0, r4
 804761a:	f001 ff6d 	bl	80494f8 <tcp_output>
 804761e:	e7a7      	b.n	8047570 <tcp_listen_input+0x1c>
      TCP_EVENT_ACCEPT(pcb, NULL, pcb->callback_arg, ERR_MEM, err);
 8047620:	69ab      	ldr	r3, [r5, #24]
 8047622:	2b00      	cmp	r3, #0
 8047624:	d0a4      	beq.n	8047570 <tcp_listen_input+0x1c>
 8047626:	f04f 32ff 	mov.w	r2, #4294967295
 804762a:	2100      	movs	r1, #0
 804762c:	6928      	ldr	r0, [r5, #16]
 804762e:	4798      	blx	r3
      return;
 8047630:	e79e      	b.n	8047570 <tcp_listen_input+0x1c>
      tcp_abandon(npcb, 0);
 8047632:	2100      	movs	r1, #0
 8047634:	4620      	mov	r0, r4
 8047636:	f7ff fc91 	bl	8046f5c <tcp_abandon>
      return;
 804763a:	e799      	b.n	8047570 <tcp_listen_input+0x1c>
 804763c:	4770      	bx	lr
 804763e:	bf00      	nop
 8047640:	200040d4 	.word	0x200040d4
 8047644:	20005200 	.word	0x20005200
 8047648:	200051f0 	.word	0x200051f0
 804764c:	20008720 	.word	0x20008720
 8047650:	2000871c 	.word	0x2000871c

08047654 <tcp_oos_insert_segment>:
{
 8047654:	b570      	push	{r4, r5, r6, lr}
 8047656:	4605      	mov	r5, r0
 8047658:	460c      	mov	r4, r1
  if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
 804765a:	68c3      	ldr	r3, [r0, #12]
 804765c:	8998      	ldrh	r0, [r3, #12]
 804765e:	f7fd ff07 	bl	8045470 <lwip_htons>
 8047662:	f010 0f01 	tst.w	r0, #1
 8047666:	d012      	beq.n	804768e <tcp_oos_insert_segment+0x3a>
    tcp_segs_free(next);
 8047668:	4620      	mov	r0, r4
 804766a:	f7ff f828 	bl	80466be <tcp_segs_free>
    next = NULL;
 804766e:	2400      	movs	r4, #0
  cseg->next = next;
 8047670:	602c      	str	r4, [r5, #0]
}
 8047672:	bd70      	pop	{r4, r5, r6, pc}
        TCPH_SET_FLAG(cseg->tcphdr, TCP_FIN);
 8047674:	68eb      	ldr	r3, [r5, #12]
 8047676:	899e      	ldrh	r6, [r3, #12]
 8047678:	2001      	movs	r0, #1
 804767a:	f7fd fef9 	bl	8045470 <lwip_htons>
 804767e:	68eb      	ldr	r3, [r5, #12]
 8047680:	4306      	orrs	r6, r0
 8047682:	819e      	strh	r6, [r3, #12]
      next = next->next;
 8047684:	6826      	ldr	r6, [r4, #0]
      tcp_seg_free(old_seg);
 8047686:	4620      	mov	r0, r4
 8047688:	f7ff f80c 	bl	80466a4 <tcp_seg_free>
      next = next->next;
 804768c:	4634      	mov	r4, r6
    while (next &&
 804768e:	b18c      	cbz	r4, 80476b4 <tcp_oos_insert_segment+0x60>
           TCP_SEQ_GEQ((seqno + cseg->len),
 8047690:	892b      	ldrh	r3, [r5, #8]
 8047692:	4a11      	ldr	r2, [pc, #68]	; (80476d8 <tcp_oos_insert_segment+0x84>)
 8047694:	6912      	ldr	r2, [r2, #16]
 8047696:	4413      	add	r3, r2
 8047698:	68e1      	ldr	r1, [r4, #12]
 804769a:	684a      	ldr	r2, [r1, #4]
 804769c:	8920      	ldrh	r0, [r4, #8]
 804769e:	4402      	add	r2, r0
 80476a0:	1a9b      	subs	r3, r3, r2
    while (next &&
 80476a2:	2b00      	cmp	r3, #0
 80476a4:	db06      	blt.n	80476b4 <tcp_oos_insert_segment+0x60>
      if (TCPH_FLAGS(next->tcphdr) & TCP_FIN) {
 80476a6:	8988      	ldrh	r0, [r1, #12]
 80476a8:	f7fd fee2 	bl	8045470 <lwip_htons>
 80476ac:	f010 0f01 	tst.w	r0, #1
 80476b0:	d0e8      	beq.n	8047684 <tcp_oos_insert_segment+0x30>
 80476b2:	e7df      	b.n	8047674 <tcp_oos_insert_segment+0x20>
    if (next &&
 80476b4:	2c00      	cmp	r4, #0
 80476b6:	d0db      	beq.n	8047670 <tcp_oos_insert_segment+0x1c>
        TCP_SEQ_GT(seqno + cseg->len, next->tcphdr->seqno)) {
 80476b8:	892b      	ldrh	r3, [r5, #8]
 80476ba:	4a07      	ldr	r2, [pc, #28]	; (80476d8 <tcp_oos_insert_segment+0x84>)
 80476bc:	6911      	ldr	r1, [r2, #16]
 80476be:	440b      	add	r3, r1
 80476c0:	68e2      	ldr	r2, [r4, #12]
 80476c2:	6852      	ldr	r2, [r2, #4]
 80476c4:	1a9b      	subs	r3, r3, r2
    if (next &&
 80476c6:	2b00      	cmp	r3, #0
 80476c8:	ddd2      	ble.n	8047670 <tcp_oos_insert_segment+0x1c>
      cseg->len = (u16_t)(next->tcphdr->seqno - seqno);
 80476ca:	1a52      	subs	r2, r2, r1
 80476cc:	b291      	uxth	r1, r2
 80476ce:	8129      	strh	r1, [r5, #8]
      pbuf_realloc(cseg->p, cseg->len);
 80476d0:	6868      	ldr	r0, [r5, #4]
 80476d2:	f7fe fc57 	bl	8045f84 <pbuf_realloc>
 80476d6:	e7cb      	b.n	8047670 <tcp_oos_insert_segment+0x1c>
 80476d8:	200040d4 	.word	0x200040d4

080476dc <tcp_receive>:
{
 80476dc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80476de:	4604      	mov	r4, r0
  LWIP_ASSERT("tcp_receive: wrong state", pcb->state >= ESTABLISHED);
 80476e0:	7d03      	ldrb	r3, [r0, #20]
 80476e2:	2b03      	cmp	r3, #3
 80476e4:	d979      	bls.n	80477da <tcp_receive+0xfe>
  if (flags & TCP_ACK) {
 80476e6:	4bb3      	ldr	r3, [pc, #716]	; (80479b4 <tcp_receive+0x2d8>)
 80476e8:	7bdb      	ldrb	r3, [r3, #15]
 80476ea:	f013 0f10 	tst.w	r3, #16
 80476ee:	f000 8194 	beq.w	8047a1a <tcp_receive+0x33e>
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl2;
 80476f2:	f8b4 005c 	ldrh.w	r0, [r4, #92]	; 0x5c
 80476f6:	6d62      	ldr	r2, [r4, #84]	; 0x54
 80476f8:	1886      	adds	r6, r0, r2
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
 80476fa:	6d21      	ldr	r1, [r4, #80]	; 0x50
 80476fc:	4bad      	ldr	r3, [pc, #692]	; (80479b4 <tcp_receive+0x2d8>)
 80476fe:	691b      	ldr	r3, [r3, #16]
 8047700:	1acd      	subs	r5, r1, r3
 8047702:	2d00      	cmp	r5, #0
 8047704:	db7c      	blt.n	8047800 <tcp_receive+0x124>
 8047706:	4299      	cmp	r1, r3
 8047708:	d06f      	beq.n	80477ea <tcp_receive+0x10e>
       (pcb->snd_wl2 == ackno && (u32_t)SND_WND_SCALE(pcb, tcphdr->wnd) > pcb->snd_wnd)) {
 804770a:	49aa      	ldr	r1, [pc, #680]	; (80479b4 <tcp_receive+0x2d8>)
 804770c:	6989      	ldr	r1, [r1, #24]
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
 804770e:	428a      	cmp	r2, r1
 8047710:	d071      	beq.n	80477f6 <tcp_receive+0x11a>
    if (TCP_SEQ_LEQ(ackno, pcb->lastack)) {
 8047712:	4ba8      	ldr	r3, [pc, #672]	; (80479b4 <tcp_receive+0x2d8>)
 8047714:	699b      	ldr	r3, [r3, #24]
 8047716:	6c61      	ldr	r1, [r4, #68]	; 0x44
 8047718:	1a5a      	subs	r2, r3, r1
 804771a:	2a00      	cmp	r2, #0
 804771c:	f340 8095 	ble.w	804784a <tcp_receive+0x16e>
    } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
 8047720:	2a01      	cmp	r2, #1
 8047722:	d404      	bmi.n	804772e <tcp_receive+0x52>
 8047724:	6ce2      	ldr	r2, [r4, #76]	; 0x4c
 8047726:	1a9a      	subs	r2, r3, r2
 8047728:	2a00      	cmp	r2, #0
 804772a:	f340 80be 	ble.w	80478aa <tcp_receive+0x1ce>
      tcp_send_empty_ack(pcb);
 804772e:	4620      	mov	r0, r4
 8047730:	f001 fea8 	bl	8049484 <tcp_send_empty_ack>
    while (pcb->unsent != NULL &&
 8047734:	6ea3      	ldr	r3, [r4, #104]	; 0x68
 8047736:	2b00      	cmp	r3, #0
 8047738:	f000 8160 	beq.w	80479fc <tcp_receive+0x320>
           TCP_SEQ_BETWEEN(ackno, lwip_ntohl(pcb->unsent->tcphdr->seqno) +
 804773c:	4a9d      	ldr	r2, [pc, #628]	; (80479b4 <tcp_receive+0x2d8>)
 804773e:	6996      	ldr	r6, [r2, #24]
 8047740:	68db      	ldr	r3, [r3, #12]
 8047742:	6858      	ldr	r0, [r3, #4]
 8047744:	f7fd fe97 	bl	8045476 <lwip_htonl>
 8047748:	4605      	mov	r5, r0
 804774a:	6ea3      	ldr	r3, [r4, #104]	; 0x68
 804774c:	891f      	ldrh	r7, [r3, #8]
 804774e:	68db      	ldr	r3, [r3, #12]
 8047750:	8998      	ldrh	r0, [r3, #12]
 8047752:	f7fd fe8d 	bl	8045470 <lwip_htons>
 8047756:	f010 0f03 	tst.w	r0, #3
 804775a:	f000 814d 	beq.w	80479f8 <tcp_receive+0x31c>
 804775e:	2001      	movs	r0, #1
 8047760:	4407      	add	r7, r0
 8047762:	443d      	add	r5, r7
 8047764:	1b75      	subs	r5, r6, r5
    while (pcb->unsent != NULL &&
 8047766:	2d00      	cmp	r5, #0
 8047768:	f2c0 8148 	blt.w	80479fc <tcp_receive+0x320>
           TCP_SEQ_BETWEEN(ackno, lwip_ntohl(pcb->unsent->tcphdr->seqno) +
 804776c:	4b91      	ldr	r3, [pc, #580]	; (80479b4 <tcp_receive+0x2d8>)
 804776e:	699b      	ldr	r3, [r3, #24]
 8047770:	6ce2      	ldr	r2, [r4, #76]	; 0x4c
 8047772:	1a9b      	subs	r3, r3, r2
 8047774:	2b00      	cmp	r3, #0
 8047776:	f300 8141 	bgt.w	80479fc <tcp_receive+0x320>
      next = pcb->unsent;
 804777a:	6ea5      	ldr	r5, [r4, #104]	; 0x68
      pcb->unsent = pcb->unsent->next;
 804777c:	682b      	ldr	r3, [r5, #0]
 804777e:	66a3      	str	r3, [r4, #104]	; 0x68
      if (pcb->unsent == NULL) {
 8047780:	2b00      	cmp	r3, #0
 8047782:	f000 812e 	beq.w	80479e2 <tcp_receive+0x306>
      LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
 8047786:	f8b4 6062 	ldrh.w	r6, [r4, #98]	; 0x62
 804778a:	6868      	ldr	r0, [r5, #4]
 804778c:	f7fe fc72 	bl	8046074 <pbuf_clen>
 8047790:	4286      	cmp	r6, r0
 8047792:	f0c0 8129 	bcc.w	80479e8 <tcp_receive+0x30c>
      pcb->snd_queuelen -= pbuf_clen(next->p);
 8047796:	6868      	ldr	r0, [r5, #4]
 8047798:	f7fe fc6c 	bl	8046074 <pbuf_clen>
 804779c:	f8b4 3062 	ldrh.w	r3, [r4, #98]	; 0x62
 80477a0:	1a1b      	subs	r3, r3, r0
 80477a2:	f8a4 3062 	strh.w	r3, [r4, #98]	; 0x62
      recv_acked += next->len;
 80477a6:	892b      	ldrh	r3, [r5, #8]
 80477a8:	4a82      	ldr	r2, [pc, #520]	; (80479b4 <tcp_receive+0x2d8>)
 80477aa:	8b91      	ldrh	r1, [r2, #28]
 80477ac:	440b      	add	r3, r1
 80477ae:	8393      	strh	r3, [r2, #28]
      tcp_seg_free(next);
 80477b0:	4628      	mov	r0, r5
 80477b2:	f7fe ff77 	bl	80466a4 <tcp_seg_free>
      if (pcb->snd_queuelen != 0) {
 80477b6:	f8b4 3062 	ldrh.w	r3, [r4, #98]	; 0x62
 80477ba:	2b00      	cmp	r3, #0
 80477bc:	d0ba      	beq.n	8047734 <tcp_receive+0x58>
        LWIP_ASSERT("tcp_receive: valid queue length",
 80477be:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 80477c0:	2b00      	cmp	r3, #0
 80477c2:	d1b7      	bne.n	8047734 <tcp_receive+0x58>
 80477c4:	6ea3      	ldr	r3, [r4, #104]	; 0x68
 80477c6:	2b00      	cmp	r3, #0
 80477c8:	d1b4      	bne.n	8047734 <tcp_receive+0x58>
 80477ca:	4b7b      	ldr	r3, [pc, #492]	; (80479b8 <tcp_receive+0x2dc>)
 80477cc:	f240 42dc 	movw	r2, #1244	; 0x4dc
 80477d0:	497a      	ldr	r1, [pc, #488]	; (80479bc <tcp_receive+0x2e0>)
 80477d2:	487b      	ldr	r0, [pc, #492]	; (80479c0 <tcp_receive+0x2e4>)
 80477d4:	f00a f938 	bl	8051a48 <printf>
 80477d8:	e7ac      	b.n	8047734 <tcp_receive+0x58>
  LWIP_ASSERT("tcp_receive: wrong state", pcb->state >= ESTABLISHED);
 80477da:	4b77      	ldr	r3, [pc, #476]	; (80479b8 <tcp_receive+0x2dc>)
 80477dc:	f44f 6281 	mov.w	r2, #1032	; 0x408
 80477e0:	4978      	ldr	r1, [pc, #480]	; (80479c4 <tcp_receive+0x2e8>)
 80477e2:	4877      	ldr	r0, [pc, #476]	; (80479c0 <tcp_receive+0x2e4>)
 80477e4:	f00a f930 	bl	8051a48 <printf>
 80477e8:	e77d      	b.n	80476e6 <tcp_receive+0xa>
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
 80477ea:	4972      	ldr	r1, [pc, #456]	; (80479b4 <tcp_receive+0x2d8>)
 80477ec:	6989      	ldr	r1, [r1, #24]
 80477ee:	1a51      	subs	r1, r2, r1
 80477f0:	2900      	cmp	r1, #0
 80477f2:	da8a      	bge.n	804770a <tcp_receive+0x2e>
 80477f4:	e004      	b.n	8047800 <tcp_receive+0x124>
       (pcb->snd_wl2 == ackno && (u32_t)SND_WND_SCALE(pcb, tcphdr->wnd) > pcb->snd_wnd)) {
 80477f6:	4a6f      	ldr	r2, [pc, #444]	; (80479b4 <tcp_receive+0x2d8>)
 80477f8:	6892      	ldr	r2, [r2, #8]
 80477fa:	89d2      	ldrh	r2, [r2, #14]
 80477fc:	4290      	cmp	r0, r2
 80477fe:	d288      	bcs.n	8047712 <tcp_receive+0x36>
      pcb->snd_wnd = SND_WND_SCALE(pcb, tcphdr->wnd);
 8047800:	4a6c      	ldr	r2, [pc, #432]	; (80479b4 <tcp_receive+0x2d8>)
 8047802:	6892      	ldr	r2, [r2, #8]
 8047804:	89d2      	ldrh	r2, [r2, #14]
 8047806:	b291      	uxth	r1, r2
 8047808:	f8a4 205c 	strh.w	r2, [r4, #92]	; 0x5c
      if (pcb->snd_wnd_max < pcb->snd_wnd) {
 804780c:	f8b4 005e 	ldrh.w	r0, [r4, #94]	; 0x5e
 8047810:	4281      	cmp	r1, r0
 8047812:	d901      	bls.n	8047818 <tcp_receive+0x13c>
        pcb->snd_wnd_max = pcb->snd_wnd;
 8047814:	f8a4 205e 	strh.w	r2, [r4, #94]	; 0x5e
      pcb->snd_wl1 = seqno;
 8047818:	6523      	str	r3, [r4, #80]	; 0x50
      pcb->snd_wl2 = ackno;
 804781a:	4b66      	ldr	r3, [pc, #408]	; (80479b4 <tcp_receive+0x2d8>)
 804781c:	699b      	ldr	r3, [r3, #24]
 804781e:	6563      	str	r3, [r4, #84]	; 0x54
      if (pcb->snd_wnd == 0) {
 8047820:	b951      	cbnz	r1, 8047838 <tcp_receive+0x15c>
        if (pcb->persist_backoff == 0) {
 8047822:	f894 3095 	ldrb.w	r3, [r4, #149]	; 0x95
 8047826:	2b00      	cmp	r3, #0
 8047828:	f47f af73 	bne.w	8047712 <tcp_receive+0x36>
          pcb->persist_cnt = 0;
 804782c:	f884 3094 	strb.w	r3, [r4, #148]	; 0x94
          pcb->persist_backoff = 1;
 8047830:	2301      	movs	r3, #1
 8047832:	f884 3095 	strb.w	r3, [r4, #149]	; 0x95
 8047836:	e76c      	b.n	8047712 <tcp_receive+0x36>
      } else if (pcb->persist_backoff > 0) {
 8047838:	f894 3095 	ldrb.w	r3, [r4, #149]	; 0x95
 804783c:	2b00      	cmp	r3, #0
 804783e:	f43f af68 	beq.w	8047712 <tcp_receive+0x36>
          pcb->persist_backoff = 0;
 8047842:	2300      	movs	r3, #0
 8047844:	f884 3095 	strb.w	r3, [r4, #149]	; 0x95
 8047848:	e763      	b.n	8047712 <tcp_receive+0x36>
      if (tcplen == 0) {
 804784a:	4a5a      	ldr	r2, [pc, #360]	; (80479b4 <tcp_receive+0x2d8>)
 804784c:	8a92      	ldrh	r2, [r2, #20]
 804784e:	b92a      	cbnz	r2, 804785c <tcp_receive+0x180>
        if (pcb->snd_wl2 + pcb->snd_wnd == right_wnd_edge) {
 8047850:	6d62      	ldr	r2, [r4, #84]	; 0x54
 8047852:	f8b4 005c 	ldrh.w	r0, [r4, #92]	; 0x5c
 8047856:	4402      	add	r2, r0
 8047858:	42b2      	cmp	r2, r6
 804785a:	d003      	beq.n	8047864 <tcp_receive+0x188>
        pcb->dupacks = 0;
 804785c:	2300      	movs	r3, #0
 804785e:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 8047862:	e767      	b.n	8047734 <tcp_receive+0x58>
          if (pcb->rtime >= 0) {
 8047864:	f9b4 2030 	ldrsh.w	r2, [r4, #48]	; 0x30
 8047868:	2a00      	cmp	r2, #0
 804786a:	dbf7      	blt.n	804785c <tcp_receive+0x180>
            if (pcb->lastack == ackno) {
 804786c:	428b      	cmp	r3, r1
 804786e:	d1f5      	bne.n	804785c <tcp_receive+0x180>
              if ((u8_t)(pcb->dupacks + 1) > pcb->dupacks) {
 8047870:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
 8047874:	2bff      	cmp	r3, #255	; 0xff
 8047876:	d002      	beq.n	804787e <tcp_receive+0x1a2>
                ++pcb->dupacks;
 8047878:	3301      	adds	r3, #1
 804787a:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
              if (pcb->dupacks > 3) {
 804787e:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
 8047882:	2b03      	cmp	r3, #3
 8047884:	d90a      	bls.n	804789c <tcp_receive+0x1c0>
                if ((tcpwnd_size_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
 8047886:	f8b4 2048 	ldrh.w	r2, [r4, #72]	; 0x48
 804788a:	8e63      	ldrh	r3, [r4, #50]	; 0x32
 804788c:	4413      	add	r3, r2
 804788e:	b29b      	uxth	r3, r3
 8047890:	429a      	cmp	r2, r3
 8047892:	f4bf af4f 	bcs.w	8047734 <tcp_receive+0x58>
                  pcb->cwnd += pcb->mss;
 8047896:	f8a4 3048 	strh.w	r3, [r4, #72]	; 0x48
      if (!found_dupack) {
 804789a:	e74b      	b.n	8047734 <tcp_receive+0x58>
              } else if (pcb->dupacks == 3) {
 804789c:	2b03      	cmp	r3, #3
 804789e:	f47f af49 	bne.w	8047734 <tcp_receive+0x58>
                tcp_rexmit_fast(pcb);
 80478a2:	4620      	mov	r0, r4
 80478a4:	f002 f809 	bl	80498ba <tcp_rexmit_fast>
      if (!found_dupack) {
 80478a8:	e744      	b.n	8047734 <tcp_receive+0x58>
      if (pcb->flags & TF_INFR) {
 80478aa:	7ea2      	ldrb	r2, [r4, #26]
 80478ac:	f012 0f04 	tst.w	r2, #4
 80478b0:	d006      	beq.n	80478c0 <tcp_receive+0x1e4>
        pcb->flags &= ~TF_INFR;
 80478b2:	f022 0204 	bic.w	r2, r2, #4
 80478b6:	76a2      	strb	r2, [r4, #26]
        pcb->cwnd = pcb->ssthresh;
 80478b8:	f8b4 204a 	ldrh.w	r2, [r4, #74]	; 0x4a
 80478bc:	f8a4 2048 	strh.w	r2, [r4, #72]	; 0x48
      pcb->nrtx = 0;
 80478c0:	2100      	movs	r1, #0
 80478c2:	f884 1042 	strb.w	r1, [r4, #66]	; 0x42
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
 80478c6:	f9b4 003c 	ldrsh.w	r0, [r4, #60]	; 0x3c
 80478ca:	8fe2      	ldrh	r2, [r4, #62]	; 0x3e
 80478cc:	eb02 02e0 	add.w	r2, r2, r0, asr #3
 80478d0:	f8a4 2040 	strh.w	r2, [r4, #64]	; 0x40
      pcb->dupacks = 0;
 80478d4:	f884 1043 	strb.w	r1, [r4, #67]	; 0x43
      pcb->lastack = ackno;
 80478d8:	6463      	str	r3, [r4, #68]	; 0x44
      if (pcb->state >= ESTABLISHED) {
 80478da:	7d23      	ldrb	r3, [r4, #20]
 80478dc:	2b03      	cmp	r3, #3
 80478de:	d90c      	bls.n	80478fa <tcp_receive+0x21e>
        if (pcb->cwnd < pcb->ssthresh) {
 80478e0:	f8b4 2048 	ldrh.w	r2, [r4, #72]	; 0x48
 80478e4:	f8b4 304a 	ldrh.w	r3, [r4, #74]	; 0x4a
 80478e8:	429a      	cmp	r2, r3
 80478ea:	d24b      	bcs.n	8047984 <tcp_receive+0x2a8>
          if ((tcpwnd_size_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
 80478ec:	8e63      	ldrh	r3, [r4, #50]	; 0x32
 80478ee:	4413      	add	r3, r2
 80478f0:	b29b      	uxth	r3, r3
 80478f2:	429a      	cmp	r2, r3
 80478f4:	d201      	bcs.n	80478fa <tcp_receive+0x21e>
            pcb->cwnd += pcb->mss;
 80478f6:	f8a4 3048 	strh.w	r3, [r4, #72]	; 0x48
      while (pcb->unacked != NULL &&
 80478fa:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 80478fc:	2b00      	cmp	r3, #0
 80478fe:	d065      	beq.n	80479cc <tcp_receive+0x2f0>
             TCP_SEQ_LEQ(lwip_ntohl(pcb->unacked->tcphdr->seqno) +
 8047900:	68db      	ldr	r3, [r3, #12]
 8047902:	6858      	ldr	r0, [r3, #4]
 8047904:	f7fd fdb7 	bl	8045476 <lwip_htonl>
 8047908:	4605      	mov	r5, r0
 804790a:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 804790c:	891e      	ldrh	r6, [r3, #8]
 804790e:	68db      	ldr	r3, [r3, #12]
 8047910:	8998      	ldrh	r0, [r3, #12]
 8047912:	f7fd fdad 	bl	8045470 <lwip_htons>
 8047916:	f010 0f03 	tst.w	r0, #3
 804791a:	d048      	beq.n	80479ae <tcp_receive+0x2d2>
 804791c:	2301      	movs	r3, #1
 804791e:	441e      	add	r6, r3
 8047920:	4435      	add	r5, r6
 8047922:	4b24      	ldr	r3, [pc, #144]	; (80479b4 <tcp_receive+0x2d8>)
 8047924:	699b      	ldr	r3, [r3, #24]
 8047926:	1aed      	subs	r5, r5, r3
      while (pcb->unacked != NULL &&
 8047928:	2d00      	cmp	r5, #0
 804792a:	dc4f      	bgt.n	80479cc <tcp_receive+0x2f0>
        next = pcb->unacked;
 804792c:	6ee5      	ldr	r5, [r4, #108]	; 0x6c
        pcb->unacked = pcb->unacked->next;
 804792e:	682b      	ldr	r3, [r5, #0]
 8047930:	66e3      	str	r3, [r4, #108]	; 0x6c
        LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
 8047932:	f8b4 6062 	ldrh.w	r6, [r4, #98]	; 0x62
 8047936:	6868      	ldr	r0, [r5, #4]
 8047938:	f7fe fb9c 	bl	8046074 <pbuf_clen>
 804793c:	4286      	cmp	r6, r0
 804793e:	d32e      	bcc.n	804799e <tcp_receive+0x2c2>
        pcb->snd_queuelen -= pbuf_clen(next->p);
 8047940:	6868      	ldr	r0, [r5, #4]
 8047942:	f7fe fb97 	bl	8046074 <pbuf_clen>
 8047946:	f8b4 3062 	ldrh.w	r3, [r4, #98]	; 0x62
 804794a:	1a1b      	subs	r3, r3, r0
 804794c:	f8a4 3062 	strh.w	r3, [r4, #98]	; 0x62
        recv_acked += next->len;
 8047950:	892b      	ldrh	r3, [r5, #8]
 8047952:	4a18      	ldr	r2, [pc, #96]	; (80479b4 <tcp_receive+0x2d8>)
 8047954:	8b91      	ldrh	r1, [r2, #28]
 8047956:	440b      	add	r3, r1
 8047958:	8393      	strh	r3, [r2, #28]
        tcp_seg_free(next);
 804795a:	4628      	mov	r0, r5
 804795c:	f7fe fea2 	bl	80466a4 <tcp_seg_free>
        if (pcb->snd_queuelen != 0) {
 8047960:	f8b4 3062 	ldrh.w	r3, [r4, #98]	; 0x62
 8047964:	2b00      	cmp	r3, #0
 8047966:	d0c8      	beq.n	80478fa <tcp_receive+0x21e>
          LWIP_ASSERT("tcp_receive: valid queue length", pcb->unacked != NULL ||
 8047968:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 804796a:	2b00      	cmp	r3, #0
 804796c:	d1c5      	bne.n	80478fa <tcp_receive+0x21e>
 804796e:	6ea3      	ldr	r3, [r4, #104]	; 0x68
 8047970:	2b00      	cmp	r3, #0
 8047972:	d1c2      	bne.n	80478fa <tcp_receive+0x21e>
 8047974:	4b10      	ldr	r3, [pc, #64]	; (80479b8 <tcp_receive+0x2dc>)
 8047976:	f240 42a6 	movw	r2, #1190	; 0x4a6
 804797a:	4910      	ldr	r1, [pc, #64]	; (80479bc <tcp_receive+0x2e0>)
 804797c:	4810      	ldr	r0, [pc, #64]	; (80479c0 <tcp_receive+0x2e4>)
 804797e:	f00a f863 	bl	8051a48 <printf>
 8047982:	e7ba      	b.n	80478fa <tcp_receive+0x21e>
          tcpwnd_size_t new_cwnd = (pcb->cwnd + pcb->mss * pcb->mss / pcb->cwnd);
 8047984:	8e63      	ldrh	r3, [r4, #50]	; 0x32
 8047986:	fb03 f303 	mul.w	r3, r3, r3
 804798a:	fb93 f3f2 	sdiv	r3, r3, r2
 804798e:	fa12 f383 	uxtah	r3, r2, r3
 8047992:	b29b      	uxth	r3, r3
          if (new_cwnd > pcb->cwnd) {
 8047994:	429a      	cmp	r2, r3
 8047996:	d2b0      	bcs.n	80478fa <tcp_receive+0x21e>
            pcb->cwnd = new_cwnd;
 8047998:	f8a4 3048 	strh.w	r3, [r4, #72]	; 0x48
 804799c:	e7ad      	b.n	80478fa <tcp_receive+0x21e>
        LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
 804799e:	4b06      	ldr	r3, [pc, #24]	; (80479b8 <tcp_receive+0x2dc>)
 80479a0:	f240 429e 	movw	r2, #1182	; 0x49e
 80479a4:	4908      	ldr	r1, [pc, #32]	; (80479c8 <tcp_receive+0x2ec>)
 80479a6:	4806      	ldr	r0, [pc, #24]	; (80479c0 <tcp_receive+0x2e4>)
 80479a8:	f00a f84e 	bl	8051a48 <printf>
 80479ac:	e7c8      	b.n	8047940 <tcp_receive+0x264>
             TCP_SEQ_LEQ(lwip_ntohl(pcb->unacked->tcphdr->seqno) +
 80479ae:	2300      	movs	r3, #0
 80479b0:	e7b5      	b.n	804791e <tcp_receive+0x242>
 80479b2:	bf00      	nop
 80479b4:	200040d4 	.word	0x200040d4
 80479b8:	08059a5c 	.word	0x08059a5c
 80479bc:	08059ad4 	.word	0x08059ad4
 80479c0:	08058ecc 	.word	0x08058ecc
 80479c4:	08059a90 	.word	0x08059a90
 80479c8:	08059aac 	.word	0x08059aac
      if (pcb->unacked == NULL) {
 80479cc:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 80479ce:	b123      	cbz	r3, 80479da <tcp_receive+0x2fe>
        pcb->rtime = 0;
 80479d0:	2300      	movs	r3, #0
 80479d2:	8623      	strh	r3, [r4, #48]	; 0x30
      pcb->polltmr = 0;
 80479d4:	2300      	movs	r3, #0
 80479d6:	76e3      	strb	r3, [r4, #27]
 80479d8:	e6ac      	b.n	8047734 <tcp_receive+0x58>
        pcb->rtime = -1;
 80479da:	f64f 73ff 	movw	r3, #65535	; 0xffff
 80479de:	8623      	strh	r3, [r4, #48]	; 0x30
 80479e0:	e7f8      	b.n	80479d4 <tcp_receive+0x2f8>
        pcb->unsent_oversize = 0;
 80479e2:	f8a4 3064 	strh.w	r3, [r4, #100]	; 0x64
 80479e6:	e6ce      	b.n	8047786 <tcp_receive+0xaa>
      LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
 80479e8:	4b9c      	ldr	r3, [pc, #624]	; (8047c5c <tcp_receive+0x580>)
 80479ea:	f240 42d5 	movw	r2, #1237	; 0x4d5
 80479ee:	499c      	ldr	r1, [pc, #624]	; (8047c60 <tcp_receive+0x584>)
 80479f0:	489c      	ldr	r0, [pc, #624]	; (8047c64 <tcp_receive+0x588>)
 80479f2:	f00a f829 	bl	8051a48 <printf>
 80479f6:	e6ce      	b.n	8047796 <tcp_receive+0xba>
           TCP_SEQ_BETWEEN(ackno, lwip_ntohl(pcb->unsent->tcphdr->seqno) +
 80479f8:	2000      	movs	r0, #0
 80479fa:	e6b1      	b.n	8047760 <tcp_receive+0x84>
    pcb->snd_buf += recv_acked;
 80479fc:	f8b4 3060 	ldrh.w	r3, [r4, #96]	; 0x60
 8047a00:	4a99      	ldr	r2, [pc, #612]	; (8047c68 <tcp_receive+0x58c>)
 8047a02:	8b92      	ldrh	r2, [r2, #28]
 8047a04:	4413      	add	r3, r2
 8047a06:	f8a4 3060 	strh.w	r3, [r4, #96]	; 0x60
    if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
 8047a0a:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8047a0c:	b12b      	cbz	r3, 8047a1a <tcp_receive+0x33e>
 8047a0e:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 8047a10:	4995      	ldr	r1, [pc, #596]	; (8047c68 <tcp_receive+0x58c>)
 8047a12:	6989      	ldr	r1, [r1, #24]
 8047a14:	1a52      	subs	r2, r2, r1
 8047a16:	2a00      	cmp	r2, #0
 8047a18:	db28      	blt.n	8047a6c <tcp_receive+0x390>
  if ((tcplen > 0) && (pcb->state < CLOSE_WAIT)) {
 8047a1a:	4b93      	ldr	r3, [pc, #588]	; (8047c68 <tcp_receive+0x58c>)
 8047a1c:	8a9b      	ldrh	r3, [r3, #20]
 8047a1e:	2b00      	cmp	r3, #0
 8047a20:	f000 8325 	beq.w	804806e <tcp_receive+0x992>
 8047a24:	7d22      	ldrb	r2, [r4, #20]
 8047a26:	2a06      	cmp	r2, #6
 8047a28:	f200 8321 	bhi.w	804806e <tcp_receive+0x992>
    if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)) {
 8047a2c:	6a61      	ldr	r1, [r4, #36]	; 0x24
 8047a2e:	4a8e      	ldr	r2, [pc, #568]	; (8047c68 <tcp_receive+0x58c>)
 8047a30:	6912      	ldr	r2, [r2, #16]
 8047a32:	1a8e      	subs	r6, r1, r2
 8047a34:	2e01      	cmp	r6, #1
 8047a36:	d404      	bmi.n	8047a42 <tcp_receive+0x366>
 8047a38:	4413      	add	r3, r2
 8047a3a:	1acb      	subs	r3, r1, r3
 8047a3c:	3301      	adds	r3, #1
 8047a3e:	2b00      	cmp	r3, #0
 8047a40:	dd38      	ble.n	8047ab4 <tcp_receive+0x3d8>
      if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)) {
 8047a42:	1a52      	subs	r2, r2, r1
 8047a44:	2a00      	cmp	r2, #0
 8047a46:	f2c0 8094 	blt.w	8047b72 <tcp_receive+0x496>
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt,
 8047a4a:	4b87      	ldr	r3, [pc, #540]	; (8047c68 <tcp_receive+0x58c>)
 8047a4c:	6919      	ldr	r1, [r3, #16]
 8047a4e:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8047a50:	1a8b      	subs	r3, r1, r2
 8047a52:	2b00      	cmp	r3, #0
 8047a54:	db06      	blt.n	8047a64 <tcp_receive+0x388>
 8047a56:	8d23      	ldrh	r3, [r4, #40]	; 0x28
 8047a58:	4413      	add	r3, r2
 8047a5a:	1acb      	subs	r3, r1, r3
 8047a5c:	3301      	adds	r3, #1
 8047a5e:	2b00      	cmp	r3, #0
 8047a60:	f340 808c 	ble.w	8047b7c <tcp_receive+0x4a0>
      tcp_send_empty_ack(pcb);
 8047a64:	4620      	mov	r0, r4
 8047a66:	f001 fd0d 	bl	8049484 <tcp_send_empty_ack>
 8047a6a:	e310      	b.n	804808e <tcp_receive+0x9b2>
      m = (s16_t)(tcp_ticks - pcb->rttest);
 8047a6c:	4a7f      	ldr	r2, [pc, #508]	; (8047c6c <tcp_receive+0x590>)
 8047a6e:	8816      	ldrh	r6, [r2, #0]
 8047a70:	b29b      	uxth	r3, r3
 8047a72:	1af1      	subs	r1, r6, r3
 8047a74:	b289      	uxth	r1, r1
      m = m - (pcb->sa >> 3);
 8047a76:	f9b4 503c 	ldrsh.w	r5, [r4, #60]	; 0x3c
 8047a7a:	f3c5 00cf 	ubfx	r0, r5, #3, #16
 8047a7e:	1a09      	subs	r1, r1, r0
 8047a80:	b20a      	sxth	r2, r1
      pcb->sa += m;
 8047a82:	fa15 f181 	uxtah	r1, r5, r1
 8047a86:	b209      	sxth	r1, r1
 8047a88:	87a1      	strh	r1, [r4, #60]	; 0x3c
      if (m < 0) {
 8047a8a:	2a00      	cmp	r2, #0
 8047a8c:	db0e      	blt.n	8047aac <tcp_receive+0x3d0>
      m = m - (pcb->sv >> 2);
 8047a8e:	f9b4 003e 	ldrsh.w	r0, [r4, #62]	; 0x3e
 8047a92:	eba2 03a0 	sub.w	r3, r2, r0, asr #2
      pcb->sv += m;
 8047a96:	fa10 f383 	uxtah	r3, r0, r3
 8047a9a:	b29b      	uxth	r3, r3
 8047a9c:	87e3      	strh	r3, [r4, #62]	; 0x3e
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
 8047a9e:	eb03 03e1 	add.w	r3, r3, r1, asr #3
 8047aa2:	f8a4 3040 	strh.w	r3, [r4, #64]	; 0x40
      pcb->rttest = 0;
 8047aa6:	2300      	movs	r3, #0
 8047aa8:	6363      	str	r3, [r4, #52]	; 0x34
 8047aaa:	e7b6      	b.n	8047a1a <tcp_receive+0x33e>
        m = -m;
 8047aac:	1b9b      	subs	r3, r3, r6
 8047aae:	4403      	add	r3, r0
 8047ab0:	b21a      	sxth	r2, r3
 8047ab2:	e7ec      	b.n	8047a8e <tcp_receive+0x3b2>
      struct pbuf *p = inseg.p;
 8047ab4:	4b6c      	ldr	r3, [pc, #432]	; (8047c68 <tcp_receive+0x58c>)
 8047ab6:	6a5d      	ldr	r5, [r3, #36]	; 0x24
      off = pcb->rcv_nxt - seqno;
 8047ab8:	4637      	mov	r7, r6
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
 8047aba:	b195      	cbz	r5, 8047ae2 <tcp_receive+0x406>
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
 8047abc:	f647 73fe 	movw	r3, #32766	; 0x7ffe
 8047ac0:	429e      	cmp	r6, r3
 8047ac2:	dc16      	bgt.n	8047af2 <tcp_receive+0x416>
      if (inseg.p->len < off) {
 8047ac4:	4b68      	ldr	r3, [pc, #416]	; (8047c68 <tcp_receive+0x58c>)
 8047ac6:	6a58      	ldr	r0, [r3, #36]	; 0x24
 8047ac8:	8943      	ldrh	r3, [r0, #10]
 8047aca:	42b3      	cmp	r3, r6
 8047acc:	da43      	bge.n	8047b56 <tcp_receive+0x47a>
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
 8047ace:	8903      	ldrh	r3, [r0, #8]
 8047ad0:	42b3      	cmp	r3, r6
 8047ad2:	db16      	blt.n	8047b02 <tcp_receive+0x426>
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
 8047ad4:	4b64      	ldr	r3, [pc, #400]	; (8047c68 <tcp_receive+0x58c>)
 8047ad6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8047ad8:	891a      	ldrh	r2, [r3, #8]
 8047ada:	b2b6      	uxth	r6, r6
 8047adc:	1b92      	subs	r2, r2, r6
 8047ade:	b292      	uxth	r2, r2
        while (p->len < off) {
 8047ae0:	e01c      	b.n	8047b1c <tcp_receive+0x440>
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
 8047ae2:	4b5e      	ldr	r3, [pc, #376]	; (8047c5c <tcp_receive+0x580>)
 8047ae4:	f240 523c 	movw	r2, #1340	; 0x53c
 8047ae8:	4961      	ldr	r1, [pc, #388]	; (8047c70 <tcp_receive+0x594>)
 8047aea:	485e      	ldr	r0, [pc, #376]	; (8047c64 <tcp_receive+0x588>)
 8047aec:	f009 ffac 	bl	8051a48 <printf>
 8047af0:	e7e4      	b.n	8047abc <tcp_receive+0x3e0>
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
 8047af2:	4b5a      	ldr	r3, [pc, #360]	; (8047c5c <tcp_receive+0x580>)
 8047af4:	f240 523d 	movw	r2, #1341	; 0x53d
 8047af8:	495e      	ldr	r1, [pc, #376]	; (8047c74 <tcp_receive+0x598>)
 8047afa:	485a      	ldr	r0, [pc, #360]	; (8047c64 <tcp_receive+0x588>)
 8047afc:	f009 ffa4 	bl	8051a48 <printf>
 8047b00:	e7e0      	b.n	8047ac4 <tcp_receive+0x3e8>
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
 8047b02:	4b56      	ldr	r3, [pc, #344]	; (8047c5c <tcp_receive+0x580>)
 8047b04:	f240 523f 	movw	r2, #1343	; 0x53f
 8047b08:	495b      	ldr	r1, [pc, #364]	; (8047c78 <tcp_receive+0x59c>)
 8047b0a:	4856      	ldr	r0, [pc, #344]	; (8047c64 <tcp_receive+0x588>)
 8047b0c:	f009 ff9c 	bl	8051a48 <printf>
 8047b10:	e7e0      	b.n	8047ad4 <tcp_receive+0x3f8>
          off -= p->len;
 8047b12:	1aff      	subs	r7, r7, r3
          p->tot_len = new_tot_len;
 8047b14:	812a      	strh	r2, [r5, #8]
          p->len = 0;
 8047b16:	2300      	movs	r3, #0
 8047b18:	816b      	strh	r3, [r5, #10]
          p = p->next;
 8047b1a:	682d      	ldr	r5, [r5, #0]
        while (p->len < off) {
 8047b1c:	896b      	ldrh	r3, [r5, #10]
 8047b1e:	42bb      	cmp	r3, r7
 8047b20:	dbf7      	blt.n	8047b12 <tcp_receive+0x436>
        if (pbuf_header(p, (s16_t)-off)) {
 8047b22:	4279      	negs	r1, r7
 8047b24:	b209      	sxth	r1, r1
 8047b26:	4628      	mov	r0, r5
 8047b28:	f7fe f8ce 	bl	8045cc8 <pbuf_header>
 8047b2c:	b958      	cbnz	r0, 8047b46 <tcp_receive+0x46a>
      inseg.len -= (u16_t)(pcb->rcv_nxt - seqno);
 8047b2e:	6a61      	ldr	r1, [r4, #36]	; 0x24
 8047b30:	4b4d      	ldr	r3, [pc, #308]	; (8047c68 <tcp_receive+0x58c>)
 8047b32:	691a      	ldr	r2, [r3, #16]
 8047b34:	1a52      	subs	r2, r2, r1
 8047b36:	8d18      	ldrh	r0, [r3, #40]	; 0x28
 8047b38:	fa10 f282 	uxtah	r2, r0, r2
 8047b3c:	851a      	strh	r2, [r3, #40]	; 0x28
      inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
 8047b3e:	6119      	str	r1, [r3, #16]
 8047b40:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8047b42:	6059      	str	r1, [r3, #4]
    if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)) {
 8047b44:	e781      	b.n	8047a4a <tcp_receive+0x36e>
          LWIP_ASSERT("pbuf_header failed", 0);
 8047b46:	4b45      	ldr	r3, [pc, #276]	; (8047c5c <tcp_receive+0x580>)
 8047b48:	f240 524c 	movw	r2, #1356	; 0x54c
 8047b4c:	494b      	ldr	r1, [pc, #300]	; (8047c7c <tcp_receive+0x5a0>)
 8047b4e:	4845      	ldr	r0, [pc, #276]	; (8047c64 <tcp_receive+0x588>)
 8047b50:	f009 ff7a 	bl	8051a48 <printf>
 8047b54:	e7eb      	b.n	8047b2e <tcp_receive+0x452>
        if (pbuf_header(inseg.p, (s16_t)-off)) {
 8047b56:	4271      	negs	r1, r6
 8047b58:	b209      	sxth	r1, r1
 8047b5a:	f7fe f8b5 	bl	8045cc8 <pbuf_header>
 8047b5e:	2800      	cmp	r0, #0
 8047b60:	d0e5      	beq.n	8047b2e <tcp_receive+0x452>
          LWIP_ASSERT("pbuf_header failed", 0);
 8047b62:	4b3e      	ldr	r3, [pc, #248]	; (8047c5c <tcp_receive+0x580>)
 8047b64:	f240 5251 	movw	r2, #1361	; 0x551
 8047b68:	4944      	ldr	r1, [pc, #272]	; (8047c7c <tcp_receive+0x5a0>)
 8047b6a:	483e      	ldr	r0, [pc, #248]	; (8047c64 <tcp_receive+0x588>)
 8047b6c:	f009 ff6c 	bl	8051a48 <printf>
 8047b70:	e7dd      	b.n	8047b2e <tcp_receive+0x452>
        tcp_ack_now(pcb);
 8047b72:	7ea3      	ldrb	r3, [r4, #26]
 8047b74:	f043 0302 	orr.w	r3, r3, #2
 8047b78:	76a3      	strb	r3, [r4, #26]
 8047b7a:	e766      	b.n	8047a4a <tcp_receive+0x36e>
      if (pcb->rcv_nxt == seqno) {
 8047b7c:	4291      	cmp	r1, r2
 8047b7e:	d008      	beq.n	8047b92 <tcp_receive+0x4b6>
        tcp_send_empty_ack(pcb);
 8047b80:	4620      	mov	r0, r4
 8047b82:	f001 fc7f 	bl	8049484 <tcp_send_empty_ack>
        if (pcb->ooseq == NULL) {
 8047b86:	6f25      	ldr	r5, [r4, #112]	; 0x70
 8047b88:	2d00      	cmp	r5, #0
 8047b8a:	f000 8194 	beq.w	8047eb6 <tcp_receive+0x7da>
          prev = NULL;
 8047b8e:	2600      	movs	r6, #0
 8047b90:	e1c2      	b.n	8047f18 <tcp_receive+0x83c>
        tcplen = TCP_TCPLEN(&inseg);
 8047b92:	4b35      	ldr	r3, [pc, #212]	; (8047c68 <tcp_receive+0x58c>)
 8047b94:	8d1d      	ldrh	r5, [r3, #40]	; 0x28
 8047b96:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8047b98:	8998      	ldrh	r0, [r3, #12]
 8047b9a:	f7fd fc69 	bl	8045470 <lwip_htons>
 8047b9e:	f010 0303 	ands.w	r3, r0, #3
 8047ba2:	d000      	beq.n	8047ba6 <tcp_receive+0x4ca>
 8047ba4:	2301      	movs	r3, #1
 8047ba6:	442b      	add	r3, r5
 8047ba8:	b29b      	uxth	r3, r3
 8047baa:	4a2f      	ldr	r2, [pc, #188]	; (8047c68 <tcp_receive+0x58c>)
 8047bac:	8293      	strh	r3, [r2, #20]
        if (tcplen > pcb->rcv_wnd) {
 8047bae:	8d22      	ldrh	r2, [r4, #40]	; 0x28
 8047bb0:	4293      	cmp	r3, r2
 8047bb2:	d80c      	bhi.n	8047bce <tcp_receive+0x4f2>
        if (pcb->ooseq != NULL) {
 8047bb4:	6f23      	ldr	r3, [r4, #112]	; 0x70
 8047bb6:	2b00      	cmp	r3, #0
 8047bb8:	d06b      	beq.n	8047c92 <tcp_receive+0x5b6>
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
 8047bba:	4b2b      	ldr	r3, [pc, #172]	; (8047c68 <tcp_receive+0x58c>)
 8047bbc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8047bbe:	8998      	ldrh	r0, [r3, #12]
 8047bc0:	f7fd fc56 	bl	8045470 <lwip_htons>
 8047bc4:	f010 0f01 	tst.w	r0, #1
 8047bc8:	d160      	bne.n	8047c8c <tcp_receive+0x5b0>
            next = pcb->ooseq;
 8047bca:	6f25      	ldr	r5, [r4, #112]	; 0x70
            while (next &&
 8047bcc:	e08f      	b.n	8047cee <tcp_receive+0x612>
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
 8047bce:	4b26      	ldr	r3, [pc, #152]	; (8047c68 <tcp_receive+0x58c>)
 8047bd0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8047bd2:	8998      	ldrh	r0, [r3, #12]
 8047bd4:	f7fd fc4c 	bl	8045470 <lwip_htons>
 8047bd8:	f010 0f01 	tst.w	r0, #1
 8047bdc:	d12e      	bne.n	8047c3c <tcp_receive+0x560>
          inseg.len = (u16_t)pcb->rcv_wnd;
 8047bde:	8d22      	ldrh	r2, [r4, #40]	; 0x28
 8047be0:	4b21      	ldr	r3, [pc, #132]	; (8047c68 <tcp_receive+0x58c>)
 8047be2:	851a      	strh	r2, [r3, #40]	; 0x28
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
 8047be4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8047be6:	8998      	ldrh	r0, [r3, #12]
 8047be8:	f7fd fc42 	bl	8045470 <lwip_htons>
 8047bec:	f010 0f02 	tst.w	r0, #2
 8047bf0:	d003      	beq.n	8047bfa <tcp_receive+0x51e>
            inseg.len -= 1;
 8047bf2:	4a1d      	ldr	r2, [pc, #116]	; (8047c68 <tcp_receive+0x58c>)
 8047bf4:	8d13      	ldrh	r3, [r2, #40]	; 0x28
 8047bf6:	3b01      	subs	r3, #1
 8047bf8:	8513      	strh	r3, [r2, #40]	; 0x28
          pbuf_realloc(inseg.p, inseg.len);
 8047bfa:	4e1b      	ldr	r6, [pc, #108]	; (8047c68 <tcp_receive+0x58c>)
 8047bfc:	8d31      	ldrh	r1, [r6, #40]	; 0x28
 8047bfe:	6a70      	ldr	r0, [r6, #36]	; 0x24
 8047c00:	f7fe f9c0 	bl	8045f84 <pbuf_realloc>
          tcplen = TCP_TCPLEN(&inseg);
 8047c04:	8d35      	ldrh	r5, [r6, #40]	; 0x28
 8047c06:	6af3      	ldr	r3, [r6, #44]	; 0x2c
 8047c08:	8998      	ldrh	r0, [r3, #12]
 8047c0a:	f7fd fc31 	bl	8045470 <lwip_htons>
 8047c0e:	f010 0303 	ands.w	r3, r0, #3
 8047c12:	d000      	beq.n	8047c16 <tcp_receive+0x53a>
 8047c14:	2301      	movs	r3, #1
 8047c16:	442b      	add	r3, r5
 8047c18:	b29b      	uxth	r3, r3
 8047c1a:	4a13      	ldr	r2, [pc, #76]	; (8047c68 <tcp_receive+0x58c>)
 8047c1c:	8293      	strh	r3, [r2, #20]
          LWIP_ASSERT("tcp_receive: segment not trimmed correctly to rcv_wnd\n",
 8047c1e:	6912      	ldr	r2, [r2, #16]
 8047c20:	4413      	add	r3, r2
 8047c22:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8047c24:	8d21      	ldrh	r1, [r4, #40]	; 0x28
 8047c26:	440a      	add	r2, r1
 8047c28:	4293      	cmp	r3, r2
 8047c2a:	d0c3      	beq.n	8047bb4 <tcp_receive+0x4d8>
 8047c2c:	4b0b      	ldr	r3, [pc, #44]	; (8047c5c <tcp_receive+0x580>)
 8047c2e:	f240 527e 	movw	r2, #1406	; 0x57e
 8047c32:	4913      	ldr	r1, [pc, #76]	; (8047c80 <tcp_receive+0x5a4>)
 8047c34:	480b      	ldr	r0, [pc, #44]	; (8047c64 <tcp_receive+0x588>)
 8047c36:	f009 ff07 	bl	8051a48 <printf>
 8047c3a:	e7bb      	b.n	8047bb4 <tcp_receive+0x4d8>
            TCPH_FLAGS_SET(inseg.tcphdr, TCPH_FLAGS(inseg.tcphdr) & ~(unsigned int)TCP_FIN);
 8047c3c:	4e0a      	ldr	r6, [pc, #40]	; (8047c68 <tcp_receive+0x58c>)
 8047c3e:	6af3      	ldr	r3, [r6, #44]	; 0x2c
 8047c40:	8998      	ldrh	r0, [r3, #12]
 8047c42:	f420 557c 	bic.w	r5, r0, #16128	; 0x3f00
 8047c46:	b2ad      	uxth	r5, r5
 8047c48:	f7fd fc12 	bl	8045470 <lwip_htons>
 8047c4c:	f000 003e 	and.w	r0, r0, #62	; 0x3e
 8047c50:	f7fd fc0e 	bl	8045470 <lwip_htons>
 8047c54:	6af3      	ldr	r3, [r6, #44]	; 0x2c
 8047c56:	4305      	orrs	r5, r0
 8047c58:	819d      	strh	r5, [r3, #12]
 8047c5a:	e7c0      	b.n	8047bde <tcp_receive+0x502>
 8047c5c:	08059a5c 	.word	0x08059a5c
 8047c60:	08059aac 	.word	0x08059aac
 8047c64:	08058ecc 	.word	0x08058ecc
 8047c68:	200040d4 	.word	0x200040d4
 8047c6c:	20008724 	.word	0x20008724
 8047c70:	08059af4 	.word	0x08059af4
 8047c74:	08059b04 	.word	0x08059b04
 8047c78:	08059b14 	.word	0x08059b14
 8047c7c:	08059b24 	.word	0x08059b24
 8047c80:	08059b38 	.word	0x08059b38
              pcb->ooseq = pcb->ooseq->next;
 8047c84:	6803      	ldr	r3, [r0, #0]
 8047c86:	6723      	str	r3, [r4, #112]	; 0x70
              tcp_seg_free(old_ooseq);
 8047c88:	f7fe fd0c 	bl	80466a4 <tcp_seg_free>
            while (pcb->ooseq != NULL) {
 8047c8c:	6f20      	ldr	r0, [r4, #112]	; 0x70
 8047c8e:	2800      	cmp	r0, #0
 8047c90:	d1f8      	bne.n	8047c84 <tcp_receive+0x5a8>
        pcb->rcv_nxt = seqno + tcplen;
 8047c92:	4b96      	ldr	r3, [pc, #600]	; (8047eec <tcp_receive+0x810>)
 8047c94:	8a9a      	ldrh	r2, [r3, #20]
 8047c96:	691b      	ldr	r3, [r3, #16]
 8047c98:	4413      	add	r3, r2
 8047c9a:	6263      	str	r3, [r4, #36]	; 0x24
        LWIP_ASSERT("tcp_receive: tcplen > rcv_wnd\n", pcb->rcv_wnd >= tcplen);
 8047c9c:	8d23      	ldrh	r3, [r4, #40]	; 0x28
 8047c9e:	429a      	cmp	r2, r3
 8047ca0:	f200 808c 	bhi.w	8047dbc <tcp_receive+0x6e0>
        pcb->rcv_wnd -= tcplen;
 8047ca4:	4d91      	ldr	r5, [pc, #580]	; (8047eec <tcp_receive+0x810>)
 8047ca6:	8d23      	ldrh	r3, [r4, #40]	; 0x28
 8047ca8:	8aaa      	ldrh	r2, [r5, #20]
 8047caa:	1a9b      	subs	r3, r3, r2
 8047cac:	8523      	strh	r3, [r4, #40]	; 0x28
        tcp_update_rcv_ann_wnd(pcb);
 8047cae:	4620      	mov	r0, r4
 8047cb0:	f7fe fc88 	bl	80465c4 <tcp_update_rcv_ann_wnd>
        if (inseg.p->tot_len > 0) {
 8047cb4:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 8047cb6:	891a      	ldrh	r2, [r3, #8]
 8047cb8:	b112      	cbz	r2, 8047cc0 <tcp_receive+0x5e4>
          recv_data = inseg.p;
 8047cba:	632b      	str	r3, [r5, #48]	; 0x30
          inseg.p = NULL;
 8047cbc:	2300      	movs	r3, #0
 8047cbe:	626b      	str	r3, [r5, #36]	; 0x24
        if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
 8047cc0:	4b8a      	ldr	r3, [pc, #552]	; (8047eec <tcp_receive+0x810>)
 8047cc2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8047cc4:	8998      	ldrh	r0, [r3, #12]
 8047cc6:	f7fd fbd3 	bl	8045470 <lwip_htons>
 8047cca:	f010 0f01 	tst.w	r0, #1
 8047cce:	f000 80a3 	beq.w	8047e18 <tcp_receive+0x73c>
          recv_flags |= TF_GOT_FIN;
 8047cd2:	4a86      	ldr	r2, [pc, #536]	; (8047eec <tcp_receive+0x810>)
 8047cd4:	7b93      	ldrb	r3, [r2, #14]
 8047cd6:	f043 0320 	orr.w	r3, r3, #32
 8047cda:	7393      	strb	r3, [r2, #14]
 8047cdc:	e09c      	b.n	8047e18 <tcp_receive+0x73c>
                tcplen = TCP_TCPLEN(&inseg);
 8047cde:	443b      	add	r3, r7
 8047ce0:	4a82      	ldr	r2, [pc, #520]	; (8047eec <tcp_receive+0x810>)
 8047ce2:	8293      	strh	r3, [r2, #20]
              next = next->next;
 8047ce4:	682e      	ldr	r6, [r5, #0]
              tcp_seg_free(prev);
 8047ce6:	4628      	mov	r0, r5
 8047ce8:	f7fe fcdc 	bl	80466a4 <tcp_seg_free>
              next = next->next;
 8047cec:	4635      	mov	r5, r6
            while (next &&
 8047cee:	b35d      	cbz	r5, 8047d48 <tcp_receive+0x66c>
                   TCP_SEQ_GEQ(seqno + tcplen,
 8047cf0:	4a7e      	ldr	r2, [pc, #504]	; (8047eec <tcp_receive+0x810>)
 8047cf2:	8a93      	ldrh	r3, [r2, #20]
 8047cf4:	6912      	ldr	r2, [r2, #16]
 8047cf6:	4413      	add	r3, r2
 8047cf8:	68e9      	ldr	r1, [r5, #12]
 8047cfa:	684a      	ldr	r2, [r1, #4]
 8047cfc:	8928      	ldrh	r0, [r5, #8]
 8047cfe:	4402      	add	r2, r0
 8047d00:	1a9b      	subs	r3, r3, r2
            while (next &&
 8047d02:	2b00      	cmp	r3, #0
 8047d04:	db20      	blt.n	8047d48 <tcp_receive+0x66c>
              if ((TCPH_FLAGS(next->tcphdr) & TCP_FIN) != 0 &&
 8047d06:	8988      	ldrh	r0, [r1, #12]
 8047d08:	f7fd fbb2 	bl	8045470 <lwip_htons>
 8047d0c:	f010 0f01 	tst.w	r0, #1
 8047d10:	d0e8      	beq.n	8047ce4 <tcp_receive+0x608>
                  (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) == 0) {
 8047d12:	4b76      	ldr	r3, [pc, #472]	; (8047eec <tcp_receive+0x810>)
 8047d14:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8047d16:	8998      	ldrh	r0, [r3, #12]
 8047d18:	f7fd fbaa 	bl	8045470 <lwip_htons>
              if ((TCPH_FLAGS(next->tcphdr) & TCP_FIN) != 0 &&
 8047d1c:	f010 0f02 	tst.w	r0, #2
 8047d20:	d1e0      	bne.n	8047ce4 <tcp_receive+0x608>
                TCPH_SET_FLAG(inseg.tcphdr, TCP_FIN);
 8047d22:	4e72      	ldr	r6, [pc, #456]	; (8047eec <tcp_receive+0x810>)
 8047d24:	6af3      	ldr	r3, [r6, #44]	; 0x2c
 8047d26:	899f      	ldrh	r7, [r3, #12]
 8047d28:	2001      	movs	r0, #1
 8047d2a:	f7fd fba1 	bl	8045470 <lwip_htons>
 8047d2e:	6af3      	ldr	r3, [r6, #44]	; 0x2c
 8047d30:	4307      	orrs	r7, r0
 8047d32:	819f      	strh	r7, [r3, #12]
                tcplen = TCP_TCPLEN(&inseg);
 8047d34:	8d37      	ldrh	r7, [r6, #40]	; 0x28
 8047d36:	6af3      	ldr	r3, [r6, #44]	; 0x2c
 8047d38:	8998      	ldrh	r0, [r3, #12]
 8047d3a:	f7fd fb99 	bl	8045470 <lwip_htons>
 8047d3e:	f010 0303 	ands.w	r3, r0, #3
 8047d42:	d0cc      	beq.n	8047cde <tcp_receive+0x602>
 8047d44:	2301      	movs	r3, #1
 8047d46:	e7ca      	b.n	8047cde <tcp_receive+0x602>
            if (next &&
 8047d48:	b145      	cbz	r5, 8047d5c <tcp_receive+0x680>
                TCP_SEQ_GT(seqno + tcplen,
 8047d4a:	4b68      	ldr	r3, [pc, #416]	; (8047eec <tcp_receive+0x810>)
 8047d4c:	6919      	ldr	r1, [r3, #16]
 8047d4e:	8a9b      	ldrh	r3, [r3, #20]
 8047d50:	440b      	add	r3, r1
 8047d52:	68ea      	ldr	r2, [r5, #12]
 8047d54:	6852      	ldr	r2, [r2, #4]
 8047d56:	1a9b      	subs	r3, r3, r2
            if (next &&
 8047d58:	2b00      	cmp	r3, #0
 8047d5a:	dc01      	bgt.n	8047d60 <tcp_receive+0x684>
            pcb->ooseq = next;
 8047d5c:	6725      	str	r5, [r4, #112]	; 0x70
 8047d5e:	e798      	b.n	8047c92 <tcp_receive+0x5b6>
              inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
 8047d60:	1a52      	subs	r2, r2, r1
 8047d62:	4b62      	ldr	r3, [pc, #392]	; (8047eec <tcp_receive+0x810>)
 8047d64:	851a      	strh	r2, [r3, #40]	; 0x28
              if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
 8047d66:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8047d68:	8998      	ldrh	r0, [r3, #12]
 8047d6a:	f7fd fb81 	bl	8045470 <lwip_htons>
 8047d6e:	f010 0f02 	tst.w	r0, #2
 8047d72:	d003      	beq.n	8047d7c <tcp_receive+0x6a0>
                inseg.len -= 1;
 8047d74:	4a5d      	ldr	r2, [pc, #372]	; (8047eec <tcp_receive+0x810>)
 8047d76:	8d13      	ldrh	r3, [r2, #40]	; 0x28
 8047d78:	3b01      	subs	r3, #1
 8047d7a:	8513      	strh	r3, [r2, #40]	; 0x28
              pbuf_realloc(inseg.p, inseg.len);
 8047d7c:	4f5b      	ldr	r7, [pc, #364]	; (8047eec <tcp_receive+0x810>)
 8047d7e:	8d39      	ldrh	r1, [r7, #40]	; 0x28
 8047d80:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8047d82:	f7fe f8ff 	bl	8045f84 <pbuf_realloc>
              tcplen = TCP_TCPLEN(&inseg);
 8047d86:	8d3e      	ldrh	r6, [r7, #40]	; 0x28
 8047d88:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8047d8a:	8998      	ldrh	r0, [r3, #12]
 8047d8c:	f7fd fb70 	bl	8045470 <lwip_htons>
 8047d90:	f010 0303 	ands.w	r3, r0, #3
 8047d94:	d000      	beq.n	8047d98 <tcp_receive+0x6bc>
 8047d96:	2301      	movs	r3, #1
 8047d98:	4433      	add	r3, r6
 8047d9a:	b29b      	uxth	r3, r3
 8047d9c:	4a53      	ldr	r2, [pc, #332]	; (8047eec <tcp_receive+0x810>)
 8047d9e:	8293      	strh	r3, [r2, #20]
              LWIP_ASSERT("tcp_receive: segment not trimmed correctly to ooseq queue\n",
 8047da0:	6912      	ldr	r2, [r2, #16]
 8047da2:	4413      	add	r3, r2
 8047da4:	68ea      	ldr	r2, [r5, #12]
 8047da6:	6852      	ldr	r2, [r2, #4]
 8047da8:	4293      	cmp	r3, r2
 8047daa:	d0d7      	beq.n	8047d5c <tcp_receive+0x680>
 8047dac:	4b50      	ldr	r3, [pc, #320]	; (8047ef0 <tcp_receive+0x814>)
 8047dae:	f240 52ae 	movw	r2, #1454	; 0x5ae
 8047db2:	4950      	ldr	r1, [pc, #320]	; (8047ef4 <tcp_receive+0x818>)
 8047db4:	4850      	ldr	r0, [pc, #320]	; (8047ef8 <tcp_receive+0x81c>)
 8047db6:	f009 fe47 	bl	8051a48 <printf>
 8047dba:	e7cf      	b.n	8047d5c <tcp_receive+0x680>
        LWIP_ASSERT("tcp_receive: tcplen > rcv_wnd\n", pcb->rcv_wnd >= tcplen);
 8047dbc:	4b4c      	ldr	r3, [pc, #304]	; (8047ef0 <tcp_receive+0x814>)
 8047dbe:	f240 52b9 	movw	r2, #1465	; 0x5b9
 8047dc2:	494e      	ldr	r1, [pc, #312]	; (8047efc <tcp_receive+0x820>)
 8047dc4:	484c      	ldr	r0, [pc, #304]	; (8047ef8 <tcp_receive+0x81c>)
 8047dc6:	f009 fe3f 	bl	8051a48 <printf>
 8047dca:	e76b      	b.n	8047ca4 <tcp_receive+0x5c8>
          pcb->rcv_nxt += TCP_TCPLEN(cseg);
 8047dcc:	2300      	movs	r3, #0
 8047dce:	e035      	b.n	8047e3c <tcp_receive+0x760>
          LWIP_ASSERT("tcp_receive: ooseq tcplen > rcv_wnd\n",
 8047dd0:	2300      	movs	r3, #0
 8047dd2:	e041      	b.n	8047e58 <tcp_receive+0x77c>
 8047dd4:	4b46      	ldr	r3, [pc, #280]	; (8047ef0 <tcp_receive+0x814>)
 8047dd6:	f240 52dd 	movw	r2, #1501	; 0x5dd
 8047dda:	4949      	ldr	r1, [pc, #292]	; (8047f00 <tcp_receive+0x824>)
 8047ddc:	4846      	ldr	r0, [pc, #280]	; (8047ef8 <tcp_receive+0x81c>)
 8047dde:	f009 fe33 	bl	8051a48 <printf>
 8047de2:	e03c      	b.n	8047e5e <tcp_receive+0x782>
          pcb->rcv_wnd -= TCP_TCPLEN(cseg);
 8047de4:	2300      	movs	r3, #0
 8047de6:	e043      	b.n	8047e70 <tcp_receive+0x794>
              recv_data = cseg->p;
 8047de8:	4b40      	ldr	r3, [pc, #256]	; (8047eec <tcp_receive+0x810>)
 8047dea:	6319      	str	r1, [r3, #48]	; 0x30
            cseg->p = NULL;
 8047dec:	2300      	movs	r3, #0
 8047dee:	606b      	str	r3, [r5, #4]
          if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
 8047df0:	68eb      	ldr	r3, [r5, #12]
 8047df2:	8998      	ldrh	r0, [r3, #12]
 8047df4:	f7fd fb3c 	bl	8045470 <lwip_htons>
 8047df8:	f010 0f01 	tst.w	r0, #1
 8047dfc:	d007      	beq.n	8047e0e <tcp_receive+0x732>
            recv_flags |= TF_GOT_FIN;
 8047dfe:	4a3b      	ldr	r2, [pc, #236]	; (8047eec <tcp_receive+0x810>)
 8047e00:	7b93      	ldrb	r3, [r2, #14]
 8047e02:	f043 0320 	orr.w	r3, r3, #32
 8047e06:	7393      	strb	r3, [r2, #14]
            if (pcb->state == ESTABLISHED) { /* force passive close or we can move to active close */
 8047e08:	7d23      	ldrb	r3, [r4, #20]
 8047e0a:	2b04      	cmp	r3, #4
 8047e0c:	d042      	beq.n	8047e94 <tcp_receive+0x7b8>
          pcb->ooseq = cseg->next;
 8047e0e:	682b      	ldr	r3, [r5, #0]
 8047e10:	6723      	str	r3, [r4, #112]	; 0x70
          tcp_seg_free(cseg);
 8047e12:	4628      	mov	r0, r5
 8047e14:	f7fe fc46 	bl	80466a4 <tcp_seg_free>
        while (pcb->ooseq != NULL &&
 8047e18:	6f25      	ldr	r5, [r4, #112]	; 0x70
 8047e1a:	2d00      	cmp	r5, #0
 8047e1c:	d03d      	beq.n	8047e9a <tcp_receive+0x7be>
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {
 8047e1e:	68ea      	ldr	r2, [r5, #12]
 8047e20:	6853      	ldr	r3, [r2, #4]
 8047e22:	6a61      	ldr	r1, [r4, #36]	; 0x24
        while (pcb->ooseq != NULL &&
 8047e24:	428b      	cmp	r3, r1
 8047e26:	d138      	bne.n	8047e9a <tcp_receive+0x7be>
          seqno = pcb->ooseq->tcphdr->seqno;
 8047e28:	4930      	ldr	r1, [pc, #192]	; (8047eec <tcp_receive+0x810>)
 8047e2a:	610b      	str	r3, [r1, #16]
          pcb->rcv_nxt += TCP_TCPLEN(cseg);
 8047e2c:	892e      	ldrh	r6, [r5, #8]
 8047e2e:	8990      	ldrh	r0, [r2, #12]
 8047e30:	f7fd fb1e 	bl	8045470 <lwip_htons>
 8047e34:	f010 0f03 	tst.w	r0, #3
 8047e38:	d0c8      	beq.n	8047dcc <tcp_receive+0x6f0>
 8047e3a:	2301      	movs	r3, #1
 8047e3c:	441e      	add	r6, r3
 8047e3e:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8047e40:	4433      	add	r3, r6
 8047e42:	6263      	str	r3, [r4, #36]	; 0x24
          LWIP_ASSERT("tcp_receive: ooseq tcplen > rcv_wnd\n",
 8047e44:	8d27      	ldrh	r7, [r4, #40]	; 0x28
 8047e46:	892e      	ldrh	r6, [r5, #8]
 8047e48:	68eb      	ldr	r3, [r5, #12]
 8047e4a:	8998      	ldrh	r0, [r3, #12]
 8047e4c:	f7fd fb10 	bl	8045470 <lwip_htons>
 8047e50:	f010 0f03 	tst.w	r0, #3
 8047e54:	d0bc      	beq.n	8047dd0 <tcp_receive+0x6f4>
 8047e56:	2301      	movs	r3, #1
 8047e58:	441e      	add	r6, r3
 8047e5a:	42b7      	cmp	r7, r6
 8047e5c:	d3ba      	bcc.n	8047dd4 <tcp_receive+0x6f8>
          pcb->rcv_wnd -= TCP_TCPLEN(cseg);
 8047e5e:	892e      	ldrh	r6, [r5, #8]
 8047e60:	68eb      	ldr	r3, [r5, #12]
 8047e62:	8998      	ldrh	r0, [r3, #12]
 8047e64:	f7fd fb04 	bl	8045470 <lwip_htons>
 8047e68:	f010 0f03 	tst.w	r0, #3
 8047e6c:	d0ba      	beq.n	8047de4 <tcp_receive+0x708>
 8047e6e:	2301      	movs	r3, #1
 8047e70:	441e      	add	r6, r3
 8047e72:	8d23      	ldrh	r3, [r4, #40]	; 0x28
 8047e74:	1b9b      	subs	r3, r3, r6
 8047e76:	8523      	strh	r3, [r4, #40]	; 0x28
          tcp_update_rcv_ann_wnd(pcb);
 8047e78:	4620      	mov	r0, r4
 8047e7a:	f7fe fba3 	bl	80465c4 <tcp_update_rcv_ann_wnd>
          if (cseg->p->tot_len > 0) {
 8047e7e:	6869      	ldr	r1, [r5, #4]
 8047e80:	890b      	ldrh	r3, [r1, #8]
 8047e82:	2b00      	cmp	r3, #0
 8047e84:	d0b4      	beq.n	8047df0 <tcp_receive+0x714>
            if (recv_data) {
 8047e86:	4b19      	ldr	r3, [pc, #100]	; (8047eec <tcp_receive+0x810>)
 8047e88:	6b18      	ldr	r0, [r3, #48]	; 0x30
 8047e8a:	2800      	cmp	r0, #0
 8047e8c:	d0ac      	beq.n	8047de8 <tcp_receive+0x70c>
              pbuf_cat(recv_data, cseg->p);
 8047e8e:	f7fe f911 	bl	80460b4 <pbuf_cat>
 8047e92:	e7ab      	b.n	8047dec <tcp_receive+0x710>
              pcb->state = CLOSE_WAIT;
 8047e94:	2307      	movs	r3, #7
 8047e96:	7523      	strb	r3, [r4, #20]
 8047e98:	e7b9      	b.n	8047e0e <tcp_receive+0x732>
        tcp_ack(pcb);
 8047e9a:	7ea3      	ldrb	r3, [r4, #26]
 8047e9c:	f013 0f01 	tst.w	r3, #1
 8047ea0:	d005      	beq.n	8047eae <tcp_receive+0x7d2>
 8047ea2:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
 8047ea6:	f043 0302 	orr.w	r3, r3, #2
 8047eaa:	76a3      	strb	r3, [r4, #26]
 8047eac:	e0ef      	b.n	804808e <tcp_receive+0x9b2>
 8047eae:	f043 0301 	orr.w	r3, r3, #1
 8047eb2:	76a3      	strb	r3, [r4, #26]
 8047eb4:	e0eb      	b.n	804808e <tcp_receive+0x9b2>
          pcb->ooseq = tcp_seg_copy(&inseg);
 8047eb6:	4813      	ldr	r0, [pc, #76]	; (8047f04 <tcp_receive+0x828>)
 8047eb8:	f7fe fc0b 	bl	80466d2 <tcp_seg_copy>
 8047ebc:	6720      	str	r0, [r4, #112]	; 0x70
 8047ebe:	e0e6      	b.n	804808e <tcp_receive+0x9b2>
              if (inseg.len > next->len) {
 8047ec0:	4b0a      	ldr	r3, [pc, #40]	; (8047eec <tcp_receive+0x810>)
 8047ec2:	8d1a      	ldrh	r2, [r3, #40]	; 0x28
 8047ec4:	892b      	ldrh	r3, [r5, #8]
 8047ec6:	429a      	cmp	r2, r3
 8047ec8:	f240 80e1 	bls.w	804808e <tcp_receive+0x9b2>
                cseg = tcp_seg_copy(&inseg);
 8047ecc:	480d      	ldr	r0, [pc, #52]	; (8047f04 <tcp_receive+0x828>)
 8047ece:	f7fe fc00 	bl	80466d2 <tcp_seg_copy>
                if (cseg != NULL) {
 8047ed2:	4603      	mov	r3, r0
 8047ed4:	2800      	cmp	r0, #0
 8047ed6:	f000 80da 	beq.w	804808e <tcp_receive+0x9b2>
                  if (prev != NULL) {
 8047eda:	b12e      	cbz	r6, 8047ee8 <tcp_receive+0x80c>
                    prev->next = cseg;
 8047edc:	6030      	str	r0, [r6, #0]
                  tcp_oos_insert_segment(cseg, next);
 8047ede:	4629      	mov	r1, r5
 8047ee0:	4618      	mov	r0, r3
 8047ee2:	f7ff fbb7 	bl	8047654 <tcp_oos_insert_segment>
 8047ee6:	e0d2      	b.n	804808e <tcp_receive+0x9b2>
                    pcb->ooseq = cseg;
 8047ee8:	6720      	str	r0, [r4, #112]	; 0x70
 8047eea:	e7f8      	b.n	8047ede <tcp_receive+0x802>
 8047eec:	200040d4 	.word	0x200040d4
 8047ef0:	08059a5c 	.word	0x08059a5c
 8047ef4:	08059b70 	.word	0x08059b70
 8047ef8:	08058ecc 	.word	0x08058ecc
 8047efc:	08059bac 	.word	0x08059bac
 8047f00:	08059bcc 	.word	0x08059bcc
 8047f04:	200040f4 	.word	0x200040f4
                if (TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {
 8047f08:	1a99      	subs	r1, r3, r2
 8047f0a:	2900      	cmp	r1, #0
 8047f0c:	db2e      	blt.n	8047f6c <tcp_receive+0x890>
              if (next->next == NULL &&
 8047f0e:	6829      	ldr	r1, [r5, #0]
 8047f10:	462e      	mov	r6, r5
 8047f12:	2900      	cmp	r1, #0
 8047f14:	d03c      	beq.n	8047f90 <tcp_receive+0x8b4>
 8047f16:	460d      	mov	r5, r1
          for (next = pcb->ooseq; next != NULL; next = next->next) {
 8047f18:	2d00      	cmp	r5, #0
 8047f1a:	f000 80b8 	beq.w	804808e <tcp_receive+0x9b2>
            if (seqno == next->tcphdr->seqno) {
 8047f1e:	68e8      	ldr	r0, [r5, #12]
 8047f20:	6842      	ldr	r2, [r0, #4]
 8047f22:	4b5b      	ldr	r3, [pc, #364]	; (8048090 <tcp_receive+0x9b4>)
 8047f24:	691b      	ldr	r3, [r3, #16]
 8047f26:	429a      	cmp	r2, r3
 8047f28:	d0ca      	beq.n	8047ec0 <tcp_receive+0x7e4>
              if (prev == NULL) {
 8047f2a:	2e00      	cmp	r6, #0
 8047f2c:	d0ec      	beq.n	8047f08 <tcp_receive+0x82c>
                if (TCP_SEQ_BETWEEN(seqno, prev->tcphdr->seqno+1, next->tcphdr->seqno-1)) {
 8047f2e:	68f1      	ldr	r1, [r6, #12]
 8047f30:	6849      	ldr	r1, [r1, #4]
 8047f32:	1a59      	subs	r1, r3, r1
 8047f34:	2901      	cmp	r1, #1
 8047f36:	d4ea      	bmi.n	8047f0e <tcp_receive+0x832>
 8047f38:	1a99      	subs	r1, r3, r2
 8047f3a:	3101      	adds	r1, #1
 8047f3c:	2900      	cmp	r1, #0
 8047f3e:	dce6      	bgt.n	8047f0e <tcp_receive+0x832>
                  cseg = tcp_seg_copy(&inseg);
 8047f40:	4854      	ldr	r0, [pc, #336]	; (8048094 <tcp_receive+0x9b8>)
 8047f42:	f7fe fbc6 	bl	80466d2 <tcp_seg_copy>
                  if (cseg != NULL) {
 8047f46:	4604      	mov	r4, r0
 8047f48:	2800      	cmp	r0, #0
 8047f4a:	f000 80a0 	beq.w	804808e <tcp_receive+0x9b2>
                    if (TCP_SEQ_GT(prev->tcphdr->seqno + prev->len, seqno)) {
 8047f4e:	68f3      	ldr	r3, [r6, #12]
 8047f50:	6859      	ldr	r1, [r3, #4]
 8047f52:	8932      	ldrh	r2, [r6, #8]
 8047f54:	440a      	add	r2, r1
 8047f56:	4b4e      	ldr	r3, [pc, #312]	; (8048090 <tcp_receive+0x9b4>)
 8047f58:	691b      	ldr	r3, [r3, #16]
 8047f5a:	1ad2      	subs	r2, r2, r3
 8047f5c:	2a00      	cmp	r2, #0
 8047f5e:	dc10      	bgt.n	8047f82 <tcp_receive+0x8a6>
                    prev->next = cseg;
 8047f60:	6034      	str	r4, [r6, #0]
                    tcp_oos_insert_segment(cseg, next);
 8047f62:	4629      	mov	r1, r5
 8047f64:	4620      	mov	r0, r4
 8047f66:	f7ff fb75 	bl	8047654 <tcp_oos_insert_segment>
 8047f6a:	e090      	b.n	804808e <tcp_receive+0x9b2>
                  cseg = tcp_seg_copy(&inseg);
 8047f6c:	4849      	ldr	r0, [pc, #292]	; (8048094 <tcp_receive+0x9b8>)
 8047f6e:	f7fe fbb0 	bl	80466d2 <tcp_seg_copy>
                  if (cseg != NULL) {
 8047f72:	2800      	cmp	r0, #0
 8047f74:	f000 808b 	beq.w	804808e <tcp_receive+0x9b2>
                    pcb->ooseq = cseg;
 8047f78:	6720      	str	r0, [r4, #112]	; 0x70
                    tcp_oos_insert_segment(cseg, next);
 8047f7a:	4629      	mov	r1, r5
 8047f7c:	f7ff fb6a 	bl	8047654 <tcp_oos_insert_segment>
 8047f80:	e085      	b.n	804808e <tcp_receive+0x9b2>
                      prev->len = (u16_t)(seqno - prev->tcphdr->seqno);
 8047f82:	1a5b      	subs	r3, r3, r1
 8047f84:	b299      	uxth	r1, r3
 8047f86:	8131      	strh	r1, [r6, #8]
                      pbuf_realloc(prev->p, prev->len);
 8047f88:	6870      	ldr	r0, [r6, #4]
 8047f8a:	f7fd fffb 	bl	8045f84 <pbuf_realloc>
 8047f8e:	e7e7      	b.n	8047f60 <tcp_receive+0x884>
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
 8047f90:	1a9b      	subs	r3, r3, r2
              if (next->next == NULL &&
 8047f92:	2b00      	cmp	r3, #0
 8047f94:	dc01      	bgt.n	8047f9a <tcp_receive+0x8be>
 8047f96:	460d      	mov	r5, r1
 8047f98:	e7be      	b.n	8047f18 <tcp_receive+0x83c>
                if (TCPH_FLAGS(next->tcphdr) & TCP_FIN) {
 8047f9a:	8980      	ldrh	r0, [r0, #12]
 8047f9c:	f7fd fa68 	bl	8045470 <lwip_htons>
 8047fa0:	f010 0f01 	tst.w	r0, #1
 8047fa4:	d173      	bne.n	804808e <tcp_receive+0x9b2>
                next->next = tcp_seg_copy(&inseg);
 8047fa6:	483b      	ldr	r0, [pc, #236]	; (8048094 <tcp_receive+0x9b8>)
 8047fa8:	f7fe fb93 	bl	80466d2 <tcp_seg_copy>
 8047fac:	6028      	str	r0, [r5, #0]
                if (next->next != NULL) {
 8047fae:	2800      	cmp	r0, #0
 8047fb0:	d06d      	beq.n	804808e <tcp_receive+0x9b2>
                  if (TCP_SEQ_GT(next->tcphdr->seqno + next->len, seqno)) {
 8047fb2:	68eb      	ldr	r3, [r5, #12]
 8047fb4:	6859      	ldr	r1, [r3, #4]
 8047fb6:	892a      	ldrh	r2, [r5, #8]
 8047fb8:	440a      	add	r2, r1
 8047fba:	4b35      	ldr	r3, [pc, #212]	; (8048090 <tcp_receive+0x9b4>)
 8047fbc:	691b      	ldr	r3, [r3, #16]
 8047fbe:	1ad2      	subs	r2, r2, r3
 8047fc0:	2a00      	cmp	r2, #0
 8047fc2:	dc3c      	bgt.n	804803e <tcp_receive+0x962>
                  if (TCP_SEQ_GT((u32_t)tcplen + seqno, pcb->rcv_nxt + (u32_t)pcb->rcv_wnd)) {
 8047fc4:	4a32      	ldr	r2, [pc, #200]	; (8048090 <tcp_receive+0x9b4>)
 8047fc6:	8a93      	ldrh	r3, [r2, #20]
 8047fc8:	6912      	ldr	r2, [r2, #16]
 8047fca:	4413      	add	r3, r2
 8047fcc:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8047fce:	8d21      	ldrh	r1, [r4, #40]	; 0x28
 8047fd0:	440a      	add	r2, r1
 8047fd2:	1a9b      	subs	r3, r3, r2
 8047fd4:	2b00      	cmp	r3, #0
 8047fd6:	dd5a      	ble.n	804808e <tcp_receive+0x9b2>
                    if (TCPH_FLAGS(next->next->tcphdr) & TCP_FIN) {
 8047fd8:	682b      	ldr	r3, [r5, #0]
 8047fda:	68db      	ldr	r3, [r3, #12]
 8047fdc:	8998      	ldrh	r0, [r3, #12]
 8047fde:	f7fd fa47 	bl	8045470 <lwip_htons>
 8047fe2:	f010 0f01 	tst.w	r0, #1
 8047fe6:	d131      	bne.n	804804c <tcp_receive+0x970>
                    next->next->len = (u16_t)(pcb->rcv_nxt + pcb->rcv_wnd - seqno);
 8047fe8:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8047fea:	8d23      	ldrh	r3, [r4, #40]	; 0x28
 8047fec:	4413      	add	r3, r2
 8047fee:	b29b      	uxth	r3, r3
 8047ff0:	682a      	ldr	r2, [r5, #0]
 8047ff2:	4927      	ldr	r1, [pc, #156]	; (8048090 <tcp_receive+0x9b4>)
 8047ff4:	6909      	ldr	r1, [r1, #16]
 8047ff6:	1a5b      	subs	r3, r3, r1
 8047ff8:	8113      	strh	r3, [r2, #8]
                    pbuf_realloc(next->next->p, next->next->len);
 8047ffa:	682b      	ldr	r3, [r5, #0]
 8047ffc:	8919      	ldrh	r1, [r3, #8]
 8047ffe:	6858      	ldr	r0, [r3, #4]
 8048000:	f7fd ffc0 	bl	8045f84 <pbuf_realloc>
                    tcplen = TCP_TCPLEN(next->next);
 8048004:	682b      	ldr	r3, [r5, #0]
 8048006:	891d      	ldrh	r5, [r3, #8]
 8048008:	68db      	ldr	r3, [r3, #12]
 804800a:	8998      	ldrh	r0, [r3, #12]
 804800c:	f7fd fa30 	bl	8045470 <lwip_htons>
 8048010:	f010 0303 	ands.w	r3, r0, #3
 8048014:	d000      	beq.n	8048018 <tcp_receive+0x93c>
 8048016:	2301      	movs	r3, #1
 8048018:	442b      	add	r3, r5
 804801a:	b29b      	uxth	r3, r3
 804801c:	4a1c      	ldr	r2, [pc, #112]	; (8048090 <tcp_receive+0x9b4>)
 804801e:	8293      	strh	r3, [r2, #20]
                    LWIP_ASSERT("tcp_receive: segment not trimmed correctly to rcv_wnd\n",
 8048020:	6912      	ldr	r2, [r2, #16]
 8048022:	4413      	add	r3, r2
 8048024:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8048026:	8d21      	ldrh	r1, [r4, #40]	; 0x28
 8048028:	440a      	add	r2, r1
 804802a:	4293      	cmp	r3, r2
 804802c:	d02f      	beq.n	804808e <tcp_receive+0x9b2>
 804802e:	4b1a      	ldr	r3, [pc, #104]	; (8048098 <tcp_receive+0x9bc>)
 8048030:	f240 627a 	movw	r2, #1658	; 0x67a
 8048034:	4919      	ldr	r1, [pc, #100]	; (804809c <tcp_receive+0x9c0>)
 8048036:	481a      	ldr	r0, [pc, #104]	; (80480a0 <tcp_receive+0x9c4>)
 8048038:	f009 fd06 	bl	8051a48 <printf>
 804803c:	e027      	b.n	804808e <tcp_receive+0x9b2>
                    next->len = (u16_t)(seqno - next->tcphdr->seqno);
 804803e:	1a5b      	subs	r3, r3, r1
 8048040:	b299      	uxth	r1, r3
 8048042:	8129      	strh	r1, [r5, #8]
                    pbuf_realloc(next->p, next->len);
 8048044:	6868      	ldr	r0, [r5, #4]
 8048046:	f7fd ff9d 	bl	8045f84 <pbuf_realloc>
 804804a:	e7bb      	b.n	8047fc4 <tcp_receive+0x8e8>
                      TCPH_FLAGS_SET(next->next->tcphdr, TCPH_FLAGS(next->next->tcphdr) & ~TCP_FIN);
 804804c:	682b      	ldr	r3, [r5, #0]
 804804e:	68db      	ldr	r3, [r3, #12]
 8048050:	8998      	ldrh	r0, [r3, #12]
 8048052:	f420 567c 	bic.w	r6, r0, #16128	; 0x3f00
 8048056:	b2b6      	uxth	r6, r6
 8048058:	f7fd fa0a 	bl	8045470 <lwip_htons>
 804805c:	f000 003e 	and.w	r0, r0, #62	; 0x3e
 8048060:	f7fd fa06 	bl	8045470 <lwip_htons>
 8048064:	682b      	ldr	r3, [r5, #0]
 8048066:	68db      	ldr	r3, [r3, #12]
 8048068:	4306      	orrs	r6, r0
 804806a:	819e      	strh	r6, [r3, #12]
 804806c:	e7bc      	b.n	8047fe8 <tcp_receive+0x90c>
    if (!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd - 1)) {
 804806e:	4b08      	ldr	r3, [pc, #32]	; (8048090 <tcp_receive+0x9b4>)
 8048070:	691b      	ldr	r3, [r3, #16]
 8048072:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8048074:	1a99      	subs	r1, r3, r2
 8048076:	2900      	cmp	r1, #0
 8048078:	db05      	blt.n	8048086 <tcp_receive+0x9aa>
 804807a:	8d21      	ldrh	r1, [r4, #40]	; 0x28
 804807c:	440a      	add	r2, r1
 804807e:	1a9b      	subs	r3, r3, r2
 8048080:	3301      	adds	r3, #1
 8048082:	2b00      	cmp	r3, #0
 8048084:	dd03      	ble.n	804808e <tcp_receive+0x9b2>
      tcp_ack_now(pcb);
 8048086:	7ea3      	ldrb	r3, [r4, #26]
 8048088:	f043 0302 	orr.w	r3, r3, #2
 804808c:	76a3      	strb	r3, [r4, #26]
}
 804808e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8048090:	200040d4 	.word	0x200040d4
 8048094:	200040f4 	.word	0x200040f4
 8048098:	08059a5c 	.word	0x08059a5c
 804809c:	08059b38 	.word	0x08059b38
 80480a0:	08058ecc 	.word	0x08058ecc

080480a4 <tcp_process>:
{
 80480a4:	b570      	push	{r4, r5, r6, lr}
 80480a6:	b082      	sub	sp, #8
 80480a8:	4604      	mov	r4, r0
  if (flags & TCP_RST) {
 80480aa:	4ba5      	ldr	r3, [pc, #660]	; (8048340 <tcp_process+0x29c>)
 80480ac:	7bdb      	ldrb	r3, [r3, #15]
 80480ae:	f013 0f04 	tst.w	r3, #4
 80480b2:	d032      	beq.n	804811a <tcp_process+0x76>
    if (pcb->state == SYN_SENT) {
 80480b4:	7d01      	ldrb	r1, [r0, #20]
 80480b6:	2902      	cmp	r1, #2
 80480b8:	d011      	beq.n	80480de <tcp_process+0x3a>
      if (seqno == pcb->rcv_nxt) {
 80480ba:	6a42      	ldr	r2, [r0, #36]	; 0x24
 80480bc:	4ba0      	ldr	r3, [pc, #640]	; (8048340 <tcp_process+0x29c>)
 80480be:	691b      	ldr	r3, [r3, #16]
 80480c0:	429a      	cmp	r2, r3
 80480c2:	d015      	beq.n	80480f0 <tcp_process+0x4c>
      } else  if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt,
 80480c4:	1a99      	subs	r1, r3, r2
 80480c6:	2900      	cmp	r1, #0
 80480c8:	db0e      	blt.n	80480e8 <tcp_process+0x44>
 80480ca:	8d01      	ldrh	r1, [r0, #40]	; 0x28
 80480cc:	440a      	add	r2, r1
 80480ce:	1a9b      	subs	r3, r3, r2
 80480d0:	2b00      	cmp	r3, #0
 80480d2:	dc09      	bgt.n	80480e8 <tcp_process+0x44>
        tcp_ack_now(pcb);
 80480d4:	7e83      	ldrb	r3, [r0, #26]
 80480d6:	f043 0302 	orr.w	r3, r3, #2
 80480da:	7683      	strb	r3, [r0, #26]
    if (acceptable) {
 80480dc:	e004      	b.n	80480e8 <tcp_process+0x44>
      if (ackno == pcb->snd_nxt) {
 80480de:	6cc2      	ldr	r2, [r0, #76]	; 0x4c
 80480e0:	4b97      	ldr	r3, [pc, #604]	; (8048340 <tcp_process+0x29c>)
 80480e2:	699b      	ldr	r3, [r3, #24]
 80480e4:	429a      	cmp	r2, r3
 80480e6:	d003      	beq.n	80480f0 <tcp_process+0x4c>
      return ERR_OK;
 80480e8:	2500      	movs	r5, #0
}
 80480ea:	4628      	mov	r0, r5
 80480ec:	b002      	add	sp, #8
 80480ee:	bd70      	pop	{r4, r5, r6, pc}
      LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
 80480f0:	b159      	cbz	r1, 804810a <tcp_process+0x66>
      recv_flags |= TF_RESET;
 80480f2:	4a93      	ldr	r2, [pc, #588]	; (8048340 <tcp_process+0x29c>)
 80480f4:	7b93      	ldrb	r3, [r2, #14]
 80480f6:	f043 0308 	orr.w	r3, r3, #8
 80480fa:	7393      	strb	r3, [r2, #14]
      pcb->flags &= ~TF_ACK_DELAY;
 80480fc:	7ea3      	ldrb	r3, [r4, #26]
 80480fe:	f023 0301 	bic.w	r3, r3, #1
 8048102:	76a3      	strb	r3, [r4, #26]
      return ERR_RST;
 8048104:	f06f 050d 	mvn.w	r5, #13
 8048108:	e7ef      	b.n	80480ea <tcp_process+0x46>
      LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
 804810a:	4b8e      	ldr	r3, [pc, #568]	; (8048344 <tcp_process+0x2a0>)
 804810c:	f240 22e7 	movw	r2, #743	; 0x2e7
 8048110:	498d      	ldr	r1, [pc, #564]	; (8048348 <tcp_process+0x2a4>)
 8048112:	488e      	ldr	r0, [pc, #568]	; (804834c <tcp_process+0x2a8>)
 8048114:	f009 fc98 	bl	8051a48 <printf>
 8048118:	e7eb      	b.n	80480f2 <tcp_process+0x4e>
  if ((flags & TCP_SYN) && (pcb->state != SYN_SENT && pcb->state != SYN_RCVD)) {
 804811a:	f013 0f02 	tst.w	r3, #2
 804811e:	d004      	beq.n	804812a <tcp_process+0x86>
 8048120:	7d03      	ldrb	r3, [r0, #20]
 8048122:	3b02      	subs	r3, #2
 8048124:	b2db      	uxtb	r3, r3
 8048126:	2b01      	cmp	r3, #1
 8048128:	d81b      	bhi.n	8048162 <tcp_process+0xbe>
  if ((pcb->flags & TF_RXCLOSED) == 0) {
 804812a:	7ea3      	ldrb	r3, [r4, #26]
 804812c:	f013 0f10 	tst.w	r3, #16
 8048130:	d102      	bne.n	8048138 <tcp_process+0x94>
    pcb->tmr = tcp_ticks;
 8048132:	4b87      	ldr	r3, [pc, #540]	; (8048350 <tcp_process+0x2ac>)
 8048134:	681b      	ldr	r3, [r3, #0]
 8048136:	6223      	str	r3, [r4, #32]
  pcb->keep_cnt_sent = 0;
 8048138:	2300      	movs	r3, #0
 804813a:	f884 3096 	strb.w	r3, [r4, #150]	; 0x96
  tcp_parseopt(pcb);
 804813e:	4620      	mov	r0, r4
 8048140:	f7ff f968 	bl	8047414 <tcp_parseopt>
  switch (pcb->state) {
 8048144:	7d23      	ldrb	r3, [r4, #20]
 8048146:	3b02      	subs	r3, #2
 8048148:	2b07      	cmp	r3, #7
 804814a:	f200 820d 	bhi.w	8048568 <tcp_process+0x4c4>
 804814e:	e8df f013 	tbh	[pc, r3, lsl #1]
 8048152:	000e      	.short	0x000e
 8048154:	0129009a 	.word	0x0129009a
 8048158:	0190013a 	.word	0x0190013a
 804815c:	01be0129 	.word	0x01be0129
 8048160:	01f1      	.short	0x01f1
    tcp_ack_now(pcb);
 8048162:	7e83      	ldrb	r3, [r0, #26]
 8048164:	f043 0302 	orr.w	r3, r3, #2
 8048168:	7683      	strb	r3, [r0, #26]
    return ERR_OK;
 804816a:	2500      	movs	r5, #0
 804816c:	e7bd      	b.n	80480ea <tcp_process+0x46>
    if ((flags & TCP_ACK) && (flags & TCP_SYN)
 804816e:	4b74      	ldr	r3, [pc, #464]	; (8048340 <tcp_process+0x29c>)
 8048170:	7bdb      	ldrb	r3, [r3, #15]
 8048172:	f003 0212 	and.w	r2, r3, #18
 8048176:	2a12      	cmp	r2, #18
 8048178:	d004      	beq.n	8048184 <tcp_process+0xe0>
    else if (flags & TCP_ACK) {
 804817a:	f013 0f10 	tst.w	r3, #16
 804817e:	d168      	bne.n	8048252 <tcp_process+0x1ae>
  return ERR_OK;
 8048180:	2500      	movs	r5, #0
 8048182:	e7b2      	b.n	80480ea <tcp_process+0x46>
        && (ackno == pcb->lastack + 1)) {
 8048184:	6c62      	ldr	r2, [r4, #68]	; 0x44
 8048186:	3201      	adds	r2, #1
 8048188:	496d      	ldr	r1, [pc, #436]	; (8048340 <tcp_process+0x29c>)
 804818a:	6989      	ldr	r1, [r1, #24]
 804818c:	428a      	cmp	r2, r1
 804818e:	d1f4      	bne.n	804817a <tcp_process+0xd6>
      pcb->rcv_nxt = seqno + 1;
 8048190:	4a6b      	ldr	r2, [pc, #428]	; (8048340 <tcp_process+0x29c>)
 8048192:	6913      	ldr	r3, [r2, #16]
 8048194:	1c58      	adds	r0, r3, #1
 8048196:	6260      	str	r0, [r4, #36]	; 0x24
      pcb->rcv_ann_right_edge = pcb->rcv_nxt;
 8048198:	62e0      	str	r0, [r4, #44]	; 0x2c
      pcb->lastack = ackno;
 804819a:	6461      	str	r1, [r4, #68]	; 0x44
      pcb->snd_wnd = tcphdr->wnd;
 804819c:	6892      	ldr	r2, [r2, #8]
 804819e:	89d2      	ldrh	r2, [r2, #14]
 80481a0:	f8a4 205c 	strh.w	r2, [r4, #92]	; 0x5c
      pcb->snd_wnd_max = pcb->snd_wnd;
 80481a4:	f8a4 205e 	strh.w	r2, [r4, #94]	; 0x5e
      pcb->snd_wl1 = seqno - 1; /* initialise to seqno - 1 to force window update */
 80481a8:	3b01      	subs	r3, #1
 80481aa:	6523      	str	r3, [r4, #80]	; 0x50
      pcb->state = ESTABLISHED;
 80481ac:	2304      	movs	r3, #4
 80481ae:	7523      	strb	r3, [r4, #20]
      pcb->mss = tcp_eff_send_mss(pcb->mss, &pcb->local_ip, &pcb->remote_ip);
 80481b0:	18e1      	adds	r1, r4, r3
 80481b2:	8e60      	ldrh	r0, [r4, #50]	; 0x32
 80481b4:	f7ff f846 	bl	8047244 <tcp_eff_send_mss_impl>
 80481b8:	8660      	strh	r0, [r4, #50]	; 0x32
      pcb->cwnd = LWIP_TCP_CALC_INITIAL_CWND(pcb->mss);
 80481ba:	0043      	lsls	r3, r0, #1
 80481bc:	f241 121c 	movw	r2, #4380	; 0x111c
 80481c0:	4293      	cmp	r3, r2
 80481c2:	bf38      	it	cc
 80481c4:	4613      	movcc	r3, r2
 80481c6:	0080      	lsls	r0, r0, #2
 80481c8:	4298      	cmp	r0, r3
 80481ca:	bf28      	it	cs
 80481cc:	4618      	movcs	r0, r3
 80481ce:	f8a4 0048 	strh.w	r0, [r4, #72]	; 0x48
      LWIP_ASSERT("pcb->snd_queuelen > 0", (pcb->snd_queuelen > 0));
 80481d2:	f8b4 3062 	ldrh.w	r3, [r4, #98]	; 0x62
 80481d6:	b31b      	cbz	r3, 8048220 <tcp_process+0x17c>
      --pcb->snd_queuelen;
 80481d8:	f8b4 3062 	ldrh.w	r3, [r4, #98]	; 0x62
 80481dc:	3b01      	subs	r3, #1
 80481de:	f8a4 3062 	strh.w	r3, [r4, #98]	; 0x62
      rseg = pcb->unacked;
 80481e2:	6ee5      	ldr	r5, [r4, #108]	; 0x6c
      if (rseg == NULL) {
 80481e4:	b325      	cbz	r5, 8048230 <tcp_process+0x18c>
        pcb->unacked = rseg->next;
 80481e6:	682b      	ldr	r3, [r5, #0]
 80481e8:	66e3      	str	r3, [r4, #108]	; 0x6c
      tcp_seg_free(rseg);
 80481ea:	4628      	mov	r0, r5
 80481ec:	f7fe fa5a 	bl	80466a4 <tcp_seg_free>
      if (pcb->unacked == NULL) {
 80481f0:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 80481f2:	b353      	cbz	r3, 804824a <tcp_process+0x1a6>
        pcb->rtime = 0;
 80481f4:	2300      	movs	r3, #0
 80481f6:	8623      	strh	r3, [r4, #48]	; 0x30
        pcb->nrtx = 0;
 80481f8:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
      TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
 80481fc:	f8d4 3084 	ldr.w	r3, [r4, #132]	; 0x84
 8048200:	b143      	cbz	r3, 8048214 <tcp_process+0x170>
 8048202:	2200      	movs	r2, #0
 8048204:	4621      	mov	r1, r4
 8048206:	6920      	ldr	r0, [r4, #16]
 8048208:	4798      	blx	r3
 804820a:	4605      	mov	r5, r0
      if (err == ERR_ABRT) {
 804820c:	f110 0f0d 	cmn.w	r0, #13
 8048210:	f43f af6b 	beq.w	80480ea <tcp_process+0x46>
      tcp_ack_now(pcb);
 8048214:	7ea3      	ldrb	r3, [r4, #26]
 8048216:	f043 0302 	orr.w	r3, r3, #2
 804821a:	76a3      	strb	r3, [r4, #26]
  return ERR_OK;
 804821c:	2500      	movs	r5, #0
      tcp_ack_now(pcb);
 804821e:	e764      	b.n	80480ea <tcp_process+0x46>
      LWIP_ASSERT("pcb->snd_queuelen > 0", (pcb->snd_queuelen > 0));
 8048220:	4b48      	ldr	r3, [pc, #288]	; (8048344 <tcp_process+0x2a0>)
 8048222:	f240 321a 	movw	r2, #794	; 0x31a
 8048226:	494b      	ldr	r1, [pc, #300]	; (8048354 <tcp_process+0x2b0>)
 8048228:	4848      	ldr	r0, [pc, #288]	; (804834c <tcp_process+0x2a8>)
 804822a:	f009 fc0d 	bl	8051a48 <printf>
 804822e:	e7d3      	b.n	80481d8 <tcp_process+0x134>
        rseg = pcb->unsent;
 8048230:	6ea5      	ldr	r5, [r4, #104]	; 0x68
        LWIP_ASSERT("no segment to free", rseg != NULL);
 8048232:	b115      	cbz	r5, 804823a <tcp_process+0x196>
        pcb->unsent = rseg->next;
 8048234:	682b      	ldr	r3, [r5, #0]
 8048236:	66a3      	str	r3, [r4, #104]	; 0x68
 8048238:	e7d7      	b.n	80481ea <tcp_process+0x146>
        LWIP_ASSERT("no segment to free", rseg != NULL);
 804823a:	4b42      	ldr	r3, [pc, #264]	; (8048344 <tcp_process+0x2a0>)
 804823c:	f240 3222 	movw	r2, #802	; 0x322
 8048240:	4945      	ldr	r1, [pc, #276]	; (8048358 <tcp_process+0x2b4>)
 8048242:	4842      	ldr	r0, [pc, #264]	; (804834c <tcp_process+0x2a8>)
 8048244:	f009 fc00 	bl	8051a48 <printf>
 8048248:	e7f4      	b.n	8048234 <tcp_process+0x190>
        pcb->rtime = -1;
 804824a:	f64f 73ff 	movw	r3, #65535	; 0xffff
 804824e:	8623      	strh	r3, [r4, #48]	; 0x30
 8048250:	e7d4      	b.n	80481fc <tcp_process+0x158>
        ip_current_src_addr(), tcphdr->dest, tcphdr->src);
 8048252:	483b      	ldr	r0, [pc, #236]	; (8048340 <tcp_process+0x29c>)
 8048254:	6882      	ldr	r2, [r0, #8]
      tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(),
 8048256:	4b41      	ldr	r3, [pc, #260]	; (804835c <tcp_process+0x2b8>)
 8048258:	8a85      	ldrh	r5, [r0, #20]
 804825a:	6901      	ldr	r1, [r0, #16]
 804825c:	8816      	ldrh	r6, [r2, #0]
 804825e:	9601      	str	r6, [sp, #4]
 8048260:	8852      	ldrh	r2, [r2, #2]
 8048262:	9200      	str	r2, [sp, #0]
 8048264:	1d1a      	adds	r2, r3, #4
 8048266:	4429      	add	r1, r5
 8048268:	6980      	ldr	r0, [r0, #24]
 804826a:	f001 fa8d 	bl	8049788 <tcp_rst>
      if (pcb->nrtx < TCP_SYNMAXRTX) {
 804826e:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
 8048272:	2b05      	cmp	r3, #5
 8048274:	d901      	bls.n	804827a <tcp_process+0x1d6>
  return ERR_OK;
 8048276:	2500      	movs	r5, #0
 8048278:	e737      	b.n	80480ea <tcp_process+0x46>
        pcb->rtime = 0;
 804827a:	2500      	movs	r5, #0
 804827c:	8625      	strh	r5, [r4, #48]	; 0x30
        tcp_rexmit_rto(pcb);
 804827e:	4620      	mov	r0, r4
 8048280:	f001 fad8 	bl	8049834 <tcp_rexmit_rto>
 8048284:	e731      	b.n	80480ea <tcp_process+0x46>
    if (flags & TCP_ACK) {
 8048286:	4b2e      	ldr	r3, [pc, #184]	; (8048340 <tcp_process+0x29c>)
 8048288:	7bdb      	ldrb	r3, [r3, #15]
 804828a:	f013 0f10 	tst.w	r3, #16
 804828e:	d078      	beq.n	8048382 <tcp_process+0x2de>
      if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
 8048290:	4b2b      	ldr	r3, [pc, #172]	; (8048340 <tcp_process+0x29c>)
 8048292:	6998      	ldr	r0, [r3, #24]
 8048294:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8048296:	1ac3      	subs	r3, r0, r3
 8048298:	2b01      	cmp	r3, #1
 804829a:	d403      	bmi.n	80482a4 <tcp_process+0x200>
 804829c:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 804829e:	1ac3      	subs	r3, r0, r3
 80482a0:	2b00      	cmp	r3, #0
 80482a2:	dd0e      	ble.n	80482c2 <tcp_process+0x21e>
          ip_current_src_addr(), tcphdr->dest, tcphdr->src);
 80482a4:	4c26      	ldr	r4, [pc, #152]	; (8048340 <tcp_process+0x29c>)
 80482a6:	68a2      	ldr	r2, [r4, #8]
        tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(),
 80482a8:	4b2c      	ldr	r3, [pc, #176]	; (804835c <tcp_process+0x2b8>)
 80482aa:	8aa5      	ldrh	r5, [r4, #20]
 80482ac:	6921      	ldr	r1, [r4, #16]
 80482ae:	8814      	ldrh	r4, [r2, #0]
 80482b0:	9401      	str	r4, [sp, #4]
 80482b2:	8852      	ldrh	r2, [r2, #2]
 80482b4:	9200      	str	r2, [sp, #0]
 80482b6:	1d1a      	adds	r2, r3, #4
 80482b8:	4429      	add	r1, r5
 80482ba:	f001 fa65 	bl	8049788 <tcp_rst>
  return ERR_OK;
 80482be:	2500      	movs	r5, #0
 80482c0:	e713      	b.n	80480ea <tcp_process+0x46>
        pcb->state = ESTABLISHED;
 80482c2:	2304      	movs	r3, #4
 80482c4:	7523      	strb	r3, [r4, #20]
        LWIP_ASSERT("pcb->listener->accept != NULL",
 80482c6:	6fa3      	ldr	r3, [r4, #120]	; 0x78
 80482c8:	b113      	cbz	r3, 80482d0 <tcp_process+0x22c>
 80482ca:	699b      	ldr	r3, [r3, #24]
 80482cc:	2b00      	cmp	r3, #0
 80482ce:	d02f      	beq.n	8048330 <tcp_process+0x28c>
        if (pcb->listener == NULL) {
 80482d0:	6fa3      	ldr	r3, [r4, #120]	; 0x78
 80482d2:	2b00      	cmp	r3, #0
 80482d4:	d046      	beq.n	8048364 <tcp_process+0x2c0>
          TCP_EVENT_ACCEPT(pcb->listener, pcb, pcb->callback_arg, ERR_OK, err);
 80482d6:	699b      	ldr	r3, [r3, #24]
 80482d8:	2b00      	cmp	r3, #0
 80482da:	d04b      	beq.n	8048374 <tcp_process+0x2d0>
 80482dc:	2200      	movs	r2, #0
 80482de:	4621      	mov	r1, r4
 80482e0:	6920      	ldr	r0, [r4, #16]
 80482e2:	4798      	blx	r3
        if (err != ERR_OK) {
 80482e4:	4605      	mov	r5, r0
 80482e6:	2800      	cmp	r0, #0
 80482e8:	d13e      	bne.n	8048368 <tcp_process+0x2c4>
        tcp_receive(pcb);
 80482ea:	4620      	mov	r0, r4
 80482ec:	f7ff f9f6 	bl	80476dc <tcp_receive>
        if (recv_acked != 0) {
 80482f0:	4b13      	ldr	r3, [pc, #76]	; (8048340 <tcp_process+0x29c>)
 80482f2:	8b9b      	ldrh	r3, [r3, #28]
 80482f4:	b113      	cbz	r3, 80482fc <tcp_process+0x258>
          recv_acked--;
 80482f6:	3b01      	subs	r3, #1
 80482f8:	4a11      	ldr	r2, [pc, #68]	; (8048340 <tcp_process+0x29c>)
 80482fa:	8393      	strh	r3, [r2, #28]
        pcb->cwnd = LWIP_TCP_CALC_INITIAL_CWND(pcb->mss);
 80482fc:	8e62      	ldrh	r2, [r4, #50]	; 0x32
 80482fe:	0053      	lsls	r3, r2, #1
 8048300:	f241 111c 	movw	r1, #4380	; 0x111c
 8048304:	428b      	cmp	r3, r1
 8048306:	bf38      	it	cc
 8048308:	460b      	movcc	r3, r1
 804830a:	0092      	lsls	r2, r2, #2
 804830c:	4293      	cmp	r3, r2
 804830e:	bf28      	it	cs
 8048310:	4613      	movcs	r3, r2
 8048312:	f8a4 3048 	strh.w	r3, [r4, #72]	; 0x48
        if (recv_flags & TF_GOT_FIN) {
 8048316:	4b0a      	ldr	r3, [pc, #40]	; (8048340 <tcp_process+0x29c>)
 8048318:	7b9b      	ldrb	r3, [r3, #14]
 804831a:	f013 0f20 	tst.w	r3, #32
 804831e:	f43f aee4 	beq.w	80480ea <tcp_process+0x46>
          tcp_ack_now(pcb);
 8048322:	7ea3      	ldrb	r3, [r4, #26]
 8048324:	f043 0302 	orr.w	r3, r3, #2
 8048328:	76a3      	strb	r3, [r4, #26]
          pcb->state = CLOSE_WAIT;
 804832a:	2307      	movs	r3, #7
 804832c:	7523      	strb	r3, [r4, #20]
 804832e:	e6dc      	b.n	80480ea <tcp_process+0x46>
        LWIP_ASSERT("pcb->listener->accept != NULL",
 8048330:	4b04      	ldr	r3, [pc, #16]	; (8048344 <tcp_process+0x2a0>)
 8048332:	f44f 7254 	mov.w	r2, #848	; 0x350
 8048336:	490a      	ldr	r1, [pc, #40]	; (8048360 <tcp_process+0x2bc>)
 8048338:	4804      	ldr	r0, [pc, #16]	; (804834c <tcp_process+0x2a8>)
 804833a:	f009 fb85 	bl	8051a48 <printf>
 804833e:	e7c7      	b.n	80482d0 <tcp_process+0x22c>
 8048340:	200040d4 	.word	0x200040d4
 8048344:	08059a5c 	.word	0x08059a5c
 8048348:	08059bf4 	.word	0x08059bf4
 804834c:	08058ecc 	.word	0x08058ecc
 8048350:	20008724 	.word	0x20008724
 8048354:	08059c14 	.word	0x08059c14
 8048358:	08059c2c 	.word	0x08059c2c
 804835c:	20005200 	.word	0x20005200
 8048360:	08059c40 	.word	0x08059c40
          err = ERR_VAL;
 8048364:	f06f 0505 	mvn.w	r5, #5
          if (err != ERR_ABRT) {
 8048368:	f115 0f0d 	cmn.w	r5, #13
 804836c:	d105      	bne.n	804837a <tcp_process+0x2d6>
          return ERR_ABRT;
 804836e:	f06f 050c 	mvn.w	r5, #12
 8048372:	e6ba      	b.n	80480ea <tcp_process+0x46>
          TCP_EVENT_ACCEPT(pcb->listener, pcb, pcb->callback_arg, ERR_OK, err);
 8048374:	f06f 050f 	mvn.w	r5, #15
 8048378:	e7f6      	b.n	8048368 <tcp_process+0x2c4>
            tcp_abort(pcb);
 804837a:	4620      	mov	r0, r4
 804837c:	f7fe fe6a 	bl	8047054 <tcp_abort>
 8048380:	e7f5      	b.n	804836e <tcp_process+0x2ca>
    } else if ((flags & TCP_SYN) && (seqno == pcb->rcv_nxt - 1)) {
 8048382:	f013 0f02 	tst.w	r3, #2
 8048386:	f000 80f1 	beq.w	804856c <tcp_process+0x4c8>
 804838a:	6a63      	ldr	r3, [r4, #36]	; 0x24
 804838c:	3b01      	subs	r3, #1
 804838e:	4a7c      	ldr	r2, [pc, #496]	; (8048580 <tcp_process+0x4dc>)
 8048390:	6912      	ldr	r2, [r2, #16]
 8048392:	4293      	cmp	r3, r2
 8048394:	d001      	beq.n	804839a <tcp_process+0x2f6>
  return ERR_OK;
 8048396:	2500      	movs	r5, #0
 8048398:	e6a7      	b.n	80480ea <tcp_process+0x46>
      tcp_rexmit(pcb);
 804839a:	4620      	mov	r0, r4
 804839c:	f001 fa63 	bl	8049866 <tcp_rexmit>
  return ERR_OK;
 80483a0:	2500      	movs	r5, #0
 80483a2:	e6a2      	b.n	80480ea <tcp_process+0x46>
    tcp_receive(pcb);
 80483a4:	4620      	mov	r0, r4
 80483a6:	f7ff f999 	bl	80476dc <tcp_receive>
    if (recv_flags & TF_GOT_FIN) { /* passive close */
 80483aa:	4b75      	ldr	r3, [pc, #468]	; (8048580 <tcp_process+0x4dc>)
 80483ac:	7b9b      	ldrb	r3, [r3, #14]
 80483ae:	f013 0f20 	tst.w	r3, #32
 80483b2:	f000 80dd 	beq.w	8048570 <tcp_process+0x4cc>
      tcp_ack_now(pcb);
 80483b6:	7ea3      	ldrb	r3, [r4, #26]
 80483b8:	f043 0302 	orr.w	r3, r3, #2
 80483bc:	76a3      	strb	r3, [r4, #26]
      pcb->state = CLOSE_WAIT;
 80483be:	2307      	movs	r3, #7
 80483c0:	7523      	strb	r3, [r4, #20]
  return ERR_OK;
 80483c2:	2500      	movs	r5, #0
 80483c4:	e691      	b.n	80480ea <tcp_process+0x46>
    tcp_receive(pcb);
 80483c6:	4620      	mov	r0, r4
 80483c8:	f7ff f988 	bl	80476dc <tcp_receive>
    if (recv_flags & TF_GOT_FIN) {
 80483cc:	4b6c      	ldr	r3, [pc, #432]	; (8048580 <tcp_process+0x4dc>)
 80483ce:	7b9b      	ldrb	r3, [r3, #14]
 80483d0:	f013 0f20 	tst.w	r3, #32
 80483d4:	d038      	beq.n	8048448 <tcp_process+0x3a4>
      if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt) &&
 80483d6:	4b6a      	ldr	r3, [pc, #424]	; (8048580 <tcp_process+0x4dc>)
 80483d8:	7bdb      	ldrb	r3, [r3, #15]
 80483da:	f013 0f10 	tst.w	r3, #16
 80483de:	d004      	beq.n	80483ea <tcp_process+0x346>
 80483e0:	6ce2      	ldr	r2, [r4, #76]	; 0x4c
 80483e2:	4b67      	ldr	r3, [pc, #412]	; (8048580 <tcp_process+0x4dc>)
 80483e4:	699b      	ldr	r3, [r3, #24]
 80483e6:	429a      	cmp	r2, r3
 80483e8:	d007      	beq.n	80483fa <tcp_process+0x356>
        tcp_ack_now(pcb);
 80483ea:	7ea3      	ldrb	r3, [r4, #26]
 80483ec:	f043 0302 	orr.w	r3, r3, #2
 80483f0:	76a3      	strb	r3, [r4, #26]
        pcb->state = CLOSING;
 80483f2:	2308      	movs	r3, #8
 80483f4:	7523      	strb	r3, [r4, #20]
  return ERR_OK;
 80483f6:	2500      	movs	r5, #0
 80483f8:	e677      	b.n	80480ea <tcp_process+0x46>
          pcb->unsent == NULL) {
 80483fa:	6ea3      	ldr	r3, [r4, #104]	; 0x68
      if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt) &&
 80483fc:	2b00      	cmp	r3, #0
 80483fe:	d1f4      	bne.n	80483ea <tcp_process+0x346>
        tcp_ack_now(pcb);
 8048400:	7ea3      	ldrb	r3, [r4, #26]
 8048402:	f043 0302 	orr.w	r3, r3, #2
 8048406:	76a3      	strb	r3, [r4, #26]
        tcp_pcb_purge(pcb);
 8048408:	4620      	mov	r0, r4
 804840a:	f7fe f9df 	bl	80467cc <tcp_pcb_purge>
        TCP_RMV_ACTIVE(pcb);
 804840e:	4b5d      	ldr	r3, [pc, #372]	; (8048584 <tcp_process+0x4e0>)
 8048410:	681b      	ldr	r3, [r3, #0]
 8048412:	42a3      	cmp	r3, r4
 8048414:	d005      	beq.n	8048422 <tcp_process+0x37e>
 8048416:	b153      	cbz	r3, 804842e <tcp_process+0x38a>
 8048418:	68da      	ldr	r2, [r3, #12]
 804841a:	42a2      	cmp	r2, r4
 804841c:	d005      	beq.n	804842a <tcp_process+0x386>
 804841e:	4613      	mov	r3, r2
 8048420:	e7f9      	b.n	8048416 <tcp_process+0x372>
 8048422:	68da      	ldr	r2, [r3, #12]
 8048424:	4b57      	ldr	r3, [pc, #348]	; (8048584 <tcp_process+0x4e0>)
 8048426:	601a      	str	r2, [r3, #0]
 8048428:	e001      	b.n	804842e <tcp_process+0x38a>
 804842a:	68e2      	ldr	r2, [r4, #12]
 804842c:	60da      	str	r2, [r3, #12]
 804842e:	4b56      	ldr	r3, [pc, #344]	; (8048588 <tcp_process+0x4e4>)
 8048430:	2201      	movs	r2, #1
 8048432:	701a      	strb	r2, [r3, #0]
        pcb->state = TIME_WAIT;
 8048434:	230a      	movs	r3, #10
 8048436:	7523      	strb	r3, [r4, #20]
        TCP_REG(&tcp_tw_pcbs, pcb);
 8048438:	4b54      	ldr	r3, [pc, #336]	; (804858c <tcp_process+0x4e8>)
 804843a:	681a      	ldr	r2, [r3, #0]
 804843c:	60e2      	str	r2, [r4, #12]
 804843e:	601c      	str	r4, [r3, #0]
 8048440:	f001 fb52 	bl	8049ae8 <tcp_timer_needed>
  return ERR_OK;
 8048444:	2500      	movs	r5, #0
        TCP_REG(&tcp_tw_pcbs, pcb);
 8048446:	e650      	b.n	80480ea <tcp_process+0x46>
    } else if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt) &&
 8048448:	4b4d      	ldr	r3, [pc, #308]	; (8048580 <tcp_process+0x4dc>)
 804844a:	7bdb      	ldrb	r3, [r3, #15]
 804844c:	f013 0f10 	tst.w	r3, #16
 8048450:	f000 8090 	beq.w	8048574 <tcp_process+0x4d0>
 8048454:	6ce2      	ldr	r2, [r4, #76]	; 0x4c
 8048456:	4b4a      	ldr	r3, [pc, #296]	; (8048580 <tcp_process+0x4dc>)
 8048458:	699b      	ldr	r3, [r3, #24]
 804845a:	429a      	cmp	r2, r3
 804845c:	d001      	beq.n	8048462 <tcp_process+0x3be>
  return ERR_OK;
 804845e:	2500      	movs	r5, #0
 8048460:	e643      	b.n	80480ea <tcp_process+0x46>
               pcb->unsent == NULL) {
 8048462:	6ea3      	ldr	r3, [r4, #104]	; 0x68
    } else if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt) &&
 8048464:	b10b      	cbz	r3, 804846a <tcp_process+0x3c6>
  return ERR_OK;
 8048466:	2500      	movs	r5, #0
 8048468:	e63f      	b.n	80480ea <tcp_process+0x46>
      pcb->state = FIN_WAIT_2;
 804846a:	2306      	movs	r3, #6
 804846c:	7523      	strb	r3, [r4, #20]
  return ERR_OK;
 804846e:	2500      	movs	r5, #0
 8048470:	e63b      	b.n	80480ea <tcp_process+0x46>
    tcp_receive(pcb);
 8048472:	4620      	mov	r0, r4
 8048474:	f7ff f932 	bl	80476dc <tcp_receive>
    if (recv_flags & TF_GOT_FIN) {
 8048478:	4b41      	ldr	r3, [pc, #260]	; (8048580 <tcp_process+0x4dc>)
 804847a:	7b9b      	ldrb	r3, [r3, #14]
 804847c:	f013 0f20 	tst.w	r3, #32
 8048480:	d101      	bne.n	8048486 <tcp_process+0x3e2>
  return ERR_OK;
 8048482:	2500      	movs	r5, #0
 8048484:	e631      	b.n	80480ea <tcp_process+0x46>
      tcp_ack_now(pcb);
 8048486:	7ea3      	ldrb	r3, [r4, #26]
 8048488:	f043 0302 	orr.w	r3, r3, #2
 804848c:	76a3      	strb	r3, [r4, #26]
      tcp_pcb_purge(pcb);
 804848e:	4620      	mov	r0, r4
 8048490:	f7fe f99c 	bl	80467cc <tcp_pcb_purge>
      TCP_RMV_ACTIVE(pcb);
 8048494:	4b3b      	ldr	r3, [pc, #236]	; (8048584 <tcp_process+0x4e0>)
 8048496:	681b      	ldr	r3, [r3, #0]
 8048498:	42a3      	cmp	r3, r4
 804849a:	d005      	beq.n	80484a8 <tcp_process+0x404>
 804849c:	b153      	cbz	r3, 80484b4 <tcp_process+0x410>
 804849e:	68da      	ldr	r2, [r3, #12]
 80484a0:	42a2      	cmp	r2, r4
 80484a2:	d005      	beq.n	80484b0 <tcp_process+0x40c>
 80484a4:	4613      	mov	r3, r2
 80484a6:	e7f9      	b.n	804849c <tcp_process+0x3f8>
 80484a8:	68da      	ldr	r2, [r3, #12]
 80484aa:	4b36      	ldr	r3, [pc, #216]	; (8048584 <tcp_process+0x4e0>)
 80484ac:	601a      	str	r2, [r3, #0]
 80484ae:	e001      	b.n	80484b4 <tcp_process+0x410>
 80484b0:	68e2      	ldr	r2, [r4, #12]
 80484b2:	60da      	str	r2, [r3, #12]
 80484b4:	4b34      	ldr	r3, [pc, #208]	; (8048588 <tcp_process+0x4e4>)
 80484b6:	2201      	movs	r2, #1
 80484b8:	701a      	strb	r2, [r3, #0]
      pcb->state = TIME_WAIT;
 80484ba:	230a      	movs	r3, #10
 80484bc:	7523      	strb	r3, [r4, #20]
      TCP_REG(&tcp_tw_pcbs, pcb);
 80484be:	4b33      	ldr	r3, [pc, #204]	; (804858c <tcp_process+0x4e8>)
 80484c0:	681a      	ldr	r2, [r3, #0]
 80484c2:	60e2      	str	r2, [r4, #12]
 80484c4:	601c      	str	r4, [r3, #0]
 80484c6:	f001 fb0f 	bl	8049ae8 <tcp_timer_needed>
  return ERR_OK;
 80484ca:	2500      	movs	r5, #0
 80484cc:	e60d      	b.n	80480ea <tcp_process+0x46>
    tcp_receive(pcb);
 80484ce:	4620      	mov	r0, r4
 80484d0:	f7ff f904 	bl	80476dc <tcp_receive>
    if ((flags & TCP_ACK) && ackno == pcb->snd_nxt && pcb->unsent == NULL) {
 80484d4:	4b2a      	ldr	r3, [pc, #168]	; (8048580 <tcp_process+0x4dc>)
 80484d6:	7bdb      	ldrb	r3, [r3, #15]
 80484d8:	f013 0f10 	tst.w	r3, #16
 80484dc:	d04c      	beq.n	8048578 <tcp_process+0x4d4>
 80484de:	6ce2      	ldr	r2, [r4, #76]	; 0x4c
 80484e0:	4b27      	ldr	r3, [pc, #156]	; (8048580 <tcp_process+0x4dc>)
 80484e2:	699b      	ldr	r3, [r3, #24]
 80484e4:	429a      	cmp	r2, r3
 80484e6:	d001      	beq.n	80484ec <tcp_process+0x448>
  return ERR_OK;
 80484e8:	2500      	movs	r5, #0
 80484ea:	e5fe      	b.n	80480ea <tcp_process+0x46>
    if ((flags & TCP_ACK) && ackno == pcb->snd_nxt && pcb->unsent == NULL) {
 80484ec:	6ea3      	ldr	r3, [r4, #104]	; 0x68
 80484ee:	b10b      	cbz	r3, 80484f4 <tcp_process+0x450>
  return ERR_OK;
 80484f0:	2500      	movs	r5, #0
 80484f2:	e5fa      	b.n	80480ea <tcp_process+0x46>
      tcp_pcb_purge(pcb);
 80484f4:	4620      	mov	r0, r4
 80484f6:	f7fe f969 	bl	80467cc <tcp_pcb_purge>
      TCP_RMV_ACTIVE(pcb);
 80484fa:	4b22      	ldr	r3, [pc, #136]	; (8048584 <tcp_process+0x4e0>)
 80484fc:	681b      	ldr	r3, [r3, #0]
 80484fe:	42a3      	cmp	r3, r4
 8048500:	d005      	beq.n	804850e <tcp_process+0x46a>
 8048502:	b153      	cbz	r3, 804851a <tcp_process+0x476>
 8048504:	68da      	ldr	r2, [r3, #12]
 8048506:	42a2      	cmp	r2, r4
 8048508:	d005      	beq.n	8048516 <tcp_process+0x472>
 804850a:	4613      	mov	r3, r2
 804850c:	e7f9      	b.n	8048502 <tcp_process+0x45e>
 804850e:	68da      	ldr	r2, [r3, #12]
 8048510:	4b1c      	ldr	r3, [pc, #112]	; (8048584 <tcp_process+0x4e0>)
 8048512:	601a      	str	r2, [r3, #0]
 8048514:	e001      	b.n	804851a <tcp_process+0x476>
 8048516:	68e2      	ldr	r2, [r4, #12]
 8048518:	60da      	str	r2, [r3, #12]
 804851a:	4b1b      	ldr	r3, [pc, #108]	; (8048588 <tcp_process+0x4e4>)
 804851c:	2201      	movs	r2, #1
 804851e:	701a      	strb	r2, [r3, #0]
      pcb->state = TIME_WAIT;
 8048520:	230a      	movs	r3, #10
 8048522:	7523      	strb	r3, [r4, #20]
      TCP_REG(&tcp_tw_pcbs, pcb);
 8048524:	4b19      	ldr	r3, [pc, #100]	; (804858c <tcp_process+0x4e8>)
 8048526:	681a      	ldr	r2, [r3, #0]
 8048528:	60e2      	str	r2, [r4, #12]
 804852a:	601c      	str	r4, [r3, #0]
 804852c:	f001 fadc 	bl	8049ae8 <tcp_timer_needed>
  return ERR_OK;
 8048530:	2500      	movs	r5, #0
 8048532:	e5da      	b.n	80480ea <tcp_process+0x46>
    tcp_receive(pcb);
 8048534:	4620      	mov	r0, r4
 8048536:	f7ff f8d1 	bl	80476dc <tcp_receive>
    if ((flags & TCP_ACK) && ackno == pcb->snd_nxt && pcb->unsent == NULL) {
 804853a:	4b11      	ldr	r3, [pc, #68]	; (8048580 <tcp_process+0x4dc>)
 804853c:	7bdb      	ldrb	r3, [r3, #15]
 804853e:	f013 0f10 	tst.w	r3, #16
 8048542:	d01b      	beq.n	804857c <tcp_process+0x4d8>
 8048544:	6ce2      	ldr	r2, [r4, #76]	; 0x4c
 8048546:	4b0e      	ldr	r3, [pc, #56]	; (8048580 <tcp_process+0x4dc>)
 8048548:	699b      	ldr	r3, [r3, #24]
 804854a:	429a      	cmp	r2, r3
 804854c:	d001      	beq.n	8048552 <tcp_process+0x4ae>
  return ERR_OK;
 804854e:	2500      	movs	r5, #0
 8048550:	e5cb      	b.n	80480ea <tcp_process+0x46>
    if ((flags & TCP_ACK) && ackno == pcb->snd_nxt && pcb->unsent == NULL) {
 8048552:	6ea3      	ldr	r3, [r4, #104]	; 0x68
 8048554:	b10b      	cbz	r3, 804855a <tcp_process+0x4b6>
  return ERR_OK;
 8048556:	2500      	movs	r5, #0
 8048558:	e5c7      	b.n	80480ea <tcp_process+0x46>
      recv_flags |= TF_CLOSED;
 804855a:	4a09      	ldr	r2, [pc, #36]	; (8048580 <tcp_process+0x4dc>)
 804855c:	7b93      	ldrb	r3, [r2, #14]
 804855e:	f043 0310 	orr.w	r3, r3, #16
 8048562:	7393      	strb	r3, [r2, #14]
  return ERR_OK;
 8048564:	2500      	movs	r5, #0
 8048566:	e5c0      	b.n	80480ea <tcp_process+0x46>
  switch (pcb->state) {
 8048568:	2500      	movs	r5, #0
 804856a:	e5be      	b.n	80480ea <tcp_process+0x46>
  return ERR_OK;
 804856c:	2500      	movs	r5, #0
 804856e:	e5bc      	b.n	80480ea <tcp_process+0x46>
 8048570:	2500      	movs	r5, #0
 8048572:	e5ba      	b.n	80480ea <tcp_process+0x46>
 8048574:	2500      	movs	r5, #0
 8048576:	e5b8      	b.n	80480ea <tcp_process+0x46>
 8048578:	2500      	movs	r5, #0
 804857a:	e5b6      	b.n	80480ea <tcp_process+0x46>
 804857c:	2500      	movs	r5, #0
 804857e:	e5b4      	b.n	80480ea <tcp_process+0x46>
 8048580:	200040d4 	.word	0x200040d4
 8048584:	20008720 	.word	0x20008720
 8048588:	2000871c 	.word	0x2000871c
 804858c:	20008730 	.word	0x20008730

08048590 <tcp_input>:
{
 8048590:	b5f0      	push	{r4, r5, r6, r7, lr}
 8048592:	b083      	sub	sp, #12
 8048594:	4605      	mov	r5, r0
  tcphdr = (struct tcp_hdr *)p->payload;
 8048596:	6842      	ldr	r2, [r0, #4]
 8048598:	4b62      	ldr	r3, [pc, #392]	; (8048724 <tcp_input+0x194>)
 804859a:	609a      	str	r2, [r3, #8]
  if (p->len < TCP_HLEN) {
 804859c:	8943      	ldrh	r3, [r0, #10]
 804859e:	2b13      	cmp	r3, #19
 80485a0:	d804      	bhi.n	80485ac <tcp_input+0x1c>
  pbuf_free(p);
 80485a2:	4628      	mov	r0, r5
 80485a4:	f7fd fb9a 	bl	8045cdc <pbuf_free>
}
 80485a8:	b003      	add	sp, #12
 80485aa:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if (ip_addr_isbroadcast(ip_current_dest_addr(), ip_current_netif()) ||
 80485ac:	4b5e      	ldr	r3, [pc, #376]	; (8048728 <tcp_input+0x198>)
 80485ae:	6819      	ldr	r1, [r3, #0]
 80485b0:	6958      	ldr	r0, [r3, #20]
 80485b2:	f002 fb3a 	bl	804ac2a <ip4_addr_isbroadcast_u32>
 80485b6:	2800      	cmp	r0, #0
 80485b8:	d1f3      	bne.n	80485a2 <tcp_input+0x12>
      ip_addr_ismulticast(ip_current_dest_addr())) {
 80485ba:	4b5b      	ldr	r3, [pc, #364]	; (8048728 <tcp_input+0x198>)
 80485bc:	695b      	ldr	r3, [r3, #20]
 80485be:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
  if (ip_addr_isbroadcast(ip_current_dest_addr(), ip_current_netif()) ||
 80485c2:	2be0      	cmp	r3, #224	; 0xe0
 80485c4:	d0ed      	beq.n	80485a2 <tcp_input+0x12>
  hdrlen_bytes = TCPH_HDRLEN(tcphdr) * 4;
 80485c6:	4b57      	ldr	r3, [pc, #348]	; (8048724 <tcp_input+0x194>)
 80485c8:	689b      	ldr	r3, [r3, #8]
 80485ca:	8998      	ldrh	r0, [r3, #12]
 80485cc:	f7fc ff50 	bl	8045470 <lwip_htons>
 80485d0:	f3c0 310f 	ubfx	r1, r0, #12, #16
 80485d4:	0089      	lsls	r1, r1, #2
 80485d6:	b2c9      	uxtb	r1, r1
  if ((hdrlen_bytes < TCP_HLEN) || (hdrlen_bytes > p->tot_len)) {
 80485d8:	2913      	cmp	r1, #19
 80485da:	d9e2      	bls.n	80485a2 <tcp_input+0x12>
 80485dc:	b289      	uxth	r1, r1
 80485de:	892b      	ldrh	r3, [r5, #8]
 80485e0:	4299      	cmp	r1, r3
 80485e2:	d8de      	bhi.n	80485a2 <tcp_input+0x12>
  tcphdr_optlen = hdrlen_bytes - TCP_HLEN;
 80485e4:	f1a1 0314 	sub.w	r3, r1, #20
 80485e8:	b29b      	uxth	r3, r3
 80485ea:	4a4e      	ldr	r2, [pc, #312]	; (8048724 <tcp_input+0x194>)
 80485ec:	8193      	strh	r3, [r2, #12]
  tcphdr_opt2 = NULL;
 80485ee:	2000      	movs	r0, #0
 80485f0:	6010      	str	r0, [r2, #0]
  if (p->len >= hdrlen_bytes) {
 80485f2:	896a      	ldrh	r2, [r5, #10]
 80485f4:	4291      	cmp	r1, r2
 80485f6:	d930      	bls.n	804865a <tcp_input+0xca>
    LWIP_ASSERT("p->next != NULL", p->next != NULL);
 80485f8:	682b      	ldr	r3, [r5, #0]
 80485fa:	2b00      	cmp	r3, #0
 80485fc:	d061      	beq.n	80486c2 <tcp_input+0x132>
    pbuf_header(p, -TCP_HLEN);
 80485fe:	f06f 0113 	mvn.w	r1, #19
 8048602:	4628      	mov	r0, r5
 8048604:	f7fd fb60 	bl	8045cc8 <pbuf_header>
    tcphdr_opt1len = p->len;
 8048608:	896c      	ldrh	r4, [r5, #10]
 804860a:	4b46      	ldr	r3, [pc, #280]	; (8048724 <tcp_input+0x194>)
 804860c:	80dc      	strh	r4, [r3, #6]
    opt2len = tcphdr_optlen - tcphdr_opt1len;
 804860e:	899f      	ldrh	r7, [r3, #12]
 8048610:	1b3e      	subs	r6, r7, r4
 8048612:	b2b6      	uxth	r6, r6
    pbuf_header(p, -(s16_t)tcphdr_opt1len);
 8048614:	4261      	negs	r1, r4
 8048616:	b209      	sxth	r1, r1
 8048618:	4628      	mov	r0, r5
 804861a:	f7fd fb55 	bl	8045cc8 <pbuf_header>
    if (opt2len > p->next->len) {
 804861e:	6828      	ldr	r0, [r5, #0]
 8048620:	8943      	ldrh	r3, [r0, #10]
 8048622:	42b3      	cmp	r3, r6
 8048624:	d3bd      	bcc.n	80485a2 <tcp_input+0x12>
    tcphdr_opt2 = (u8_t*)p->next->payload;
 8048626:	6842      	ldr	r2, [r0, #4]
 8048628:	4b3e      	ldr	r3, [pc, #248]	; (8048724 <tcp_input+0x194>)
 804862a:	601a      	str	r2, [r3, #0]
    pbuf_header(p->next, -(s16_t)opt2len);
 804862c:	1be1      	subs	r1, r4, r7
 804862e:	b28c      	uxth	r4, r1
 8048630:	b209      	sxth	r1, r1
 8048632:	f7fd fb49 	bl	8045cc8 <pbuf_header>
    p->tot_len -= opt2len;
 8048636:	892b      	ldrh	r3, [r5, #8]
 8048638:	441c      	add	r4, r3
 804863a:	812c      	strh	r4, [r5, #8]
    LWIP_ASSERT("p->len == 0", p->len == 0);
 804863c:	896b      	ldrh	r3, [r5, #10]
 804863e:	2b00      	cmp	r3, #0
 8048640:	d146      	bne.n	80486d0 <tcp_input+0x140>
    LWIP_ASSERT("p->tot_len == p->next->tot_len", p->tot_len == p->next->tot_len);
 8048642:	892a      	ldrh	r2, [r5, #8]
 8048644:	682b      	ldr	r3, [r5, #0]
 8048646:	891b      	ldrh	r3, [r3, #8]
 8048648:	429a      	cmp	r2, r3
 804864a:	d00c      	beq.n	8048666 <tcp_input+0xd6>
 804864c:	4b37      	ldr	r3, [pc, #220]	; (804872c <tcp_input+0x19c>)
 804864e:	22d0      	movs	r2, #208	; 0xd0
 8048650:	4937      	ldr	r1, [pc, #220]	; (8048730 <tcp_input+0x1a0>)
 8048652:	4838      	ldr	r0, [pc, #224]	; (8048734 <tcp_input+0x1a4>)
 8048654:	f009 f9f8 	bl	8051a48 <printf>
 8048658:	e005      	b.n	8048666 <tcp_input+0xd6>
    tcphdr_opt1len = tcphdr_optlen;
 804865a:	4a32      	ldr	r2, [pc, #200]	; (8048724 <tcp_input+0x194>)
 804865c:	80d3      	strh	r3, [r2, #6]
    pbuf_header(p, -(s16_t)hdrlen_bytes); /* cannot fail */
 804865e:	4249      	negs	r1, r1
 8048660:	4628      	mov	r0, r5
 8048662:	f7fd fb31 	bl	8045cc8 <pbuf_header>
  tcphdr->src = lwip_ntohs(tcphdr->src);
 8048666:	4c2f      	ldr	r4, [pc, #188]	; (8048724 <tcp_input+0x194>)
 8048668:	68a6      	ldr	r6, [r4, #8]
 804866a:	8830      	ldrh	r0, [r6, #0]
 804866c:	f7fc ff00 	bl	8045470 <lwip_htons>
 8048670:	8030      	strh	r0, [r6, #0]
  tcphdr->dest = lwip_ntohs(tcphdr->dest);
 8048672:	68a6      	ldr	r6, [r4, #8]
 8048674:	8870      	ldrh	r0, [r6, #2]
 8048676:	f7fc fefb 	bl	8045470 <lwip_htons>
 804867a:	8070      	strh	r0, [r6, #2]
  seqno = tcphdr->seqno = lwip_ntohl(tcphdr->seqno);
 804867c:	68a6      	ldr	r6, [r4, #8]
 804867e:	6870      	ldr	r0, [r6, #4]
 8048680:	f7fc fef9 	bl	8045476 <lwip_htonl>
 8048684:	6070      	str	r0, [r6, #4]
 8048686:	6120      	str	r0, [r4, #16]
  ackno = tcphdr->ackno = lwip_ntohl(tcphdr->ackno);
 8048688:	68a6      	ldr	r6, [r4, #8]
 804868a:	68b0      	ldr	r0, [r6, #8]
 804868c:	f7fc fef3 	bl	8045476 <lwip_htonl>
 8048690:	60b0      	str	r0, [r6, #8]
 8048692:	61a0      	str	r0, [r4, #24]
  tcphdr->wnd = lwip_ntohs(tcphdr->wnd);
 8048694:	68a6      	ldr	r6, [r4, #8]
 8048696:	89f0      	ldrh	r0, [r6, #14]
 8048698:	f7fc feea 	bl	8045470 <lwip_htons>
 804869c:	81f0      	strh	r0, [r6, #14]
  flags = TCPH_FLAGS(tcphdr);
 804869e:	68a3      	ldr	r3, [r4, #8]
 80486a0:	8998      	ldrh	r0, [r3, #12]
 80486a2:	f7fc fee5 	bl	8045470 <lwip_htons>
 80486a6:	f000 033f 	and.w	r3, r0, #63	; 0x3f
 80486aa:	73e3      	strb	r3, [r4, #15]
  tcplen = p->tot_len + ((flags & (TCP_FIN | TCP_SYN)) ? 1 : 0);
 80486ac:	892a      	ldrh	r2, [r5, #8]
 80486ae:	f013 0303 	ands.w	r3, r3, #3
 80486b2:	bf18      	it	ne
 80486b4:	2301      	movne	r3, #1
 80486b6:	4413      	add	r3, r2
 80486b8:	82a3      	strh	r3, [r4, #20]
  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 80486ba:	4b1f      	ldr	r3, [pc, #124]	; (8048738 <tcp_input+0x1a8>)
 80486bc:	681c      	ldr	r4, [r3, #0]
  prev = NULL;
 80486be:	2600      	movs	r6, #0
  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 80486c0:	e04c      	b.n	804875c <tcp_input+0x1cc>
    LWIP_ASSERT("p->next != NULL", p->next != NULL);
 80486c2:	4b1a      	ldr	r3, [pc, #104]	; (804872c <tcp_input+0x19c>)
 80486c4:	22b2      	movs	r2, #178	; 0xb2
 80486c6:	491d      	ldr	r1, [pc, #116]	; (804873c <tcp_input+0x1ac>)
 80486c8:	481a      	ldr	r0, [pc, #104]	; (8048734 <tcp_input+0x1a4>)
 80486ca:	f009 f9bd 	bl	8051a48 <printf>
 80486ce:	e796      	b.n	80485fe <tcp_input+0x6e>
    LWIP_ASSERT("p->len == 0", p->len == 0);
 80486d0:	4b16      	ldr	r3, [pc, #88]	; (804872c <tcp_input+0x19c>)
 80486d2:	22cf      	movs	r2, #207	; 0xcf
 80486d4:	491a      	ldr	r1, [pc, #104]	; (8048740 <tcp_input+0x1b0>)
 80486d6:	4817      	ldr	r0, [pc, #92]	; (8048734 <tcp_input+0x1a4>)
 80486d8:	f009 f9b6 	bl	8051a48 <printf>
 80486dc:	e7b1      	b.n	8048642 <tcp_input+0xb2>
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
 80486de:	4b13      	ldr	r3, [pc, #76]	; (804872c <tcp_input+0x19c>)
 80486e0:	22e2      	movs	r2, #226	; 0xe2
 80486e2:	4918      	ldr	r1, [pc, #96]	; (8048744 <tcp_input+0x1b4>)
 80486e4:	4813      	ldr	r0, [pc, #76]	; (8048734 <tcp_input+0x1a4>)
 80486e6:	f009 f9af 	bl	8051a48 <printf>
 80486ea:	e03c      	b.n	8048766 <tcp_input+0x1d6>
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
 80486ec:	4b0f      	ldr	r3, [pc, #60]	; (804872c <tcp_input+0x19c>)
 80486ee:	22e3      	movs	r2, #227	; 0xe3
 80486f0:	4915      	ldr	r1, [pc, #84]	; (8048748 <tcp_input+0x1b8>)
 80486f2:	4810      	ldr	r0, [pc, #64]	; (8048734 <tcp_input+0x1a4>)
 80486f4:	f009 f9a8 	bl	8051a48 <printf>
 80486f8:	e038      	b.n	804876c <tcp_input+0x1dc>
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
 80486fa:	4b0c      	ldr	r3, [pc, #48]	; (804872c <tcp_input+0x19c>)
 80486fc:	22e4      	movs	r2, #228	; 0xe4
 80486fe:	4913      	ldr	r1, [pc, #76]	; (804874c <tcp_input+0x1bc>)
 8048700:	480c      	ldr	r0, [pc, #48]	; (8048734 <tcp_input+0x1a4>)
 8048702:	f009 f9a1 	bl	8051a48 <printf>
 8048706:	e034      	b.n	8048772 <tcp_input+0x1e2>
      LWIP_ASSERT("tcp_input: pcb->next != pcb (before cache)", pcb->next != pcb);
 8048708:	4b08      	ldr	r3, [pc, #32]	; (804872c <tcp_input+0x19c>)
 804870a:	22ec      	movs	r2, #236	; 0xec
 804870c:	4910      	ldr	r1, [pc, #64]	; (8048750 <tcp_input+0x1c0>)
 804870e:	4809      	ldr	r0, [pc, #36]	; (8048734 <tcp_input+0x1a4>)
 8048710:	f009 f99a 	bl	8051a48 <printf>
 8048714:	e044      	b.n	80487a0 <tcp_input+0x210>
      LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
 8048716:	4b05      	ldr	r3, [pc, #20]	; (804872c <tcp_input+0x19c>)
 8048718:	22f4      	movs	r2, #244	; 0xf4
 804871a:	490e      	ldr	r1, [pc, #56]	; (8048754 <tcp_input+0x1c4>)
 804871c:	4805      	ldr	r0, [pc, #20]	; (8048734 <tcp_input+0x1a4>)
 804871e:	f009 f993 	bl	8051a48 <printf>
 8048722:	e047      	b.n	80487b4 <tcp_input+0x224>
 8048724:	200040d4 	.word	0x200040d4
 8048728:	200051f0 	.word	0x200051f0
 804872c:	08059a5c 	.word	0x08059a5c
 8048730:	08059c7c 	.word	0x08059c7c
 8048734:	08058ecc 	.word	0x08058ecc
 8048738:	20008720 	.word	0x20008720
 804873c:	08059c60 	.word	0x08059c60
 8048740:	08059c70 	.word	0x08059c70
 8048744:	08059c9c 	.word	0x08059c9c
 8048748:	08059cc4 	.word	0x08059cc4
 804874c:	08059cf0 	.word	0x08059cf0
 8048750:	08059d18 	.word	0x08059d18
 8048754:	08059d44 	.word	0x08059d44
    prev = pcb;
 8048758:	4626      	mov	r6, r4
  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 804875a:	68e4      	ldr	r4, [r4, #12]
 804875c:	2c00      	cmp	r4, #0
 804875e:	d029      	beq.n	80487b4 <tcp_input+0x224>
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
 8048760:	7d23      	ldrb	r3, [r4, #20]
 8048762:	2b00      	cmp	r3, #0
 8048764:	d0bb      	beq.n	80486de <tcp_input+0x14e>
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
 8048766:	7d23      	ldrb	r3, [r4, #20]
 8048768:	2b0a      	cmp	r3, #10
 804876a:	d0bf      	beq.n	80486ec <tcp_input+0x15c>
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
 804876c:	7d23      	ldrb	r3, [r4, #20]
 804876e:	2b01      	cmp	r3, #1
 8048770:	d0c3      	beq.n	80486fa <tcp_input+0x16a>
    if (pcb->remote_port == tcphdr->src &&
 8048772:	8b21      	ldrh	r1, [r4, #24]
 8048774:	4b92      	ldr	r3, [pc, #584]	; (80489c0 <tcp_input+0x430>)
 8048776:	689b      	ldr	r3, [r3, #8]
 8048778:	881a      	ldrh	r2, [r3, #0]
 804877a:	4291      	cmp	r1, r2
 804877c:	d1ec      	bne.n	8048758 <tcp_input+0x1c8>
        pcb->local_port == tcphdr->dest &&
 804877e:	8ae2      	ldrh	r2, [r4, #22]
 8048780:	885b      	ldrh	r3, [r3, #2]
    if (pcb->remote_port == tcphdr->src &&
 8048782:	429a      	cmp	r2, r3
 8048784:	d1e8      	bne.n	8048758 <tcp_input+0x1c8>
        ip_addr_cmp(&pcb->remote_ip, ip_current_src_addr()) &&
 8048786:	6862      	ldr	r2, [r4, #4]
 8048788:	4b8e      	ldr	r3, [pc, #568]	; (80489c4 <tcp_input+0x434>)
 804878a:	691b      	ldr	r3, [r3, #16]
        pcb->local_port == tcphdr->dest &&
 804878c:	429a      	cmp	r2, r3
 804878e:	d1e3      	bne.n	8048758 <tcp_input+0x1c8>
        ip_addr_cmp(&pcb->local_ip, ip_current_dest_addr())) {
 8048790:	6822      	ldr	r2, [r4, #0]
 8048792:	4b8c      	ldr	r3, [pc, #560]	; (80489c4 <tcp_input+0x434>)
 8048794:	695b      	ldr	r3, [r3, #20]
        ip_addr_cmp(&pcb->remote_ip, ip_current_src_addr()) &&
 8048796:	429a      	cmp	r2, r3
 8048798:	d1de      	bne.n	8048758 <tcp_input+0x1c8>
      LWIP_ASSERT("tcp_input: pcb->next != pcb (before cache)", pcb->next != pcb);
 804879a:	68e3      	ldr	r3, [r4, #12]
 804879c:	42a3      	cmp	r3, r4
 804879e:	d0b3      	beq.n	8048708 <tcp_input+0x178>
      if (prev != NULL) {
 80487a0:	b12e      	cbz	r6, 80487ae <tcp_input+0x21e>
        prev->next = pcb->next;
 80487a2:	68e3      	ldr	r3, [r4, #12]
 80487a4:	60f3      	str	r3, [r6, #12]
        pcb->next = tcp_active_pcbs;
 80487a6:	4b88      	ldr	r3, [pc, #544]	; (80489c8 <tcp_input+0x438>)
 80487a8:	681a      	ldr	r2, [r3, #0]
 80487aa:	60e2      	str	r2, [r4, #12]
        tcp_active_pcbs = pcb;
 80487ac:	601c      	str	r4, [r3, #0]
      LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
 80487ae:	68e3      	ldr	r3, [r4, #12]
 80487b0:	42a3      	cmp	r3, r4
 80487b2:	d0b0      	beq.n	8048716 <tcp_input+0x186>
  if (pcb == NULL) {
 80487b4:	2c00      	cmp	r4, #0
 80487b6:	d04e      	beq.n	8048856 <tcp_input+0x2c6>
  if (pcb != NULL) {
 80487b8:	2c00      	cmp	r4, #0
 80487ba:	f000 8128 	beq.w	8048a0e <tcp_input+0x47e>
    inseg.next = NULL;
 80487be:	4b80      	ldr	r3, [pc, #512]	; (80489c0 <tcp_input+0x430>)
 80487c0:	2200      	movs	r2, #0
 80487c2:	621a      	str	r2, [r3, #32]
    inseg.len = p->tot_len;
 80487c4:	8929      	ldrh	r1, [r5, #8]
 80487c6:	8519      	strh	r1, [r3, #40]	; 0x28
    inseg.p = p;
 80487c8:	625d      	str	r5, [r3, #36]	; 0x24
    inseg.tcphdr = tcphdr;
 80487ca:	6899      	ldr	r1, [r3, #8]
 80487cc:	62d9      	str	r1, [r3, #44]	; 0x2c
    recv_data = NULL;
 80487ce:	631a      	str	r2, [r3, #48]	; 0x30
    recv_flags = 0;
 80487d0:	739a      	strb	r2, [r3, #14]
    recv_acked = 0;
 80487d2:	839a      	strh	r2, [r3, #28]
    if (flags & TCP_PSH) {
 80487d4:	7bdb      	ldrb	r3, [r3, #15]
 80487d6:	f013 0f08 	tst.w	r3, #8
 80487da:	d003      	beq.n	80487e4 <tcp_input+0x254>
      p->flags |= PBUF_FLAG_PUSH;
 80487dc:	7b6b      	ldrb	r3, [r5, #13]
 80487de:	f043 0301 	orr.w	r3, r3, #1
 80487e2:	736b      	strb	r3, [r5, #13]
    if (pcb->refused_data != NULL) {
 80487e4:	6f63      	ldr	r3, [r4, #116]	; 0x74
 80487e6:	b15b      	cbz	r3, 8048800 <tcp_input+0x270>
      if ((tcp_process_refused_data(pcb) == ERR_ABRT) ||
 80487e8:	4620      	mov	r0, r4
 80487ea:	f7fe fb2f 	bl	8046e4c <tcp_process_refused_data>
 80487ee:	f110 0f0d 	cmn.w	r0, #13
 80487f2:	d07f      	beq.n	80488f4 <tcp_input+0x364>
        ((pcb->refused_data != NULL) && (tcplen > 0))) {
 80487f4:	6f63      	ldr	r3, [r4, #116]	; 0x74
      if ((tcp_process_refused_data(pcb) == ERR_ABRT) ||
 80487f6:	b11b      	cbz	r3, 8048800 <tcp_input+0x270>
        ((pcb->refused_data != NULL) && (tcplen > 0))) {
 80487f8:	4b71      	ldr	r3, [pc, #452]	; (80489c0 <tcp_input+0x430>)
 80487fa:	8a9b      	ldrh	r3, [r3, #20]
 80487fc:	2b00      	cmp	r3, #0
 80487fe:	d179      	bne.n	80488f4 <tcp_input+0x364>
    tcp_input_pcb = pcb;
 8048800:	4b72      	ldr	r3, [pc, #456]	; (80489cc <tcp_input+0x43c>)
 8048802:	601c      	str	r4, [r3, #0]
    err = tcp_process(pcb);
 8048804:	4620      	mov	r0, r4
 8048806:	f7ff fc4d 	bl	80480a4 <tcp_process>
    if (err != ERR_ABRT) {
 804880a:	f110 0f0d 	cmn.w	r0, #13
 804880e:	d013      	beq.n	8048838 <tcp_input+0x2a8>
      if (recv_flags & TF_RESET) {
 8048810:	4b6b      	ldr	r3, [pc, #428]	; (80489c0 <tcp_input+0x430>)
 8048812:	7b9b      	ldrb	r3, [r3, #14]
 8048814:	f013 0f08 	tst.w	r3, #8
 8048818:	d073      	beq.n	8048902 <tcp_input+0x372>
        TCP_EVENT_ERR(pcb->state, pcb->errf, pcb->callback_arg, ERR_RST);
 804881a:	f8d4 308c 	ldr.w	r3, [r4, #140]	; 0x8c
 804881e:	b11b      	cbz	r3, 8048828 <tcp_input+0x298>
 8048820:	f06f 010d 	mvn.w	r1, #13
 8048824:	6920      	ldr	r0, [r4, #16]
 8048826:	4798      	blx	r3
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
 8048828:	4621      	mov	r1, r4
 804882a:	4867      	ldr	r0, [pc, #412]	; (80489c8 <tcp_input+0x438>)
 804882c:	f7fe f9f6 	bl	8046c1c <tcp_pcb_remove>
        memp_free(MEMP_TCP_PCB, pcb);
 8048830:	4621      	mov	r1, r4
 8048832:	2001      	movs	r0, #1
 8048834:	f7fd f89e 	bl	8045974 <memp_free>
    tcp_input_pcb = NULL;
 8048838:	2200      	movs	r2, #0
 804883a:	4b64      	ldr	r3, [pc, #400]	; (80489cc <tcp_input+0x43c>)
 804883c:	601a      	str	r2, [r3, #0]
    recv_data = NULL;
 804883e:	4b60      	ldr	r3, [pc, #384]	; (80489c0 <tcp_input+0x430>)
 8048840:	631a      	str	r2, [r3, #48]	; 0x30
    if (inseg.p != NULL)
 8048842:	6a58      	ldr	r0, [r3, #36]	; 0x24
 8048844:	2800      	cmp	r0, #0
 8048846:	f43f aeaf 	beq.w	80485a8 <tcp_input+0x18>
      pbuf_free(inseg.p);
 804884a:	f7fd fa47 	bl	8045cdc <pbuf_free>
      inseg.p = NULL;
 804884e:	4b5c      	ldr	r3, [pc, #368]	; (80489c0 <tcp_input+0x430>)
 8048850:	2200      	movs	r2, #0
 8048852:	625a      	str	r2, [r3, #36]	; 0x24
 8048854:	e6a8      	b.n	80485a8 <tcp_input+0x18>
    for (pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
 8048856:	4b5e      	ldr	r3, [pc, #376]	; (80489d0 <tcp_input+0x440>)
 8048858:	681c      	ldr	r4, [r3, #0]
 804885a:	e00c      	b.n	8048876 <tcp_input+0x2e6>
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
 804885c:	4b5d      	ldr	r3, [pc, #372]	; (80489d4 <tcp_input+0x444>)
 804885e:	22fe      	movs	r2, #254	; 0xfe
 8048860:	495d      	ldr	r1, [pc, #372]	; (80489d8 <tcp_input+0x448>)
 8048862:	485e      	ldr	r0, [pc, #376]	; (80489dc <tcp_input+0x44c>)
 8048864:	f009 f8f0 	bl	8051a48 <printf>
      if (pcb->remote_port == tcphdr->src &&
 8048868:	8b21      	ldrh	r1, [r4, #24]
 804886a:	4b55      	ldr	r3, [pc, #340]	; (80489c0 <tcp_input+0x430>)
 804886c:	689b      	ldr	r3, [r3, #8]
 804886e:	881a      	ldrh	r2, [r3, #0]
 8048870:	4291      	cmp	r1, r2
 8048872:	d005      	beq.n	8048880 <tcp_input+0x2f0>
    for (pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
 8048874:	68e4      	ldr	r4, [r4, #12]
 8048876:	b1c4      	cbz	r4, 80488aa <tcp_input+0x31a>
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
 8048878:	7d23      	ldrb	r3, [r4, #20]
 804887a:	2b0a      	cmp	r3, #10
 804887c:	d0f4      	beq.n	8048868 <tcp_input+0x2d8>
 804887e:	e7ed      	b.n	804885c <tcp_input+0x2cc>
          pcb->local_port == tcphdr->dest &&
 8048880:	8ae2      	ldrh	r2, [r4, #22]
 8048882:	885b      	ldrh	r3, [r3, #2]
      if (pcb->remote_port == tcphdr->src &&
 8048884:	429a      	cmp	r2, r3
 8048886:	d1f5      	bne.n	8048874 <tcp_input+0x2e4>
          ip_addr_cmp(&pcb->remote_ip, ip_current_src_addr()) &&
 8048888:	6862      	ldr	r2, [r4, #4]
 804888a:	4b4e      	ldr	r3, [pc, #312]	; (80489c4 <tcp_input+0x434>)
 804888c:	691b      	ldr	r3, [r3, #16]
          pcb->local_port == tcphdr->dest &&
 804888e:	429a      	cmp	r2, r3
 8048890:	d1f0      	bne.n	8048874 <tcp_input+0x2e4>
          ip_addr_cmp(&pcb->local_ip, ip_current_dest_addr())) {
 8048892:	6822      	ldr	r2, [r4, #0]
 8048894:	4b4b      	ldr	r3, [pc, #300]	; (80489c4 <tcp_input+0x434>)
 8048896:	695b      	ldr	r3, [r3, #20]
          ip_addr_cmp(&pcb->remote_ip, ip_current_src_addr()) &&
 8048898:	429a      	cmp	r2, r3
 804889a:	d1eb      	bne.n	8048874 <tcp_input+0x2e4>
        tcp_timewait_input(pcb);
 804889c:	4620      	mov	r0, r4
 804889e:	f7fe fe1b 	bl	80474d8 <tcp_timewait_input>
        pbuf_free(p);
 80488a2:	4628      	mov	r0, r5
 80488a4:	f7fd fa1a 	bl	8045cdc <pbuf_free>
        return;
 80488a8:	e67e      	b.n	80485a8 <tcp_input+0x18>
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
 80488aa:	4b4d      	ldr	r3, [pc, #308]	; (80489e0 <tcp_input+0x450>)
 80488ac:	681e      	ldr	r6, [r3, #0]
 80488ae:	4630      	mov	r0, r6
    prev = NULL;
 80488b0:	4621      	mov	r1, r4
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
 80488b2:	e001      	b.n	80488b8 <tcp_input+0x328>
      prev = (struct tcp_pcb *)lpcb;
 80488b4:	4601      	mov	r1, r0
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
 80488b6:	68c0      	ldr	r0, [r0, #12]
 80488b8:	b168      	cbz	r0, 80488d6 <tcp_input+0x346>
      if (lpcb->local_port == tcphdr->dest) {
 80488ba:	8ac2      	ldrh	r2, [r0, #22]
 80488bc:	4b40      	ldr	r3, [pc, #256]	; (80489c0 <tcp_input+0x430>)
 80488be:	689b      	ldr	r3, [r3, #8]
 80488c0:	885b      	ldrh	r3, [r3, #2]
 80488c2:	429a      	cmp	r2, r3
 80488c4:	d1f6      	bne.n	80488b4 <tcp_input+0x324>
          if (ip_addr_cmp(&lpcb->local_ip, ip_current_dest_addr())) {
 80488c6:	6803      	ldr	r3, [r0, #0]
 80488c8:	4a3e      	ldr	r2, [pc, #248]	; (80489c4 <tcp_input+0x434>)
 80488ca:	6952      	ldr	r2, [r2, #20]
 80488cc:	4293      	cmp	r3, r2
 80488ce:	d002      	beq.n	80488d6 <tcp_input+0x346>
          } else if (ip_addr_isany(&lpcb->local_ip)) {
 80488d0:	b108      	cbz	r0, 80488d6 <tcp_input+0x346>
 80488d2:	2b00      	cmp	r3, #0
 80488d4:	d1ee      	bne.n	80488b4 <tcp_input+0x324>
    if (lpcb != NULL) {
 80488d6:	2800      	cmp	r0, #0
 80488d8:	f43f af6e 	beq.w	80487b8 <tcp_input+0x228>
      if (prev != NULL) {
 80488dc:	b121      	cbz	r1, 80488e8 <tcp_input+0x358>
        ((struct tcp_pcb_listen *)prev)->next = lpcb->next;
 80488de:	68c3      	ldr	r3, [r0, #12]
 80488e0:	60cb      	str	r3, [r1, #12]
        lpcb->next = tcp_listen_pcbs.listen_pcbs;
 80488e2:	60c6      	str	r6, [r0, #12]
        tcp_listen_pcbs.listen_pcbs = lpcb;
 80488e4:	4b3e      	ldr	r3, [pc, #248]	; (80489e0 <tcp_input+0x450>)
 80488e6:	6018      	str	r0, [r3, #0]
      tcp_listen_input(lpcb);
 80488e8:	f7fe fe34 	bl	8047554 <tcp_listen_input>
      pbuf_free(p);
 80488ec:	4628      	mov	r0, r5
 80488ee:	f7fd f9f5 	bl	8045cdc <pbuf_free>
      return;
 80488f2:	e659      	b.n	80485a8 <tcp_input+0x18>
        if (pcb->rcv_ann_wnd == 0) {
 80488f4:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 80488f6:	2b00      	cmp	r3, #0
 80488f8:	d19e      	bne.n	8048838 <tcp_input+0x2a8>
          tcp_send_empty_ack(pcb);
 80488fa:	4620      	mov	r0, r4
 80488fc:	f000 fdc2 	bl	8049484 <tcp_send_empty_ack>
        goto aborted;
 8048900:	e79a      	b.n	8048838 <tcp_input+0x2a8>
        if (recv_acked > 0) {
 8048902:	4b2f      	ldr	r3, [pc, #188]	; (80489c0 <tcp_input+0x430>)
 8048904:	8b9a      	ldrh	r2, [r3, #28]
 8048906:	b152      	cbz	r2, 804891e <tcp_input+0x38e>
            TCP_EVENT_SENT(pcb, (u16_t)acked16, err);
 8048908:	6fe3      	ldr	r3, [r4, #124]	; 0x7c
 804890a:	b12b      	cbz	r3, 8048918 <tcp_input+0x388>
 804890c:	4621      	mov	r1, r4
 804890e:	6920      	ldr	r0, [r4, #16]
 8048910:	4798      	blx	r3
            if (err == ERR_ABRT) {
 8048912:	f110 0f0d 	cmn.w	r0, #13
 8048916:	d08f      	beq.n	8048838 <tcp_input+0x2a8>
          recv_acked = 0;
 8048918:	4b29      	ldr	r3, [pc, #164]	; (80489c0 <tcp_input+0x430>)
 804891a:	2200      	movs	r2, #0
 804891c:	839a      	strh	r2, [r3, #28]
        if (tcp_input_delayed_close(pcb)) {
 804891e:	4620      	mov	r0, r4
 8048920:	f7fe fdb8 	bl	8047494 <tcp_input_delayed_close>
 8048924:	2800      	cmp	r0, #0
 8048926:	d187      	bne.n	8048838 <tcp_input+0x2a8>
        if (recv_data != NULL) {
 8048928:	4b25      	ldr	r3, [pc, #148]	; (80489c0 <tcp_input+0x430>)
 804892a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 804892c:	b1f3      	cbz	r3, 804896c <tcp_input+0x3dc>
          LWIP_ASSERT("pcb->refused_data == NULL", pcb->refused_data == NULL);
 804892e:	6f63      	ldr	r3, [r4, #116]	; 0x74
 8048930:	b133      	cbz	r3, 8048940 <tcp_input+0x3b0>
 8048932:	4b28      	ldr	r3, [pc, #160]	; (80489d4 <tcp_input+0x444>)
 8048934:	f44f 72d2 	mov.w	r2, #420	; 0x1a4
 8048938:	492a      	ldr	r1, [pc, #168]	; (80489e4 <tcp_input+0x454>)
 804893a:	4828      	ldr	r0, [pc, #160]	; (80489dc <tcp_input+0x44c>)
 804893c:	f009 f884 	bl	8051a48 <printf>
          if (pcb->flags & TF_RXCLOSED) {
 8048940:	7ea3      	ldrb	r3, [r4, #26]
 8048942:	f013 0f10 	tst.w	r3, #16
 8048946:	d12a      	bne.n	804899e <tcp_input+0x40e>
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
 8048948:	f8d4 5080 	ldr.w	r5, [r4, #128]	; 0x80
 804894c:	2d00      	cmp	r5, #0
 804894e:	d02e      	beq.n	80489ae <tcp_input+0x41e>
 8048950:	2300      	movs	r3, #0
 8048952:	4a1b      	ldr	r2, [pc, #108]	; (80489c0 <tcp_input+0x430>)
 8048954:	6b12      	ldr	r2, [r2, #48]	; 0x30
 8048956:	4621      	mov	r1, r4
 8048958:	6920      	ldr	r0, [r4, #16]
 804895a:	47a8      	blx	r5
          if (err == ERR_ABRT) {
 804895c:	f110 0f0d 	cmn.w	r0, #13
 8048960:	f43f af6a 	beq.w	8048838 <tcp_input+0x2a8>
          if (err != ERR_OK) {
 8048964:	b110      	cbz	r0, 804896c <tcp_input+0x3dc>
            pcb->refused_data = recv_data;
 8048966:	4b16      	ldr	r3, [pc, #88]	; (80489c0 <tcp_input+0x430>)
 8048968:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 804896a:	6763      	str	r3, [r4, #116]	; 0x74
        if (recv_flags & TF_GOT_FIN) {
 804896c:	4b14      	ldr	r3, [pc, #80]	; (80489c0 <tcp_input+0x430>)
 804896e:	7b9b      	ldrb	r3, [r3, #14]
 8048970:	f013 0f20 	tst.w	r3, #32
 8048974:	d006      	beq.n	8048984 <tcp_input+0x3f4>
          if (pcb->refused_data != NULL) {
 8048976:	6f63      	ldr	r3, [r4, #116]	; 0x74
 8048978:	2b00      	cmp	r3, #0
 804897a:	d035      	beq.n	80489e8 <tcp_input+0x458>
            pcb->refused_data->flags |= PBUF_FLAG_TCP_FIN;
 804897c:	7b5a      	ldrb	r2, [r3, #13]
 804897e:	f042 0220 	orr.w	r2, r2, #32
 8048982:	735a      	strb	r2, [r3, #13]
        tcp_input_pcb = NULL;
 8048984:	4b11      	ldr	r3, [pc, #68]	; (80489cc <tcp_input+0x43c>)
 8048986:	2200      	movs	r2, #0
 8048988:	601a      	str	r2, [r3, #0]
        if (tcp_input_delayed_close(pcb)) {
 804898a:	4620      	mov	r0, r4
 804898c:	f7fe fd82 	bl	8047494 <tcp_input_delayed_close>
 8048990:	2800      	cmp	r0, #0
 8048992:	f47f af51 	bne.w	8048838 <tcp_input+0x2a8>
        tcp_output(pcb);
 8048996:	4620      	mov	r0, r4
 8048998:	f000 fdae 	bl	80494f8 <tcp_output>
 804899c:	e74c      	b.n	8048838 <tcp_input+0x2a8>
            pbuf_free(recv_data);
 804899e:	4b08      	ldr	r3, [pc, #32]	; (80489c0 <tcp_input+0x430>)
 80489a0:	6b18      	ldr	r0, [r3, #48]	; 0x30
 80489a2:	f7fd f99b 	bl	8045cdc <pbuf_free>
            tcp_abort(pcb);
 80489a6:	4620      	mov	r0, r4
 80489a8:	f7fe fb54 	bl	8047054 <tcp_abort>
            goto aborted;
 80489ac:	e744      	b.n	8048838 <tcp_input+0x2a8>
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
 80489ae:	2300      	movs	r3, #0
 80489b0:	4a03      	ldr	r2, [pc, #12]	; (80489c0 <tcp_input+0x430>)
 80489b2:	6b12      	ldr	r2, [r2, #48]	; 0x30
 80489b4:	4621      	mov	r1, r4
 80489b6:	4618      	mov	r0, r3
 80489b8:	f7fe fa36 	bl	8046e28 <tcp_recv_null>
 80489bc:	e7ce      	b.n	804895c <tcp_input+0x3cc>
 80489be:	bf00      	nop
 80489c0:	200040d4 	.word	0x200040d4
 80489c4:	200051f0 	.word	0x200051f0
 80489c8:	20008720 	.word	0x20008720
 80489cc:	20008734 	.word	0x20008734
 80489d0:	20008730 	.word	0x20008730
 80489d4:	08059a5c 	.word	0x08059a5c
 80489d8:	08059d70 	.word	0x08059d70
 80489dc:	08058ecc 	.word	0x08058ecc
 80489e0:	20008728 	.word	0x20008728
 80489e4:	08059da0 	.word	0x08059da0
            if (pcb->rcv_wnd != TCP_WND_MAX(pcb)) {
 80489e8:	8d23      	ldrh	r3, [r4, #40]	; 0x28
 80489ea:	f5b3 6f06 	cmp.w	r3, #2144	; 0x860
 80489ee:	d001      	beq.n	80489f4 <tcp_input+0x464>
              pcb->rcv_wnd++;
 80489f0:	3301      	adds	r3, #1
 80489f2:	8523      	strh	r3, [r4, #40]	; 0x28
            TCP_EVENT_CLOSED(pcb, err);
 80489f4:	f8d4 5080 	ldr.w	r5, [r4, #128]	; 0x80
 80489f8:	2d00      	cmp	r5, #0
 80489fa:	d0c3      	beq.n	8048984 <tcp_input+0x3f4>
 80489fc:	2300      	movs	r3, #0
 80489fe:	461a      	mov	r2, r3
 8048a00:	4621      	mov	r1, r4
 8048a02:	6920      	ldr	r0, [r4, #16]
 8048a04:	47a8      	blx	r5
            if (err == ERR_ABRT) {
 8048a06:	f110 0f0d 	cmn.w	r0, #13
 8048a0a:	d1bb      	bne.n	8048984 <tcp_input+0x3f4>
 8048a0c:	e714      	b.n	8048838 <tcp_input+0x2a8>
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
 8048a0e:	4b0d      	ldr	r3, [pc, #52]	; (8048a44 <tcp_input+0x4b4>)
 8048a10:	689b      	ldr	r3, [r3, #8]
 8048a12:	8998      	ldrh	r0, [r3, #12]
 8048a14:	f7fc fd2c 	bl	8045470 <lwip_htons>
 8048a18:	f010 0f04 	tst.w	r0, #4
 8048a1c:	d003      	beq.n	8048a26 <tcp_input+0x496>
    pbuf_free(p);
 8048a1e:	4628      	mov	r0, r5
 8048a20:	f7fd f95c 	bl	8045cdc <pbuf_free>
 8048a24:	e5c0      	b.n	80485a8 <tcp_input+0x18>
        ip_current_src_addr(), tcphdr->dest, tcphdr->src);
 8048a26:	4807      	ldr	r0, [pc, #28]	; (8048a44 <tcp_input+0x4b4>)
 8048a28:	6882      	ldr	r2, [r0, #8]
      tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(),
 8048a2a:	4b07      	ldr	r3, [pc, #28]	; (8048a48 <tcp_input+0x4b8>)
 8048a2c:	8a84      	ldrh	r4, [r0, #20]
 8048a2e:	6901      	ldr	r1, [r0, #16]
 8048a30:	8816      	ldrh	r6, [r2, #0]
 8048a32:	9601      	str	r6, [sp, #4]
 8048a34:	8852      	ldrh	r2, [r2, #2]
 8048a36:	9200      	str	r2, [sp, #0]
 8048a38:	1d1a      	adds	r2, r3, #4
 8048a3a:	4421      	add	r1, r4
 8048a3c:	6980      	ldr	r0, [r0, #24]
 8048a3e:	f000 fea3 	bl	8049788 <tcp_rst>
 8048a42:	e7ec      	b.n	8048a1e <tcp_input+0x48e>
 8048a44:	200040d4 	.word	0x200040d4
 8048a48:	20005200 	.word	0x20005200

08048a4c <tcp_trigger_input_pcb_close>:

void
tcp_trigger_input_pcb_close(void)
{
  recv_flags |= TF_CLOSED;
 8048a4c:	4a02      	ldr	r2, [pc, #8]	; (8048a58 <tcp_trigger_input_pcb_close+0xc>)
 8048a4e:	7b93      	ldrb	r3, [r2, #14]
 8048a50:	f043 0310 	orr.w	r3, r3, #16
 8048a54:	7393      	strb	r3, [r2, #14]
}
 8048a56:	4770      	bx	lr
 8048a58:	200040d4 	.word	0x200040d4

08048a5c <tcp_write_checks>:
 * @param len length of data to send (checked agains snd_buf)
 * @return ERR_OK if tcp_write is allowed to proceed, another err_t otherwise
 */
static err_t
tcp_write_checks(struct tcp_pcb *pcb, u16_t len)
{
 8048a5c:	b508      	push	{r3, lr}
  /* connection is in invalid state for data transmission? */
  if ((pcb->state != ESTABLISHED) &&
 8048a5e:	7d03      	ldrb	r3, [r0, #20]
 8048a60:	2b04      	cmp	r3, #4
 8048a62:	d005      	beq.n	8048a70 <tcp_write_checks+0x14>
 8048a64:	2b07      	cmp	r3, #7
 8048a66:	d003      	beq.n	8048a70 <tcp_write_checks+0x14>
      (pcb->state != CLOSE_WAIT) &&
 8048a68:	2b02      	cmp	r3, #2
 8048a6a:	d001      	beq.n	8048a70 <tcp_write_checks+0x14>
      (pcb->state != SYN_SENT) &&
 8048a6c:	2b03      	cmp	r3, #3
 8048a6e:	d139      	bne.n	8048ae4 <tcp_write_checks+0x88>
      (pcb->state != SYN_RCVD)) {
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_STATE | LWIP_DBG_LEVEL_SEVERE, ("tcp_write() called in invalid state\n"));
    return ERR_CONN;
  } else if (len == 0) {
 8048a70:	2900      	cmp	r1, #0
 8048a72:	d03a      	beq.n	8048aea <tcp_write_checks+0x8e>
    return ERR_OK;
  }

  /* fail on too much data */
  if (len > pcb->snd_buf) {
 8048a74:	f8b0 3060 	ldrh.w	r3, [r0, #96]	; 0x60
 8048a78:	428b      	cmp	r3, r1
 8048a7a:	d308      	bcc.n	8048a8e <tcp_write_checks+0x32>
  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_write: queuelen: %"TCPWNDSIZE_F"\n", (tcpwnd_size_t)pcb->snd_queuelen));

  /* If total number of pbufs on the unsent/unacked queues exceeds the
   * configured maximum, return an error */
  /* check for configured max queuelen and possible overflow */
  if ((pcb->snd_queuelen >= TCP_SND_QUEUELEN) || (pcb->snd_queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
 8048a7c:	f8b0 3062 	ldrh.w	r3, [r0, #98]	; 0x62
 8048a80:	2b08      	cmp	r3, #8
 8048a82:	d80b      	bhi.n	8048a9c <tcp_write_checks+0x40>
      pcb->snd_queuelen, (u16_t)TCP_SND_QUEUELEN));
    TCP_STATS_INC(tcp.memerr);
    pcb->flags |= TF_NAGLEMEMERR;
    return ERR_MEM;
  }
  if (pcb->snd_queuelen != 0) {
 8048a84:	b1f3      	cbz	r3, 8048ac4 <tcp_write_checks+0x68>
    LWIP_ASSERT("tcp_write: pbufs on queue => at least one queue non-empty",
 8048a86:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
 8048a88:	b17b      	cbz	r3, 8048aaa <tcp_write_checks+0x4e>
      pcb->unacked != NULL || pcb->unsent != NULL);
  } else {
    LWIP_ASSERT("tcp_write: no pbufs on queue => both queues empty",
      pcb->unacked == NULL && pcb->unsent == NULL);
  }
  return ERR_OK;
 8048a8a:	2000      	movs	r0, #0
 8048a8c:	e02e      	b.n	8048aec <tcp_write_checks+0x90>
    pcb->flags |= TF_NAGLEMEMERR;
 8048a8e:	7e83      	ldrb	r3, [r0, #26]
 8048a90:	f063 037f 	orn	r3, r3, #127	; 0x7f
 8048a94:	7683      	strb	r3, [r0, #26]
    return ERR_MEM;
 8048a96:	f04f 30ff 	mov.w	r0, #4294967295
 8048a9a:	e027      	b.n	8048aec <tcp_write_checks+0x90>
    pcb->flags |= TF_NAGLEMEMERR;
 8048a9c:	7e83      	ldrb	r3, [r0, #26]
 8048a9e:	f063 037f 	orn	r3, r3, #127	; 0x7f
 8048aa2:	7683      	strb	r3, [r0, #26]
    return ERR_MEM;
 8048aa4:	f04f 30ff 	mov.w	r0, #4294967295
 8048aa8:	e020      	b.n	8048aec <tcp_write_checks+0x90>
    LWIP_ASSERT("tcp_write: pbufs on queue => at least one queue non-empty",
 8048aaa:	6e83      	ldr	r3, [r0, #104]	; 0x68
 8048aac:	b10b      	cbz	r3, 8048ab2 <tcp_write_checks+0x56>
  return ERR_OK;
 8048aae:	2000      	movs	r0, #0
 8048ab0:	e01c      	b.n	8048aec <tcp_write_checks+0x90>
    LWIP_ASSERT("tcp_write: pbufs on queue => at least one queue non-empty",
 8048ab2:	4b0f      	ldr	r3, [pc, #60]	; (8048af0 <tcp_write_checks+0x94>)
 8048ab4:	f240 1255 	movw	r2, #341	; 0x155
 8048ab8:	490e      	ldr	r1, [pc, #56]	; (8048af4 <tcp_write_checks+0x98>)
 8048aba:	480f      	ldr	r0, [pc, #60]	; (8048af8 <tcp_write_checks+0x9c>)
 8048abc:	f008 ffc4 	bl	8051a48 <printf>
  return ERR_OK;
 8048ac0:	2000      	movs	r0, #0
 8048ac2:	e013      	b.n	8048aec <tcp_write_checks+0x90>
    LWIP_ASSERT("tcp_write: no pbufs on queue => both queues empty",
 8048ac4:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
 8048ac6:	b143      	cbz	r3, 8048ada <tcp_write_checks+0x7e>
 8048ac8:	4b09      	ldr	r3, [pc, #36]	; (8048af0 <tcp_write_checks+0x94>)
 8048aca:	f44f 72ac 	mov.w	r2, #344	; 0x158
 8048ace:	490b      	ldr	r1, [pc, #44]	; (8048afc <tcp_write_checks+0xa0>)
 8048ad0:	4809      	ldr	r0, [pc, #36]	; (8048af8 <tcp_write_checks+0x9c>)
 8048ad2:	f008 ffb9 	bl	8051a48 <printf>
  return ERR_OK;
 8048ad6:	2000      	movs	r0, #0
 8048ad8:	e008      	b.n	8048aec <tcp_write_checks+0x90>
    LWIP_ASSERT("tcp_write: no pbufs on queue => both queues empty",
 8048ada:	6e83      	ldr	r3, [r0, #104]	; 0x68
 8048adc:	2b00      	cmp	r3, #0
 8048ade:	d1f3      	bne.n	8048ac8 <tcp_write_checks+0x6c>
  return ERR_OK;
 8048ae0:	2000      	movs	r0, #0
 8048ae2:	e003      	b.n	8048aec <tcp_write_checks+0x90>
    return ERR_CONN;
 8048ae4:	f06f 000a 	mvn.w	r0, #10
 8048ae8:	e000      	b.n	8048aec <tcp_write_checks+0x90>
    return ERR_OK;
 8048aea:	2000      	movs	r0, #0
}
 8048aec:	bd08      	pop	{r3, pc}
 8048aee:	bf00      	nop
 8048af0:	08059dbc 	.word	0x08059dbc
 8048af4:	08059df0 	.word	0x08059df0
 8048af8:	08058ecc 	.word	0x08058ecc
 8048afc:	08059e2c 	.word	0x08059e2c

08048b00 <tcp_pbuf_prealloc>:
{
 8048b00:	b570      	push	{r4, r5, r6, lr}
 8048b02:	460c      	mov	r4, r1
 8048b04:	461e      	mov	r6, r3
 8048b06:	f89d 3018 	ldrb.w	r3, [sp, #24]
  if (length < max_length) {
 8048b0a:	4291      	cmp	r1, r2
 8048b0c:	d215      	bcs.n	8048b3a <tcp_pbuf_prealloc+0x3a>
    if ((apiflags & TCP_WRITE_FLAG_MORE) ||
 8048b0e:	f89d 1014 	ldrb.w	r1, [sp, #20]
 8048b12:	f011 0f02 	tst.w	r1, #2
 8048b16:	d108      	bne.n	8048b2a <tcp_pbuf_prealloc+0x2a>
        (!(pcb->flags & TF_NODELAY) &&
 8048b18:	9904      	ldr	r1, [sp, #16]
 8048b1a:	7e89      	ldrb	r1, [r1, #26]
    if ((apiflags & TCP_WRITE_FLAG_MORE) ||
 8048b1c:	f011 0f40 	tst.w	r1, #64	; 0x40
 8048b20:	d126      	bne.n	8048b70 <tcp_pbuf_prealloc+0x70>
        (!(pcb->flags & TF_NODELAY) &&
 8048b22:	b113      	cbz	r3, 8048b2a <tcp_pbuf_prealloc+0x2a>
          pcb->unsent != NULL ||
 8048b24:	9b04      	ldr	r3, [sp, #16]
 8048b26:	6e9b      	ldr	r3, [r3, #104]	; 0x68
         (!first_seg ||
 8048b28:	b1e3      	cbz	r3, 8048b64 <tcp_pbuf_prealloc+0x64>
      alloc = LWIP_MIN(max_length, LWIP_MEM_ALIGN_SIZE(TCP_OVERSIZE_CALC_LENGTH(length)));
 8048b2a:	f204 211b 	addw	r1, r4, #539	; 0x21b
 8048b2e:	f021 0103 	bic.w	r1, r1, #3
 8048b32:	428a      	cmp	r2, r1
 8048b34:	bf28      	it	cs
 8048b36:	460a      	movcs	r2, r1
 8048b38:	b291      	uxth	r1, r2
  p = pbuf_alloc(layer, alloc, PBUF_RAM);
 8048b3a:	2200      	movs	r2, #0
 8048b3c:	f7fd f932 	bl	8045da4 <pbuf_alloc>
  if (p == NULL) {
 8048b40:	4605      	mov	r5, r0
 8048b42:	b168      	cbz	r0, 8048b60 <tcp_pbuf_prealloc+0x60>
  LWIP_ASSERT("need unchained pbuf", p->next == NULL);
 8048b44:	6803      	ldr	r3, [r0, #0]
 8048b46:	b133      	cbz	r3, 8048b56 <tcp_pbuf_prealloc+0x56>
 8048b48:	4b0a      	ldr	r3, [pc, #40]	; (8048b74 <tcp_pbuf_prealloc+0x74>)
 8048b4a:	f44f 7288 	mov.w	r2, #272	; 0x110
 8048b4e:	490a      	ldr	r1, [pc, #40]	; (8048b78 <tcp_pbuf_prealloc+0x78>)
 8048b50:	480a      	ldr	r0, [pc, #40]	; (8048b7c <tcp_pbuf_prealloc+0x7c>)
 8048b52:	f008 ff79 	bl	8051a48 <printf>
  *oversize = p->len - length;
 8048b56:	896b      	ldrh	r3, [r5, #10]
 8048b58:	1b1b      	subs	r3, r3, r4
 8048b5a:	8033      	strh	r3, [r6, #0]
  p->len = p->tot_len = length;
 8048b5c:	812c      	strh	r4, [r5, #8]
 8048b5e:	816c      	strh	r4, [r5, #10]
}
 8048b60:	4628      	mov	r0, r5
 8048b62:	bd70      	pop	{r4, r5, r6, pc}
          pcb->unacked != NULL))) {
 8048b64:	9b04      	ldr	r3, [sp, #16]
 8048b66:	6edb      	ldr	r3, [r3, #108]	; 0x6c
          pcb->unsent != NULL ||
 8048b68:	2b00      	cmp	r3, #0
 8048b6a:	d1de      	bne.n	8048b2a <tcp_pbuf_prealloc+0x2a>
  u16_t alloc = length;
 8048b6c:	4621      	mov	r1, r4
 8048b6e:	e7e4      	b.n	8048b3a <tcp_pbuf_prealloc+0x3a>
 8048b70:	4621      	mov	r1, r4
 8048b72:	e7e2      	b.n	8048b3a <tcp_pbuf_prealloc+0x3a>
 8048b74:	08059dbc 	.word	0x08059dbc
 8048b78:	08059e60 	.word	0x08059e60
 8048b7c:	08058ecc 	.word	0x08058ecc

08048b80 <tcp_create_segment>:
{
 8048b80:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8048b84:	4607      	mov	r7, r0
 8048b86:	460e      	mov	r6, r1
 8048b88:	4690      	mov	r8, r2
 8048b8a:	4699      	mov	r9, r3
 8048b8c:	f89d a020 	ldrb.w	sl, [sp, #32]
  if ((seg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG)) == NULL) {
 8048b90:	2003      	movs	r0, #3
 8048b92:	f7fc fed5 	bl	8045940 <memp_malloc>
 8048b96:	4604      	mov	r4, r0
 8048b98:	2800      	cmp	r0, #0
 8048b9a:	d036      	beq.n	8048c0a <tcp_create_segment+0x8a>
 8048b9c:	ea4f 058a 	mov.w	r5, sl, lsl #2
 8048ba0:	f005 0504 	and.w	r5, r5, #4
  seg->flags = optflags;
 8048ba4:	f880 a00a 	strb.w	sl, [r0, #10]
  seg->next = NULL;
 8048ba8:	2300      	movs	r3, #0
 8048baa:	6003      	str	r3, [r0, #0]
  seg->p = p;
 8048bac:	6046      	str	r6, [r0, #4]
  LWIP_ASSERT("p->tot_len >= optlen", p->tot_len >= optlen);
 8048bae:	8933      	ldrh	r3, [r6, #8]
 8048bb0:	fa1f fa85 	uxth.w	sl, r5
 8048bb4:	4553      	cmp	r3, sl
 8048bb6:	d32c      	bcc.n	8048c12 <tcp_create_segment+0x92>
  seg->len = p->tot_len - optlen;
 8048bb8:	8931      	ldrh	r1, [r6, #8]
 8048bba:	eba1 010a 	sub.w	r1, r1, sl
 8048bbe:	8121      	strh	r1, [r4, #8]
  if (pbuf_header(p, TCP_HLEN)) {
 8048bc0:	2114      	movs	r1, #20
 8048bc2:	4630      	mov	r0, r6
 8048bc4:	f7fd f880 	bl	8045cc8 <pbuf_header>
 8048bc8:	bb50      	cbnz	r0, 8048c20 <tcp_create_segment+0xa0>
  seg->tcphdr = (struct tcp_hdr *)seg->p->payload;
 8048bca:	6863      	ldr	r3, [r4, #4]
 8048bcc:	685e      	ldr	r6, [r3, #4]
 8048bce:	60e6      	str	r6, [r4, #12]
  seg->tcphdr->src = lwip_htons(pcb->local_port);
 8048bd0:	8af8      	ldrh	r0, [r7, #22]
 8048bd2:	f7fc fc4d 	bl	8045470 <lwip_htons>
 8048bd6:	8030      	strh	r0, [r6, #0]
  seg->tcphdr->dest = lwip_htons(pcb->remote_port);
 8048bd8:	68e6      	ldr	r6, [r4, #12]
 8048bda:	8b38      	ldrh	r0, [r7, #24]
 8048bdc:	f7fc fc48 	bl	8045470 <lwip_htons>
 8048be0:	8070      	strh	r0, [r6, #2]
  seg->tcphdr->seqno = lwip_htonl(seqno);
 8048be2:	68e6      	ldr	r6, [r4, #12]
 8048be4:	4648      	mov	r0, r9
 8048be6:	f7fc fc46 	bl	8045476 <lwip_htonl>
 8048bea:	6070      	str	r0, [r6, #4]
  TCPH_HDRLEN_FLAGS_SET(seg->tcphdr, (5 + optlen / 4), flags);
 8048bec:	08a8      	lsrs	r0, r5, #2
 8048bee:	3005      	adds	r0, #5
 8048bf0:	68e5      	ldr	r5, [r4, #12]
 8048bf2:	ea48 3000 	orr.w	r0, r8, r0, lsl #12
 8048bf6:	f7fc fc3b 	bl	8045470 <lwip_htons>
 8048bfa:	81a8      	strh	r0, [r5, #12]
  seg->tcphdr->urgp = 0;
 8048bfc:	68e3      	ldr	r3, [r4, #12]
 8048bfe:	2200      	movs	r2, #0
 8048c00:	749a      	strb	r2, [r3, #18]
 8048c02:	74da      	strb	r2, [r3, #19]
}
 8048c04:	4620      	mov	r0, r4
 8048c06:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    pbuf_free(p);
 8048c0a:	4630      	mov	r0, r6
 8048c0c:	f7fd f866 	bl	8045cdc <pbuf_free>
    return NULL;
 8048c10:	e7f8      	b.n	8048c04 <tcp_create_segment+0x84>
  LWIP_ASSERT("p->tot_len >= optlen", p->tot_len >= optlen);
 8048c12:	4b06      	ldr	r3, [pc, #24]	; (8048c2c <tcp_create_segment+0xac>)
 8048c14:	22ba      	movs	r2, #186	; 0xba
 8048c16:	4906      	ldr	r1, [pc, #24]	; (8048c30 <tcp_create_segment+0xb0>)
 8048c18:	4806      	ldr	r0, [pc, #24]	; (8048c34 <tcp_create_segment+0xb4>)
 8048c1a:	f008 ff15 	bl	8051a48 <printf>
 8048c1e:	e7cb      	b.n	8048bb8 <tcp_create_segment+0x38>
    tcp_seg_free(seg);
 8048c20:	4620      	mov	r0, r4
 8048c22:	f7fd fd3f 	bl	80466a4 <tcp_seg_free>
    return NULL;
 8048c26:	2400      	movs	r4, #0
 8048c28:	e7ec      	b.n	8048c04 <tcp_create_segment+0x84>
 8048c2a:	bf00      	nop
 8048c2c:	08059dbc 	.word	0x08059dbc
 8048c30:	08059e74 	.word	0x08059e74
 8048c34:	08058ecc 	.word	0x08058ecc

08048c38 <tcp_output_alloc_header>:
{
 8048c38:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8048c3c:	4605      	mov	r5, r0
 8048c3e:	460c      	mov	r4, r1
 8048c40:	4698      	mov	r8, r3
  struct pbuf *p = pbuf_alloc(PBUF_IP, TCP_HLEN + optlen + datalen, PBUF_RAM);
 8048c42:	4411      	add	r1, r2
 8048c44:	b289      	uxth	r1, r1
 8048c46:	3114      	adds	r1, #20
 8048c48:	2200      	movs	r2, #0
 8048c4a:	b289      	uxth	r1, r1
 8048c4c:	2001      	movs	r0, #1
 8048c4e:	f7fd f8a9 	bl	8045da4 <pbuf_alloc>
  if (p != NULL) {
 8048c52:	4607      	mov	r7, r0
 8048c54:	b348      	cbz	r0, 8048caa <tcp_output_alloc_header+0x72>
    LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
 8048c56:	f104 0313 	add.w	r3, r4, #19
 8048c5a:	8942      	ldrh	r2, [r0, #10]
 8048c5c:	4293      	cmp	r3, r2
 8048c5e:	da27      	bge.n	8048cb0 <tcp_output_alloc_header+0x78>
    tcphdr = (struct tcp_hdr *)p->payload;
 8048c60:	687e      	ldr	r6, [r7, #4]
    tcphdr->src = lwip_htons(pcb->local_port);
 8048c62:	8ae8      	ldrh	r0, [r5, #22]
 8048c64:	f7fc fc04 	bl	8045470 <lwip_htons>
 8048c68:	8030      	strh	r0, [r6, #0]
    tcphdr->dest = lwip_htons(pcb->remote_port);
 8048c6a:	8b28      	ldrh	r0, [r5, #24]
 8048c6c:	f7fc fc00 	bl	8045470 <lwip_htons>
 8048c70:	8070      	strh	r0, [r6, #2]
    tcphdr->seqno = seqno_be;
 8048c72:	f8c6 8004 	str.w	r8, [r6, #4]
    tcphdr->ackno = lwip_htonl(pcb->rcv_nxt);
 8048c76:	6a68      	ldr	r0, [r5, #36]	; 0x24
 8048c78:	f7fc fbfd 	bl	8045476 <lwip_htonl>
 8048c7c:	60b0      	str	r0, [r6, #8]
    TCPH_HDRLEN_FLAGS_SET(tcphdr, (5 + optlen / 4), TCP_ACK);
 8048c7e:	08a4      	lsrs	r4, r4, #2
 8048c80:	3405      	adds	r4, #5
 8048c82:	0324      	lsls	r4, r4, #12
 8048c84:	b2a4      	uxth	r4, r4
 8048c86:	f044 0010 	orr.w	r0, r4, #16
 8048c8a:	f7fc fbf1 	bl	8045470 <lwip_htons>
 8048c8e:	81b0      	strh	r0, [r6, #12]
    tcphdr->wnd = lwip_htons(TCPWND_MIN16(RCV_WND_SCALE(pcb, pcb->rcv_ann_wnd)));
 8048c90:	8d68      	ldrh	r0, [r5, #42]	; 0x2a
 8048c92:	f7fc fbed 	bl	8045470 <lwip_htons>
 8048c96:	81f0      	strh	r0, [r6, #14]
    tcphdr->chksum = 0;
 8048c98:	2300      	movs	r3, #0
 8048c9a:	7433      	strb	r3, [r6, #16]
 8048c9c:	7473      	strb	r3, [r6, #17]
    tcphdr->urgp = 0;
 8048c9e:	74b3      	strb	r3, [r6, #18]
 8048ca0:	74f3      	strb	r3, [r6, #19]
    pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
 8048ca2:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 8048ca4:	8d6a      	ldrh	r2, [r5, #42]	; 0x2a
 8048ca6:	4413      	add	r3, r2
 8048ca8:	62eb      	str	r3, [r5, #44]	; 0x2c
}
 8048caa:	4638      	mov	r0, r7
 8048cac:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
 8048cb0:	4b03      	ldr	r3, [pc, #12]	; (8048cc0 <tcp_output_alloc_header+0x88>)
 8048cb2:	2272      	movs	r2, #114	; 0x72
 8048cb4:	4903      	ldr	r1, [pc, #12]	; (8048cc4 <tcp_output_alloc_header+0x8c>)
 8048cb6:	4804      	ldr	r0, [pc, #16]	; (8048cc8 <tcp_output_alloc_header+0x90>)
 8048cb8:	f008 fec6 	bl	8051a48 <printf>
 8048cbc:	e7d0      	b.n	8048c60 <tcp_output_alloc_header+0x28>
 8048cbe:	bf00      	nop
 8048cc0:	08059dbc 	.word	0x08059dbc
 8048cc4:	08059e8c 	.word	0x08059e8c
 8048cc8:	08058ecc 	.word	0x08058ecc

08048ccc <tcp_output_segment>:
{
  err_t err;
  u16_t len;
  u32_t *opts;

  if (seg->p->ref != 1) {
 8048ccc:	6843      	ldr	r3, [r0, #4]
 8048cce:	89db      	ldrh	r3, [r3, #14]
 8048cd0:	2b01      	cmp	r3, #1
 8048cd2:	d001      	beq.n	8048cd8 <tcp_output_segment+0xc>
    /* This can happen if the pbuf of this segment is still referenced by the
       netif driver due to deferred transmission. Since this function modifies
       p->len, we must not continue in this case. */
    return ERR_OK;
 8048cd4:	2000      	movs	r0, #0
  NETIF_SET_HWADDRHINT(netif, &(pcb->addr_hint));
  err = ip_output_if(seg->p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl,
    pcb->tos, IP_PROTO_TCP, netif);
  NETIF_SET_HWADDRHINT(netif, NULL);
  return err;
}
 8048cd6:	4770      	bx	lr
{
 8048cd8:	b5f0      	push	{r4, r5, r6, r7, lr}
 8048cda:	b085      	sub	sp, #20
 8048cdc:	4604      	mov	r4, r0
 8048cde:	460d      	mov	r5, r1
 8048ce0:	4616      	mov	r6, r2
  seg->tcphdr->ackno = lwip_htonl(pcb->rcv_nxt);
 8048ce2:	68c7      	ldr	r7, [r0, #12]
 8048ce4:	6a48      	ldr	r0, [r1, #36]	; 0x24
 8048ce6:	f7fc fbc6 	bl	8045476 <lwip_htonl>
 8048cea:	60b8      	str	r0, [r7, #8]
    seg->tcphdr->wnd = lwip_htons(TCPWND_MIN16(RCV_WND_SCALE(pcb, pcb->rcv_ann_wnd)));
 8048cec:	68e7      	ldr	r7, [r4, #12]
 8048cee:	8d68      	ldrh	r0, [r5, #42]	; 0x2a
 8048cf0:	f7fc fbbe 	bl	8045470 <lwip_htons>
 8048cf4:	81f8      	strh	r0, [r7, #14]
  pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
 8048cf6:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 8048cf8:	8d6a      	ldrh	r2, [r5, #42]	; 0x2a
 8048cfa:	4413      	add	r3, r2
 8048cfc:	62eb      	str	r3, [r5, #44]	; 0x2c
  opts = (u32_t *)(void *)(seg->tcphdr + 1);
 8048cfe:	68e7      	ldr	r7, [r4, #12]
  if (seg->flags & TF_SEG_OPTS_MSS) {
 8048d00:	7aa3      	ldrb	r3, [r4, #10]
 8048d02:	f013 0f01 	tst.w	r3, #1
 8048d06:	d125      	bne.n	8048d54 <tcp_output_segment+0x88>
  if (pcb->rtime < 0) {
 8048d08:	f9b5 3030 	ldrsh.w	r3, [r5, #48]	; 0x30
 8048d0c:	2b00      	cmp	r3, #0
 8048d0e:	db2c      	blt.n	8048d6a <tcp_output_segment+0x9e>
  if (pcb->rttest == 0) {
 8048d10:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 8048d12:	2b00      	cmp	r3, #0
 8048d14:	d02c      	beq.n	8048d70 <tcp_output_segment+0xa4>
  len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);
 8048d16:	68e3      	ldr	r3, [r4, #12]
 8048d18:	6862      	ldr	r2, [r4, #4]
 8048d1a:	6851      	ldr	r1, [r2, #4]
 8048d1c:	1a5b      	subs	r3, r3, r1
 8048d1e:	b29b      	uxth	r3, r3
  seg->p->len -= len;
 8048d20:	8951      	ldrh	r1, [r2, #10]
 8048d22:	1ac9      	subs	r1, r1, r3
 8048d24:	8151      	strh	r1, [r2, #10]
  seg->p->tot_len -= len;
 8048d26:	6861      	ldr	r1, [r4, #4]
 8048d28:	890a      	ldrh	r2, [r1, #8]
 8048d2a:	1ad3      	subs	r3, r2, r3
 8048d2c:	810b      	strh	r3, [r1, #8]
  seg->p->payload = seg->tcphdr;
 8048d2e:	6862      	ldr	r2, [r4, #4]
 8048d30:	68e3      	ldr	r3, [r4, #12]
 8048d32:	6053      	str	r3, [r2, #4]
  seg->tcphdr->chksum = 0;
 8048d34:	2200      	movs	r2, #0
 8048d36:	741a      	strb	r2, [r3, #16]
 8048d38:	745a      	strb	r2, [r3, #17]
  err = ip_output_if(seg->p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl,
 8048d3a:	9602      	str	r6, [sp, #8]
 8048d3c:	2306      	movs	r3, #6
 8048d3e:	9301      	str	r3, [sp, #4]
 8048d40:	7a6b      	ldrb	r3, [r5, #9]
 8048d42:	9300      	str	r3, [sp, #0]
 8048d44:	7aab      	ldrb	r3, [r5, #10]
 8048d46:	1d2a      	adds	r2, r5, #4
 8048d48:	4629      	mov	r1, r5
 8048d4a:	6860      	ldr	r0, [r4, #4]
 8048d4c:	f001 ff58 	bl	804ac00 <ip4_output_if>
}
 8048d50:	b005      	add	sp, #20
 8048d52:	bdf0      	pop	{r4, r5, r6, r7, pc}
    mss = tcp_eff_send_mss(TCP_MSS, &pcb->local_ip, &pcb->remote_ip);
 8048d54:	1d29      	adds	r1, r5, #4
 8048d56:	f44f 7006 	mov.w	r0, #536	; 0x218
 8048d5a:	f7fe fa73 	bl	8047244 <tcp_eff_send_mss_impl>
    *opts = TCP_BUILD_MSS_OPTION(mss);
 8048d5e:	f040 7001 	orr.w	r0, r0, #33816576	; 0x2040000
 8048d62:	f7fc fb88 	bl	8045476 <lwip_htonl>
 8048d66:	6178      	str	r0, [r7, #20]
    opts += 1;
 8048d68:	e7ce      	b.n	8048d08 <tcp_output_segment+0x3c>
    pcb->rtime = 0;
 8048d6a:	2300      	movs	r3, #0
 8048d6c:	862b      	strh	r3, [r5, #48]	; 0x30
 8048d6e:	e7cf      	b.n	8048d10 <tcp_output_segment+0x44>
    pcb->rttest = tcp_ticks;
 8048d70:	4b04      	ldr	r3, [pc, #16]	; (8048d84 <tcp_output_segment+0xb8>)
 8048d72:	681b      	ldr	r3, [r3, #0]
 8048d74:	636b      	str	r3, [r5, #52]	; 0x34
    pcb->rtseq = lwip_ntohl(seg->tcphdr->seqno);
 8048d76:	68e3      	ldr	r3, [r4, #12]
 8048d78:	6858      	ldr	r0, [r3, #4]
 8048d7a:	f7fc fb7c 	bl	8045476 <lwip_htonl>
 8048d7e:	63a8      	str	r0, [r5, #56]	; 0x38
 8048d80:	e7c9      	b.n	8048d16 <tcp_output_segment+0x4a>
 8048d82:	bf00      	nop
 8048d84:	20008724 	.word	0x20008724

08048d88 <tcp_write>:
{
 8048d88:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8048d8c:	b091      	sub	sp, #68	; 0x44
 8048d8e:	4680      	mov	r8, r0
 8048d90:	9108      	str	r1, [sp, #32]
 8048d92:	4692      	mov	sl, r2
 8048d94:	9307      	str	r3, [sp, #28]
  u16_t oversize = 0;
 8048d96:	2300      	movs	r3, #0
 8048d98:	f8ad 303e 	strh.w	r3, [sp, #62]	; 0x3e
  u16_t mss_local = LWIP_MIN(pcb->mss, TCPWND_MIN16(pcb->snd_wnd_max/2));
 8048d9c:	f8b0 305e 	ldrh.w	r3, [r0, #94]	; 0x5e
 8048da0:	085b      	lsrs	r3, r3, #1
 8048da2:	f8b0 b032 	ldrh.w	fp, [r0, #50]	; 0x32
 8048da6:	455b      	cmp	r3, fp
 8048da8:	bf28      	it	cs
 8048daa:	465b      	movcs	r3, fp
  mss_local = mss_local ? mss_local : pcb->mss;
 8048dac:	b103      	cbz	r3, 8048db0 <tcp_write+0x28>
 8048dae:	469b      	mov	fp, r3
  LWIP_ERROR("tcp_write: arg == NULL (programmer violates API)",
 8048db0:	9b08      	ldr	r3, [sp, #32]
 8048db2:	2b00      	cmp	r3, #0
 8048db4:	f000 808a 	beq.w	8048ecc <tcp_write+0x144>
  err = tcp_write_checks(pcb, len);
 8048db8:	4651      	mov	r1, sl
 8048dba:	4640      	mov	r0, r8
 8048dbc:	f7ff fe4e 	bl	8048a5c <tcp_write_checks>
  if (err != ERR_OK) {
 8048dc0:	900a      	str	r0, [sp, #40]	; 0x28
 8048dc2:	2800      	cmp	r0, #0
 8048dc4:	f040 818d 	bne.w	80490e2 <tcp_write+0x35a>
  queuelen = pcb->snd_queuelen;
 8048dc8:	f8b8 6062 	ldrh.w	r6, [r8, #98]	; 0x62
  if (pcb->unsent != NULL) {
 8048dcc:	f8d8 9068 	ldr.w	r9, [r8, #104]	; 0x68
 8048dd0:	f1b9 0f00 	cmp.w	r9, #0
 8048dd4:	f000 80cc 	beq.w	8048f70 <tcp_write+0x1e8>
 8048dd8:	464b      	mov	r3, r9
    for (last_unsent = pcb->unsent; last_unsent->next != NULL;
 8048dda:	9309      	str	r3, [sp, #36]	; 0x24
 8048ddc:	681b      	ldr	r3, [r3, #0]
 8048dde:	2b00      	cmp	r3, #0
 8048de0:	d1fb      	bne.n	8048dda <tcp_write+0x52>
 8048de2:	4699      	mov	r9, r3
    unsent_optlen = LWIP_TCP_OPT_LENGTH(last_unsent->flags);
 8048de4:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8048de6:	7a9c      	ldrb	r4, [r3, #10]
 8048de8:	00a4      	lsls	r4, r4, #2
 8048dea:	f004 0404 	and.w	r4, r4, #4
    LWIP_ASSERT("mss_local is too small", mss_local >= last_unsent->len + unsent_optlen);
 8048dee:	891b      	ldrh	r3, [r3, #8]
 8048df0:	4423      	add	r3, r4
 8048df2:	459b      	cmp	fp, r3
 8048df4:	db75      	blt.n	8048ee2 <tcp_write+0x15a>
    space = mss_local - (last_unsent->len + unsent_optlen);
 8048df6:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8048df8:	891b      	ldrh	r3, [r3, #8]
 8048dfa:	441c      	add	r4, r3
 8048dfc:	b2a4      	uxth	r4, r4
 8048dfe:	ebab 0404 	sub.w	r4, fp, r4
 8048e02:	b2a1      	uxth	r1, r4
 8048e04:	910c      	str	r1, [sp, #48]	; 0x30
    oversize = pcb->unsent_oversize;
 8048e06:	f8b8 3064 	ldrh.w	r3, [r8, #100]	; 0x64
 8048e0a:	930b      	str	r3, [sp, #44]	; 0x2c
 8048e0c:	f8ad 303e 	strh.w	r3, [sp, #62]	; 0x3e
    if (oversize > 0) {
 8048e10:	2b00      	cmp	r3, #0
 8048e12:	d076      	beq.n	8048f02 <tcp_write+0x17a>
      LWIP_ASSERT("inconsistent oversize vs. space", oversize <= space);
 8048e14:	428b      	cmp	r3, r1
 8048e16:	d86c      	bhi.n	8048ef2 <tcp_write+0x16a>
      oversize_used = LWIP_MIN(space, LWIP_MIN(oversize, len));
 8048e18:	f8bd 303e 	ldrh.w	r3, [sp, #62]	; 0x3e
 8048e1c:	461a      	mov	r2, r3
 8048e1e:	4553      	cmp	r3, sl
 8048e20:	bf28      	it	cs
 8048e22:	4652      	movcs	r2, sl
 8048e24:	990c      	ldr	r1, [sp, #48]	; 0x30
 8048e26:	428a      	cmp	r2, r1
 8048e28:	bf28      	it	cs
 8048e2a:	460a      	movcs	r2, r1
 8048e2c:	b292      	uxth	r2, r2
 8048e2e:	920b      	str	r2, [sp, #44]	; 0x2c
      oversize -= oversize_used;
 8048e30:	1a9b      	subs	r3, r3, r2
 8048e32:	f8ad 303e 	strh.w	r3, [sp, #62]	; 0x3e
      space -= oversize_used;
 8048e36:	1a8b      	subs	r3, r1, r2
 8048e38:	b29b      	uxth	r3, r3
 8048e3a:	930c      	str	r3, [sp, #48]	; 0x30
      seg = last_unsent;
 8048e3c:	9f09      	ldr	r7, [sp, #36]	; 0x24
    LWIP_ASSERT("inconsistent oversize vs. len", (oversize == 0) || (pos == len));
 8048e3e:	f8bd 303e 	ldrh.w	r3, [sp, #62]	; 0x3e
 8048e42:	b113      	cbz	r3, 8048e4a <tcp_write+0xc2>
 8048e44:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8048e46:	4553      	cmp	r3, sl
 8048e48:	d15d      	bne.n	8048f06 <tcp_write+0x17e>
    if ((pos < len) && (space > 0) && (last_unsent->len > 0)) {
 8048e4a:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8048e4c:	4552      	cmp	r2, sl
 8048e4e:	f080 8156 	bcs.w	80490fe <tcp_write+0x376>
 8048e52:	990c      	ldr	r1, [sp, #48]	; 0x30
 8048e54:	2900      	cmp	r1, #0
 8048e56:	f000 815b 	beq.w	8049110 <tcp_write+0x388>
 8048e5a:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8048e5c:	891b      	ldrh	r3, [r3, #8]
 8048e5e:	2b00      	cmp	r3, #0
 8048e60:	f000 8158 	beq.w	8049114 <tcp_write+0x38c>
      u16_t seglen = LWIP_MIN(space, len - pos);
 8048e64:	ebaa 0402 	sub.w	r4, sl, r2
 8048e68:	428c      	cmp	r4, r1
 8048e6a:	bfa8      	it	ge
 8048e6c:	460c      	movge	r4, r1
 8048e6e:	b2a5      	uxth	r5, r4
      if (apiflags & TCP_WRITE_FLAG_COPY) {
 8048e70:	9b07      	ldr	r3, [sp, #28]
 8048e72:	f013 0f01 	tst.w	r3, #1
 8048e76:	d14e      	bne.n	8048f16 <tcp_write+0x18e>
        for (p = last_unsent->p; p->next != NULL; p = p->next);
 8048e78:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8048e7a:	f8d3 9004 	ldr.w	r9, [r3, #4]
 8048e7e:	464a      	mov	r2, r9
 8048e80:	4613      	mov	r3, r2
 8048e82:	6812      	ldr	r2, [r2, #0]
 8048e84:	2a00      	cmp	r2, #0
 8048e86:	d1fb      	bne.n	8048e80 <tcp_write+0xf8>
 8048e88:	4691      	mov	r9, r2
        if (p->type == PBUF_ROM && (const u8_t *)p->payload + p->len == (const u8_t *)arg) {
 8048e8a:	7b1a      	ldrb	r2, [r3, #12]
 8048e8c:	2a01      	cmp	r2, #1
 8048e8e:	d105      	bne.n	8048e9c <tcp_write+0x114>
 8048e90:	685a      	ldr	r2, [r3, #4]
 8048e92:	895b      	ldrh	r3, [r3, #10]
 8048e94:	4413      	add	r3, r2
 8048e96:	9a08      	ldr	r2, [sp, #32]
 8048e98:	4293      	cmp	r3, r2
 8048e9a:	d05c      	beq.n	8048f56 <tcp_write+0x1ce>
          if ((concat_p = pbuf_alloc(PBUF_RAW, seglen, PBUF_ROM)) == NULL) {
 8048e9c:	2201      	movs	r2, #1
 8048e9e:	4629      	mov	r1, r5
 8048ea0:	2004      	movs	r0, #4
 8048ea2:	f7fc ff7f 	bl	8045da4 <pbuf_alloc>
 8048ea6:	4681      	mov	r9, r0
 8048ea8:	2800      	cmp	r0, #0
 8048eaa:	f000 81ef 	beq.w	804928c <tcp_write+0x504>
          ((struct pbuf_rom*)concat_p)->payload = (const u8_t*)arg + pos;
 8048eae:	9b08      	ldr	r3, [sp, #32]
 8048eb0:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8048eb2:	4413      	add	r3, r2
 8048eb4:	6043      	str	r3, [r0, #4]
          queuelen += pbuf_clen(concat_p);
 8048eb6:	f7fd f8dd 	bl	8046074 <pbuf_clen>
 8048eba:	4406      	add	r6, r0
 8048ebc:	b2b6      	uxth	r6, r6
  u16_t extendlen = 0;
 8048ebe:	2300      	movs	r3, #0
 8048ec0:	930c      	str	r3, [sp, #48]	; 0x30
      pos += seglen;
 8048ec2:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8048ec4:	195c      	adds	r4, r3, r5
 8048ec6:	b2a4      	uxth	r4, r4
      seg = last_unsent;
 8048ec8:	9f09      	ldr	r7, [sp, #36]	; 0x24
 8048eca:	e11b      	b.n	8049104 <tcp_write+0x37c>
  LWIP_ERROR("tcp_write: arg == NULL (programmer violates API)",
 8048ecc:	4ba1      	ldr	r3, [pc, #644]	; (8049154 <tcp_write+0x3cc>)
 8048ece:	f240 1291 	movw	r2, #401	; 0x191
 8048ed2:	49a1      	ldr	r1, [pc, #644]	; (8049158 <tcp_write+0x3d0>)
 8048ed4:	48a1      	ldr	r0, [pc, #644]	; (804915c <tcp_write+0x3d4>)
 8048ed6:	f008 fdb7 	bl	8051a48 <printf>
 8048eda:	f06f 030f 	mvn.w	r3, #15
 8048ede:	930a      	str	r3, [sp, #40]	; 0x28
 8048ee0:	e0ff      	b.n	80490e2 <tcp_write+0x35a>
    LWIP_ASSERT("mss_local is too small", mss_local >= last_unsent->len + unsent_optlen);
 8048ee2:	4b9c      	ldr	r3, [pc, #624]	; (8049154 <tcp_write+0x3cc>)
 8048ee4:	f240 12c7 	movw	r2, #455	; 0x1c7
 8048ee8:	499d      	ldr	r1, [pc, #628]	; (8049160 <tcp_write+0x3d8>)
 8048eea:	489c      	ldr	r0, [pc, #624]	; (804915c <tcp_write+0x3d4>)
 8048eec:	f008 fdac 	bl	8051a48 <printf>
 8048ef0:	e781      	b.n	8048df6 <tcp_write+0x6e>
      LWIP_ASSERT("inconsistent oversize vs. space", oversize <= space);
 8048ef2:	4b98      	ldr	r3, [pc, #608]	; (8049154 <tcp_write+0x3cc>)
 8048ef4:	f240 12d9 	movw	r2, #473	; 0x1d9
 8048ef8:	499a      	ldr	r1, [pc, #616]	; (8049164 <tcp_write+0x3dc>)
 8048efa:	4898      	ldr	r0, [pc, #608]	; (804915c <tcp_write+0x3d4>)
 8048efc:	f008 fda4 	bl	8051a48 <printf>
 8048f00:	e78a      	b.n	8048e18 <tcp_write+0x90>
  struct tcp_seg *last_unsent = NULL, *seg = NULL, *prev_seg = NULL, *queue = NULL;
 8048f02:	464f      	mov	r7, r9
 8048f04:	e79b      	b.n	8048e3e <tcp_write+0xb6>
    LWIP_ASSERT("inconsistent oversize vs. len", (oversize == 0) || (pos == len));
 8048f06:	4b93      	ldr	r3, [pc, #588]	; (8049154 <tcp_write+0x3cc>)
 8048f08:	f240 12e1 	movw	r2, #481	; 0x1e1
 8048f0c:	4996      	ldr	r1, [pc, #600]	; (8049168 <tcp_write+0x3e0>)
 8048f0e:	4893      	ldr	r0, [pc, #588]	; (804915c <tcp_write+0x3d4>)
 8048f10:	f008 fd9a 	bl	8051a48 <printf>
 8048f14:	e799      	b.n	8048e4a <tcp_write+0xc2>
        if ((concat_p = tcp_pbuf_prealloc(PBUF_RAW, seglen, space, &oversize, pcb, apiflags, 1)) == NULL) {
 8048f16:	2301      	movs	r3, #1
 8048f18:	9302      	str	r3, [sp, #8]
 8048f1a:	9b07      	ldr	r3, [sp, #28]
 8048f1c:	9301      	str	r3, [sp, #4]
 8048f1e:	f8cd 8000 	str.w	r8, [sp]
 8048f22:	f10d 033e 	add.w	r3, sp, #62	; 0x3e
 8048f26:	460a      	mov	r2, r1
 8048f28:	4629      	mov	r1, r5
 8048f2a:	2004      	movs	r0, #4
 8048f2c:	f7ff fde8 	bl	8048b00 <tcp_pbuf_prealloc>
 8048f30:	4681      	mov	r9, r0
 8048f32:	2800      	cmp	r0, #0
 8048f34:	f000 81a8 	beq.w	8049288 <tcp_write+0x500>
        TCP_DATA_COPY2(concat_p->payload, (const u8_t*)arg + pos, seglen, &concat_chksum, &concat_chksum_swapped);
 8048f38:	462a      	mov	r2, r5
 8048f3a:	9b08      	ldr	r3, [sp, #32]
 8048f3c:	990b      	ldr	r1, [sp, #44]	; 0x2c
 8048f3e:	1859      	adds	r1, r3, r1
 8048f40:	6840      	ldr	r0, [r0, #4]
 8048f42:	f008 fd5f 	bl	8051a04 <memcpy>
        queuelen += pbuf_clen(concat_p);
 8048f46:	4648      	mov	r0, r9
 8048f48:	f7fd f894 	bl	8046074 <pbuf_clen>
 8048f4c:	4406      	add	r6, r0
 8048f4e:	b2b6      	uxth	r6, r6
  u16_t extendlen = 0;
 8048f50:	2300      	movs	r3, #0
 8048f52:	930c      	str	r3, [sp, #48]	; 0x30
 8048f54:	e7b5      	b.n	8048ec2 <tcp_write+0x13a>
          LWIP_ASSERT("tcp_write: ROM pbufs cannot be oversized", pos == 0);
 8048f56:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8048f58:	b90b      	cbnz	r3, 8048f5e <tcp_write+0x1d6>
          extendlen = seglen;
 8048f5a:	950c      	str	r5, [sp, #48]	; 0x30
 8048f5c:	e7b1      	b.n	8048ec2 <tcp_write+0x13a>
          LWIP_ASSERT("tcp_write: ROM pbufs cannot be oversized", pos == 0);
 8048f5e:	4b7d      	ldr	r3, [pc, #500]	; (8049154 <tcp_write+0x3cc>)
 8048f60:	f44f 7203 	mov.w	r2, #524	; 0x20c
 8048f64:	4981      	ldr	r1, [pc, #516]	; (804916c <tcp_write+0x3e4>)
 8048f66:	487d      	ldr	r0, [pc, #500]	; (804915c <tcp_write+0x3d4>)
 8048f68:	f008 fd6e 	bl	8051a48 <printf>
          extendlen = seglen;
 8048f6c:	950c      	str	r5, [sp, #48]	; 0x30
 8048f6e:	e7a8      	b.n	8048ec2 <tcp_write+0x13a>
    LWIP_ASSERT("unsent_oversize mismatch (pcb->unsent is NULL)",
 8048f70:	f8b8 4064 	ldrh.w	r4, [r8, #100]	; 0x64
 8048f74:	b92c      	cbnz	r4, 8048f82 <tcp_write+0x1fa>
  u16_t extendlen = 0;
 8048f76:	940c      	str	r4, [sp, #48]	; 0x30
  u16_t oversize_used = 0;
 8048f78:	940b      	str	r4, [sp, #44]	; 0x2c
  struct tcp_seg *last_unsent = NULL, *seg = NULL, *prev_seg = NULL, *queue = NULL;
 8048f7a:	464f      	mov	r7, r9
 8048f7c:	f8cd 9024 	str.w	r9, [sp, #36]	; 0x24
 8048f80:	e0c0      	b.n	8049104 <tcp_write+0x37c>
    LWIP_ASSERT("unsent_oversize mismatch (pcb->unsent is NULL)",
 8048f82:	4b74      	ldr	r3, [pc, #464]	; (8049154 <tcp_write+0x3cc>)
 8048f84:	f44f 7209 	mov.w	r2, #548	; 0x224
 8048f88:	4979      	ldr	r1, [pc, #484]	; (8049170 <tcp_write+0x3e8>)
 8048f8a:	4874      	ldr	r0, [pc, #464]	; (804915c <tcp_write+0x3d4>)
 8048f8c:	f008 fd5c 	bl	8051a48 <printf>
  struct tcp_seg *last_unsent = NULL, *seg = NULL, *prev_seg = NULL, *queue = NULL;
 8048f90:	464f      	mov	r7, r9
 8048f92:	f8cd 9024 	str.w	r9, [sp, #36]	; 0x24
  u16_t extendlen = 0;
 8048f96:	2400      	movs	r4, #0
 8048f98:	940c      	str	r4, [sp, #48]	; 0x30
  u16_t oversize_used = 0;
 8048f9a:	940b      	str	r4, [sp, #44]	; 0x2c
 8048f9c:	e0b2      	b.n	8049104 <tcp_write+0x37c>
      if ((p = tcp_pbuf_prealloc(PBUF_TRANSPORT, seglen + optlen, mss_local, &oversize, pcb, apiflags, queue == NULL)) == NULL) {
 8048f9e:	9b06      	ldr	r3, [sp, #24]
 8048fa0:	fab3 f383 	clz	r3, r3
 8048fa4:	095b      	lsrs	r3, r3, #5
 8048fa6:	9302      	str	r3, [sp, #8]
 8048fa8:	9b07      	ldr	r3, [sp, #28]
 8048faa:	9301      	str	r3, [sp, #4]
 8048fac:	f8cd 8000 	str.w	r8, [sp]
 8048fb0:	f10d 033e 	add.w	r3, sp, #62	; 0x3e
 8048fb4:	465a      	mov	r2, fp
 8048fb6:	4629      	mov	r1, r5
 8048fb8:	2000      	movs	r0, #0
 8048fba:	f7ff fda1 	bl	8048b00 <tcp_pbuf_prealloc>
 8048fbe:	4607      	mov	r7, r0
 8048fc0:	2800      	cmp	r0, #0
 8048fc2:	f000 8165 	beq.w	8049290 <tcp_write+0x508>
      LWIP_ASSERT("tcp_write: check that first pbuf can hold the complete seglen",
 8048fc6:	8943      	ldrh	r3, [r0, #10]
 8048fc8:	42ab      	cmp	r3, r5
 8048fca:	d306      	bcc.n	8048fda <tcp_write+0x252>
      TCP_DATA_COPY2((char *)p->payload + optlen, (const u8_t*)arg + pos, seglen, &chksum, &chksum_swapped);
 8048fcc:	462a      	mov	r2, r5
 8048fce:	9b08      	ldr	r3, [sp, #32]
 8048fd0:	1919      	adds	r1, r3, r4
 8048fd2:	6878      	ldr	r0, [r7, #4]
 8048fd4:	f008 fd16 	bl	8051a04 <memcpy>
 8048fd8:	e025      	b.n	8049026 <tcp_write+0x29e>
      LWIP_ASSERT("tcp_write: check that first pbuf can hold the complete seglen",
 8048fda:	4b5e      	ldr	r3, [pc, #376]	; (8049154 <tcp_write+0x3cc>)
 8048fdc:	f44f 7210 	mov.w	r2, #576	; 0x240
 8048fe0:	4964      	ldr	r1, [pc, #400]	; (8049174 <tcp_write+0x3ec>)
 8048fe2:	485e      	ldr	r0, [pc, #376]	; (804915c <tcp_write+0x3d4>)
 8048fe4:	f008 fd30 	bl	8051a48 <printf>
 8048fe8:	e7f0      	b.n	8048fcc <tcp_write+0x244>
      LWIP_ASSERT("oversize == 0", oversize == 0);
 8048fea:	4b5a      	ldr	r3, [pc, #360]	; (8049154 <tcp_write+0x3cc>)
 8048fec:	f240 224b 	movw	r2, #587	; 0x24b
 8048ff0:	4961      	ldr	r1, [pc, #388]	; (8049178 <tcp_write+0x3f0>)
 8048ff2:	485a      	ldr	r0, [pc, #360]	; (804915c <tcp_write+0x3d4>)
 8048ff4:	f008 fd28 	bl	8051a48 <printf>
      if ((p2 = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_ROM)) == NULL) {
 8048ff8:	2201      	movs	r2, #1
 8048ffa:	4629      	mov	r1, r5
 8048ffc:	2000      	movs	r0, #0
 8048ffe:	f7fc fed1 	bl	8045da4 <pbuf_alloc>
 8049002:	4681      	mov	r9, r0
 8049004:	2800      	cmp	r0, #0
 8049006:	f000 8146 	beq.w	8049296 <tcp_write+0x50e>
      ((struct pbuf_rom*)p2)->payload = (const u8_t*)arg + pos;
 804900a:	9b08      	ldr	r3, [sp, #32]
 804900c:	4423      	add	r3, r4
 804900e:	6043      	str	r3, [r0, #4]
      if ((p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
 8049010:	2200      	movs	r2, #0
 8049012:	4611      	mov	r1, r2
 8049014:	4610      	mov	r0, r2
 8049016:	f7fc fec5 	bl	8045da4 <pbuf_alloc>
 804901a:	4607      	mov	r7, r0
 804901c:	2800      	cmp	r0, #0
 804901e:	d032      	beq.n	8049086 <tcp_write+0x2fe>
      pbuf_cat(p/*header*/, p2/*data*/);
 8049020:	4649      	mov	r1, r9
 8049022:	f7fd f847 	bl	80460b4 <pbuf_cat>
    queuelen += pbuf_clen(p);
 8049026:	4638      	mov	r0, r7
 8049028:	f7fd f824 	bl	8046074 <pbuf_clen>
 804902c:	4406      	add	r6, r0
 804902e:	b2b6      	uxth	r6, r6
    if ((queuelen > TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
 8049030:	2e09      	cmp	r6, #9
 8049032:	d82e      	bhi.n	8049092 <tcp_write+0x30a>
    if ((seg = tcp_create_segment(pcb, p, 0, pcb->snd_lbb + pos, optflags)) == NULL) {
 8049034:	f8d8 3058 	ldr.w	r3, [r8, #88]	; 0x58
 8049038:	2200      	movs	r2, #0
 804903a:	9200      	str	r2, [sp, #0]
 804903c:	4423      	add	r3, r4
 804903e:	4639      	mov	r1, r7
 8049040:	4640      	mov	r0, r8
 8049042:	f7ff fd9d 	bl	8048b80 <tcp_create_segment>
 8049046:	4607      	mov	r7, r0
 8049048:	2800      	cmp	r0, #0
 804904a:	f000 8127 	beq.w	804929c <tcp_write+0x514>
    if (queue == NULL) {
 804904e:	9b06      	ldr	r3, [sp, #24]
 8049050:	2b00      	cmp	r3, #0
 8049052:	d052      	beq.n	80490fa <tcp_write+0x372>
      LWIP_ASSERT("prev_seg != NULL", prev_seg != NULL);
 8049054:	9b05      	ldr	r3, [sp, #20]
 8049056:	2b00      	cmp	r3, #0
 8049058:	d047      	beq.n	80490ea <tcp_write+0x362>
      prev_seg->next = seg;
 804905a:	9b05      	ldr	r3, [sp, #20]
 804905c:	601f      	str	r7, [r3, #0]
    pos += seglen;
 804905e:	442c      	add	r4, r5
 8049060:	b2a4      	uxth	r4, r4
    prev_seg = seg;
 8049062:	9705      	str	r7, [sp, #20]
  while (pos < len) {
 8049064:	4554      	cmp	r4, sl
 8049066:	d258      	bcs.n	804911a <tcp_write+0x392>
    u16_t left = len - pos;
 8049068:	ebaa 0504 	sub.w	r5, sl, r4
 804906c:	b2ad      	uxth	r5, r5
    u16_t seglen = LWIP_MIN(left, max_len);
 804906e:	455d      	cmp	r5, fp
 8049070:	bf28      	it	cs
 8049072:	465d      	movcs	r5, fp
    if (apiflags & TCP_WRITE_FLAG_COPY) {
 8049074:	9b07      	ldr	r3, [sp, #28]
 8049076:	f013 0f01 	tst.w	r3, #1
 804907a:	d190      	bne.n	8048f9e <tcp_write+0x216>
      LWIP_ASSERT("oversize == 0", oversize == 0);
 804907c:	f8bd 303e 	ldrh.w	r3, [sp, #62]	; 0x3e
 8049080:	2b00      	cmp	r3, #0
 8049082:	d0b9      	beq.n	8048ff8 <tcp_write+0x270>
 8049084:	e7b1      	b.n	8048fea <tcp_write+0x262>
 8049086:	4648      	mov	r0, r9
 8049088:	f8dd 9034 	ldr.w	r9, [sp, #52]	; 0x34
        pbuf_free(p2);
 804908c:	f7fc fe26 	bl	8045cdc <pbuf_free>
        goto memerr;
 8049090:	e004      	b.n	804909c <tcp_write+0x314>
 8049092:	f8dd 9034 	ldr.w	r9, [sp, #52]	; 0x34
      pbuf_free(p);
 8049096:	4638      	mov	r0, r7
 8049098:	f7fc fe20 	bl	8045cdc <pbuf_free>
  pcb->flags |= TF_NAGLEMEMERR;
 804909c:	f898 301a 	ldrb.w	r3, [r8, #26]
 80490a0:	f063 037f 	orn	r3, r3, #127	; 0x7f
 80490a4:	f888 301a 	strb.w	r3, [r8, #26]
  if (concat_p != NULL) {
 80490a8:	f1b9 0f00 	cmp.w	r9, #0
 80490ac:	d002      	beq.n	80490b4 <tcp_write+0x32c>
    pbuf_free(concat_p);
 80490ae:	4648      	mov	r0, r9
 80490b0:	f7fc fe14 	bl	8045cdc <pbuf_free>
  if (queue != NULL) {
 80490b4:	9b06      	ldr	r3, [sp, #24]
 80490b6:	b113      	cbz	r3, 80490be <tcp_write+0x336>
    tcp_segs_free(queue);
 80490b8:	4618      	mov	r0, r3
 80490ba:	f7fd fb00 	bl	80466be <tcp_segs_free>
  if (pcb->snd_queuelen != 0) {
 80490be:	f8b8 3062 	ldrh.w	r3, [r8, #98]	; 0x62
 80490c2:	2b00      	cmp	r3, #0
 80490c4:	f000 80f8 	beq.w	80492b8 <tcp_write+0x530>
    LWIP_ASSERT("tcp_write: valid queue length", pcb->unacked != NULL ||
 80490c8:	f8d8 306c 	ldr.w	r3, [r8, #108]	; 0x6c
 80490cc:	2b00      	cmp	r3, #0
 80490ce:	f040 80f7 	bne.w	80492c0 <tcp_write+0x538>
 80490d2:	f8d8 3068 	ldr.w	r3, [r8, #104]	; 0x68
 80490d6:	2b00      	cmp	r3, #0
 80490d8:	f000 80e3 	beq.w	80492a2 <tcp_write+0x51a>
  return ERR_MEM;
 80490dc:	f04f 33ff 	mov.w	r3, #4294967295
 80490e0:	930a      	str	r3, [sp, #40]	; 0x28
}
 80490e2:	980a      	ldr	r0, [sp, #40]	; 0x28
 80490e4:	b011      	add	sp, #68	; 0x44
 80490e6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      LWIP_ASSERT("prev_seg != NULL", prev_seg != NULL);
 80490ea:	4b1a      	ldr	r3, [pc, #104]	; (8049154 <tcp_write+0x3cc>)
 80490ec:	f240 2285 	movw	r2, #645	; 0x285
 80490f0:	4922      	ldr	r1, [pc, #136]	; (804917c <tcp_write+0x3f4>)
 80490f2:	481a      	ldr	r0, [pc, #104]	; (804915c <tcp_write+0x3d4>)
 80490f4:	f008 fca8 	bl	8051a48 <printf>
 80490f8:	e7af      	b.n	804905a <tcp_write+0x2d2>
      queue = seg;
 80490fa:	9006      	str	r0, [sp, #24]
 80490fc:	e7af      	b.n	804905e <tcp_write+0x2d6>
 80490fe:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
  u16_t extendlen = 0;
 8049100:	2300      	movs	r3, #0
 8049102:	930c      	str	r3, [sp, #48]	; 0x30
  struct tcp_seg *last_unsent = NULL, *seg = NULL, *prev_seg = NULL, *queue = NULL;
 8049104:	2300      	movs	r3, #0
 8049106:	9306      	str	r3, [sp, #24]
 8049108:	9305      	str	r3, [sp, #20]
 804910a:	f8cd 9034 	str.w	r9, [sp, #52]	; 0x34
 804910e:	e7a9      	b.n	8049064 <tcp_write+0x2dc>
 8049110:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
 8049112:	e7f7      	b.n	8049104 <tcp_write+0x37c>
  u16_t extendlen = 0;
 8049114:	930c      	str	r3, [sp, #48]	; 0x30
 8049116:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
 8049118:	e7f4      	b.n	8049104 <tcp_write+0x37c>
 804911a:	f8dd 9034 	ldr.w	r9, [sp, #52]	; 0x34
  if (oversize_used > 0) {
 804911e:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
 8049120:	2d00      	cmp	r5, #0
 8049122:	d032      	beq.n	804918a <tcp_write+0x402>
    for (p = last_unsent->p; p; p = p->next) {
 8049124:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8049126:	685c      	ldr	r4, [r3, #4]
 8049128:	f8dd b020 	ldr.w	fp, [sp, #32]
 804912c:	e000      	b.n	8049130 <tcp_write+0x3a8>
 804912e:	6824      	ldr	r4, [r4, #0]
 8049130:	b334      	cbz	r4, 8049180 <tcp_write+0x3f8>
      p->tot_len += oversize_used;
 8049132:	8923      	ldrh	r3, [r4, #8]
 8049134:	442b      	add	r3, r5
 8049136:	8123      	strh	r3, [r4, #8]
      if (p->next == NULL) {
 8049138:	6823      	ldr	r3, [r4, #0]
 804913a:	2b00      	cmp	r3, #0
 804913c:	d1f7      	bne.n	804912e <tcp_write+0x3a6>
        TCP_DATA_COPY((char *)p->payload + p->len, arg, oversize_used, last_unsent);
 804913e:	6860      	ldr	r0, [r4, #4]
 8049140:	8963      	ldrh	r3, [r4, #10]
 8049142:	462a      	mov	r2, r5
 8049144:	4659      	mov	r1, fp
 8049146:	4418      	add	r0, r3
 8049148:	f008 fc5c 	bl	8051a04 <memcpy>
        p->len += oversize_used;
 804914c:	8963      	ldrh	r3, [r4, #10]
 804914e:	442b      	add	r3, r5
 8049150:	8163      	strh	r3, [r4, #10]
 8049152:	e7ec      	b.n	804912e <tcp_write+0x3a6>
 8049154:	08059dbc 	.word	0x08059dbc
 8049158:	08059ebc 	.word	0x08059ebc
 804915c:	08058ecc 	.word	0x08058ecc
 8049160:	08059ef0 	.word	0x08059ef0
 8049164:	08059f08 	.word	0x08059f08
 8049168:	08059f28 	.word	0x08059f28
 804916c:	08059f48 	.word	0x08059f48
 8049170:	08059f74 	.word	0x08059f74
 8049174:	08059fa4 	.word	0x08059fa4
 8049178:	08059fe4 	.word	0x08059fe4
 804917c:	08059ff4 	.word	0x08059ff4
    last_unsent->len += oversize_used;
 8049180:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8049182:	8913      	ldrh	r3, [r2, #8]
 8049184:	990b      	ldr	r1, [sp, #44]	; 0x2c
 8049186:	4419      	add	r1, r3
 8049188:	8111      	strh	r1, [r2, #8]
  pcb->unsent_oversize = oversize;
 804918a:	f8bd 303e 	ldrh.w	r3, [sp, #62]	; 0x3e
 804918e:	f8a8 3064 	strh.w	r3, [r8, #100]	; 0x64
  if (concat_p != NULL) {
 8049192:	f1b9 0f00 	cmp.w	r9, #0
 8049196:	d041      	beq.n	804921c <tcp_write+0x494>
    LWIP_ASSERT("tcp_write: cannot concatenate when pcb->unsent is empty",
 8049198:	9b09      	ldr	r3, [sp, #36]	; 0x24
 804919a:	2b00      	cmp	r3, #0
 804919c:	d036      	beq.n	804920c <tcp_write+0x484>
    pbuf_cat(last_unsent->p, concat_p);
 804919e:	4649      	mov	r1, r9
 80491a0:	9c09      	ldr	r4, [sp, #36]	; 0x24
 80491a2:	6860      	ldr	r0, [r4, #4]
 80491a4:	f7fc ff86 	bl	80460b4 <pbuf_cat>
    last_unsent->len += concat_p->tot_len;
 80491a8:	f8b9 3008 	ldrh.w	r3, [r9, #8]
 80491ac:	8922      	ldrh	r2, [r4, #8]
 80491ae:	4413      	add	r3, r2
 80491b0:	8123      	strh	r3, [r4, #8]
  if (last_unsent == NULL) {
 80491b2:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80491b4:	2b00      	cmp	r3, #0
 80491b6:	d057      	beq.n	8049268 <tcp_write+0x4e0>
    last_unsent->next = queue;
 80491b8:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80491ba:	461a      	mov	r2, r3
 80491bc:	9b06      	ldr	r3, [sp, #24]
 80491be:	6013      	str	r3, [r2, #0]
  pcb->snd_lbb += len;
 80491c0:	f8d8 3058 	ldr.w	r3, [r8, #88]	; 0x58
 80491c4:	4453      	add	r3, sl
 80491c6:	f8c8 3058 	str.w	r3, [r8, #88]	; 0x58
  pcb->snd_buf -= len;
 80491ca:	f8b8 3060 	ldrh.w	r3, [r8, #96]	; 0x60
 80491ce:	eba3 0a0a 	sub.w	sl, r3, sl
 80491d2:	f8a8 a060 	strh.w	sl, [r8, #96]	; 0x60
  pcb->snd_queuelen = queuelen;
 80491d6:	f8a8 6062 	strh.w	r6, [r8, #98]	; 0x62
  if (pcb->snd_queuelen != 0) {
 80491da:	b11e      	cbz	r6, 80491e4 <tcp_write+0x45c>
    LWIP_ASSERT("tcp_write: valid queue length",
 80491dc:	f8d8 306c 	ldr.w	r3, [r8, #108]	; 0x6c
 80491e0:	2b00      	cmp	r3, #0
 80491e2:	d045      	beq.n	8049270 <tcp_write+0x4e8>
  if (seg != NULL && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE)==0)) {
 80491e4:	2f00      	cmp	r7, #0
 80491e6:	f43f af7c 	beq.w	80490e2 <tcp_write+0x35a>
 80491ea:	68fb      	ldr	r3, [r7, #12]
 80491ec:	2b00      	cmp	r3, #0
 80491ee:	f43f af78 	beq.w	80490e2 <tcp_write+0x35a>
 80491f2:	9a07      	ldr	r2, [sp, #28]
 80491f4:	f012 0f02 	tst.w	r2, #2
 80491f8:	f47f af73 	bne.w	80490e2 <tcp_write+0x35a>
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
 80491fc:	899c      	ldrh	r4, [r3, #12]
 80491fe:	2008      	movs	r0, #8
 8049200:	f7fc f936 	bl	8045470 <lwip_htons>
 8049204:	68fb      	ldr	r3, [r7, #12]
 8049206:	4304      	orrs	r4, r0
 8049208:	819c      	strh	r4, [r3, #12]
 804920a:	e76a      	b.n	80490e2 <tcp_write+0x35a>
    LWIP_ASSERT("tcp_write: cannot concatenate when pcb->unsent is empty",
 804920c:	4b2e      	ldr	r3, [pc, #184]	; (80492c8 <tcp_write+0x540>)
 804920e:	f240 22ba 	movw	r2, #698	; 0x2ba
 8049212:	492e      	ldr	r1, [pc, #184]	; (80492cc <tcp_write+0x544>)
 8049214:	482e      	ldr	r0, [pc, #184]	; (80492d0 <tcp_write+0x548>)
 8049216:	f008 fc17 	bl	8051a48 <printf>
 804921a:	e7c0      	b.n	804919e <tcp_write+0x416>
  } else if (extendlen > 0) {
 804921c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 804921e:	2b00      	cmp	r3, #0
 8049220:	d0c7      	beq.n	80491b2 <tcp_write+0x42a>
    LWIP_ASSERT("tcp_write: extension of reference requires reference",
 8049222:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8049224:	b12b      	cbz	r3, 8049232 <tcp_write+0x4aa>
 8049226:	685b      	ldr	r3, [r3, #4]
 8049228:	b11b      	cbz	r3, 8049232 <tcp_write+0x4aa>
    for (p = last_unsent->p; p->next != NULL; p = p->next) {
 804922a:	9b09      	ldr	r3, [sp, #36]	; 0x24
 804922c:	685b      	ldr	r3, [r3, #4]
 804922e:	980c      	ldr	r0, [sp, #48]	; 0x30
 8049230:	e00b      	b.n	804924a <tcp_write+0x4c2>
    LWIP_ASSERT("tcp_write: extension of reference requires reference",
 8049232:	4b25      	ldr	r3, [pc, #148]	; (80492c8 <tcp_write+0x540>)
 8049234:	f44f 7230 	mov.w	r2, #704	; 0x2c0
 8049238:	4926      	ldr	r1, [pc, #152]	; (80492d4 <tcp_write+0x54c>)
 804923a:	4825      	ldr	r0, [pc, #148]	; (80492d0 <tcp_write+0x548>)
 804923c:	f008 fc04 	bl	8051a48 <printf>
 8049240:	e7f3      	b.n	804922a <tcp_write+0x4a2>
      p->tot_len += extendlen;
 8049242:	891a      	ldrh	r2, [r3, #8]
 8049244:	4402      	add	r2, r0
 8049246:	811a      	strh	r2, [r3, #8]
    for (p = last_unsent->p; p->next != NULL; p = p->next) {
 8049248:	460b      	mov	r3, r1
 804924a:	6819      	ldr	r1, [r3, #0]
 804924c:	2900      	cmp	r1, #0
 804924e:	d1f8      	bne.n	8049242 <tcp_write+0x4ba>
    p->tot_len += extendlen;
 8049250:	891a      	ldrh	r2, [r3, #8]
 8049252:	990c      	ldr	r1, [sp, #48]	; 0x30
 8049254:	440a      	add	r2, r1
 8049256:	811a      	strh	r2, [r3, #8]
    p->len += extendlen;
 8049258:	895a      	ldrh	r2, [r3, #10]
 804925a:	440a      	add	r2, r1
 804925c:	815a      	strh	r2, [r3, #10]
    last_unsent->len += extendlen;
 804925e:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8049260:	8913      	ldrh	r3, [r2, #8]
 8049262:	440b      	add	r3, r1
 8049264:	8113      	strh	r3, [r2, #8]
 8049266:	e7a4      	b.n	80491b2 <tcp_write+0x42a>
    pcb->unsent = queue;
 8049268:	9b06      	ldr	r3, [sp, #24]
 804926a:	f8c8 3068 	str.w	r3, [r8, #104]	; 0x68
 804926e:	e7a7      	b.n	80491c0 <tcp_write+0x438>
    LWIP_ASSERT("tcp_write: valid queue length",
 8049270:	f8d8 3068 	ldr.w	r3, [r8, #104]	; 0x68
 8049274:	2b00      	cmp	r3, #0
 8049276:	d1b5      	bne.n	80491e4 <tcp_write+0x45c>
 8049278:	4b13      	ldr	r3, [pc, #76]	; (80492c8 <tcp_write+0x540>)
 804927a:	f44f 723b 	mov.w	r2, #748	; 0x2ec
 804927e:	4916      	ldr	r1, [pc, #88]	; (80492d8 <tcp_write+0x550>)
 8049280:	4813      	ldr	r0, [pc, #76]	; (80492d0 <tcp_write+0x548>)
 8049282:	f008 fbe1 	bl	8051a48 <printf>
 8049286:	e7ad      	b.n	80491e4 <tcp_write+0x45c>
  struct tcp_seg *last_unsent = NULL, *seg = NULL, *prev_seg = NULL, *queue = NULL;
 8049288:	9006      	str	r0, [sp, #24]
 804928a:	e707      	b.n	804909c <tcp_write+0x314>
 804928c:	9006      	str	r0, [sp, #24]
 804928e:	e705      	b.n	804909c <tcp_write+0x314>
 8049290:	f8dd 9034 	ldr.w	r9, [sp, #52]	; 0x34
 8049294:	e702      	b.n	804909c <tcp_write+0x314>
 8049296:	f8dd 9034 	ldr.w	r9, [sp, #52]	; 0x34
 804929a:	e6ff      	b.n	804909c <tcp_write+0x314>
 804929c:	f8dd 9034 	ldr.w	r9, [sp, #52]	; 0x34
 80492a0:	e6fc      	b.n	804909c <tcp_write+0x314>
    LWIP_ASSERT("tcp_write: valid queue length", pcb->unacked != NULL ||
 80492a2:	4b09      	ldr	r3, [pc, #36]	; (80492c8 <tcp_write+0x540>)
 80492a4:	f240 3201 	movw	r2, #769	; 0x301
 80492a8:	490b      	ldr	r1, [pc, #44]	; (80492d8 <tcp_write+0x550>)
 80492aa:	4809      	ldr	r0, [pc, #36]	; (80492d0 <tcp_write+0x548>)
 80492ac:	f008 fbcc 	bl	8051a48 <printf>
  return ERR_MEM;
 80492b0:	f04f 33ff 	mov.w	r3, #4294967295
 80492b4:	930a      	str	r3, [sp, #40]	; 0x28
 80492b6:	e714      	b.n	80490e2 <tcp_write+0x35a>
 80492b8:	f04f 33ff 	mov.w	r3, #4294967295
 80492bc:	930a      	str	r3, [sp, #40]	; 0x28
 80492be:	e710      	b.n	80490e2 <tcp_write+0x35a>
 80492c0:	f04f 33ff 	mov.w	r3, #4294967295
 80492c4:	930a      	str	r3, [sp, #40]	; 0x28
 80492c6:	e70c      	b.n	80490e2 <tcp_write+0x35a>
 80492c8:	08059dbc 	.word	0x08059dbc
 80492cc:	0805a008 	.word	0x0805a008
 80492d0:	08058ecc 	.word	0x08058ecc
 80492d4:	0805a040 	.word	0x0805a040
 80492d8:	0805a078 	.word	0x0805a078

080492dc <tcp_enqueue_flags>:
{
 80492dc:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80492e0:	b083      	sub	sp, #12
 80492e2:	4604      	mov	r4, r0
 80492e4:	460d      	mov	r5, r1
  LWIP_ASSERT("tcp_enqueue_flags: need either TCP_SYN or TCP_FIN in flags (programmer violates API)",
 80492e6:	f011 0703 	ands.w	r7, r1, #3
 80492ea:	d052      	beq.n	8049392 <tcp_enqueue_flags+0xb6>
  if (((pcb->snd_queuelen >= TCP_SND_QUEUELEN) || (pcb->snd_queuelen > TCP_SNDQUEUELEN_OVERFLOW)) &&
 80492ec:	f8b4 3062 	ldrh.w	r3, [r4, #98]	; 0x62
 80492f0:	2b08      	cmp	r3, #8
 80492f2:	d902      	bls.n	80492fa <tcp_enqueue_flags+0x1e>
 80492f4:	f015 0f01 	tst.w	r5, #1
 80492f8:	d053      	beq.n	80493a2 <tcp_enqueue_flags+0xc6>
  if (flags & TCP_SYN) {
 80492fa:	f015 0802 	ands.w	r8, r5, #2
 80492fe:	d001      	beq.n	8049304 <tcp_enqueue_flags+0x28>
    optflags = TF_SEG_OPTS_MSS;
 8049300:	f04f 0801 	mov.w	r8, #1
  optlen = LWIP_TCP_OPT_LENGTH(optflags);
 8049304:	ea4f 0688 	mov.w	r6, r8, lsl #2
  if ((p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
 8049308:	f006 0604 	and.w	r6, r6, #4
 804930c:	2200      	movs	r2, #0
 804930e:	4631      	mov	r1, r6
 8049310:	4610      	mov	r0, r2
 8049312:	f7fc fd47 	bl	8045da4 <pbuf_alloc>
 8049316:	4681      	mov	r9, r0
 8049318:	2800      	cmp	r0, #0
 804931a:	d049      	beq.n	80493b0 <tcp_enqueue_flags+0xd4>
  LWIP_ASSERT("tcp_enqueue_flags: check that first pbuf can hold optlen",
 804931c:	8943      	ldrh	r3, [r0, #10]
 804931e:	429e      	cmp	r6, r3
 8049320:	d84d      	bhi.n	80493be <tcp_enqueue_flags+0xe2>
  if ((seg = tcp_create_segment(pcb, p, flags, pcb->snd_lbb, optflags)) == NULL) {
 8049322:	f8cd 8000 	str.w	r8, [sp]
 8049326:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8049328:	462a      	mov	r2, r5
 804932a:	4649      	mov	r1, r9
 804932c:	4620      	mov	r0, r4
 804932e:	f7ff fc27 	bl	8048b80 <tcp_create_segment>
 8049332:	4606      	mov	r6, r0
 8049334:	2800      	cmp	r0, #0
 8049336:	d04a      	beq.n	80493ce <tcp_enqueue_flags+0xf2>
  LWIP_ASSERT("seg->tcphdr not aligned", ((mem_ptr_t)seg->tcphdr % LWIP_MIN(MEM_ALIGNMENT, 4)) == 0);
 8049338:	68c3      	ldr	r3, [r0, #12]
 804933a:	f013 0f03 	tst.w	r3, #3
 804933e:	d14d      	bne.n	80493dc <tcp_enqueue_flags+0x100>
  LWIP_ASSERT("tcp_enqueue_flags: invalid segment length", seg->len == 0);
 8049340:	8933      	ldrh	r3, [r6, #8]
 8049342:	2b00      	cmp	r3, #0
 8049344:	d152      	bne.n	80493ec <tcp_enqueue_flags+0x110>
  if (pcb->unsent == NULL) {
 8049346:	6ea3      	ldr	r3, [r4, #104]	; 0x68
 8049348:	2b00      	cmp	r3, #0
 804934a:	d057      	beq.n	80493fc <tcp_enqueue_flags+0x120>
    for (useg = pcb->unsent; useg->next != NULL; useg = useg->next);
 804934c:	461a      	mov	r2, r3
 804934e:	681b      	ldr	r3, [r3, #0]
 8049350:	2b00      	cmp	r3, #0
 8049352:	d1fb      	bne.n	804934c <tcp_enqueue_flags+0x70>
    useg->next = seg;
 8049354:	6016      	str	r6, [r2, #0]
  pcb->unsent_oversize = 0;
 8049356:	2300      	movs	r3, #0
 8049358:	f8a4 3064 	strh.w	r3, [r4, #100]	; 0x64
  if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
 804935c:	b117      	cbz	r7, 8049364 <tcp_enqueue_flags+0x88>
    pcb->snd_lbb++;
 804935e:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8049360:	3301      	adds	r3, #1
 8049362:	65a3      	str	r3, [r4, #88]	; 0x58
  if (flags & TCP_FIN) {
 8049364:	f015 0f01 	tst.w	r5, #1
 8049368:	d003      	beq.n	8049372 <tcp_enqueue_flags+0x96>
    pcb->flags |= TF_FIN;
 804936a:	7ea3      	ldrb	r3, [r4, #26]
 804936c:	f043 0320 	orr.w	r3, r3, #32
 8049370:	76a3      	strb	r3, [r4, #26]
  pcb->snd_queuelen += pbuf_clen(seg->p);
 8049372:	6870      	ldr	r0, [r6, #4]
 8049374:	f7fc fe7e 	bl	8046074 <pbuf_clen>
 8049378:	f8b4 3062 	ldrh.w	r3, [r4, #98]	; 0x62
 804937c:	4418      	add	r0, r3
 804937e:	b280      	uxth	r0, r0
 8049380:	f8a4 0062 	strh.w	r0, [r4, #98]	; 0x62
  if (pcb->snd_queuelen != 0) {
 8049384:	2800      	cmp	r0, #0
 8049386:	d048      	beq.n	804941a <tcp_enqueue_flags+0x13e>
    LWIP_ASSERT("tcp_enqueue_flags: invalid queue length",
 8049388:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 804938a:	2b00      	cmp	r3, #0
 804938c:	d038      	beq.n	8049400 <tcp_enqueue_flags+0x124>
  return ERR_OK;
 804938e:	2000      	movs	r0, #0
 8049390:	e044      	b.n	804941c <tcp_enqueue_flags+0x140>
  LWIP_ASSERT("tcp_enqueue_flags: need either TCP_SYN or TCP_FIN in flags (programmer violates API)",
 8049392:	4b24      	ldr	r3, [pc, #144]	; (8049424 <tcp_enqueue_flags+0x148>)
 8049394:	f240 321a 	movw	r2, #794	; 0x31a
 8049398:	4923      	ldr	r1, [pc, #140]	; (8049428 <tcp_enqueue_flags+0x14c>)
 804939a:	4824      	ldr	r0, [pc, #144]	; (804942c <tcp_enqueue_flags+0x150>)
 804939c:	f008 fb54 	bl	8051a48 <printf>
 80493a0:	e7a4      	b.n	80492ec <tcp_enqueue_flags+0x10>
    pcb->flags |= TF_NAGLEMEMERR;
 80493a2:	7ea3      	ldrb	r3, [r4, #26]
 80493a4:	f063 037f 	orn	r3, r3, #127	; 0x7f
 80493a8:	76a3      	strb	r3, [r4, #26]
    return ERR_MEM;
 80493aa:	f04f 30ff 	mov.w	r0, #4294967295
 80493ae:	e035      	b.n	804941c <tcp_enqueue_flags+0x140>
    pcb->flags |= TF_NAGLEMEMERR;
 80493b0:	7ea3      	ldrb	r3, [r4, #26]
 80493b2:	f063 037f 	orn	r3, r3, #127	; 0x7f
 80493b6:	76a3      	strb	r3, [r4, #26]
    return ERR_MEM;
 80493b8:	f04f 30ff 	mov.w	r0, #4294967295
 80493bc:	e02e      	b.n	804941c <tcp_enqueue_flags+0x140>
  LWIP_ASSERT("tcp_enqueue_flags: check that first pbuf can hold optlen",
 80493be:	4b19      	ldr	r3, [pc, #100]	; (8049424 <tcp_enqueue_flags+0x148>)
 80493c0:	f44f 7250 	mov.w	r2, #832	; 0x340
 80493c4:	491a      	ldr	r1, [pc, #104]	; (8049430 <tcp_enqueue_flags+0x154>)
 80493c6:	4819      	ldr	r0, [pc, #100]	; (804942c <tcp_enqueue_flags+0x150>)
 80493c8:	f008 fb3e 	bl	8051a48 <printf>
 80493cc:	e7a9      	b.n	8049322 <tcp_enqueue_flags+0x46>
    pcb->flags |= TF_NAGLEMEMERR;
 80493ce:	7ea3      	ldrb	r3, [r4, #26]
 80493d0:	f063 037f 	orn	r3, r3, #127	; 0x7f
 80493d4:	76a3      	strb	r3, [r4, #26]
    return ERR_MEM;
 80493d6:	f04f 30ff 	mov.w	r0, #4294967295
 80493da:	e01f      	b.n	804941c <tcp_enqueue_flags+0x140>
  LWIP_ASSERT("seg->tcphdr not aligned", ((mem_ptr_t)seg->tcphdr % LWIP_MIN(MEM_ALIGNMENT, 4)) == 0);
 80493dc:	4b11      	ldr	r3, [pc, #68]	; (8049424 <tcp_enqueue_flags+0x148>)
 80493de:	f240 3249 	movw	r2, #841	; 0x349
 80493e2:	4914      	ldr	r1, [pc, #80]	; (8049434 <tcp_enqueue_flags+0x158>)
 80493e4:	4811      	ldr	r0, [pc, #68]	; (804942c <tcp_enqueue_flags+0x150>)
 80493e6:	f008 fb2f 	bl	8051a48 <printf>
 80493ea:	e7a9      	b.n	8049340 <tcp_enqueue_flags+0x64>
  LWIP_ASSERT("tcp_enqueue_flags: invalid segment length", seg->len == 0);
 80493ec:	4b0d      	ldr	r3, [pc, #52]	; (8049424 <tcp_enqueue_flags+0x148>)
 80493ee:	f240 324a 	movw	r2, #842	; 0x34a
 80493f2:	4911      	ldr	r1, [pc, #68]	; (8049438 <tcp_enqueue_flags+0x15c>)
 80493f4:	480d      	ldr	r0, [pc, #52]	; (804942c <tcp_enqueue_flags+0x150>)
 80493f6:	f008 fb27 	bl	8051a48 <printf>
 80493fa:	e7a4      	b.n	8049346 <tcp_enqueue_flags+0x6a>
    pcb->unsent = seg;
 80493fc:	66a6      	str	r6, [r4, #104]	; 0x68
 80493fe:	e7aa      	b.n	8049356 <tcp_enqueue_flags+0x7a>
    LWIP_ASSERT("tcp_enqueue_flags: invalid queue length",
 8049400:	6ea3      	ldr	r3, [r4, #104]	; 0x68
 8049402:	b10b      	cbz	r3, 8049408 <tcp_enqueue_flags+0x12c>
  return ERR_OK;
 8049404:	2000      	movs	r0, #0
 8049406:	e009      	b.n	804941c <tcp_enqueue_flags+0x140>
    LWIP_ASSERT("tcp_enqueue_flags: invalid queue length",
 8049408:	4b06      	ldr	r3, [pc, #24]	; (8049424 <tcp_enqueue_flags+0x148>)
 804940a:	f44f 725b 	mov.w	r2, #876	; 0x36c
 804940e:	490b      	ldr	r1, [pc, #44]	; (804943c <tcp_enqueue_flags+0x160>)
 8049410:	4806      	ldr	r0, [pc, #24]	; (804942c <tcp_enqueue_flags+0x150>)
 8049412:	f008 fb19 	bl	8051a48 <printf>
  return ERR_OK;
 8049416:	2000      	movs	r0, #0
 8049418:	e000      	b.n	804941c <tcp_enqueue_flags+0x140>
 804941a:	2000      	movs	r0, #0
}
 804941c:	b003      	add	sp, #12
 804941e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8049422:	bf00      	nop
 8049424:	08059dbc 	.word	0x08059dbc
 8049428:	0805a098 	.word	0x0805a098
 804942c:	08058ecc 	.word	0x08058ecc
 8049430:	0805a0f0 	.word	0x0805a0f0
 8049434:	0805a12c 	.word	0x0805a12c
 8049438:	0805a144 	.word	0x0805a144
 804943c:	0805a170 	.word	0x0805a170

08049440 <tcp_send_fin>:
{
 8049440:	b570      	push	{r4, r5, r6, lr}
 8049442:	4605      	mov	r5, r0
  if (pcb->unsent != NULL) {
 8049444:	6e83      	ldr	r3, [r0, #104]	; 0x68
 8049446:	b153      	cbz	r3, 804945e <tcp_send_fin+0x1e>
    for (last_unsent = pcb->unsent; last_unsent->next != NULL;
 8049448:	461c      	mov	r4, r3
 804944a:	681b      	ldr	r3, [r3, #0]
 804944c:	2b00      	cmp	r3, #0
 804944e:	d1fb      	bne.n	8049448 <tcp_send_fin+0x8>
    if ((TCPH_FLAGS(last_unsent->tcphdr) & (TCP_SYN | TCP_FIN | TCP_RST)) == 0) {
 8049450:	68e3      	ldr	r3, [r4, #12]
 8049452:	8998      	ldrh	r0, [r3, #12]
 8049454:	f7fc f80c 	bl	8045470 <lwip_htons>
 8049458:	f010 0f07 	tst.w	r0, #7
 804945c:	d004      	beq.n	8049468 <tcp_send_fin+0x28>
  return tcp_enqueue_flags(pcb, TCP_FIN);
 804945e:	2101      	movs	r1, #1
 8049460:	4628      	mov	r0, r5
 8049462:	f7ff ff3b 	bl	80492dc <tcp_enqueue_flags>
}
 8049466:	bd70      	pop	{r4, r5, r6, pc}
      TCPH_SET_FLAG(last_unsent->tcphdr, TCP_FIN);
 8049468:	68e3      	ldr	r3, [r4, #12]
 804946a:	899e      	ldrh	r6, [r3, #12]
 804946c:	2001      	movs	r0, #1
 804946e:	f7fb ffff 	bl	8045470 <lwip_htons>
 8049472:	68e3      	ldr	r3, [r4, #12]
 8049474:	4306      	orrs	r6, r0
 8049476:	819e      	strh	r6, [r3, #12]
      pcb->flags |= TF_FIN;
 8049478:	7eab      	ldrb	r3, [r5, #26]
 804947a:	f043 0320 	orr.w	r3, r3, #32
 804947e:	76ab      	strb	r3, [r5, #26]
      return ERR_OK;
 8049480:	2000      	movs	r0, #0
 8049482:	e7f0      	b.n	8049466 <tcp_send_fin+0x26>

08049484 <tcp_send_empty_ack>:
{
 8049484:	b570      	push	{r4, r5, r6, lr}
 8049486:	b084      	sub	sp, #16
 8049488:	4604      	mov	r4, r0
  p = tcp_output_alloc_header(pcb, optlen, 0, lwip_htonl(pcb->snd_nxt));
 804948a:	6cc0      	ldr	r0, [r0, #76]	; 0x4c
 804948c:	f7fb fff3 	bl	8045476 <lwip_htonl>
 8049490:	4603      	mov	r3, r0
 8049492:	2200      	movs	r2, #0
 8049494:	4611      	mov	r1, r2
 8049496:	4620      	mov	r0, r4
 8049498:	f7ff fbce 	bl	8048c38 <tcp_output_alloc_header>
  if (p == NULL) {
 804949c:	b1e0      	cbz	r0, 80494d8 <tcp_send_empty_ack+0x54>
 804949e:	4606      	mov	r6, r0
  netif = ip_route(&pcb->local_ip, &pcb->remote_ip);
 80494a0:	1d25      	adds	r5, r4, #4
 80494a2:	4628      	mov	r0, r5
 80494a4:	f001 fa24 	bl	804a8f0 <ip4_route>
  if (netif == NULL) {
 80494a8:	b1e8      	cbz	r0, 80494e6 <tcp_send_empty_ack+0x62>
    err = ip_output_if(p, &pcb->local_ip, &pcb->remote_ip,
 80494aa:	9002      	str	r0, [sp, #8]
 80494ac:	2306      	movs	r3, #6
 80494ae:	9301      	str	r3, [sp, #4]
 80494b0:	7a63      	ldrb	r3, [r4, #9]
 80494b2:	9300      	str	r3, [sp, #0]
 80494b4:	7aa3      	ldrb	r3, [r4, #10]
 80494b6:	462a      	mov	r2, r5
 80494b8:	4621      	mov	r1, r4
 80494ba:	4630      	mov	r0, r6
 80494bc:	f001 fba0 	bl	804ac00 <ip4_output_if>
 80494c0:	4605      	mov	r5, r0
  pbuf_free(p);
 80494c2:	4630      	mov	r0, r6
 80494c4:	f7fc fc0a 	bl	8045cdc <pbuf_free>
  if (err != ERR_OK) {
 80494c8:	b185      	cbz	r5, 80494ec <tcp_send_empty_ack+0x68>
    pcb->flags |= (TF_ACK_DELAY | TF_ACK_NOW);
 80494ca:	7ea3      	ldrb	r3, [r4, #26]
 80494cc:	f043 0303 	orr.w	r3, r3, #3
 80494d0:	76a3      	strb	r3, [r4, #26]
}
 80494d2:	4628      	mov	r0, r5
 80494d4:	b004      	add	sp, #16
 80494d6:	bd70      	pop	{r4, r5, r6, pc}
    pcb->flags |= (TF_ACK_DELAY | TF_ACK_NOW);
 80494d8:	7ea3      	ldrb	r3, [r4, #26]
 80494da:	f043 0303 	orr.w	r3, r3, #3
 80494de:	76a3      	strb	r3, [r4, #26]
    return ERR_BUF;
 80494e0:	f06f 0501 	mvn.w	r5, #1
 80494e4:	e7f5      	b.n	80494d2 <tcp_send_empty_ack+0x4e>
    err = ERR_RTE;
 80494e6:	f06f 0503 	mvn.w	r5, #3
 80494ea:	e7ea      	b.n	80494c2 <tcp_send_empty_ack+0x3e>
    pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
 80494ec:	7ea3      	ldrb	r3, [r4, #26]
 80494ee:	f023 0303 	bic.w	r3, r3, #3
 80494f2:	76a3      	strb	r3, [r4, #26]
 80494f4:	e7ed      	b.n	80494d2 <tcp_send_empty_ack+0x4e>
	...

080494f8 <tcp_output>:
{
 80494f8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80494fc:	4605      	mov	r5, r0
  LWIP_ASSERT("don't call tcp_output for listen-pcbs",
 80494fe:	7d03      	ldrb	r3, [r0, #20]
 8049500:	2b01      	cmp	r3, #1
 8049502:	d054      	beq.n	80495ae <tcp_output+0xb6>
  if (tcp_input_pcb == pcb) {
 8049504:	4b9b      	ldr	r3, [pc, #620]	; (8049774 <tcp_output+0x27c>)
 8049506:	681b      	ldr	r3, [r3, #0]
 8049508:	42ab      	cmp	r3, r5
 804950a:	f000 812b 	beq.w	8049764 <tcp_output+0x26c>
  wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);
 804950e:	f8b5 9048 	ldrh.w	r9, [r5, #72]	; 0x48
 8049512:	f8b5 305c 	ldrh.w	r3, [r5, #92]	; 0x5c
 8049516:	4599      	cmp	r9, r3
 8049518:	bf28      	it	cs
 804951a:	4699      	movcs	r9, r3
 804951c:	46c8      	mov	r8, r9
  seg = pcb->unsent;
 804951e:	6eac      	ldr	r4, [r5, #104]	; 0x68
  if (pcb->flags & TF_ACK_NOW &&
 8049520:	7eab      	ldrb	r3, [r5, #26]
 8049522:	f013 0f02 	tst.w	r3, #2
 8049526:	d00b      	beq.n	8049540 <tcp_output+0x48>
 8049528:	2c00      	cmp	r4, #0
 804952a:	d048      	beq.n	80495be <tcp_output+0xc6>
      lwip_ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
 804952c:	68e3      	ldr	r3, [r4, #12]
 804952e:	6858      	ldr	r0, [r3, #4]
 8049530:	f7fb ffa1 	bl	8045476 <lwip_htonl>
 8049534:	6c6b      	ldr	r3, [r5, #68]	; 0x44
 8049536:	1ac3      	subs	r3, r0, r3
 8049538:	8922      	ldrh	r2, [r4, #8]
 804953a:	4413      	add	r3, r2
     (seg == NULL ||
 804953c:	454b      	cmp	r3, r9
 804953e:	d83e      	bhi.n	80495be <tcp_output+0xc6>
  useg = pcb->unacked;
 8049540:	6eeb      	ldr	r3, [r5, #108]	; 0x6c
  if (useg != NULL) {
 8049542:	2b00      	cmp	r3, #0
 8049544:	d040      	beq.n	80495c8 <tcp_output+0xd0>
    for (; useg->next != NULL; useg = useg->next);
 8049546:	461e      	mov	r6, r3
 8049548:	681b      	ldr	r3, [r3, #0]
 804954a:	2b00      	cmp	r3, #0
 804954c:	d1fb      	bne.n	8049546 <tcp_output+0x4e>
  netif = ip_route(&pcb->local_ip, &pcb->remote_ip);
 804954e:	1d28      	adds	r0, r5, #4
 8049550:	f001 f9ce 	bl	804a8f0 <ip4_route>
  if (netif == NULL) {
 8049554:	4607      	mov	r7, r0
 8049556:	2800      	cmp	r0, #0
 8049558:	f000 8106 	beq.w	8049768 <tcp_output+0x270>
  if (ip_addr_isany(&pcb->local_ip)) {
 804955c:	b10d      	cbz	r5, 8049562 <tcp_output+0x6a>
 804955e:	682b      	ldr	r3, [r5, #0]
 8049560:	b92b      	cbnz	r3, 804956e <tcp_output+0x76>
    if (local_ip == NULL) {
 8049562:	f117 0f04 	cmn.w	r7, #4
 8049566:	f000 8102 	beq.w	804976e <tcp_output+0x276>
    ip_addr_copy(pcb->local_ip, *local_ip);
 804956a:	687b      	ldr	r3, [r7, #4]
 804956c:	602b      	str	r3, [r5, #0]
  if (seg != NULL &&
 804956e:	2c00      	cmp	r4, #0
 8049570:	f000 8089 	beq.w	8049686 <tcp_output+0x18e>
      lwip_ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd &&
 8049574:	68e3      	ldr	r3, [r4, #12]
 8049576:	6858      	ldr	r0, [r3, #4]
 8049578:	f7fb ff7d 	bl	8045476 <lwip_htonl>
 804957c:	6c6b      	ldr	r3, [r5, #68]	; 0x44
 804957e:	1ac3      	subs	r3, r0, r3
 8049580:	8922      	ldrh	r2, [r4, #8]
 8049582:	4413      	add	r3, r2
  if (seg != NULL &&
 8049584:	454b      	cmp	r3, r9
 8049586:	d97e      	bls.n	8049686 <tcp_output+0x18e>
      lwip_ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd &&
 8049588:	f1b9 0f00 	cmp.w	r9, #0
 804958c:	d07b      	beq.n	8049686 <tcp_output+0x18e>
      wnd > 0 && wnd == pcb->snd_wnd && pcb->unacked == NULL) {
 804958e:	f8b5 305c 	ldrh.w	r3, [r5, #92]	; 0x5c
 8049592:	4599      	cmp	r9, r3
 8049594:	d177      	bne.n	8049686 <tcp_output+0x18e>
 8049596:	6eeb      	ldr	r3, [r5, #108]	; 0x6c
 8049598:	2b00      	cmp	r3, #0
 804959a:	d174      	bne.n	8049686 <tcp_output+0x18e>
    if (pcb->persist_backoff == 0) {
 804959c:	f895 3095 	ldrb.w	r3, [r5, #149]	; 0x95
 80495a0:	bb5b      	cbnz	r3, 80495fa <tcp_output+0x102>
      pcb->persist_cnt = 0;
 80495a2:	f885 3094 	strb.w	r3, [r5, #148]	; 0x94
      pcb->persist_backoff = 1;
 80495a6:	2301      	movs	r3, #1
 80495a8:	f885 3095 	strb.w	r3, [r5, #149]	; 0x95
    goto output_done;
 80495ac:	e025      	b.n	80495fa <tcp_output+0x102>
  LWIP_ASSERT("don't call tcp_output for listen-pcbs",
 80495ae:	4b72      	ldr	r3, [pc, #456]	; (8049778 <tcp_output+0x280>)
 80495b0:	f44f 727b 	mov.w	r2, #1004	; 0x3ec
 80495b4:	4971      	ldr	r1, [pc, #452]	; (804977c <tcp_output+0x284>)
 80495b6:	4872      	ldr	r0, [pc, #456]	; (8049780 <tcp_output+0x288>)
 80495b8:	f008 fa46 	bl	8051a48 <printf>
 80495bc:	e7a2      	b.n	8049504 <tcp_output+0xc>
     return tcp_send_empty_ack(pcb);
 80495be:	4628      	mov	r0, r5
 80495c0:	f7ff ff60 	bl	8049484 <tcp_send_empty_ack>
 80495c4:	4603      	mov	r3, r0
 80495c6:	e021      	b.n	804960c <tcp_output+0x114>
  useg = pcb->unacked;
 80495c8:	461e      	mov	r6, r3
 80495ca:	e7c0      	b.n	804954e <tcp_output+0x56>
    LWIP_ASSERT("RST not expected here!",
 80495cc:	4b6a      	ldr	r3, [pc, #424]	; (8049778 <tcp_output+0x280>)
 80495ce:	f240 4245 	movw	r2, #1093	; 0x445
 80495d2:	496c      	ldr	r1, [pc, #432]	; (8049784 <tcp_output+0x28c>)
 80495d4:	486a      	ldr	r0, [pc, #424]	; (8049780 <tcp_output+0x288>)
 80495d6:	f008 fa37 	bl	8051a48 <printf>
 80495da:	e067      	b.n	80496ac <tcp_output+0x1b4>
    if ((tcp_do_output_nagle(pcb) == 0) &&
 80495dc:	8911      	ldrh	r1, [r2, #8]
 80495de:	8e6a      	ldrh	r2, [r5, #50]	; 0x32
 80495e0:	4291      	cmp	r1, r2
 80495e2:	d26f      	bcs.n	80496c4 <tcp_output+0x1cc>
 80495e4:	f8b5 2060 	ldrh.w	r2, [r5, #96]	; 0x60
 80495e8:	2a00      	cmp	r2, #0
 80495ea:	d06b      	beq.n	80496c4 <tcp_output+0x1cc>
 80495ec:	f8b5 2062 	ldrh.w	r2, [r5, #98]	; 0x62
 80495f0:	2a08      	cmp	r2, #8
 80495f2:	d867      	bhi.n	80496c4 <tcp_output+0x1cc>
 80495f4:	f013 0fa0 	tst.w	r3, #160	; 0xa0
 80495f8:	d164      	bne.n	80496c4 <tcp_output+0x1cc>
  if (pcb->unsent == NULL) {
 80495fa:	6eab      	ldr	r3, [r5, #104]	; 0x68
 80495fc:	2b00      	cmp	r3, #0
 80495fe:	f000 80ae 	beq.w	804975e <tcp_output+0x266>
  pcb->flags &= ~TF_NAGLEMEMERR;
 8049602:	7eab      	ldrb	r3, [r5, #26]
 8049604:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8049608:	76ab      	strb	r3, [r5, #26]
  return ERR_OK;
 804960a:	2300      	movs	r3, #0
}
 804960c:	4618      	mov	r0, r3
 804960e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
 8049612:	68e3      	ldr	r3, [r4, #12]
 8049614:	f8b3 900c 	ldrh.w	r9, [r3, #12]
 8049618:	2010      	movs	r0, #16
 804961a:	f7fb ff29 	bl	8045470 <lwip_htons>
 804961e:	68e3      	ldr	r3, [r4, #12]
 8049620:	ea49 0900 	orr.w	r9, r9, r0
 8049624:	f8a3 900c 	strh.w	r9, [r3, #12]
 8049628:	e04f      	b.n	80496ca <tcp_output+0x1d2>
      pcb->flags |= TF_NAGLEMEMERR;
 804962a:	7eaa      	ldrb	r2, [r5, #26]
 804962c:	f062 027f 	orn	r2, r2, #127	; 0x7f
 8049630:	76aa      	strb	r2, [r5, #26]
      return err;
 8049632:	e7eb      	b.n	804960c <tcp_output+0x114>
    snd_nxt = lwip_ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
 8049634:	2000      	movs	r0, #0
 8049636:	e068      	b.n	804970a <tcp_output+0x212>
      pcb->snd_nxt = snd_nxt;
 8049638:	64e8      	str	r0, [r5, #76]	; 0x4c
 804963a:	e06c      	b.n	8049716 <tcp_output+0x21e>
    if (TCP_TCPLEN(seg) > 0) {
 804963c:	2300      	movs	r3, #0
 804963e:	e074      	b.n	804972a <tcp_output+0x232>
        pcb->unacked = seg;
 8049640:	66ec      	str	r4, [r5, #108]	; 0x6c
        useg = seg;
 8049642:	4626      	mov	r6, r4
 8049644:	e01e      	b.n	8049684 <tcp_output+0x18c>
          struct tcp_seg **cur_seg = &(pcb->unacked);
 8049646:	f105 0a6c 	add.w	sl, r5, #108	; 0x6c
          while (*cur_seg &&
 804964a:	f8da 3000 	ldr.w	r3, [sl]
 804964e:	b183      	cbz	r3, 8049672 <tcp_output+0x17a>
            TCP_SEQ_LT(lwip_ntohl((*cur_seg)->tcphdr->seqno), lwip_ntohl(seg->tcphdr->seqno))) {
 8049650:	68db      	ldr	r3, [r3, #12]
 8049652:	6858      	ldr	r0, [r3, #4]
 8049654:	f7fb ff0f 	bl	8045476 <lwip_htonl>
 8049658:	4681      	mov	r9, r0
 804965a:	68e3      	ldr	r3, [r4, #12]
 804965c:	6858      	ldr	r0, [r3, #4]
 804965e:	f7fb ff0a 	bl	8045476 <lwip_htonl>
 8049662:	eba9 0900 	sub.w	r9, r9, r0
          while (*cur_seg &&
 8049666:	f1b9 0f00 	cmp.w	r9, #0
 804966a:	da02      	bge.n	8049672 <tcp_output+0x17a>
              cur_seg = &((*cur_seg)->next );
 804966c:	f8da a000 	ldr.w	sl, [sl]
 8049670:	e7eb      	b.n	804964a <tcp_output+0x152>
          seg->next = (*cur_seg);
 8049672:	f8da 3000 	ldr.w	r3, [sl]
 8049676:	6023      	str	r3, [r4, #0]
          (*cur_seg) = seg;
 8049678:	f8ca 4000 	str.w	r4, [sl]
 804967c:	e002      	b.n	8049684 <tcp_output+0x18c>
      tcp_seg_free(seg);
 804967e:	4620      	mov	r0, r4
 8049680:	f7fd f810 	bl	80466a4 <tcp_seg_free>
    seg = pcb->unsent;
 8049684:	6eac      	ldr	r4, [r5, #104]	; 0x68
  while (seg != NULL &&
 8049686:	2c00      	cmp	r4, #0
 8049688:	d0b7      	beq.n	80495fa <tcp_output+0x102>
         lwip_ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
 804968a:	68e3      	ldr	r3, [r4, #12]
 804968c:	6858      	ldr	r0, [r3, #4]
 804968e:	f7fb fef2 	bl	8045476 <lwip_htonl>
 8049692:	6c6b      	ldr	r3, [r5, #68]	; 0x44
 8049694:	1ac0      	subs	r0, r0, r3
 8049696:	8923      	ldrh	r3, [r4, #8]
 8049698:	4418      	add	r0, r3
  while (seg != NULL &&
 804969a:	4540      	cmp	r0, r8
 804969c:	d8ad      	bhi.n	80495fa <tcp_output+0x102>
    LWIP_ASSERT("RST not expected here!",
 804969e:	68e3      	ldr	r3, [r4, #12]
 80496a0:	8998      	ldrh	r0, [r3, #12]
 80496a2:	f7fb fee5 	bl	8045470 <lwip_htons>
 80496a6:	f010 0f04 	tst.w	r0, #4
 80496aa:	d18f      	bne.n	80495cc <tcp_output+0xd4>
    if ((tcp_do_output_nagle(pcb) == 0) &&
 80496ac:	6eeb      	ldr	r3, [r5, #108]	; 0x6c
 80496ae:	b14b      	cbz	r3, 80496c4 <tcp_output+0x1cc>
 80496b0:	7eab      	ldrb	r3, [r5, #26]
 80496b2:	f013 0f44 	tst.w	r3, #68	; 0x44
 80496b6:	d105      	bne.n	80496c4 <tcp_output+0x1cc>
 80496b8:	6eaa      	ldr	r2, [r5, #104]	; 0x68
 80496ba:	2a00      	cmp	r2, #0
 80496bc:	d092      	beq.n	80495e4 <tcp_output+0xec>
 80496be:	6811      	ldr	r1, [r2, #0]
 80496c0:	2900      	cmp	r1, #0
 80496c2:	d08b      	beq.n	80495dc <tcp_output+0xe4>
    if (pcb->state != SYN_SENT) {
 80496c4:	7d2b      	ldrb	r3, [r5, #20]
 80496c6:	2b02      	cmp	r3, #2
 80496c8:	d1a3      	bne.n	8049612 <tcp_output+0x11a>
    err = tcp_output_segment(seg, pcb, netif);
 80496ca:	463a      	mov	r2, r7
 80496cc:	4629      	mov	r1, r5
 80496ce:	4620      	mov	r0, r4
 80496d0:	f7ff fafc 	bl	8048ccc <tcp_output_segment>
    if (err != ERR_OK) {
 80496d4:	4603      	mov	r3, r0
 80496d6:	2800      	cmp	r0, #0
 80496d8:	d1a7      	bne.n	804962a <tcp_output+0x132>
    pcb->unsent = seg->next;
 80496da:	6823      	ldr	r3, [r4, #0]
 80496dc:	66ab      	str	r3, [r5, #104]	; 0x68
    if (pcb->state != SYN_SENT) {
 80496de:	7d2b      	ldrb	r3, [r5, #20]
 80496e0:	2b02      	cmp	r3, #2
 80496e2:	d003      	beq.n	80496ec <tcp_output+0x1f4>
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
 80496e4:	7eab      	ldrb	r3, [r5, #26]
 80496e6:	f023 0303 	bic.w	r3, r3, #3
 80496ea:	76ab      	strb	r3, [r5, #26]
    snd_nxt = lwip_ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
 80496ec:	68e3      	ldr	r3, [r4, #12]
 80496ee:	6858      	ldr	r0, [r3, #4]
 80496f0:	f7fb fec1 	bl	8045476 <lwip_htonl>
 80496f4:	4681      	mov	r9, r0
 80496f6:	f8b4 a008 	ldrh.w	sl, [r4, #8]
 80496fa:	68e3      	ldr	r3, [r4, #12]
 80496fc:	8998      	ldrh	r0, [r3, #12]
 80496fe:	f7fb feb7 	bl	8045470 <lwip_htons>
 8049702:	f010 0f03 	tst.w	r0, #3
 8049706:	d095      	beq.n	8049634 <tcp_output+0x13c>
 8049708:	2001      	movs	r0, #1
 804970a:	4450      	add	r0, sl
 804970c:	4448      	add	r0, r9
    if (TCP_SEQ_LT(pcb->snd_nxt, snd_nxt)) {
 804970e:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
 8049710:	1a1b      	subs	r3, r3, r0
 8049712:	2b00      	cmp	r3, #0
 8049714:	db90      	blt.n	8049638 <tcp_output+0x140>
    if (TCP_TCPLEN(seg) > 0) {
 8049716:	f8b4 9008 	ldrh.w	r9, [r4, #8]
 804971a:	68e3      	ldr	r3, [r4, #12]
 804971c:	8998      	ldrh	r0, [r3, #12]
 804971e:	f7fb fea7 	bl	8045470 <lwip_htons>
 8049722:	f010 0f03 	tst.w	r0, #3
 8049726:	d089      	beq.n	804963c <tcp_output+0x144>
 8049728:	2301      	movs	r3, #1
 804972a:	eb19 0f03 	cmn.w	r9, r3
 804972e:	d0a6      	beq.n	804967e <tcp_output+0x186>
      seg->next = NULL;
 8049730:	2300      	movs	r3, #0
 8049732:	6023      	str	r3, [r4, #0]
      if (pcb->unacked == NULL) {
 8049734:	6eeb      	ldr	r3, [r5, #108]	; 0x6c
 8049736:	2b00      	cmp	r3, #0
 8049738:	d082      	beq.n	8049640 <tcp_output+0x148>
        if (TCP_SEQ_LT(lwip_ntohl(seg->tcphdr->seqno), lwip_ntohl(useg->tcphdr->seqno))) {
 804973a:	68e3      	ldr	r3, [r4, #12]
 804973c:	6858      	ldr	r0, [r3, #4]
 804973e:	f7fb fe9a 	bl	8045476 <lwip_htonl>
 8049742:	4681      	mov	r9, r0
 8049744:	68f3      	ldr	r3, [r6, #12]
 8049746:	6858      	ldr	r0, [r3, #4]
 8049748:	f7fb fe95 	bl	8045476 <lwip_htonl>
 804974c:	eba9 0900 	sub.w	r9, r9, r0
 8049750:	f1b9 0f00 	cmp.w	r9, #0
 8049754:	f6ff af77 	blt.w	8049646 <tcp_output+0x14e>
          useg->next = seg;
 8049758:	6034      	str	r4, [r6, #0]
          useg = useg->next;
 804975a:	4626      	mov	r6, r4
 804975c:	e792      	b.n	8049684 <tcp_output+0x18c>
    pcb->unsent_oversize = 0;
 804975e:	f8a5 3064 	strh.w	r3, [r5, #100]	; 0x64
 8049762:	e74e      	b.n	8049602 <tcp_output+0x10a>
    return ERR_OK;
 8049764:	2300      	movs	r3, #0
 8049766:	e751      	b.n	804960c <tcp_output+0x114>
    return ERR_RTE;
 8049768:	f06f 0303 	mvn.w	r3, #3
 804976c:	e74e      	b.n	804960c <tcp_output+0x114>
      return ERR_RTE;
 804976e:	f06f 0303 	mvn.w	r3, #3
 8049772:	e74b      	b.n	804960c <tcp_output+0x114>
 8049774:	20008734 	.word	0x20008734
 8049778:	08059dbc 	.word	0x08059dbc
 804977c:	0805a198 	.word	0x0805a198
 8049780:	08058ecc 	.word	0x08058ecc
 8049784:	0805a1c0 	.word	0x0805a1c0

08049788 <tcp_rst>:
 */
void
tcp_rst(u32_t seqno, u32_t ackno,
  const ip_addr_t *local_ip, const ip_addr_t *remote_ip,
  u16_t local_port, u16_t remote_port)
{
 8049788:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 804978c:	b085      	sub	sp, #20
 804978e:	4680      	mov	r8, r0
 8049790:	460f      	mov	r7, r1
 8049792:	4691      	mov	r9, r2
 8049794:	461d      	mov	r5, r3
  struct pbuf *p;
  struct tcp_hdr *tcphdr;
  struct netif *netif;
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
 8049796:	2200      	movs	r2, #0
 8049798:	2114      	movs	r1, #20
 804979a:	2001      	movs	r0, #1
 804979c:	f7fc fb02 	bl	8045da4 <pbuf_alloc>
  if (p == NULL) {
 80497a0:	b3b0      	cbz	r0, 8049810 <tcp_rst+0x88>
 80497a2:	4606      	mov	r6, r0
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_rst: could not allocate memory for pbuf\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
 80497a4:	8943      	ldrh	r3, [r0, #10]
 80497a6:	2b13      	cmp	r3, #19
 80497a8:	d935      	bls.n	8049816 <tcp_rst+0x8e>
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = (struct tcp_hdr *)p->payload;
 80497aa:	6874      	ldr	r4, [r6, #4]
  tcphdr->src = lwip_htons(local_port);
 80497ac:	f8bd 0030 	ldrh.w	r0, [sp, #48]	; 0x30
 80497b0:	f7fb fe5e 	bl	8045470 <lwip_htons>
 80497b4:	8020      	strh	r0, [r4, #0]
  tcphdr->dest = lwip_htons(remote_port);
 80497b6:	f8bd 0034 	ldrh.w	r0, [sp, #52]	; 0x34
 80497ba:	f7fb fe59 	bl	8045470 <lwip_htons>
 80497be:	8060      	strh	r0, [r4, #2]
  tcphdr->seqno = lwip_htonl(seqno);
 80497c0:	4640      	mov	r0, r8
 80497c2:	f7fb fe58 	bl	8045476 <lwip_htonl>
 80497c6:	6060      	str	r0, [r4, #4]
  tcphdr->ackno = lwip_htonl(ackno);
 80497c8:	4638      	mov	r0, r7
 80497ca:	f7fb fe54 	bl	8045476 <lwip_htonl>
 80497ce:	60a0      	str	r0, [r4, #8]
  TCPH_HDRLEN_FLAGS_SET(tcphdr, TCP_HLEN/4, TCP_RST | TCP_ACK);
 80497d0:	f245 0014 	movw	r0, #20500	; 0x5014
 80497d4:	f7fb fe4c 	bl	8045470 <lwip_htons>
 80497d8:	81a0      	strh	r0, [r4, #12]
#if LWIP_WND_SCALE
  tcphdr->wnd = PP_HTONS(((TCP_WND >> TCP_RCV_SCALE) & 0xFFFF));
#else
  tcphdr->wnd = PP_HTONS(TCP_WND);
 80497da:	2300      	movs	r3, #0
 80497dc:	2208      	movs	r2, #8
 80497de:	73a2      	strb	r2, [r4, #14]
 80497e0:	2260      	movs	r2, #96	; 0x60
 80497e2:	73e2      	strb	r2, [r4, #15]
#endif
  tcphdr->chksum = 0;
 80497e4:	7423      	strb	r3, [r4, #16]
 80497e6:	7463      	strb	r3, [r4, #17]
  tcphdr->urgp = 0;
 80497e8:	74a3      	strb	r3, [r4, #18]
 80497ea:	74e3      	strb	r3, [r4, #19]

  TCP_STATS_INC(tcp.xmit);
  MIB2_STATS_INC(mib2.tcpoutrsts);

  netif = ip_route(local_ip, remote_ip);
 80497ec:	4628      	mov	r0, r5
 80497ee:	f001 f87f 	bl	804a8f0 <ip4_route>
  if (netif != NULL) {
 80497f2:	b150      	cbz	r0, 804980a <tcp_rst+0x82>
      tcphdr->chksum = ip_chksum_pseudo(p, IP_PROTO_TCP, p->tot_len,
                                        local_ip, remote_ip);
    }
#endif
    /* Send output with hardcoded TTL/HL since we have no access to the pcb */
    ip_output_if(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP, netif);
 80497f4:	9002      	str	r0, [sp, #8]
 80497f6:	2306      	movs	r3, #6
 80497f8:	9301      	str	r3, [sp, #4]
 80497fa:	2300      	movs	r3, #0
 80497fc:	9300      	str	r3, [sp, #0]
 80497fe:	23ff      	movs	r3, #255	; 0xff
 8049800:	462a      	mov	r2, r5
 8049802:	4649      	mov	r1, r9
 8049804:	4630      	mov	r0, r6
 8049806:	f001 f9fb 	bl	804ac00 <ip4_output_if>
  }
  pbuf_free(p);
 804980a:	4630      	mov	r0, r6
 804980c:	f7fc fa66 	bl	8045cdc <pbuf_free>
  LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_rst: seqno %"U32_F" ackno %"U32_F".\n", seqno, ackno));
}
 8049810:	b005      	add	sp, #20
 8049812:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
 8049816:	4b04      	ldr	r3, [pc, #16]	; (8049828 <tcp_rst+0xa0>)
 8049818:	f240 524c 	movw	r2, #1356	; 0x54c
 804981c:	4903      	ldr	r1, [pc, #12]	; (804982c <tcp_rst+0xa4>)
 804981e:	4804      	ldr	r0, [pc, #16]	; (8049830 <tcp_rst+0xa8>)
 8049820:	f008 f912 	bl	8051a48 <printf>
 8049824:	e7c1      	b.n	80497aa <tcp_rst+0x22>
 8049826:	bf00      	nop
 8049828:	08059dbc 	.word	0x08059dbc
 804982c:	08059e8c 	.word	0x08059e8c
 8049830:	08058ecc 	.word	0x08058ecc

08049834 <tcp_rexmit_rto>:
 *
 * @param pcb the tcp_pcb for which to re-enqueue all unacked segments
 */
void
tcp_rexmit_rto(struct tcp_pcb *pcb)
{
 8049834:	b508      	push	{r3, lr}
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
 8049836:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
 8049838:	b1a3      	cbz	r3, 8049864 <tcp_rexmit_rto+0x30>
    return;
  }

  /* Move all unacked segments to the head of the unsent queue */
  for (seg = pcb->unacked; seg->next != NULL; seg = seg->next);
 804983a:	461a      	mov	r2, r3
 804983c:	681b      	ldr	r3, [r3, #0]
 804983e:	2b00      	cmp	r3, #0
 8049840:	d1fb      	bne.n	804983a <tcp_rexmit_rto+0x6>
  /* concatenate unsent queue after unacked queue */
  seg->next = pcb->unsent;
 8049842:	6e83      	ldr	r3, [r0, #104]	; 0x68
 8049844:	6013      	str	r3, [r2, #0]
  if (pcb->unsent == NULL) {
    pcb->unsent_oversize = seg->oversize_left;
  }
#endif /* TCP_OVERSIZE_DBGCHECK */
  /* unsent queue is the concatenated queue (of unacked, unsent) */
  pcb->unsent = pcb->unacked;
 8049846:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
 8049848:	6683      	str	r3, [r0, #104]	; 0x68
  /* unacked queue is now empty */
  pcb->unacked = NULL;
 804984a:	2300      	movs	r3, #0
 804984c:	66c3      	str	r3, [r0, #108]	; 0x6c

  /* increment number of retransmissions */
  if (pcb->nrtx < 0xFF) {
 804984e:	f890 3042 	ldrb.w	r3, [r0, #66]	; 0x42
 8049852:	2bff      	cmp	r3, #255	; 0xff
 8049854:	d002      	beq.n	804985c <tcp_rexmit_rto+0x28>
    ++pcb->nrtx;
 8049856:	3301      	adds	r3, #1
 8049858:	f880 3042 	strb.w	r3, [r0, #66]	; 0x42
  }

  /* Don't take any RTT measurements after retransmitting. */
  pcb->rttest = 0;
 804985c:	2300      	movs	r3, #0
 804985e:	6343      	str	r3, [r0, #52]	; 0x34

  /* Do the actual retransmission */
  tcp_output(pcb);
 8049860:	f7ff fe4a 	bl	80494f8 <tcp_output>
}
 8049864:	bd08      	pop	{r3, pc}

08049866 <tcp_rexmit>:
 *
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void
tcp_rexmit(struct tcp_pcb *pcb)
{
 8049866:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  struct tcp_seg *seg;
  struct tcp_seg **cur_seg;

  if (pcb->unacked == NULL) {
 8049868:	6ec6      	ldr	r6, [r0, #108]	; 0x6c
 804986a:	b316      	cbz	r6, 80498b2 <tcp_rexmit+0x4c>
 804986c:	4607      	mov	r7, r0
  }

  /* Move the first unacked segment to the unsent queue */
  /* Keep the unsent queue sorted. */
  seg = pcb->unacked;
  pcb->unacked = seg->next;
 804986e:	6833      	ldr	r3, [r6, #0]
 8049870:	66c3      	str	r3, [r0, #108]	; 0x6c

  cur_seg = &(pcb->unsent);
 8049872:	f100 0568 	add.w	r5, r0, #104	; 0x68
  while (*cur_seg &&
 8049876:	682b      	ldr	r3, [r5, #0]
 8049878:	b16b      	cbz	r3, 8049896 <tcp_rexmit+0x30>
    TCP_SEQ_LT(lwip_ntohl((*cur_seg)->tcphdr->seqno), lwip_ntohl(seg->tcphdr->seqno))) {
 804987a:	68db      	ldr	r3, [r3, #12]
 804987c:	6858      	ldr	r0, [r3, #4]
 804987e:	f7fb fdfa 	bl	8045476 <lwip_htonl>
 8049882:	4604      	mov	r4, r0
 8049884:	68f3      	ldr	r3, [r6, #12]
 8049886:	6858      	ldr	r0, [r3, #4]
 8049888:	f7fb fdf5 	bl	8045476 <lwip_htonl>
 804988c:	1a24      	subs	r4, r4, r0
  while (*cur_seg &&
 804988e:	2c00      	cmp	r4, #0
 8049890:	da01      	bge.n	8049896 <tcp_rexmit+0x30>
      cur_seg = &((*cur_seg)->next );
 8049892:	682d      	ldr	r5, [r5, #0]
 8049894:	e7ef      	b.n	8049876 <tcp_rexmit+0x10>
  }
  seg->next = *cur_seg;
 8049896:	682b      	ldr	r3, [r5, #0]
 8049898:	6033      	str	r3, [r6, #0]
  *cur_seg = seg;
 804989a:	602e      	str	r6, [r5, #0]
#if TCP_OVERSIZE
  if (seg->next == NULL) {
 804989c:	6833      	ldr	r3, [r6, #0]
 804989e:	b14b      	cbz	r3, 80498b4 <tcp_rexmit+0x4e>
    /* the retransmitted segment is last in unsent, so reset unsent_oversize */
    pcb->unsent_oversize = 0;
  }
#endif /* TCP_OVERSIZE */

  if (pcb->nrtx < 0xFF) {
 80498a0:	f897 3042 	ldrb.w	r3, [r7, #66]	; 0x42
 80498a4:	2bff      	cmp	r3, #255	; 0xff
 80498a6:	d002      	beq.n	80498ae <tcp_rexmit+0x48>
    ++pcb->nrtx;
 80498a8:	3301      	adds	r3, #1
 80498aa:	f887 3042 	strb.w	r3, [r7, #66]	; 0x42
  }

  /* Don't take any rtt measurements after retransmitting. */
  pcb->rttest = 0;
 80498ae:	2300      	movs	r3, #0
 80498b0:	637b      	str	r3, [r7, #52]	; 0x34

  /* Do the actual retransmission. */
  MIB2_STATS_INC(mib2.tcpretranssegs);
  /* No need to call tcp_output: we are always called from tcp_input()
     and thus tcp_output directly returns. */
}
 80498b2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    pcb->unsent_oversize = 0;
 80498b4:	f8a7 3064 	strh.w	r3, [r7, #100]	; 0x64
 80498b8:	e7f2      	b.n	80498a0 <tcp_rexmit+0x3a>

080498ba <tcp_rexmit_fast>:
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void
tcp_rexmit_fast(struct tcp_pcb *pcb)
{
  if (pcb->unacked != NULL && !(pcb->flags & TF_INFR)) {
 80498ba:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
 80498bc:	b33b      	cbz	r3, 804990e <tcp_rexmit_fast+0x54>
{
 80498be:	b510      	push	{r4, lr}
 80498c0:	4604      	mov	r4, r0
  if (pcb->unacked != NULL && !(pcb->flags & TF_INFR)) {
 80498c2:	7e83      	ldrb	r3, [r0, #26]
 80498c4:	f013 0f04 	tst.w	r3, #4
 80498c8:	d000      	beq.n	80498cc <tcp_rexmit_fast+0x12>
    pcb->flags |= TF_INFR;

    /* Reset the retransmission timer to prevent immediate rto retransmissions */
    pcb->rtime = 0;
  }
}
 80498ca:	bd10      	pop	{r4, pc}
    tcp_rexmit(pcb);
 80498cc:	f7ff ffcb 	bl	8049866 <tcp_rexmit>
    pcb->ssthresh = LWIP_MIN(pcb->cwnd, pcb->snd_wnd) / 2;
 80498d0:	f8b4 305c 	ldrh.w	r3, [r4, #92]	; 0x5c
 80498d4:	f8b4 2048 	ldrh.w	r2, [r4, #72]	; 0x48
 80498d8:	4293      	cmp	r3, r2
 80498da:	bf28      	it	cs
 80498dc:	4613      	movcs	r3, r2
 80498de:	085b      	lsrs	r3, r3, #1
 80498e0:	f8a4 304a 	strh.w	r3, [r4, #74]	; 0x4a
    if (pcb->ssthresh < (2U * pcb->mss)) {
 80498e4:	8e62      	ldrh	r2, [r4, #50]	; 0x32
 80498e6:	ebb3 0f42 	cmp.w	r3, r2, lsl #1
 80498ea:	d202      	bcs.n	80498f2 <tcp_rexmit_fast+0x38>
      pcb->ssthresh = 2*pcb->mss;
 80498ec:	0053      	lsls	r3, r2, #1
 80498ee:	f8a4 304a 	strh.w	r3, [r4, #74]	; 0x4a
    pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
 80498f2:	f8b4 304a 	ldrh.w	r3, [r4, #74]	; 0x4a
 80498f6:	eb02 0242 	add.w	r2, r2, r2, lsl #1
 80498fa:	441a      	add	r2, r3
 80498fc:	f8a4 2048 	strh.w	r2, [r4, #72]	; 0x48
    pcb->flags |= TF_INFR;
 8049900:	7ea3      	ldrb	r3, [r4, #26]
 8049902:	f043 0304 	orr.w	r3, r3, #4
 8049906:	76a3      	strb	r3, [r4, #26]
    pcb->rtime = 0;
 8049908:	2300      	movs	r3, #0
 804990a:	8623      	strh	r3, [r4, #48]	; 0x30
}
 804990c:	e7dd      	b.n	80498ca <tcp_rexmit_fast+0x10>
 804990e:	4770      	bx	lr

08049910 <tcp_keepalive>:
 *
 * @param pcb the tcp_pcb for which to send a keepalive packet
 */
err_t
tcp_keepalive(struct tcp_pcb *pcb)
{
 8049910:	b570      	push	{r4, r5, r6, lr}
 8049912:	b084      	sub	sp, #16
 8049914:	4604      	mov	r4, r0
  LWIP_DEBUGF(TCP_DEBUG, ("\n"));

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: tcp_ticks %"U32_F"   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n",
                          tcp_ticks, pcb->tmr, (u16_t)pcb->keep_cnt_sent));

  p = tcp_output_alloc_header(pcb, 0, 0, lwip_htonl(pcb->snd_nxt - 1));
 8049916:	6cc0      	ldr	r0, [r0, #76]	; 0x4c
 8049918:	3801      	subs	r0, #1
 804991a:	f7fb fdac 	bl	8045476 <lwip_htonl>
 804991e:	4603      	mov	r3, r0
 8049920:	2200      	movs	r2, #0
 8049922:	4611      	mov	r1, r2
 8049924:	4620      	mov	r0, r4
 8049926:	f7ff f987 	bl	8048c38 <tcp_output_alloc_header>
  if (p == NULL) {
 804992a:	b1d0      	cbz	r0, 8049962 <tcp_keepalive+0x52>
 804992c:	4605      	mov	r5, r0
    LWIP_DEBUGF(TCP_DEBUG,
                ("tcp_keepalive: could not allocate memory for pbuf\n"));
    return ERR_MEM;
  }
  netif = ip_route(&pcb->local_ip, &pcb->remote_ip);
 804992e:	1d26      	adds	r6, r4, #4
 8049930:	4630      	mov	r0, r6
 8049932:	f000 ffdd 	bl	804a8f0 <ip4_route>
  if (netif == NULL) {
 8049936:	b188      	cbz	r0, 804995c <tcp_keepalive+0x4c>
#endif /* CHECKSUM_GEN_TCP */
    TCP_STATS_INC(tcp.xmit);

    /* Send output to IP */
    NETIF_SET_HWADDRHINT(netif, &(pcb->addr_hint));
    err = ip_output_if(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP, netif);
 8049938:	9002      	str	r0, [sp, #8]
 804993a:	2306      	movs	r3, #6
 804993c:	9301      	str	r3, [sp, #4]
 804993e:	2300      	movs	r3, #0
 8049940:	9300      	str	r3, [sp, #0]
 8049942:	7aa3      	ldrb	r3, [r4, #10]
 8049944:	4632      	mov	r2, r6
 8049946:	4621      	mov	r1, r4
 8049948:	4628      	mov	r0, r5
 804994a:	f001 f959 	bl	804ac00 <ip4_output_if>
 804994e:	4604      	mov	r4, r0
    NETIF_SET_HWADDRHINT(netif, NULL);
  }
  pbuf_free(p);
 8049950:	4628      	mov	r0, r5
 8049952:	f7fc f9c3 	bl	8045cdc <pbuf_free>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: seqno %"U32_F" ackno %"U32_F" err %d.\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt, (int)err));
  return err;
}
 8049956:	4620      	mov	r0, r4
 8049958:	b004      	add	sp, #16
 804995a:	bd70      	pop	{r4, r5, r6, pc}
    err = ERR_RTE;
 804995c:	f06f 0403 	mvn.w	r4, #3
 8049960:	e7f6      	b.n	8049950 <tcp_keepalive+0x40>
    return ERR_MEM;
 8049962:	f04f 34ff 	mov.w	r4, #4294967295
 8049966:	e7f6      	b.n	8049956 <tcp_keepalive+0x46>

08049968 <tcp_zero_window_probe>:
 *
 * @param pcb the tcp_pcb for which to send a zero-window probe packet
 */
err_t
tcp_zero_window_probe(struct tcp_pcb *pcb)
{
 8049968:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 804996c:	b084      	sub	sp, #16
 804996e:	4604      	mov	r4, r0
  LWIP_DEBUGF(TCP_DEBUG,
              ("tcp_zero_window_probe: tcp_ticks %"U32_F
               "   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n",
               tcp_ticks, pcb->tmr, (u16_t)pcb->keep_cnt_sent));

  seg = pcb->unacked;
 8049970:	6ec5      	ldr	r5, [r0, #108]	; 0x6c

  if (seg == NULL) {
 8049972:	b16d      	cbz	r5, 8049990 <tcp_zero_window_probe+0x28>
    seg = pcb->unsent;
  }
  if (seg == NULL) {
 8049974:	2d00      	cmp	r5, #0
 8049976:	d05c      	beq.n	8049a32 <tcp_zero_window_probe+0xca>
    /* nothing to send, zero window probe not needed */
    return ERR_OK;
  }

  is_fin = ((TCPH_FLAGS(seg->tcphdr) & TCP_FIN) != 0) && (seg->len == 0);
 8049978:	68eb      	ldr	r3, [r5, #12]
 804997a:	8998      	ldrh	r0, [r3, #12]
 804997c:	f7fb fd78 	bl	8045470 <lwip_htons>
 8049980:	f010 0f01 	tst.w	r0, #1
 8049984:	d006      	beq.n	8049994 <tcp_zero_window_probe+0x2c>
 8049986:	892b      	ldrh	r3, [r5, #8]
 8049988:	2b00      	cmp	r3, #0
 804998a:	d040      	beq.n	8049a0e <tcp_zero_window_probe+0xa6>
 804998c:	2200      	movs	r2, #0
 804998e:	e002      	b.n	8049996 <tcp_zero_window_probe+0x2e>
    seg = pcb->unsent;
 8049990:	6e85      	ldr	r5, [r0, #104]	; 0x68
 8049992:	e7ef      	b.n	8049974 <tcp_zero_window_probe+0xc>
  is_fin = ((TCPH_FLAGS(seg->tcphdr) & TCP_FIN) != 0) && (seg->len == 0);
 8049994:	2200      	movs	r2, #0
  /* we want to send one seqno: either FIN or data (no options) */
  len = is_fin ? 0 : 1;
 8049996:	f002 06ff 	and.w	r6, r2, #255	; 0xff

  p = tcp_output_alloc_header(pcb, 0, len, seg->tcphdr->seqno);
 804999a:	68eb      	ldr	r3, [r5, #12]
 804999c:	685b      	ldr	r3, [r3, #4]
 804999e:	f082 0201 	eor.w	r2, r2, #1
 80499a2:	2100      	movs	r1, #0
 80499a4:	4620      	mov	r0, r4
 80499a6:	f7ff f947 	bl	8048c38 <tcp_output_alloc_header>
  if (p == NULL) {
 80499aa:	4607      	mov	r7, r0
 80499ac:	2800      	cmp	r0, #0
 80499ae:	d042      	beq.n	8049a36 <tcp_zero_window_probe+0xce>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: no memory for pbuf\n"));
    return ERR_MEM;
  }
  tcphdr = (struct tcp_hdr *)p->payload;
 80499b0:	f8d0 8004 	ldr.w	r8, [r0, #4]

  if (is_fin) {
 80499b4:	b36e      	cbz	r6, 8049a12 <tcp_zero_window_probe+0xaa>
    /* FIN segment, no data */
    TCPH_FLAGS_SET(tcphdr, TCP_ACK | TCP_FIN);
 80499b6:	f8b8 600c 	ldrh.w	r6, [r8, #12]
 80499ba:	f426 567c 	bic.w	r6, r6, #16128	; 0x3f00
 80499be:	b2b6      	uxth	r6, r6
 80499c0:	2011      	movs	r0, #17
 80499c2:	f7fb fd55 	bl	8045470 <lwip_htons>
 80499c6:	4306      	orrs	r6, r0
 80499c8:	f8a8 600c 	strh.w	r6, [r8, #12]
       Ensure we copy the first TCP data byte: */
    pbuf_copy_partial(seg->p, d, 1, seg->p->tot_len - seg->len);
  }

  /* The byte may be acknowledged without the window being opened. */
  snd_nxt = lwip_ntohl(seg->tcphdr->seqno) + 1;
 80499cc:	68eb      	ldr	r3, [r5, #12]
 80499ce:	6858      	ldr	r0, [r3, #4]
 80499d0:	f7fb fd51 	bl	8045476 <lwip_htonl>
 80499d4:	3001      	adds	r0, #1
  if (TCP_SEQ_LT(pcb->snd_nxt, snd_nxt)) {
 80499d6:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 80499d8:	1a1b      	subs	r3, r3, r0
 80499da:	2b00      	cmp	r3, #0
 80499dc:	db24      	blt.n	8049a28 <tcp_zero_window_probe+0xc0>
    pcb->snd_nxt = snd_nxt;
  }

  netif = ip_route(&pcb->local_ip, &pcb->remote_ip);
 80499de:	1d25      	adds	r5, r4, #4
 80499e0:	4628      	mov	r0, r5
 80499e2:	f000 ff85 	bl	804a8f0 <ip4_route>
  if (netif == NULL) {
 80499e6:	b308      	cbz	r0, 8049a2c <tcp_zero_window_probe+0xc4>
#endif
    TCP_STATS_INC(tcp.xmit);

    /* Send output to IP */
    NETIF_SET_HWADDRHINT(netif, &(pcb->addr_hint));
    err = ip_output_if(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl,
 80499e8:	9002      	str	r0, [sp, #8]
 80499ea:	2306      	movs	r3, #6
 80499ec:	9301      	str	r3, [sp, #4]
 80499ee:	2300      	movs	r3, #0
 80499f0:	9300      	str	r3, [sp, #0]
 80499f2:	7aa3      	ldrb	r3, [r4, #10]
 80499f4:	462a      	mov	r2, r5
 80499f6:	4621      	mov	r1, r4
 80499f8:	4638      	mov	r0, r7
 80499fa:	f001 f901 	bl	804ac00 <ip4_output_if>
 80499fe:	4604      	mov	r4, r0
      0, IP_PROTO_TCP, netif);
    NETIF_SET_HWADDRHINT(netif, NULL);
  }

  pbuf_free(p);
 8049a00:	4638      	mov	r0, r7
 8049a02:	f7fc f96b 	bl	8045cdc <pbuf_free>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: seqno %"U32_F
                          " ackno %"U32_F" err %d.\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt, (int)err));
  return err;
}
 8049a06:	4620      	mov	r0, r4
 8049a08:	b004      	add	sp, #16
 8049a0a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  is_fin = ((TCPH_FLAGS(seg->tcphdr) & TCP_FIN) != 0) && (seg->len == 0);
 8049a0e:	2201      	movs	r2, #1
 8049a10:	e7c1      	b.n	8049996 <tcp_zero_window_probe+0x2e>
    pbuf_copy_partial(seg->p, d, 1, seg->p->tot_len - seg->len);
 8049a12:	6868      	ldr	r0, [r5, #4]
 8049a14:	8903      	ldrh	r3, [r0, #8]
 8049a16:	892a      	ldrh	r2, [r5, #8]
 8049a18:	1a9b      	subs	r3, r3, r2
 8049a1a:	b29b      	uxth	r3, r3
 8049a1c:	2201      	movs	r2, #1
 8049a1e:	f108 0114 	add.w	r1, r8, #20
 8049a22:	f7fc fc19 	bl	8046258 <pbuf_copy_partial>
 8049a26:	e7d1      	b.n	80499cc <tcp_zero_window_probe+0x64>
    pcb->snd_nxt = snd_nxt;
 8049a28:	64e0      	str	r0, [r4, #76]	; 0x4c
 8049a2a:	e7d8      	b.n	80499de <tcp_zero_window_probe+0x76>
    err = ERR_RTE;
 8049a2c:	f06f 0403 	mvn.w	r4, #3
 8049a30:	e7e6      	b.n	8049a00 <tcp_zero_window_probe+0x98>
    return ERR_OK;
 8049a32:	2400      	movs	r4, #0
 8049a34:	e7e7      	b.n	8049a06 <tcp_zero_window_probe+0x9e>
    return ERR_MEM;
 8049a36:	f04f 34ff 	mov.w	r4, #4294967295
 8049a3a:	e7e4      	b.n	8049a06 <tcp_zero_window_probe+0x9e>

08049a3c <sys_timeout>:
sys_timeout_debug(u32_t msecs, sys_timeout_handler handler, void *arg, const char* handler_name)
#else /* LWIP_DEBUG_TIMERNAMES */
void
sys_timeout(u32_t msecs, sys_timeout_handler handler, void *arg)
#endif /* LWIP_DEBUG_TIMERNAMES */
{
 8049a3c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8049a40:	4605      	mov	r5, r0
 8049a42:	4688      	mov	r8, r1
 8049a44:	4617      	mov	r7, r2
  struct sys_timeo *timeout, *t;
  u32_t now, diff;

  timeout = (struct sys_timeo *)memp_malloc(MEMP_SYS_TIMEOUT);
 8049a46:	2006      	movs	r0, #6
 8049a48:	f7fb ff7a 	bl	8045940 <memp_malloc>
  if (timeout == NULL) {
 8049a4c:	b1d0      	cbz	r0, 8049a84 <sys_timeout+0x48>
 8049a4e:	4604      	mov	r4, r0
    LWIP_ASSERT("sys_timeout: timeout != NULL, pool MEMP_SYS_TIMEOUT is empty", timeout != NULL);
    return;
  }

  now = sys_now();
 8049a50:	f002 f942 	bl	804bcd8 <sys_now>
  if (next_timeout == NULL) {
 8049a54:	4b20      	ldr	r3, [pc, #128]	; (8049ad8 <sys_timeout+0x9c>)
 8049a56:	681e      	ldr	r6, [r3, #0]
 8049a58:	b1de      	cbz	r6, 8049a92 <sys_timeout+0x56>
    diff = 0;
    timeouts_last_time = now;
  } else {
    diff = now - timeouts_last_time;
 8049a5a:	4b1f      	ldr	r3, [pc, #124]	; (8049ad8 <sys_timeout+0x9c>)
 8049a5c:	685b      	ldr	r3, [r3, #4]
 8049a5e:	1ac3      	subs	r3, r0, r3
  }

  timeout->next = NULL;
 8049a60:	2200      	movs	r2, #0
 8049a62:	6022      	str	r2, [r4, #0]
  timeout->h = handler;
 8049a64:	f8c4 8008 	str.w	r8, [r4, #8]
  timeout->arg = arg;
 8049a68:	60e7      	str	r7, [r4, #12]
  timeout->time = msecs + diff;
 8049a6a:	442b      	add	r3, r5
 8049a6c:	6063      	str	r3, [r4, #4]
  timeout->handler_name = handler_name;
  LWIP_DEBUGF(TIMERS_DEBUG, ("sys_timeout: %p msecs=%"U32_F" handler=%s arg=%p\n",
    (void *)timeout, msecs, handler_name, (void *)arg));
#endif /* LWIP_DEBUG_TIMERNAMES */

  if (next_timeout == NULL) {
 8049a6e:	b19e      	cbz	r6, 8049a98 <sys_timeout+0x5c>
    next_timeout = timeout;
    return;
  }

  if (next_timeout->time > msecs) {
 8049a70:	6870      	ldr	r0, [r6, #4]
 8049a72:	42a8      	cmp	r0, r5
 8049a74:	d921      	bls.n	8049aba <sys_timeout+0x7e>
    next_timeout->time -= msecs;
 8049a76:	1b40      	subs	r0, r0, r5
 8049a78:	6070      	str	r0, [r6, #4]
    timeout->next = next_timeout;
 8049a7a:	6026      	str	r6, [r4, #0]
    next_timeout = timeout;
 8049a7c:	4b16      	ldr	r3, [pc, #88]	; (8049ad8 <sys_timeout+0x9c>)
 8049a7e:	601c      	str	r4, [r3, #0]
        t->next = timeout;
        break;
      }
    }
  }
}
 8049a80:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    LWIP_ASSERT("sys_timeout: timeout != NULL, pool MEMP_SYS_TIMEOUT is empty", timeout != NULL);
 8049a84:	4b15      	ldr	r3, [pc, #84]	; (8049adc <sys_timeout+0xa0>)
 8049a86:	22d4      	movs	r2, #212	; 0xd4
 8049a88:	4915      	ldr	r1, [pc, #84]	; (8049ae0 <sys_timeout+0xa4>)
 8049a8a:	4816      	ldr	r0, [pc, #88]	; (8049ae4 <sys_timeout+0xa8>)
 8049a8c:	f007 ffdc 	bl	8051a48 <printf>
    return;
 8049a90:	e7f6      	b.n	8049a80 <sys_timeout+0x44>
    timeouts_last_time = now;
 8049a92:	6058      	str	r0, [r3, #4]
    diff = 0;
 8049a94:	2300      	movs	r3, #0
 8049a96:	e7e3      	b.n	8049a60 <sys_timeout+0x24>
    next_timeout = timeout;
 8049a98:	4b0f      	ldr	r3, [pc, #60]	; (8049ad8 <sys_timeout+0x9c>)
 8049a9a:	601c      	str	r4, [r3, #0]
    return;
 8049a9c:	e7f0      	b.n	8049a80 <sys_timeout+0x44>
        if (t->next != NULL) {
 8049a9e:	b131      	cbz	r1, 8049aae <sys_timeout+0x72>
          t->next->time -= timeout->time;
 8049aa0:	6848      	ldr	r0, [r1, #4]
 8049aa2:	1ac3      	subs	r3, r0, r3
 8049aa4:	604b      	str	r3, [r1, #4]
        timeout->next = t->next;
 8049aa6:	6813      	ldr	r3, [r2, #0]
 8049aa8:	6023      	str	r3, [r4, #0]
        t->next = timeout;
 8049aaa:	6014      	str	r4, [r2, #0]
        break;
 8049aac:	e7e8      	b.n	8049a80 <sys_timeout+0x44>
        } else if (timeout->time > msecs) {
 8049aae:	42ab      	cmp	r3, r5
 8049ab0:	d9f9      	bls.n	8049aa6 <sys_timeout+0x6a>
          timeout->time = msecs + next_timeout->time;
 8049ab2:	6873      	ldr	r3, [r6, #4]
 8049ab4:	441d      	add	r5, r3
 8049ab6:	6065      	str	r5, [r4, #4]
 8049ab8:	e7f5      	b.n	8049aa6 <sys_timeout+0x6a>
    for (t = next_timeout; t != NULL; t = t->next) {
 8049aba:	4632      	mov	r2, r6
 8049abc:	2a00      	cmp	r2, #0
 8049abe:	d0df      	beq.n	8049a80 <sys_timeout+0x44>
      timeout->time -= t->time;
 8049ac0:	6851      	ldr	r1, [r2, #4]
 8049ac2:	6863      	ldr	r3, [r4, #4]
 8049ac4:	1a5b      	subs	r3, r3, r1
 8049ac6:	6063      	str	r3, [r4, #4]
      if (t->next == NULL || t->next->time > timeout->time) {
 8049ac8:	6811      	ldr	r1, [r2, #0]
 8049aca:	2900      	cmp	r1, #0
 8049acc:	d0e7      	beq.n	8049a9e <sys_timeout+0x62>
 8049ace:	6848      	ldr	r0, [r1, #4]
 8049ad0:	4283      	cmp	r3, r0
 8049ad2:	d3e4      	bcc.n	8049a9e <sys_timeout+0x62>
    for (t = next_timeout; t != NULL; t = t->next) {
 8049ad4:	460a      	mov	r2, r1
 8049ad6:	e7f1      	b.n	8049abc <sys_timeout+0x80>
 8049ad8:	20004108 	.word	0x20004108
 8049adc:	0805a1d8 	.word	0x0805a1d8
 8049ae0:	0805a20c 	.word	0x0805a20c
 8049ae4:	08058ecc 	.word	0x08058ecc

08049ae8 <tcp_timer_needed>:
{
 8049ae8:	b508      	push	{r3, lr}
  if (!tcpip_tcp_timer_active && (tcp_active_pcbs || tcp_tw_pcbs)) {
 8049aea:	4b0a      	ldr	r3, [pc, #40]	; (8049b14 <tcp_timer_needed+0x2c>)
 8049aec:	689b      	ldr	r3, [r3, #8]
 8049aee:	b953      	cbnz	r3, 8049b06 <tcp_timer_needed+0x1e>
 8049af0:	4b09      	ldr	r3, [pc, #36]	; (8049b18 <tcp_timer_needed+0x30>)
 8049af2:	681b      	ldr	r3, [r3, #0]
 8049af4:	b143      	cbz	r3, 8049b08 <tcp_timer_needed+0x20>
    tcpip_tcp_timer_active = 1;
 8049af6:	4b07      	ldr	r3, [pc, #28]	; (8049b14 <tcp_timer_needed+0x2c>)
 8049af8:	2201      	movs	r2, #1
 8049afa:	609a      	str	r2, [r3, #8]
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
 8049afc:	2200      	movs	r2, #0
 8049afe:	4907      	ldr	r1, [pc, #28]	; (8049b1c <tcp_timer_needed+0x34>)
 8049b00:	20fa      	movs	r0, #250	; 0xfa
 8049b02:	f7ff ff9b 	bl	8049a3c <sys_timeout>
}
 8049b06:	bd08      	pop	{r3, pc}
  if (!tcpip_tcp_timer_active && (tcp_active_pcbs || tcp_tw_pcbs)) {
 8049b08:	4b05      	ldr	r3, [pc, #20]	; (8049b20 <tcp_timer_needed+0x38>)
 8049b0a:	681b      	ldr	r3, [r3, #0]
 8049b0c:	2b00      	cmp	r3, #0
 8049b0e:	d1f2      	bne.n	8049af6 <tcp_timer_needed+0xe>
 8049b10:	e7f9      	b.n	8049b06 <tcp_timer_needed+0x1e>
 8049b12:	bf00      	nop
 8049b14:	20004108 	.word	0x20004108
 8049b18:	20008720 	.word	0x20008720
 8049b1c:	08049b25 	.word	0x08049b25
 8049b20:	20008730 	.word	0x20008730

08049b24 <tcpip_tcp_timer>:
{
 8049b24:	b508      	push	{r3, lr}
  tcp_tmr();
 8049b26:	f7fd fa07 	bl	8046f38 <tcp_tmr>
  if (tcp_active_pcbs || tcp_tw_pcbs) {
 8049b2a:	4b08      	ldr	r3, [pc, #32]	; (8049b4c <tcpip_tcp_timer+0x28>)
 8049b2c:	681b      	ldr	r3, [r3, #0]
 8049b2e:	b12b      	cbz	r3, 8049b3c <tcpip_tcp_timer+0x18>
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
 8049b30:	2200      	movs	r2, #0
 8049b32:	4907      	ldr	r1, [pc, #28]	; (8049b50 <tcpip_tcp_timer+0x2c>)
 8049b34:	20fa      	movs	r0, #250	; 0xfa
 8049b36:	f7ff ff81 	bl	8049a3c <sys_timeout>
}
 8049b3a:	bd08      	pop	{r3, pc}
  if (tcp_active_pcbs || tcp_tw_pcbs) {
 8049b3c:	4b05      	ldr	r3, [pc, #20]	; (8049b54 <tcpip_tcp_timer+0x30>)
 8049b3e:	681b      	ldr	r3, [r3, #0]
 8049b40:	2b00      	cmp	r3, #0
 8049b42:	d1f5      	bne.n	8049b30 <tcpip_tcp_timer+0xc>
    tcpip_tcp_timer_active = 0;
 8049b44:	4b04      	ldr	r3, [pc, #16]	; (8049b58 <tcpip_tcp_timer+0x34>)
 8049b46:	2200      	movs	r2, #0
 8049b48:	609a      	str	r2, [r3, #8]
}
 8049b4a:	e7f6      	b.n	8049b3a <tcpip_tcp_timer+0x16>
 8049b4c:	20008720 	.word	0x20008720
 8049b50:	08049b25 	.word	0x08049b25
 8049b54:	20008730 	.word	0x20008730
 8049b58:	20004108 	.word	0x20004108

08049b5c <sys_timeouts_init>:
{
 8049b5c:	b510      	push	{r4, lr}
  for (i = (LWIP_TCP ? 1 : 0); i < LWIP_ARRAYSIZE(lwip_cyclic_timers); i++) {
 8049b5e:	2401      	movs	r4, #1
 8049b60:	e008      	b.n	8049b74 <sys_timeouts_init+0x18>
    sys_timeout(lwip_cyclic_timers[i].interval_ms, cyclic_timer, LWIP_CONST_CAST(void*, &lwip_cyclic_timers[i]));
 8049b62:	4b08      	ldr	r3, [pc, #32]	; (8049b84 <sys_timeouts_init+0x28>)
 8049b64:	eb03 02c4 	add.w	r2, r3, r4, lsl #3
 8049b68:	4907      	ldr	r1, [pc, #28]	; (8049b88 <sys_timeouts_init+0x2c>)
 8049b6a:	f853 0034 	ldr.w	r0, [r3, r4, lsl #3]
 8049b6e:	f7ff ff65 	bl	8049a3c <sys_timeout>
  for (i = (LWIP_TCP ? 1 : 0); i < LWIP_ARRAYSIZE(lwip_cyclic_timers); i++) {
 8049b72:	3401      	adds	r4, #1
 8049b74:	2c02      	cmp	r4, #2
 8049b76:	d9f4      	bls.n	8049b62 <sys_timeouts_init+0x6>
  timeouts_last_time = sys_now();
 8049b78:	f002 f8ae 	bl	804bcd8 <sys_now>
 8049b7c:	4b03      	ldr	r3, [pc, #12]	; (8049b8c <sys_timeouts_init+0x30>)
 8049b7e:	6058      	str	r0, [r3, #4]
}
 8049b80:	bd10      	pop	{r4, pc}
 8049b82:	bf00      	nop
 8049b84:	08058e3c 	.word	0x08058e3c
 8049b88:	08049b91 	.word	0x08049b91
 8049b8c:	20004108 	.word	0x20004108

08049b90 <cyclic_timer>:
{
 8049b90:	b510      	push	{r4, lr}
 8049b92:	4604      	mov	r4, r0
  cyclic->handler();
 8049b94:	6843      	ldr	r3, [r0, #4]
 8049b96:	4798      	blx	r3
  sys_timeout(cyclic->interval_ms, cyclic_timer, arg);
 8049b98:	4622      	mov	r2, r4
 8049b9a:	4902      	ldr	r1, [pc, #8]	; (8049ba4 <cyclic_timer+0x14>)
 8049b9c:	6820      	ldr	r0, [r4, #0]
 8049b9e:	f7ff ff4d 	bl	8049a3c <sys_timeout>
}
 8049ba2:	bd10      	pop	{r4, pc}
 8049ba4:	08049b91 	.word	0x08049b91

08049ba8 <sys_check_timeouts>:
static
#endif /* !NO_SYS */
void
sys_check_timeouts(void)
{
  if (next_timeout) {
 8049ba8:	4b13      	ldr	r3, [pc, #76]	; (8049bf8 <sys_check_timeouts+0x50>)
 8049baa:	681b      	ldr	r3, [r3, #0]
 8049bac:	b31b      	cbz	r3, 8049bf6 <sys_check_timeouts+0x4e>
{
 8049bae:	b570      	push	{r4, r5, r6, lr}
    sys_timeout_handler handler;
    void *arg;
    u8_t had_one;
    u32_t now;

    now = sys_now();
 8049bb0:	f002 f892 	bl	804bcd8 <sys_now>
    /* this cares for wraparounds */
    diff = now - timeouts_last_time;
 8049bb4:	4b10      	ldr	r3, [pc, #64]	; (8049bf8 <sys_check_timeouts+0x50>)
 8049bb6:	685d      	ldr	r5, [r3, #4]
 8049bb8:	1b45      	subs	r5, r0, r5
    do {
      PBUF_CHECK_FREE_OOSEQ();
 8049bba:	4b10      	ldr	r3, [pc, #64]	; (8049bfc <sys_check_timeouts+0x54>)
 8049bbc:	781b      	ldrb	r3, [r3, #0]
 8049bbe:	b9b3      	cbnz	r3, 8049bee <sys_check_timeouts+0x46>
      had_one = 0;
      tmptimeout = next_timeout;
 8049bc0:	4b0d      	ldr	r3, [pc, #52]	; (8049bf8 <sys_check_timeouts+0x50>)
 8049bc2:	6819      	ldr	r1, [r3, #0]
      if (tmptimeout && (tmptimeout->time <= diff)) {
 8049bc4:	b1b1      	cbz	r1, 8049bf4 <sys_check_timeouts+0x4c>
 8049bc6:	684b      	ldr	r3, [r1, #4]
 8049bc8:	42ab      	cmp	r3, r5
 8049bca:	d813      	bhi.n	8049bf4 <sys_check_timeouts+0x4c>
        /* timeout has expired */
        had_one = 1;
        timeouts_last_time += tmptimeout->time;
 8049bcc:	4a0a      	ldr	r2, [pc, #40]	; (8049bf8 <sys_check_timeouts+0x50>)
 8049bce:	6854      	ldr	r4, [r2, #4]
 8049bd0:	441c      	add	r4, r3
 8049bd2:	6054      	str	r4, [r2, #4]
        diff -= tmptimeout->time;
 8049bd4:	1aed      	subs	r5, r5, r3
        next_timeout = tmptimeout->next;
 8049bd6:	680b      	ldr	r3, [r1, #0]
 8049bd8:	6013      	str	r3, [r2, #0]
        handler = tmptimeout->h;
 8049bda:	688c      	ldr	r4, [r1, #8]
        arg = tmptimeout->arg;
 8049bdc:	68ce      	ldr	r6, [r1, #12]
        if (handler != NULL) {
          LWIP_DEBUGF(TIMERS_DEBUG, ("sct calling h=%s arg=%p\n",
            tmptimeout->handler_name, arg));
        }
#endif /* LWIP_DEBUG_TIMERNAMES */
        memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
 8049bde:	2006      	movs	r0, #6
 8049be0:	f7fb fec8 	bl	8045974 <memp_free>
        if (handler != NULL) {
 8049be4:	2c00      	cmp	r4, #0
 8049be6:	d0e8      	beq.n	8049bba <sys_check_timeouts+0x12>
#if !NO_SYS
          /* For LWIP_TCPIP_CORE_LOCKING, lock the core before calling the
             timeout handler function. */
          LOCK_TCPIP_CORE();
#endif /* !NO_SYS */
          handler(arg);
 8049be8:	4630      	mov	r0, r6
 8049bea:	47a0      	blx	r4
#endif /* !NO_SYS */
        }
        LWIP_TCPIP_THREAD_ALIVE();
      }
    /* repeat until all expired timers have been called */
    } while (had_one);
 8049bec:	e7e5      	b.n	8049bba <sys_check_timeouts+0x12>
      PBUF_CHECK_FREE_OOSEQ();
 8049bee:	f7fc f81b 	bl	8045c28 <pbuf_free_ooseq>
 8049bf2:	e7e5      	b.n	8049bc0 <sys_check_timeouts+0x18>
  }
}
 8049bf4:	bd70      	pop	{r4, r5, r6, pc}
 8049bf6:	4770      	bx	lr
 8049bf8:	20004108 	.word	0x20004108
 8049bfc:	20008718 	.word	0x20008718

08049c00 <udp_input_local_match>:
  /* Only need to check PCB if incoming IP version matches PCB IP version */
  if (IP_ADDR_PCB_VERSION_MATCH_EXACT(pcb, ip_current_dest_addr())) {
#if LWIP_IPV4
    /* Special case: IPv4 broadcast: all or broadcasts in my subnet
     * Note: broadcast variable can only be 1 if it is an IPv4 broadcast */
    if (broadcast != 0) {
 8049c00:	4613      	mov	r3, r2
 8049c02:	b16a      	cbz	r2, 8049c20 <udp_input_local_match+0x20>
#if IP_SOF_BROADCAST_RECV
      if (ip_get_option(pcb, SOF_BROADCAST))
#endif /* IP_SOF_BROADCAST_RECV */
      {
        if (ip4_addr_isany(ip_2_ip4(&pcb->local_ip)) ||
 8049c04:	b1a8      	cbz	r0, 8049c32 <udp_input_local_match+0x32>
 8049c06:	6803      	ldr	r3, [r0, #0]
 8049c08:	b1ab      	cbz	r3, 8049c36 <udp_input_local_match+0x36>
          ((ip4_current_dest_addr()->addr == IPADDR_BROADCAST)) ||
 8049c0a:	4a11      	ldr	r2, [pc, #68]	; (8049c50 <udp_input_local_match+0x50>)
 8049c0c:	6952      	ldr	r2, [r2, #20]
        if (ip4_addr_isany(ip_2_ip4(&pcb->local_ip)) ||
 8049c0e:	f1b2 3fff 	cmp.w	r2, #4294967295
 8049c12:	d012      	beq.n	8049c3a <udp_input_local_match+0x3a>
           ip4_addr_netcmp(ip_2_ip4(&pcb->local_ip), ip4_current_dest_addr(), netif_ip4_netmask(inp))) {
 8049c14:	6889      	ldr	r1, [r1, #8]
 8049c16:	4053      	eors	r3, r2
          ((ip4_current_dest_addr()->addr == IPADDR_BROADCAST)) ||
 8049c18:	420b      	tst	r3, r1
 8049c1a:	d010      	beq.n	8049c3e <udp_input_local_match+0x3e>
    if (ip_addr_isany(&pcb->local_ip) || ip_addr_cmp(&pcb->local_ip, ip_current_dest_addr())) {
      return 1;
    }
  }

  return 0;
 8049c1c:	2000      	movs	r0, #0
 8049c1e:	4770      	bx	lr
    if (ip_addr_isany(&pcb->local_ip) || ip_addr_cmp(&pcb->local_ip, ip_current_dest_addr())) {
 8049c20:	b178      	cbz	r0, 8049c42 <udp_input_local_match+0x42>
 8049c22:	6802      	ldr	r2, [r0, #0]
 8049c24:	b17a      	cbz	r2, 8049c46 <udp_input_local_match+0x46>
 8049c26:	490a      	ldr	r1, [pc, #40]	; (8049c50 <udp_input_local_match+0x50>)
 8049c28:	6949      	ldr	r1, [r1, #20]
 8049c2a:	428a      	cmp	r2, r1
 8049c2c:	d00d      	beq.n	8049c4a <udp_input_local_match+0x4a>
  return 0;
 8049c2e:	4618      	mov	r0, r3
 8049c30:	4770      	bx	lr
          return 1;
 8049c32:	2001      	movs	r0, #1
 8049c34:	4770      	bx	lr
 8049c36:	2001      	movs	r0, #1
 8049c38:	4770      	bx	lr
 8049c3a:	2001      	movs	r0, #1
 8049c3c:	4770      	bx	lr
 8049c3e:	2001      	movs	r0, #1
 8049c40:	4770      	bx	lr
      return 1;
 8049c42:	2001      	movs	r0, #1
 8049c44:	4770      	bx	lr
 8049c46:	2001      	movs	r0, #1
 8049c48:	4770      	bx	lr
 8049c4a:	2001      	movs	r0, #1
}
 8049c4c:	4770      	bx	lr
 8049c4e:	bf00      	nop
 8049c50:	200051f0 	.word	0x200051f0

08049c54 <udp_init>:
}
 8049c54:	4770      	bx	lr
	...

08049c58 <udp_input>:
 * @param inp network interface on which the datagram was received.
 *
 */
void
udp_input(struct pbuf *p, struct netif *inp)
{
 8049c58:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8049c5c:	b085      	sub	sp, #20
 8049c5e:	4681      	mov	r9, r0
  PERF_START;

  UDP_STATS_INC(udp.recv);

  /* Check minimum length (UDP header) */
  if (p->len < UDP_HLEN) {
 8049c60:	8943      	ldrh	r3, [r0, #10]
 8049c62:	2b07      	cmp	r3, #7
 8049c64:	d917      	bls.n	8049c96 <udp_input+0x3e>
 8049c66:	460f      	mov	r7, r1
    MIB2_STATS_INC(mib2.udpinerrors);
    pbuf_free(p);
    goto end;
  }

  udphdr = (struct udp_hdr *)p->payload;
 8049c68:	6844      	ldr	r4, [r0, #4]

  /* is broadcast packet ? */
  broadcast = ip_addr_isbroadcast(ip_current_dest_addr(), ip_current_netif());
 8049c6a:	4b43      	ldr	r3, [pc, #268]	; (8049d78 <udp_input+0x120>)
 8049c6c:	6819      	ldr	r1, [r3, #0]
 8049c6e:	6958      	ldr	r0, [r3, #20]
 8049c70:	f000 ffdb 	bl	804ac2a <ip4_addr_isbroadcast_u32>
 8049c74:	4680      	mov	r8, r0

  LWIP_DEBUGF(UDP_DEBUG, ("udp_input: received datagram of length %"U16_F"\n", p->tot_len));

  /* convert src and dest ports to host byte order */
  src = lwip_ntohs(udphdr->src);
 8049c76:	8820      	ldrh	r0, [r4, #0]
 8049c78:	f7fb fbfa 	bl	8045470 <lwip_htons>
 8049c7c:	4682      	mov	sl, r0
  dest = lwip_ntohs(udphdr->dest);
 8049c7e:	8860      	ldrh	r0, [r4, #2]
 8049c80:	f7fb fbf6 	bl	8045470 <lwip_htons>
 8049c84:	4605      	mov	r5, r0
  uncon_pcb = NULL;
  /* Iterate through the UDP pcb list for a matching pcb.
   * 'Perfect match' pcbs (connected to the remote port & ip address) are
   * preferred. If no perfect match is found, the first unconnected pcb that
   * matches the local port and ip address gets the datagram. */
  for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
 8049c86:	4b3d      	ldr	r3, [pc, #244]	; (8049d7c <udp_input+0x124>)
 8049c88:	681b      	ldr	r3, [r3, #0]
 8049c8a:	9303      	str	r3, [sp, #12]
 8049c8c:	461c      	mov	r4, r3
  uncon_pcb = NULL;
 8049c8e:	f04f 0b00 	mov.w	fp, #0
  prev = NULL;
 8049c92:	465e      	mov	r6, fp
  for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
 8049c94:	e009      	b.n	8049caa <udp_input+0x52>
    pbuf_free(p);
 8049c96:	f7fc f821 	bl	8045cdc <pbuf_free>
  UDP_STATS_INC(udp.drop);
  MIB2_STATS_INC(mib2.udpinerrors);
  pbuf_free(p);
  PERF_STOP("udp_input");
#endif /* CHECKSUM_CHECK_UDP */
}
 8049c9a:	b005      	add	sp, #20
 8049c9c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      if ((pcb->remote_port == src) &&
 8049ca0:	8aa3      	ldrh	r3, [r4, #20]
 8049ca2:	4553      	cmp	r3, sl
 8049ca4:	d015      	beq.n	8049cd2 <udp_input+0x7a>
    prev = pcb;
 8049ca6:	4626      	mov	r6, r4
  for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
 8049ca8:	68e4      	ldr	r4, [r4, #12]
 8049caa:	b1fc      	cbz	r4, 8049cec <udp_input+0x94>
    if ((pcb->local_port == dest) &&
 8049cac:	8a63      	ldrh	r3, [r4, #18]
 8049cae:	42ab      	cmp	r3, r5
 8049cb0:	d1f9      	bne.n	8049ca6 <udp_input+0x4e>
        (udp_input_local_match(pcb, inp, broadcast) != 0)) {
 8049cb2:	4642      	mov	r2, r8
 8049cb4:	4639      	mov	r1, r7
 8049cb6:	4620      	mov	r0, r4
 8049cb8:	f7ff ffa2 	bl	8049c00 <udp_input_local_match>
    if ((pcb->local_port == dest) &&
 8049cbc:	2800      	cmp	r0, #0
 8049cbe:	d0f2      	beq.n	8049ca6 <udp_input+0x4e>
      if (((pcb->flags & UDP_FLAGS_CONNECTED) == 0) &&
 8049cc0:	7c23      	ldrb	r3, [r4, #16]
 8049cc2:	f013 0f04 	tst.w	r3, #4
 8049cc6:	d1eb      	bne.n	8049ca0 <udp_input+0x48>
 8049cc8:	f1bb 0f00 	cmp.w	fp, #0
 8049ccc:	d1e8      	bne.n	8049ca0 <udp_input+0x48>
        uncon_pcb = pcb;
 8049cce:	46a3      	mov	fp, r4
 8049cd0:	e7e6      	b.n	8049ca0 <udp_input+0x48>
          (ip_addr_isany_val(pcb->remote_ip) ||
 8049cd2:	6863      	ldr	r3, [r4, #4]
      if ((pcb->remote_port == src) &&
 8049cd4:	b11b      	cbz	r3, 8049cde <udp_input+0x86>
          ip_addr_cmp(&pcb->remote_ip, ip_current_src_addr()))) {
 8049cd6:	4a28      	ldr	r2, [pc, #160]	; (8049d78 <udp_input+0x120>)
 8049cd8:	6912      	ldr	r2, [r2, #16]
          (ip_addr_isany_val(pcb->remote_ip) ||
 8049cda:	4293      	cmp	r3, r2
 8049cdc:	d1e3      	bne.n	8049ca6 <udp_input+0x4e>
        if (prev != NULL) {
 8049cde:	b12e      	cbz	r6, 8049cec <udp_input+0x94>
          prev->next = pcb->next;
 8049ce0:	68e3      	ldr	r3, [r4, #12]
 8049ce2:	60f3      	str	r3, [r6, #12]
          pcb->next = udp_pcbs;
 8049ce4:	9b03      	ldr	r3, [sp, #12]
 8049ce6:	60e3      	str	r3, [r4, #12]
          udp_pcbs = pcb;
 8049ce8:	4b24      	ldr	r3, [pc, #144]	; (8049d7c <udp_input+0x124>)
 8049cea:	601c      	str	r4, [r3, #0]
  if (pcb == NULL) {
 8049cec:	b18c      	cbz	r4, 8049d12 <udp_input+0xba>
  if (pcb != NULL) {
 8049cee:	b194      	cbz	r4, 8049d16 <udp_input+0xbe>
    if (pbuf_header(p, -UDP_HLEN)) {
 8049cf0:	f06f 0107 	mvn.w	r1, #7
 8049cf4:	4648      	mov	r0, r9
 8049cf6:	f7fb ffe7 	bl	8045cc8 <pbuf_header>
 8049cfa:	b9a8      	cbnz	r0, 8049d28 <udp_input+0xd0>
    if (pcb != NULL) {
 8049cfc:	b31c      	cbz	r4, 8049d46 <udp_input+0xee>
      if (pcb->recv != NULL) {
 8049cfe:	69a5      	ldr	r5, [r4, #24]
 8049d00:	b1ed      	cbz	r5, 8049d3e <udp_input+0xe6>
        pcb->recv(pcb->recv_arg, pcb, p, ip_current_src_addr(), src);
 8049d02:	69e0      	ldr	r0, [r4, #28]
 8049d04:	f8cd a000 	str.w	sl, [sp]
 8049d08:	4b1d      	ldr	r3, [pc, #116]	; (8049d80 <udp_input+0x128>)
 8049d0a:	464a      	mov	r2, r9
 8049d0c:	4621      	mov	r1, r4
 8049d0e:	47a8      	blx	r5
 8049d10:	e7c3      	b.n	8049c9a <udp_input+0x42>
    pcb = uncon_pcb;
 8049d12:	465c      	mov	r4, fp
 8049d14:	e7eb      	b.n	8049cee <udp_input+0x96>
      for_us = ip4_addr_cmp(netif_ip4_addr(inp), ip4_current_dest_addr());
 8049d16:	687a      	ldr	r2, [r7, #4]
 8049d18:	4b17      	ldr	r3, [pc, #92]	; (8049d78 <udp_input+0x120>)
 8049d1a:	695b      	ldr	r3, [r3, #20]
  if (for_us) {
 8049d1c:	429a      	cmp	r2, r3
 8049d1e:	d0e7      	beq.n	8049cf0 <udp_input+0x98>
    pbuf_free(p);
 8049d20:	4648      	mov	r0, r9
 8049d22:	f7fb ffdb 	bl	8045cdc <pbuf_free>
  return;
 8049d26:	e7b8      	b.n	8049c9a <udp_input+0x42>
      LWIP_ASSERT("pbuf_header failed\n", 0);
 8049d28:	4b16      	ldr	r3, [pc, #88]	; (8049d84 <udp_input+0x12c>)
 8049d2a:	f240 1255 	movw	r2, #341	; 0x155
 8049d2e:	4916      	ldr	r1, [pc, #88]	; (8049d88 <udp_input+0x130>)
 8049d30:	4816      	ldr	r0, [pc, #88]	; (8049d8c <udp_input+0x134>)
 8049d32:	f007 fe89 	bl	8051a48 <printf>
      pbuf_free(p);
 8049d36:	4648      	mov	r0, r9
 8049d38:	f7fb ffd0 	bl	8045cdc <pbuf_free>
      goto end;
 8049d3c:	e7ad      	b.n	8049c9a <udp_input+0x42>
        pbuf_free(p);
 8049d3e:	4648      	mov	r0, r9
 8049d40:	f7fb ffcc 	bl	8045cdc <pbuf_free>
        goto end;
 8049d44:	e7a9      	b.n	8049c9a <udp_input+0x42>
      if (!broadcast && !ip_addr_ismulticast(ip_current_dest_addr())) {
 8049d46:	f1b8 0f00 	cmp.w	r8, #0
 8049d4a:	d105      	bne.n	8049d58 <udp_input+0x100>
 8049d4c:	4b0a      	ldr	r3, [pc, #40]	; (8049d78 <udp_input+0x120>)
 8049d4e:	695b      	ldr	r3, [r3, #20]
 8049d50:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 8049d54:	2be0      	cmp	r3, #224	; 0xe0
 8049d56:	d103      	bne.n	8049d60 <udp_input+0x108>
      pbuf_free(p);
 8049d58:	4648      	mov	r0, r9
 8049d5a:	f7fb ffbf 	bl	8045cdc <pbuf_free>
 8049d5e:	e79c      	b.n	8049c9a <udp_input+0x42>
        pbuf_header_force(p, (s16_t)(ip_current_header_tot_len() + UDP_HLEN));
 8049d60:	4b05      	ldr	r3, [pc, #20]	; (8049d78 <udp_input+0x120>)
 8049d62:	8999      	ldrh	r1, [r3, #12]
 8049d64:	3108      	adds	r1, #8
 8049d66:	b209      	sxth	r1, r1
 8049d68:	4648      	mov	r0, r9
 8049d6a:	f7fb ffb2 	bl	8045cd2 <pbuf_header_force>
        icmp_port_unreach(ip_current_is_v6(), p);
 8049d6e:	2103      	movs	r1, #3
 8049d70:	4648      	mov	r0, r9
 8049d72:	f000 fdb1 	bl	804a8d8 <icmp_dest_unreach>
 8049d76:	e7ef      	b.n	8049d58 <udp_input+0x100>
 8049d78:	200051f0 	.word	0x200051f0
 8049d7c:	20008738 	.word	0x20008738
 8049d80:	20005200 	.word	0x20005200
 8049d84:	0805a24c 	.word	0x0805a24c
 8049d88:	0805a27c 	.word	0x0805a27c
 8049d8c:	08058ecc 	.word	0x08058ecc

08049d90 <udp_netif_ip_addr_changed>:
 */
void udp_netif_ip_addr_changed(const ip_addr_t* old_addr, const ip_addr_t* new_addr)
{
  struct udp_pcb* upcb;

  if (!ip_addr_isany(old_addr) && !ip_addr_isany(new_addr)) {
 8049d90:	b1b8      	cbz	r0, 8049dc2 <udp_netif_ip_addr_changed+0x32>
 8049d92:	4602      	mov	r2, r0
 8049d94:	6803      	ldr	r3, [r0, #0]
 8049d96:	b1a3      	cbz	r3, 8049dc2 <udp_netif_ip_addr_changed+0x32>
 8049d98:	b199      	cbz	r1, 8049dc2 <udp_netif_ip_addr_changed+0x32>
 8049d9a:	680b      	ldr	r3, [r1, #0]
 8049d9c:	b18b      	cbz	r3, 8049dc2 <udp_netif_ip_addr_changed+0x32>
    for (upcb = udp_pcbs; upcb != NULL; upcb = upcb->next) {
 8049d9e:	4b09      	ldr	r3, [pc, #36]	; (8049dc4 <udp_netif_ip_addr_changed+0x34>)
 8049da0:	681b      	ldr	r3, [r3, #0]
 8049da2:	b16b      	cbz	r3, 8049dc0 <udp_netif_ip_addr_changed+0x30>
{
 8049da4:	b410      	push	{r4}
 8049da6:	e001      	b.n	8049dac <udp_netif_ip_addr_changed+0x1c>
    for (upcb = udp_pcbs; upcb != NULL; upcb = upcb->next) {
 8049da8:	68db      	ldr	r3, [r3, #12]
 8049daa:	b133      	cbz	r3, 8049dba <udp_netif_ip_addr_changed+0x2a>
      /* PCB bound to current local interface address? */
      if (ip_addr_cmp(&upcb->local_ip, old_addr)) {
 8049dac:	681c      	ldr	r4, [r3, #0]
 8049dae:	6810      	ldr	r0, [r2, #0]
 8049db0:	4284      	cmp	r4, r0
 8049db2:	d1f9      	bne.n	8049da8 <udp_netif_ip_addr_changed+0x18>
        /* The PCB is bound to the old ipaddr and
         * is set to bound to the new one instead */
        ip_addr_copy(upcb->local_ip, *new_addr);
 8049db4:	6808      	ldr	r0, [r1, #0]
 8049db6:	6018      	str	r0, [r3, #0]
 8049db8:	e7f6      	b.n	8049da8 <udp_netif_ip_addr_changed+0x18>
      }
    }
  }
}
 8049dba:	f85d 4b04 	ldr.w	r4, [sp], #4
 8049dbe:	4770      	bx	lr
 8049dc0:	4770      	bx	lr
 8049dc2:	4770      	bx	lr
 8049dc4:	20008738 	.word	0x20008738

08049dc8 <etharp_free_entry>:
#endif /* ARP_QUEUEING */

/** Clean up ARP table entries */
static void
etharp_free_entry(int i)
{
 8049dc8:	b510      	push	{r4, lr}
 8049dca:	4604      	mov	r4, r0
  /* remove from SNMP ARP index tree */
  mib2_remove_arp_entry(arp_table[i].netif, &arp_table[i].ipaddr);
  /* and empty packet queue */
  if (arp_table[i].q != NULL) {
 8049dcc:	eb00 0240 	add.w	r2, r0, r0, lsl #1
 8049dd0:	4b09      	ldr	r3, [pc, #36]	; (8049df8 <etharp_free_entry+0x30>)
 8049dd2:	f853 0032 	ldr.w	r0, [r3, r2, lsl #3]
 8049dd6:	b138      	cbz	r0, 8049de8 <etharp_free_entry+0x20>
    /* remove all queued packets */
    LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_free_entry: freeing entry %"U16_F", packet queue %p.\n", (u16_t)i, (void *)(arp_table[i].q)));
    free_etharp_q(arp_table[i].q);
 8049dd8:	f7fb ff80 	bl	8045cdc <pbuf_free>
    arp_table[i].q = NULL;
 8049ddc:	eb04 0344 	add.w	r3, r4, r4, lsl #1
 8049de0:	00db      	lsls	r3, r3, #3
 8049de2:	4a05      	ldr	r2, [pc, #20]	; (8049df8 <etharp_free_entry+0x30>)
 8049de4:	2100      	movs	r1, #0
 8049de6:	50d1      	str	r1, [r2, r3]
  }
  /* recycle entry for re-use */
  arp_table[i].state = ETHARP_STATE_EMPTY;
 8049de8:	eb04 0444 	add.w	r4, r4, r4, lsl #1
 8049dec:	4802      	ldr	r0, [pc, #8]	; (8049df8 <etharp_free_entry+0x30>)
 8049dee:	eb00 04c4 	add.w	r4, r0, r4, lsl #3
 8049df2:	2300      	movs	r3, #0
 8049df4:	7523      	strb	r3, [r4, #20]
  arp_table[i].ctime = 0;
  arp_table[i].netif = NULL;
  ip4_addr_set_zero(&arp_table[i].ipaddr);
  arp_table[i].ethaddr = ethzero;
#endif /* LWIP_DEBUG */
}
 8049df6:	bd10      	pop	{r4, pc}
 8049df8:	20004114 	.word	0x20004114

08049dfc <etharp_find_entry>:
 * @return The ARP entry index that matched or is created, ERR_MEM if no
 * entry is found or could be recycled.
 */
static s8_t
etharp_find_entry(const ip4_addr_t *ipaddr, u8_t flags, struct netif* netif)
{
 8049dfc:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8049e00:	4606      	mov	r6, r0
  s8_t empty = ARP_TABLE_SIZE;
  u8_t i = 0;
  /* oldest entry with packets on queue */
  s8_t old_queue = ARP_TABLE_SIZE;
  /* its age */
  u16_t age_queue = 0, age_pending = 0, age_stable = 0;
 8049e02:	f04f 0c00 	mov.w	ip, #0
 8049e06:	46e3      	mov	fp, ip
 8049e08:	46e1      	mov	r9, ip
  s8_t old_queue = ARP_TABLE_SIZE;
 8049e0a:	f04f 0e0a 	mov.w	lr, #10
   * 4) remember the oldest pending entry with queued packets (if any)
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
 8049e0e:	4663      	mov	r3, ip
  s8_t empty = ARP_TABLE_SIZE;
 8049e10:	4675      	mov	r5, lr
  s8_t old_pending = ARP_TABLE_SIZE, old_stable = ARP_TABLE_SIZE;
 8049e12:	46f0      	mov	r8, lr
 8049e14:	46f2      	mov	sl, lr
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
 8049e16:	e003      	b.n	8049e20 <etharp_find_entry+0x24>
    u8_t state = arp_table[i].state;
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
 8049e18:	b968      	cbnz	r0, 8049e36 <etharp_find_entry+0x3a>
      LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
 8049e1a:	b25d      	sxtb	r5, r3
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
 8049e1c:	3301      	adds	r3, #1
 8049e1e:	b2db      	uxtb	r3, r3
 8049e20:	2b09      	cmp	r3, #9
 8049e22:	d843      	bhi.n	8049eac <etharp_find_entry+0xb0>
    u8_t state = arp_table[i].state;
 8049e24:	461a      	mov	r2, r3
 8049e26:	eb03 0043 	add.w	r0, r3, r3, lsl #1
 8049e2a:	4c57      	ldr	r4, [pc, #348]	; (8049f88 <etharp_find_entry+0x18c>)
 8049e2c:	eb04 00c0 	add.w	r0, r4, r0, lsl #3
 8049e30:	7d00      	ldrb	r0, [r0, #20]
    if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
 8049e32:	2d0a      	cmp	r5, #10
 8049e34:	d0f0      	beq.n	8049e18 <etharp_find_entry+0x1c>
    } else if (state != ETHARP_STATE_EMPTY) {
 8049e36:	2800      	cmp	r0, #0
 8049e38:	d0f0      	beq.n	8049e1c <etharp_find_entry+0x20>
      LWIP_ASSERT("state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE",
        state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE);
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip4_addr_cmp(ipaddr, &arp_table[i].ipaddr)
 8049e3a:	b146      	cbz	r6, 8049e4e <etharp_find_entry+0x52>
 8049e3c:	eb02 0742 	add.w	r7, r2, r2, lsl #1
 8049e40:	4c51      	ldr	r4, [pc, #324]	; (8049f88 <etharp_find_entry+0x18c>)
 8049e42:	eb04 04c7 	add.w	r4, r4, r7, lsl #3
 8049e46:	6864      	ldr	r4, [r4, #4]
 8049e48:	6837      	ldr	r7, [r6, #0]
 8049e4a:	42a7      	cmp	r7, r4
 8049e4c:	d00f      	beq.n	8049e6e <etharp_find_entry+0x72>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: found matching entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
        return i;
      }
      /* pending entry? */
      if (state == ETHARP_STATE_PENDING) {
 8049e4e:	2801      	cmp	r0, #1
 8049e50:	d00f      	beq.n	8049e72 <etharp_find_entry+0x76>
            old_pending = i;
            age_pending = arp_table[i].ctime;
          }
        }
      /* stable entry? */
      } else if (state >= ETHARP_STATE_STABLE) {
 8049e52:	2801      	cmp	r0, #1
 8049e54:	d9e2      	bls.n	8049e1c <etharp_find_entry+0x20>
        /* don't record old_stable for static entries since they never expire */
        if (state < ETHARP_STATE_STATIC)
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
        {
          /* remember entry with oldest stable entry in oldest, its age in maxtime */
          if (arp_table[i].ctime >= age_stable) {
 8049e56:	eb02 0242 	add.w	r2, r2, r2, lsl #1
 8049e5a:	484b      	ldr	r0, [pc, #300]	; (8049f88 <etharp_find_entry+0x18c>)
 8049e5c:	eb00 02c2 	add.w	r2, r0, r2, lsl #3
 8049e60:	8a52      	ldrh	r2, [r2, #18]
 8049e62:	4562      	cmp	r2, ip
 8049e64:	d3da      	bcc.n	8049e1c <etharp_find_entry+0x20>
            old_stable = i;
 8049e66:	fa4f f883 	sxtb.w	r8, r3
            age_stable = arp_table[i].ctime;
 8049e6a:	4694      	mov	ip, r2
 8049e6c:	e7d6      	b.n	8049e1c <etharp_find_entry+0x20>
        return i;
 8049e6e:	b258      	sxtb	r0, r3
 8049e70:	e03f      	b.n	8049ef2 <etharp_find_entry+0xf6>
        if (arp_table[i].q != NULL) {
 8049e72:	eb02 0042 	add.w	r0, r2, r2, lsl #1
 8049e76:	4c44      	ldr	r4, [pc, #272]	; (8049f88 <etharp_find_entry+0x18c>)
 8049e78:	f854 0030 	ldr.w	r0, [r4, r0, lsl #3]
 8049e7c:	b150      	cbz	r0, 8049e94 <etharp_find_entry+0x98>
          if (arp_table[i].ctime >= age_queue) {
 8049e7e:	eb02 0242 	add.w	r2, r2, r2, lsl #1
 8049e82:	eb04 02c2 	add.w	r2, r4, r2, lsl #3
 8049e86:	8a52      	ldrh	r2, [r2, #18]
 8049e88:	454a      	cmp	r2, r9
 8049e8a:	d3c7      	bcc.n	8049e1c <etharp_find_entry+0x20>
            old_queue = i;
 8049e8c:	fa4f fe83 	sxtb.w	lr, r3
            age_queue = arp_table[i].ctime;
 8049e90:	4691      	mov	r9, r2
 8049e92:	e7c3      	b.n	8049e1c <etharp_find_entry+0x20>
          if (arp_table[i].ctime >= age_pending) {
 8049e94:	eb02 0242 	add.w	r2, r2, r2, lsl #1
 8049e98:	483b      	ldr	r0, [pc, #236]	; (8049f88 <etharp_find_entry+0x18c>)
 8049e9a:	eb00 02c2 	add.w	r2, r0, r2, lsl #3
 8049e9e:	8a52      	ldrh	r2, [r2, #18]
 8049ea0:	455a      	cmp	r2, fp
 8049ea2:	d3bb      	bcc.n	8049e1c <etharp_find_entry+0x20>
            old_pending = i;
 8049ea4:	fa4f fa83 	sxtb.w	sl, r3
            age_pending = arp_table[i].ctime;
 8049ea8:	4693      	mov	fp, r2
 8049eaa:	e7b7      	b.n	8049e1c <etharp_find_entry+0x20>
    }
  }
  /* { we have no match } => try to create a new entry */

  /* don't create new entry, only search? */
  if (((flags & ETHARP_FLAG_FIND_ONLY) != 0) ||
 8049eac:	f011 0f02 	tst.w	r1, #2
 8049eb0:	d163      	bne.n	8049f7a <etharp_find_entry+0x17e>
 8049eb2:	2d0a      	cmp	r5, #10
 8049eb4:	d01f      	beq.n	8049ef6 <etharp_find_entry+0xfa>
   *
   * { ETHARP_FLAG_TRY_HARD is set at this point }
   */

  /* 1) empty entry available? */
  if (empty < ARP_TABLE_SIZE) {
 8049eb6:	2d09      	cmp	r5, #9
 8049eb8:	dc23      	bgt.n	8049f02 <etharp_find_entry+0x106>
    i = empty;
 8049eba:	b2ed      	uxtb	r5, r5
    /* { empty or recyclable entry found } */
    LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
    etharp_free_entry(i);
  }

  LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
 8049ebc:	2d09      	cmp	r5, #9
 8049ebe:	d84c      	bhi.n	8049f5a <etharp_find_entry+0x15e>
  LWIP_ASSERT("arp_table[i].state == ETHARP_STATE_EMPTY",
 8049ec0:	462c      	mov	r4, r5
 8049ec2:	eb05 0345 	add.w	r3, r5, r5, lsl #1
 8049ec6:	4a30      	ldr	r2, [pc, #192]	; (8049f88 <etharp_find_entry+0x18c>)
 8049ec8:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 8049ecc:	7d1b      	ldrb	r3, [r3, #20]
 8049ece:	2b00      	cmp	r3, #0
 8049ed0:	d14b      	bne.n	8049f6a <etharp_find_entry+0x16e>
    arp_table[i].state == ETHARP_STATE_EMPTY);

  /* IP address given? */
  if (ipaddr != NULL) {
 8049ed2:	b136      	cbz	r6, 8049ee2 <etharp_find_entry+0xe6>
    /* set IP address */
    ip4_addr_copy(arp_table[i].ipaddr, *ipaddr);
 8049ed4:	6831      	ldr	r1, [r6, #0]
 8049ed6:	eb04 0344 	add.w	r3, r4, r4, lsl #1
 8049eda:	4a2b      	ldr	r2, [pc, #172]	; (8049f88 <etharp_find_entry+0x18c>)
 8049edc:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 8049ee0:	6059      	str	r1, [r3, #4]
  }
  arp_table[i].ctime = 0;
 8049ee2:	eb04 0444 	add.w	r4, r4, r4, lsl #1
 8049ee6:	4b28      	ldr	r3, [pc, #160]	; (8049f88 <etharp_find_entry+0x18c>)
 8049ee8:	eb03 04c4 	add.w	r4, r3, r4, lsl #3
 8049eec:	2300      	movs	r3, #0
 8049eee:	8263      	strh	r3, [r4, #18]
#if ETHARP_TABLE_MATCH_NETIF
  arp_table[i].netif = netif;
#endif /* ETHARP_TABLE_MATCH_NETIF*/
  return (err_t)i;
 8049ef0:	b268      	sxtb	r0, r5
}
 8049ef2:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
      ((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_FLAG_TRY_HARD) == 0))) {
 8049ef6:	f011 0f01 	tst.w	r1, #1
 8049efa:	d1dc      	bne.n	8049eb6 <etharp_find_entry+0xba>
    return (s8_t)ERR_MEM;
 8049efc:	f04f 30ff 	mov.w	r0, #4294967295
 8049f00:	e7f7      	b.n	8049ef2 <etharp_find_entry+0xf6>
    if (old_stable < ARP_TABLE_SIZE) {
 8049f02:	f1b8 0f09 	cmp.w	r8, #9
 8049f06:	dc14      	bgt.n	8049f32 <etharp_find_entry+0x136>
      i = old_stable;
 8049f08:	fa5f f588 	uxtb.w	r5, r8
      LWIP_ASSERT("arp_table[i].q == NULL", arp_table[i].q == NULL);
 8049f0c:	eb05 0245 	add.w	r2, r5, r5, lsl #1
 8049f10:	4b1d      	ldr	r3, [pc, #116]	; (8049f88 <etharp_find_entry+0x18c>)
 8049f12:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
 8049f16:	b133      	cbz	r3, 8049f26 <etharp_find_entry+0x12a>
 8049f18:	4b1c      	ldr	r3, [pc, #112]	; (8049f8c <etharp_find_entry+0x190>)
 8049f1a:	f240 126f 	movw	r2, #367	; 0x16f
 8049f1e:	491c      	ldr	r1, [pc, #112]	; (8049f90 <etharp_find_entry+0x194>)
 8049f20:	481c      	ldr	r0, [pc, #112]	; (8049f94 <etharp_find_entry+0x198>)
 8049f22:	f007 fd91 	bl	8051a48 <printf>
    LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
 8049f26:	2d09      	cmp	r5, #9
 8049f28:	d80f      	bhi.n	8049f4a <etharp_find_entry+0x14e>
    etharp_free_entry(i);
 8049f2a:	4628      	mov	r0, r5
 8049f2c:	f7ff ff4c 	bl	8049dc8 <etharp_free_entry>
 8049f30:	e7c4      	b.n	8049ebc <etharp_find_entry+0xc0>
    } else if (old_pending < ARP_TABLE_SIZE) {
 8049f32:	f1ba 0f09 	cmp.w	sl, #9
 8049f36:	dc02      	bgt.n	8049f3e <etharp_find_entry+0x142>
      i = old_pending;
 8049f38:	fa5f f58a 	uxtb.w	r5, sl
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting oldest pending entry %"U16_F" (without queue)\n", (u16_t)i));
 8049f3c:	e7f3      	b.n	8049f26 <etharp_find_entry+0x12a>
    } else if (old_queue < ARP_TABLE_SIZE) {
 8049f3e:	f1be 0f09 	cmp.w	lr, #9
 8049f42:	dc1d      	bgt.n	8049f80 <etharp_find_entry+0x184>
      i = old_queue;
 8049f44:	fa5f f58e 	uxtb.w	r5, lr
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting oldest pending entry %"U16_F", freeing packet queue %p\n", (u16_t)i, (void *)(arp_table[i].q)));
 8049f48:	e7ed      	b.n	8049f26 <etharp_find_entry+0x12a>
    LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
 8049f4a:	4b10      	ldr	r3, [pc, #64]	; (8049f8c <etharp_find_entry+0x190>)
 8049f4c:	f240 1281 	movw	r2, #385	; 0x181
 8049f50:	4911      	ldr	r1, [pc, #68]	; (8049f98 <etharp_find_entry+0x19c>)
 8049f52:	4810      	ldr	r0, [pc, #64]	; (8049f94 <etharp_find_entry+0x198>)
 8049f54:	f007 fd78 	bl	8051a48 <printf>
 8049f58:	e7e7      	b.n	8049f2a <etharp_find_entry+0x12e>
  LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
 8049f5a:	4b0c      	ldr	r3, [pc, #48]	; (8049f8c <etharp_find_entry+0x190>)
 8049f5c:	f240 1285 	movw	r2, #389	; 0x185
 8049f60:	490d      	ldr	r1, [pc, #52]	; (8049f98 <etharp_find_entry+0x19c>)
 8049f62:	480c      	ldr	r0, [pc, #48]	; (8049f94 <etharp_find_entry+0x198>)
 8049f64:	f007 fd70 	bl	8051a48 <printf>
 8049f68:	e7aa      	b.n	8049ec0 <etharp_find_entry+0xc4>
  LWIP_ASSERT("arp_table[i].state == ETHARP_STATE_EMPTY",
 8049f6a:	4b08      	ldr	r3, [pc, #32]	; (8049f8c <etharp_find_entry+0x190>)
 8049f6c:	f44f 72c3 	mov.w	r2, #390	; 0x186
 8049f70:	490a      	ldr	r1, [pc, #40]	; (8049f9c <etharp_find_entry+0x1a0>)
 8049f72:	4808      	ldr	r0, [pc, #32]	; (8049f94 <etharp_find_entry+0x198>)
 8049f74:	f007 fd68 	bl	8051a48 <printf>
 8049f78:	e7ab      	b.n	8049ed2 <etharp_find_entry+0xd6>
    return (s8_t)ERR_MEM;
 8049f7a:	f04f 30ff 	mov.w	r0, #4294967295
 8049f7e:	e7b8      	b.n	8049ef2 <etharp_find_entry+0xf6>
      return (s8_t)ERR_MEM;
 8049f80:	f04f 30ff 	mov.w	r0, #4294967295
 8049f84:	e7b5      	b.n	8049ef2 <etharp_find_entry+0xf6>
 8049f86:	bf00      	nop
 8049f88:	20004114 	.word	0x20004114
 8049f8c:	0805a2c0 	.word	0x0805a2c0
 8049f90:	0805a2f8 	.word	0x0805a2f8
 8049f94:	08058ecc 	.word	0x08058ecc
 8049f98:	0805a310 	.word	0x0805a310
 8049f9c:	0805a324 	.word	0x0805a324

08049fa0 <etharp_update_arp_entry>:
 *
 * @see pbuf_free()
 */
static err_t
etharp_update_arp_entry(struct netif *netif, const ip4_addr_t *ipaddr, struct eth_addr *ethaddr, u8_t flags)
{
 8049fa0:	b5f0      	push	{r4, r5, r6, r7, lr}
 8049fa2:	b083      	sub	sp, #12
 8049fa4:	4604      	mov	r4, r0
 8049fa6:	460e      	mov	r6, r1
 8049fa8:	4615      	mov	r5, r2
 8049faa:	461f      	mov	r7, r3
  s8_t i;
  LWIP_ASSERT("netif->hwaddr_len == ETH_HWADDR_LEN", netif->hwaddr_len == ETH_HWADDR_LEN);
 8049fac:	f890 2024 	ldrb.w	r2, [r0, #36]	; 0x24
 8049fb0:	2a06      	cmp	r2, #6
 8049fb2:	d13e      	bne.n	804a032 <etharp_update_arp_entry+0x92>
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
    ip4_addr1_16(ipaddr), ip4_addr2_16(ipaddr), ip4_addr3_16(ipaddr), ip4_addr4_16(ipaddr),
    (u16_t)ethaddr->addr[0], (u16_t)ethaddr->addr[1], (u16_t)ethaddr->addr[2],
    (u16_t)ethaddr->addr[3], (u16_t)ethaddr->addr[4], (u16_t)ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip4_addr_isany(ipaddr) ||
 8049fb4:	2e00      	cmp	r6, #0
 8049fb6:	d044      	beq.n	804a042 <etharp_update_arp_entry+0xa2>
 8049fb8:	6830      	ldr	r0, [r6, #0]
 8049fba:	2800      	cmp	r0, #0
 8049fbc:	d041      	beq.n	804a042 <etharp_update_arp_entry+0xa2>
      ip4_addr_isbroadcast(ipaddr, netif) ||
 8049fbe:	4621      	mov	r1, r4
 8049fc0:	f000 fe33 	bl	804ac2a <ip4_addr_isbroadcast_u32>
  if (ip4_addr_isany(ipaddr) ||
 8049fc4:	2800      	cmp	r0, #0
 8049fc6:	d13c      	bne.n	804a042 <etharp_update_arp_entry+0xa2>
      ip4_addr_ismulticast(ipaddr)) {
 8049fc8:	6832      	ldr	r2, [r6, #0]
 8049fca:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
      ip4_addr_isbroadcast(ipaddr, netif) ||
 8049fce:	2ae0      	cmp	r2, #224	; 0xe0
 8049fd0:	d037      	beq.n	804a042 <etharp_update_arp_entry+0xa2>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: will not add non-unicast IP address to ARP cache\n"));
    return ERR_ARG;
  }
  /* find or create ARP entry */
  i = etharp_find_entry(ipaddr, flags, netif);
 8049fd2:	4622      	mov	r2, r4
 8049fd4:	4639      	mov	r1, r7
 8049fd6:	4630      	mov	r0, r6
 8049fd8:	f7ff ff10 	bl	8049dfc <etharp_find_entry>
  /* bail out if no entry could be found */
  if (i < 0) {
 8049fdc:	2800      	cmp	r0, #0
 8049fde:	db26      	blt.n	804a02e <etharp_update_arp_entry+0x8e>
    return ERR_VAL;
  } else
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
  {
    /* mark it stable */
    arp_table[i].state = ETHARP_STATE_STABLE;
 8049fe0:	4a1a      	ldr	r2, [pc, #104]	; (804a04c <etharp_update_arp_entry+0xac>)
 8049fe2:	eb00 0640 	add.w	r6, r0, r0, lsl #1
 8049fe6:	eb02 01c6 	add.w	r1, r2, r6, lsl #3
 8049fea:	2302      	movs	r3, #2
 8049fec:	750b      	strb	r3, [r1, #20]
  }

  /* record network interface */
  arp_table[i].netif = netif;
 8049fee:	608c      	str	r4, [r1, #8]
  /* insert in SNMP ARP index tree */
  mib2_add_arp_entry(netif, &arp_table[i].ipaddr);

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
  /* update address */
  ETHADDR32_COPY(&arp_table[i].ethaddr, ethaddr);
 8049ff0:	00f3      	lsls	r3, r6, #3
 8049ff2:	3308      	adds	r3, #8
 8049ff4:	4413      	add	r3, r2
 8049ff6:	682f      	ldr	r7, [r5, #0]
 8049ff8:	605f      	str	r7, [r3, #4]
 8049ffa:	88af      	ldrh	r7, [r5, #4]
 8049ffc:	811f      	strh	r7, [r3, #8]
  /* reset time stamp */
  arp_table[i].ctime = 0;
 8049ffe:	2300      	movs	r3, #0
 804a000:	824b      	strh	r3, [r1, #18]
    /* get the packet pointer */
    p = q->p;
    /* now queue entry can be freed */
    memp_free(MEMP_ARP_QUEUE, q);
#else /* ARP_QUEUEING */
  if (arp_table[i].q != NULL) {
 804a002:	f852 6036 	ldr.w	r6, [r2, r6, lsl #3]
 804a006:	b1fe      	cbz	r6, 804a048 <etharp_update_arp_entry+0xa8>
    struct pbuf *p = arp_table[i].q;
    arp_table[i].q = NULL;
 804a008:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 804a00c:	00c0      	lsls	r0, r0, #3
 804a00e:	461f      	mov	r7, r3
 804a010:	5013      	str	r3, [r2, r0]
#endif /* ARP_QUEUEING */
    /* send the queued IP packet */
    ethernet_output(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr, ETHTYPE_IP);
 804a012:	f44f 6300 	mov.w	r3, #2048	; 0x800
 804a016:	9300      	str	r3, [sp, #0]
 804a018:	462b      	mov	r3, r5
 804a01a:	f104 0225 	add.w	r2, r4, #37	; 0x25
 804a01e:	4631      	mov	r1, r6
 804a020:	4620      	mov	r0, r4
 804a022:	f001 fb19 	bl	804b658 <ethernet_output>
    /* free the queued IP packet */
    pbuf_free(p);
 804a026:	4630      	mov	r0, r6
 804a028:	f7fb fe58 	bl	8045cdc <pbuf_free>
  }
  return ERR_OK;
 804a02c:	4638      	mov	r0, r7
}
 804a02e:	b003      	add	sp, #12
 804a030:	bdf0      	pop	{r4, r5, r6, r7, pc}
  LWIP_ASSERT("netif->hwaddr_len == ETH_HWADDR_LEN", netif->hwaddr_len == ETH_HWADDR_LEN);
 804a032:	4b07      	ldr	r3, [pc, #28]	; (804a050 <etharp_update_arp_entry+0xb0>)
 804a034:	f240 12ab 	movw	r2, #427	; 0x1ab
 804a038:	4906      	ldr	r1, [pc, #24]	; (804a054 <etharp_update_arp_entry+0xb4>)
 804a03a:	4807      	ldr	r0, [pc, #28]	; (804a058 <etharp_update_arp_entry+0xb8>)
 804a03c:	f007 fd04 	bl	8051a48 <printf>
 804a040:	e7b8      	b.n	8049fb4 <etharp_update_arp_entry+0x14>
    return ERR_ARG;
 804a042:	f06f 000f 	mvn.w	r0, #15
 804a046:	e7f2      	b.n	804a02e <etharp_update_arp_entry+0x8e>
  return ERR_OK;
 804a048:	2000      	movs	r0, #0
 804a04a:	e7f0      	b.n	804a02e <etharp_update_arp_entry+0x8e>
 804a04c:	20004114 	.word	0x20004114
 804a050:	0805a2c0 	.word	0x0805a2c0
 804a054:	0805a350 	.word	0x0805a350
 804a058:	08058ecc 	.word	0x08058ecc

0804a05c <etharp_raw>:
etharp_raw(struct netif *netif, const struct eth_addr *ethsrc_addr,
           const struct eth_addr *ethdst_addr,
           const struct eth_addr *hwsrc_addr, const ip4_addr_t *ipsrc_addr,
           const struct eth_addr *hwdst_addr, const ip4_addr_t *ipdst_addr,
           const u16_t opcode)
{
 804a05c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 804a060:	b082      	sub	sp, #8
 804a062:	460f      	mov	r7, r1
 804a064:	4690      	mov	r8, r2
 804a066:	461d      	mov	r5, r3
 804a068:	f8dd a02c 	ldr.w	sl, [sp, #44]	; 0x2c
  struct pbuf *p;
  err_t result = ERR_OK;
  struct etharp_hdr *hdr;

  LWIP_ASSERT("netif != NULL", netif != NULL);
 804a06c:	4681      	mov	r9, r0
 804a06e:	2800      	cmp	r0, #0
 804a070:	d041      	beq.n	804a0f6 <etharp_raw+0x9a>

  /* allocate a pbuf for the outgoing ARP request packet */
  p = pbuf_alloc(PBUF_LINK, SIZEOF_ETHARP_HDR, PBUF_RAM);
 804a072:	2200      	movs	r2, #0
 804a074:	211c      	movs	r1, #28
 804a076:	2002      	movs	r0, #2
 804a078:	f7fb fe94 	bl	8045da4 <pbuf_alloc>
  /* could allocate a pbuf for an ARP request? */
  if (p == NULL) {
 804a07c:	4606      	mov	r6, r0
 804a07e:	2800      	cmp	r0, #0
 804a080:	d051      	beq.n	804a126 <etharp_raw+0xca>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
      ("etharp_raw: could not allocate pbuf for ARP request.\n"));
    ETHARP_STATS_INC(etharp.memerr);
    return ERR_MEM;
  }
  LWIP_ASSERT("check that first pbuf can hold struct etharp_hdr",
 804a082:	8943      	ldrh	r3, [r0, #10]
 804a084:	2b1b      	cmp	r3, #27
 804a086:	d93e      	bls.n	804a106 <etharp_raw+0xaa>
              (p->len >= SIZEOF_ETHARP_HDR));

  hdr = (struct etharp_hdr *)p->payload;
 804a088:	6874      	ldr	r4, [r6, #4]
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_raw: sending raw ARP packet.\n"));
  hdr->opcode = lwip_htons(opcode);
 804a08a:	f8bd 0034 	ldrh.w	r0, [sp, #52]	; 0x34
 804a08e:	f7fb f9ef 	bl	8045470 <lwip_htons>
 804a092:	80e0      	strh	r0, [r4, #6]

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETH_HWADDR_LEN for etharp!",
 804a094:	f899 3024 	ldrb.w	r3, [r9, #36]	; 0x24
 804a098:	2b06      	cmp	r3, #6
 804a09a:	d13c      	bne.n	804a116 <etharp_raw+0xba>
              (netif->hwaddr_len == ETH_HWADDR_LEN));

  /* Write the ARP MAC-Addresses */
  ETHADDR16_COPY(&hdr->shwaddr, hwsrc_addr);
 804a09c:	682b      	ldr	r3, [r5, #0]
 804a09e:	60a3      	str	r3, [r4, #8]
 804a0a0:	88ab      	ldrh	r3, [r5, #4]
 804a0a2:	81a3      	strh	r3, [r4, #12]
  ETHADDR16_COPY(&hdr->dhwaddr, hwdst_addr);
 804a0a4:	f8da 3000 	ldr.w	r3, [sl]
 804a0a8:	f8c4 3012 	str.w	r3, [r4, #18]
 804a0ac:	f8ba 3004 	ldrh.w	r3, [sl, #4]
 804a0b0:	82e3      	strh	r3, [r4, #22]
  /* Copy struct ip4_addr2 to aligned ip4_addr, to support compilers without
   * structure packing. */
  IPADDR2_COPY(&hdr->sipaddr, ipsrc_addr);
 804a0b2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 804a0b4:	681b      	ldr	r3, [r3, #0]
 804a0b6:	f8c4 300e 	str.w	r3, [r4, #14]
  IPADDR2_COPY(&hdr->dipaddr, ipdst_addr);
 804a0ba:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 804a0bc:	681b      	ldr	r3, [r3, #0]
 804a0be:	61a3      	str	r3, [r4, #24]

  hdr->hwtype = PP_HTONS(HWTYPE_ETHERNET);
 804a0c0:	2500      	movs	r5, #0
 804a0c2:	7025      	strb	r5, [r4, #0]
 804a0c4:	2301      	movs	r3, #1
 804a0c6:	7063      	strb	r3, [r4, #1]
  hdr->proto = PP_HTONS(ETHTYPE_IP);
 804a0c8:	2308      	movs	r3, #8
 804a0ca:	70a3      	strb	r3, [r4, #2]
 804a0cc:	70e5      	strb	r5, [r4, #3]
  /* set hwlen and protolen */
  hdr->hwlen = ETH_HWADDR_LEN;
 804a0ce:	2306      	movs	r3, #6
 804a0d0:	7123      	strb	r3, [r4, #4]
  hdr->protolen = sizeof(ip4_addr_t);
 804a0d2:	2304      	movs	r3, #4
 804a0d4:	7163      	strb	r3, [r4, #5]
  if(ip4_addr_islinklocal(ipsrc_addr)) {
    ethernet_output(netif, p, ethsrc_addr, &ethbroadcast, ETHTYPE_ARP);
  } else
#endif /* LWIP_AUTOIP */
  {
    ethernet_output(netif, p, ethsrc_addr, ethdst_addr, ETHTYPE_ARP);
 804a0d6:	f640 0306 	movw	r3, #2054	; 0x806
 804a0da:	9300      	str	r3, [sp, #0]
 804a0dc:	4643      	mov	r3, r8
 804a0de:	463a      	mov	r2, r7
 804a0e0:	4631      	mov	r1, r6
 804a0e2:	4648      	mov	r0, r9
 804a0e4:	f001 fab8 	bl	804b658 <ethernet_output>
  }

  ETHARP_STATS_INC(etharp.xmit);
  /* free ARP query packet */
  pbuf_free(p);
 804a0e8:	4630      	mov	r0, r6
 804a0ea:	f7fb fdf7 	bl	8045cdc <pbuf_free>
  p = NULL;
  /* could not allocate pbuf for ARP request */

  return result;
 804a0ee:	4628      	mov	r0, r5
}
 804a0f0:	b002      	add	sp, #8
 804a0f2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  LWIP_ASSERT("netif != NULL", netif != NULL);
 804a0f6:	4b0d      	ldr	r3, [pc, #52]	; (804a12c <etharp_raw+0xd0>)
 804a0f8:	f44f 628b 	mov.w	r2, #1112	; 0x458
 804a0fc:	490c      	ldr	r1, [pc, #48]	; (804a130 <etharp_raw+0xd4>)
 804a0fe:	480d      	ldr	r0, [pc, #52]	; (804a134 <etharp_raw+0xd8>)
 804a100:	f007 fca2 	bl	8051a48 <printf>
 804a104:	e7b5      	b.n	804a072 <etharp_raw+0x16>
  LWIP_ASSERT("check that first pbuf can hold struct etharp_hdr",
 804a106:	4b09      	ldr	r3, [pc, #36]	; (804a12c <etharp_raw+0xd0>)
 804a108:	f240 4263 	movw	r2, #1123	; 0x463
 804a10c:	490a      	ldr	r1, [pc, #40]	; (804a138 <etharp_raw+0xdc>)
 804a10e:	4809      	ldr	r0, [pc, #36]	; (804a134 <etharp_raw+0xd8>)
 804a110:	f007 fc9a 	bl	8051a48 <printf>
 804a114:	e7b8      	b.n	804a088 <etharp_raw+0x2c>
  LWIP_ASSERT("netif->hwaddr_len must be the same as ETH_HWADDR_LEN for etharp!",
 804a116:	4b05      	ldr	r3, [pc, #20]	; (804a12c <etharp_raw+0xd0>)
 804a118:	f240 426a 	movw	r2, #1130	; 0x46a
 804a11c:	4907      	ldr	r1, [pc, #28]	; (804a13c <etharp_raw+0xe0>)
 804a11e:	4805      	ldr	r0, [pc, #20]	; (804a134 <etharp_raw+0xd8>)
 804a120:	f007 fc92 	bl	8051a48 <printf>
 804a124:	e7ba      	b.n	804a09c <etharp_raw+0x40>
    return ERR_MEM;
 804a126:	f04f 30ff 	mov.w	r0, #4294967295
 804a12a:	e7e1      	b.n	804a0f0 <etharp_raw+0x94>
 804a12c:	0805a2c0 	.word	0x0805a2c0
 804a130:	0805a374 	.word	0x0805a374
 804a134:	08058ecc 	.word	0x08058ecc
 804a138:	0805a384 	.word	0x0805a384
 804a13c:	0805a3b8 	.word	0x0805a3b8

0804a140 <etharp_request_dst>:
 *         ERR_MEM if the ARP packet couldn't be allocated
 *         any other err_t on failure
 */
static err_t
etharp_request_dst(struct netif *netif, const ip4_addr_t *ipaddr, const struct eth_addr* hw_dst_addr)
{
 804a140:	b530      	push	{r4, r5, lr}
 804a142:	b085      	sub	sp, #20
 804a144:	4604      	mov	r4, r0
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, hw_dst_addr,
 804a146:	f100 0325 	add.w	r3, r0, #37	; 0x25
                    (struct eth_addr *)netif->hwaddr, netif_ip4_addr(netif), &ethzero,
 804a14a:	3404      	adds	r4, #4
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, hw_dst_addr,
 804a14c:	2501      	movs	r5, #1
 804a14e:	9503      	str	r5, [sp, #12]
 804a150:	9102      	str	r1, [sp, #8]
 804a152:	4904      	ldr	r1, [pc, #16]	; (804a164 <etharp_request_dst+0x24>)
 804a154:	9101      	str	r1, [sp, #4]
 804a156:	9400      	str	r4, [sp, #0]
 804a158:	4619      	mov	r1, r3
 804a15a:	f7ff ff7f 	bl	804a05c <etharp_raw>
                    ipaddr, ARP_REQUEST);
}
 804a15e:	b005      	add	sp, #20
 804a160:	bd30      	pop	{r4, r5, pc}
 804a162:	bf00      	nop
 804a164:	08058e64 	.word	0x08058e64

0804a168 <etharp_cleanup_netif>:
{
 804a168:	b538      	push	{r3, r4, r5, lr}
 804a16a:	4605      	mov	r5, r0
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
 804a16c:	2400      	movs	r4, #0
 804a16e:	e001      	b.n	804a174 <etharp_cleanup_netif+0xc>
 804a170:	3401      	adds	r4, #1
 804a172:	b2e4      	uxtb	r4, r4
 804a174:	2c09      	cmp	r4, #9
 804a176:	d812      	bhi.n	804a19e <etharp_cleanup_netif+0x36>
    u8_t state = arp_table[i].state;
 804a178:	4620      	mov	r0, r4
 804a17a:	eb04 0344 	add.w	r3, r4, r4, lsl #1
 804a17e:	4a08      	ldr	r2, [pc, #32]	; (804a1a0 <etharp_cleanup_netif+0x38>)
 804a180:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 804a184:	7d1b      	ldrb	r3, [r3, #20]
    if ((state != ETHARP_STATE_EMPTY) && (arp_table[i].netif == netif)) {
 804a186:	2b00      	cmp	r3, #0
 804a188:	d0f2      	beq.n	804a170 <etharp_cleanup_netif+0x8>
 804a18a:	eb04 0344 	add.w	r3, r4, r4, lsl #1
 804a18e:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 804a192:	689b      	ldr	r3, [r3, #8]
 804a194:	42ab      	cmp	r3, r5
 804a196:	d1eb      	bne.n	804a170 <etharp_cleanup_netif+0x8>
      etharp_free_entry(i);
 804a198:	f7ff fe16 	bl	8049dc8 <etharp_free_entry>
 804a19c:	e7e8      	b.n	804a170 <etharp_cleanup_netif+0x8>
}
 804a19e:	bd38      	pop	{r3, r4, r5, pc}
 804a1a0:	20004114 	.word	0x20004114

0804a1a4 <etharp_input>:
{
 804a1a4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 804a1a8:	b086      	sub	sp, #24
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
 804a1aa:	b1a9      	cbz	r1, 804a1d8 <etharp_input+0x34>
 804a1ac:	4604      	mov	r4, r0
 804a1ae:	460e      	mov	r6, r1
  hdr = (struct etharp_hdr *)p->payload;
 804a1b0:	6845      	ldr	r5, [r0, #4]
  if ((hdr->hwtype != PP_HTONS(HWTYPE_ETHERNET)) ||
 804a1b2:	882b      	ldrh	r3, [r5, #0]
 804a1b4:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 804a1b8:	d108      	bne.n	804a1cc <etharp_input+0x28>
      (hdr->hwlen != ETH_HWADDR_LEN) ||
 804a1ba:	792b      	ldrb	r3, [r5, #4]
  if ((hdr->hwtype != PP_HTONS(HWTYPE_ETHERNET)) ||
 804a1bc:	2b06      	cmp	r3, #6
 804a1be:	d105      	bne.n	804a1cc <etharp_input+0x28>
      (hdr->protolen != sizeof(ip4_addr_t)) ||
 804a1c0:	796b      	ldrb	r3, [r5, #5]
      (hdr->hwlen != ETH_HWADDR_LEN) ||
 804a1c2:	2b04      	cmp	r3, #4
 804a1c4:	d102      	bne.n	804a1cc <etharp_input+0x28>
      (hdr->proto != PP_HTONS(ETHTYPE_IP)))  {
 804a1c6:	886b      	ldrh	r3, [r5, #2]
      (hdr->protolen != sizeof(ip4_addr_t)) ||
 804a1c8:	2b08      	cmp	r3, #8
 804a1ca:	d00d      	beq.n	804a1e8 <etharp_input+0x44>
    pbuf_free(p);
 804a1cc:	4620      	mov	r0, r4
 804a1ce:	f7fb fd85 	bl	8045cdc <pbuf_free>
}
 804a1d2:	b006      	add	sp, #24
 804a1d4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
 804a1d8:	4b1d      	ldr	r3, [pc, #116]	; (804a250 <etharp_input+0xac>)
 804a1da:	f44f 7222 	mov.w	r2, #648	; 0x288
 804a1de:	491d      	ldr	r1, [pc, #116]	; (804a254 <etharp_input+0xb0>)
 804a1e0:	481d      	ldr	r0, [pc, #116]	; (804a258 <etharp_input+0xb4>)
 804a1e2:	f007 fc31 	bl	8051a48 <printf>
 804a1e6:	e7f4      	b.n	804a1d2 <etharp_input+0x2e>
  IPADDR2_COPY(&sipaddr, &hdr->sipaddr);
 804a1e8:	f8d5 300e 	ldr.w	r3, [r5, #14]
 804a1ec:	9305      	str	r3, [sp, #20]
  IPADDR2_COPY(&dipaddr, &hdr->dipaddr);
 804a1ee:	69af      	ldr	r7, [r5, #24]
  if (ip4_addr_isany_val(*netif_ip4_addr(netif))) {
 804a1f0:	684b      	ldr	r3, [r1, #4]
 804a1f2:	b983      	cbnz	r3, 804a216 <etharp_input+0x72>
  etharp_update_arp_entry(netif, &sipaddr, &(hdr->shwaddr),
 804a1f4:	f105 0808 	add.w	r8, r5, #8
    for_us = 0;
 804a1f8:	2700      	movs	r7, #0
  etharp_update_arp_entry(netif, &sipaddr, &(hdr->shwaddr),
 804a1fa:	2302      	movs	r3, #2
 804a1fc:	4642      	mov	r2, r8
 804a1fe:	a905      	add	r1, sp, #20
 804a200:	4630      	mov	r0, r6
 804a202:	f7ff fecd 	bl	8049fa0 <etharp_update_arp_entry>
  switch (hdr->opcode) {
 804a206:	88eb      	ldrh	r3, [r5, #6]
 804a208:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 804a20c:	d00e      	beq.n	804a22c <etharp_input+0x88>
  pbuf_free(p);
 804a20e:	4620      	mov	r0, r4
 804a210:	f7fb fd64 	bl	8045cdc <pbuf_free>
 804a214:	e7dd      	b.n	804a1d2 <etharp_input+0x2e>
    for_us = (u8_t)ip4_addr_cmp(&dipaddr, netif_ip4_addr(netif));
 804a216:	42bb      	cmp	r3, r7
 804a218:	bf14      	ite	ne
 804a21a:	2700      	movne	r7, #0
 804a21c:	2701      	moveq	r7, #1
  etharp_update_arp_entry(netif, &sipaddr, &(hdr->shwaddr),
 804a21e:	f105 0808 	add.w	r8, r5, #8
 804a222:	b10f      	cbz	r7, 804a228 <etharp_input+0x84>
 804a224:	2301      	movs	r3, #1
 804a226:	e7e9      	b.n	804a1fc <etharp_input+0x58>
 804a228:	2302      	movs	r3, #2
 804a22a:	e7e7      	b.n	804a1fc <etharp_input+0x58>
    if (for_us) {
 804a22c:	2f00      	cmp	r7, #0
 804a22e:	d0ee      	beq.n	804a20e <etharp_input+0x6a>
                 (struct eth_addr *)netif->hwaddr, &hdr->shwaddr,
 804a230:	f106 0125 	add.w	r1, r6, #37	; 0x25
                 (struct eth_addr *)netif->hwaddr, netif_ip4_addr(netif),
 804a234:	1d33      	adds	r3, r6, #4
      etharp_raw(netif,
 804a236:	2202      	movs	r2, #2
 804a238:	9203      	str	r2, [sp, #12]
 804a23a:	aa05      	add	r2, sp, #20
 804a23c:	9202      	str	r2, [sp, #8]
 804a23e:	f8cd 8004 	str.w	r8, [sp, #4]
 804a242:	9300      	str	r3, [sp, #0]
 804a244:	460b      	mov	r3, r1
 804a246:	4642      	mov	r2, r8
 804a248:	4630      	mov	r0, r6
 804a24a:	f7ff ff07 	bl	804a05c <etharp_raw>
 804a24e:	e7de      	b.n	804a20e <etharp_input+0x6a>
 804a250:	0805a2c0 	.word	0x0805a2c0
 804a254:	0805a374 	.word	0x0805a374
 804a258:	08058ecc 	.word	0x08058ecc

0804a25c <etharp_request>:
 *         ERR_MEM if the ARP packet couldn't be allocated
 *         any other err_t on failure
 */
err_t
etharp_request(struct netif *netif, const ip4_addr_t *ipaddr)
{
 804a25c:	b508      	push	{r3, lr}
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_request_dst(netif, ipaddr, &ethbroadcast);
 804a25e:	4a02      	ldr	r2, [pc, #8]	; (804a268 <etharp_request+0xc>)
 804a260:	f7ff ff6e 	bl	804a140 <etharp_request_dst>
}
 804a264:	bd08      	pop	{r3, pc}
 804a266:	bf00      	nop
 804a268:	08058e5c 	.word	0x08058e5c

0804a26c <etharp_tmr>:
{
 804a26c:	b510      	push	{r4, lr}
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
 804a26e:	2400      	movs	r4, #0
 804a270:	e005      	b.n	804a27e <etharp_tmr+0x12>
          ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
 804a272:	2b04      	cmp	r3, #4
 804a274:	d922      	bls.n	804a2bc <etharp_tmr+0x50>
        etharp_free_entry(i);
 804a276:	f7ff fda7 	bl	8049dc8 <etharp_free_entry>
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
 804a27a:	3401      	adds	r4, #1
 804a27c:	b2e4      	uxtb	r4, r4
 804a27e:	2c09      	cmp	r4, #9
 804a280:	d83d      	bhi.n	804a2fe <etharp_tmr+0x92>
    u8_t state = arp_table[i].state;
 804a282:	4620      	mov	r0, r4
 804a284:	eb04 0344 	add.w	r3, r4, r4, lsl #1
 804a288:	00da      	lsls	r2, r3, #3
 804a28a:	4b1d      	ldr	r3, [pc, #116]	; (804a300 <etharp_tmr+0x94>)
 804a28c:	4413      	add	r3, r2
 804a28e:	7d1b      	ldrb	r3, [r3, #20]
    if (state != ETHARP_STATE_EMPTY
 804a290:	2b00      	cmp	r3, #0
 804a292:	d0f2      	beq.n	804a27a <etharp_tmr+0xe>
      arp_table[i].ctime++;
 804a294:	eb04 0244 	add.w	r2, r4, r4, lsl #1
 804a298:	00d3      	lsls	r3, r2, #3
 804a29a:	4a19      	ldr	r2, [pc, #100]	; (804a300 <etharp_tmr+0x94>)
 804a29c:	441a      	add	r2, r3
 804a29e:	8a53      	ldrh	r3, [r2, #18]
 804a2a0:	3301      	adds	r3, #1
 804a2a2:	b29b      	uxth	r3, r3
 804a2a4:	8253      	strh	r3, [r2, #18]
      if ((arp_table[i].ctime >= ARP_MAXAGE) ||
 804a2a6:	f5b3 7f96 	cmp.w	r3, #300	; 0x12c
 804a2aa:	d2e4      	bcs.n	804a276 <etharp_tmr+0xa>
          ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
 804a2ac:	eb04 0244 	add.w	r2, r4, r4, lsl #1
 804a2b0:	00d1      	lsls	r1, r2, #3
 804a2b2:	4a13      	ldr	r2, [pc, #76]	; (804a300 <etharp_tmr+0x94>)
 804a2b4:	440a      	add	r2, r1
 804a2b6:	7d12      	ldrb	r2, [r2, #20]
      if ((arp_table[i].ctime >= ARP_MAXAGE) ||
 804a2b8:	2a01      	cmp	r2, #1
 804a2ba:	d0da      	beq.n	804a272 <etharp_tmr+0x6>
      } else if (arp_table[i].state == ETHARP_STATE_STABLE_REREQUESTING_1) {
 804a2bc:	2a03      	cmp	r2, #3
 804a2be:	d00e      	beq.n	804a2de <etharp_tmr+0x72>
      } else if (arp_table[i].state == ETHARP_STATE_STABLE_REREQUESTING_2) {
 804a2c0:	2a04      	cmp	r2, #4
 804a2c2:	d014      	beq.n	804a2ee <etharp_tmr+0x82>
      } else if (arp_table[i].state == ETHARP_STATE_PENDING) {
 804a2c4:	2a01      	cmp	r2, #1
 804a2c6:	d1d8      	bne.n	804a27a <etharp_tmr+0xe>
        etharp_request(arp_table[i].netif, &arp_table[i].ipaddr);
 804a2c8:	4b0d      	ldr	r3, [pc, #52]	; (804a300 <etharp_tmr+0x94>)
 804a2ca:	eb00 0240 	add.w	r2, r0, r0, lsl #1
 804a2ce:	00d1      	lsls	r1, r2, #3
 804a2d0:	4419      	add	r1, r3
 804a2d2:	460b      	mov	r3, r1
 804a2d4:	3104      	adds	r1, #4
 804a2d6:	6898      	ldr	r0, [r3, #8]
 804a2d8:	f7ff ffc0 	bl	804a25c <etharp_request>
 804a2dc:	e7cd      	b.n	804a27a <etharp_tmr+0xe>
        arp_table[i].state = ETHARP_STATE_STABLE_REREQUESTING_2;
 804a2de:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 804a2e2:	00c2      	lsls	r2, r0, #3
 804a2e4:	4b06      	ldr	r3, [pc, #24]	; (804a300 <etharp_tmr+0x94>)
 804a2e6:	4413      	add	r3, r2
 804a2e8:	2204      	movs	r2, #4
 804a2ea:	751a      	strb	r2, [r3, #20]
 804a2ec:	e7c5      	b.n	804a27a <etharp_tmr+0xe>
        arp_table[i].state = ETHARP_STATE_STABLE;
 804a2ee:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 804a2f2:	00c2      	lsls	r2, r0, #3
 804a2f4:	4b02      	ldr	r3, [pc, #8]	; (804a300 <etharp_tmr+0x94>)
 804a2f6:	4413      	add	r3, r2
 804a2f8:	2202      	movs	r2, #2
 804a2fa:	751a      	strb	r2, [r3, #20]
 804a2fc:	e7bd      	b.n	804a27a <etharp_tmr+0xe>
}
 804a2fe:	bd10      	pop	{r4, pc}
 804a300:	20004114 	.word	0x20004114

0804a304 <etharp_output_to_arp_index>:
{
 804a304:	b570      	push	{r4, r5, r6, lr}
 804a306:	b082      	sub	sp, #8
 804a308:	4605      	mov	r5, r0
 804a30a:	460e      	mov	r6, r1
 804a30c:	4614      	mov	r4, r2
  LWIP_ASSERT("arp_table[arp_idx].state >= ETHARP_STATE_STABLE",
 804a30e:	eb02 0242 	add.w	r2, r2, r2, lsl #1
 804a312:	4b2f      	ldr	r3, [pc, #188]	; (804a3d0 <etharp_output_to_arp_index+0xcc>)
 804a314:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 804a318:	7d1b      	ldrb	r3, [r3, #20]
 804a31a:	2b01      	cmp	r3, #1
 804a31c:	d919      	bls.n	804a352 <etharp_output_to_arp_index+0x4e>
  if (arp_table[arp_idx].state == ETHARP_STATE_STABLE) {
 804a31e:	eb04 0344 	add.w	r3, r4, r4, lsl #1
 804a322:	4a2b      	ldr	r2, [pc, #172]	; (804a3d0 <etharp_output_to_arp_index+0xcc>)
 804a324:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 804a328:	7d1b      	ldrb	r3, [r3, #20]
 804a32a:	2b02      	cmp	r3, #2
 804a32c:	d019      	beq.n	804a362 <etharp_output_to_arp_index+0x5e>
  return ethernet_output(netif, q, (struct eth_addr*)(netif->hwaddr), &arp_table[arp_idx].ethaddr, ETHTYPE_IP);
 804a32e:	eb04 0344 	add.w	r3, r4, r4, lsl #1
 804a332:	00db      	lsls	r3, r3, #3
 804a334:	3308      	adds	r3, #8
 804a336:	4c26      	ldr	r4, [pc, #152]	; (804a3d0 <etharp_output_to_arp_index+0xcc>)
 804a338:	4423      	add	r3, r4
 804a33a:	f44f 6200 	mov.w	r2, #2048	; 0x800
 804a33e:	9200      	str	r2, [sp, #0]
 804a340:	3304      	adds	r3, #4
 804a342:	f105 0225 	add.w	r2, r5, #37	; 0x25
 804a346:	4631      	mov	r1, r6
 804a348:	4628      	mov	r0, r5
 804a34a:	f001 f985 	bl	804b658 <ethernet_output>
}
 804a34e:	b002      	add	sp, #8
 804a350:	bd70      	pop	{r4, r5, r6, pc}
  LWIP_ASSERT("arp_table[arp_idx].state >= ETHARP_STATE_STABLE",
 804a352:	4b20      	ldr	r3, [pc, #128]	; (804a3d4 <etharp_output_to_arp_index+0xd0>)
 804a354:	f44f 723b 	mov.w	r2, #748	; 0x2ec
 804a358:	491f      	ldr	r1, [pc, #124]	; (804a3d8 <etharp_output_to_arp_index+0xd4>)
 804a35a:	4820      	ldr	r0, [pc, #128]	; (804a3dc <etharp_output_to_arp_index+0xd8>)
 804a35c:	f007 fb74 	bl	8051a48 <printf>
 804a360:	e7dd      	b.n	804a31e <etharp_output_to_arp_index+0x1a>
    if (arp_table[arp_idx].ctime >= ARP_AGE_REREQUEST_USED_BROADCAST) {
 804a362:	eb04 0344 	add.w	r3, r4, r4, lsl #1
 804a366:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 804a36a:	8a5b      	ldrh	r3, [r3, #18]
 804a36c:	f5b3 7f8e 	cmp.w	r3, #284	; 0x11c
 804a370:	d81b      	bhi.n	804a3aa <etharp_output_to_arp_index+0xa6>
    } else if (arp_table[arp_idx].ctime >= ARP_AGE_REREQUEST_USED_UNICAST) {
 804a372:	f5b3 7f87 	cmp.w	r3, #270	; 0x10e
 804a376:	d3da      	bcc.n	804a32e <etharp_output_to_arp_index+0x2a>
      if (etharp_request_dst(netif, &arp_table[arp_idx].ipaddr, &arp_table[arp_idx].ethaddr) == ERR_OK) {
 804a378:	4b15      	ldr	r3, [pc, #84]	; (804a3d0 <etharp_output_to_arp_index+0xcc>)
 804a37a:	eb04 0144 	add.w	r1, r4, r4, lsl #1
 804a37e:	eb03 01c1 	add.w	r1, r3, r1, lsl #3
 804a382:	eb04 0244 	add.w	r2, r4, r4, lsl #1
 804a386:	00d2      	lsls	r2, r2, #3
 804a388:	3208      	adds	r2, #8
 804a38a:	441a      	add	r2, r3
 804a38c:	3204      	adds	r2, #4
 804a38e:	3104      	adds	r1, #4
 804a390:	4628      	mov	r0, r5
 804a392:	f7ff fed5 	bl	804a140 <etharp_request_dst>
 804a396:	2800      	cmp	r0, #0
 804a398:	d1c9      	bne.n	804a32e <etharp_output_to_arp_index+0x2a>
        arp_table[arp_idx].state = ETHARP_STATE_STABLE_REREQUESTING_1;
 804a39a:	eb04 0344 	add.w	r3, r4, r4, lsl #1
 804a39e:	4a0c      	ldr	r2, [pc, #48]	; (804a3d0 <etharp_output_to_arp_index+0xcc>)
 804a3a0:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 804a3a4:	2203      	movs	r2, #3
 804a3a6:	751a      	strb	r2, [r3, #20]
 804a3a8:	e7c1      	b.n	804a32e <etharp_output_to_arp_index+0x2a>
      if (etharp_request(netif, &arp_table[arp_idx].ipaddr) == ERR_OK) {
 804a3aa:	eb04 0144 	add.w	r1, r4, r4, lsl #1
 804a3ae:	eb02 01c1 	add.w	r1, r2, r1, lsl #3
 804a3b2:	3104      	adds	r1, #4
 804a3b4:	4628      	mov	r0, r5
 804a3b6:	f7ff ff51 	bl	804a25c <etharp_request>
 804a3ba:	2800      	cmp	r0, #0
 804a3bc:	d1b7      	bne.n	804a32e <etharp_output_to_arp_index+0x2a>
        arp_table[arp_idx].state = ETHARP_STATE_STABLE_REREQUESTING_1;
 804a3be:	eb04 0344 	add.w	r3, r4, r4, lsl #1
 804a3c2:	4a03      	ldr	r2, [pc, #12]	; (804a3d0 <etharp_output_to_arp_index+0xcc>)
 804a3c4:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 804a3c8:	2203      	movs	r2, #3
 804a3ca:	751a      	strb	r2, [r3, #20]
 804a3cc:	e7af      	b.n	804a32e <etharp_output_to_arp_index+0x2a>
 804a3ce:	bf00      	nop
 804a3d0:	20004114 	.word	0x20004114
 804a3d4:	0805a2c0 	.word	0x0805a2c0
 804a3d8:	0805a440 	.word	0x0805a440
 804a3dc:	08058ecc 	.word	0x08058ecc

0804a3e0 <etharp_query>:
{
 804a3e0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 804a3e4:	b082      	sub	sp, #8
 804a3e6:	4606      	mov	r6, r0
 804a3e8:	460d      	mov	r5, r1
 804a3ea:	4690      	mov	r8, r2
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
 804a3ec:	f100 0925 	add.w	r9, r0, #37	; 0x25
  if (ip4_addr_isbroadcast(ipaddr, netif) ||
 804a3f0:	4601      	mov	r1, r0
 804a3f2:	6828      	ldr	r0, [r5, #0]
 804a3f4:	f000 fc19 	bl	804ac2a <ip4_addr_isbroadcast_u32>
 804a3f8:	2800      	cmp	r0, #0
 804a3fa:	f040 80b3 	bne.w	804a564 <etharp_query+0x184>
      ip4_addr_ismulticast(ipaddr) ||
 804a3fe:	682b      	ldr	r3, [r5, #0]
 804a400:	f003 02f0 	and.w	r2, r3, #240	; 0xf0
  if (ip4_addr_isbroadcast(ipaddr, netif) ||
 804a404:	2ae0      	cmp	r2, #224	; 0xe0
 804a406:	f000 80b0 	beq.w	804a56a <etharp_query+0x18a>
      ip4_addr_ismulticast(ipaddr) ||
 804a40a:	2d00      	cmp	r5, #0
 804a40c:	f000 80b0 	beq.w	804a570 <etharp_query+0x190>
      ip4_addr_isany(ipaddr)) {
 804a410:	2b00      	cmp	r3, #0
 804a412:	f000 80b0 	beq.w	804a576 <etharp_query+0x196>
  i = etharp_find_entry(ipaddr, ETHARP_FLAG_TRY_HARD, netif);
 804a416:	4632      	mov	r2, r6
 804a418:	2101      	movs	r1, #1
 804a41a:	4628      	mov	r0, r5
 804a41c:	f7ff fcee 	bl	8049dfc <etharp_find_entry>
  if (i < 0) {
 804a420:	1e04      	subs	r4, r0, #0
 804a422:	db5c      	blt.n	804a4de <etharp_query+0xfe>
  if (arp_table[i].state == ETHARP_STATE_EMPTY) {
 804a424:	4627      	mov	r7, r4
 804a426:	eb04 0344 	add.w	r3, r4, r4, lsl #1
 804a42a:	4a56      	ldr	r2, [pc, #344]	; (804a584 <etharp_query+0x1a4>)
 804a42c:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 804a430:	7d1b      	ldrb	r3, [r3, #20]
 804a432:	b94b      	cbnz	r3, 804a448 <etharp_query+0x68>
    arp_table[i].state = ETHARP_STATE_PENDING;
 804a434:	eb04 0344 	add.w	r3, r4, r4, lsl #1
 804a438:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 804a43c:	f04f 0a01 	mov.w	sl, #1
 804a440:	f883 a014 	strb.w	sl, [r3, #20]
    arp_table[i].netif = netif;
 804a444:	609e      	str	r6, [r3, #8]
 804a446:	e001      	b.n	804a44c <etharp_query+0x6c>
  int is_new_entry = 0;
 804a448:	f04f 0a00 	mov.w	sl, #0
  LWIP_ASSERT("arp_table[i].state == PENDING or STABLE",
 804a44c:	eb07 0347 	add.w	r3, r7, r7, lsl #1
 804a450:	4a4c      	ldr	r2, [pc, #304]	; (804a584 <etharp_query+0x1a4>)
 804a452:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 804a456:	7d1b      	ldrb	r3, [r3, #20]
 804a458:	b1b3      	cbz	r3, 804a488 <etharp_query+0xa8>
  if (is_new_entry || (q == NULL)) {
 804a45a:	f1ba 0f00 	cmp.w	sl, #0
 804a45e:	d11b      	bne.n	804a498 <etharp_query+0xb8>
 804a460:	f1b8 0f00 	cmp.w	r8, #0
 804a464:	d018      	beq.n	804a498 <etharp_query+0xb8>
  err_t result = ERR_MEM;
 804a466:	f04f 35ff 	mov.w	r5, #4294967295
  LWIP_ASSERT("q != NULL", q != NULL);
 804a46a:	f1b8 0f00 	cmp.w	r8, #0
 804a46e:	d01d      	beq.n	804a4ac <etharp_query+0xcc>
  if (arp_table[i].state >= ETHARP_STATE_STABLE) {
 804a470:	eb07 0347 	add.w	r3, r7, r7, lsl #1
 804a474:	4a43      	ldr	r2, [pc, #268]	; (804a584 <etharp_query+0x1a4>)
 804a476:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 804a47a:	7d1b      	ldrb	r3, [r3, #20]
 804a47c:	2b01      	cmp	r3, #1
 804a47e:	d81d      	bhi.n	804a4bc <etharp_query+0xdc>
  } else if (arp_table[i].state == ETHARP_STATE_PENDING) {
 804a480:	2b01      	cmp	r3, #1
 804a482:	d044      	beq.n	804a50e <etharp_query+0x12e>
 804a484:	462c      	mov	r4, r5
 804a486:	e02a      	b.n	804a4de <etharp_query+0xfe>
  LWIP_ASSERT("arp_table[i].state == PENDING or STABLE",
 804a488:	4b3f      	ldr	r3, [pc, #252]	; (804a588 <etharp_query+0x1a8>)
 804a48a:	f240 32c7 	movw	r2, #967	; 0x3c7
 804a48e:	493f      	ldr	r1, [pc, #252]	; (804a58c <etharp_query+0x1ac>)
 804a490:	483f      	ldr	r0, [pc, #252]	; (804a590 <etharp_query+0x1b0>)
 804a492:	f007 fad9 	bl	8051a48 <printf>
 804a496:	e7e0      	b.n	804a45a <etharp_query+0x7a>
    result = etharp_request(netif, ipaddr);
 804a498:	4629      	mov	r1, r5
 804a49a:	4630      	mov	r0, r6
 804a49c:	f7ff fede 	bl	804a25c <etharp_request>
 804a4a0:	4605      	mov	r5, r0
    if (q == NULL) {
 804a4a2:	f1b8 0f00 	cmp.w	r8, #0
 804a4a6:	d1e0      	bne.n	804a46a <etharp_query+0x8a>
      return result;
 804a4a8:	4604      	mov	r4, r0
 804a4aa:	e018      	b.n	804a4de <etharp_query+0xfe>
  LWIP_ASSERT("q != NULL", q != NULL);
 804a4ac:	4b36      	ldr	r3, [pc, #216]	; (804a588 <etharp_query+0x1a8>)
 804a4ae:	f240 32db 	movw	r2, #987	; 0x3db
 804a4b2:	4938      	ldr	r1, [pc, #224]	; (804a594 <etharp_query+0x1b4>)
 804a4b4:	4836      	ldr	r0, [pc, #216]	; (804a590 <etharp_query+0x1b0>)
 804a4b6:	f007 fac7 	bl	8051a48 <printf>
 804a4ba:	e7d9      	b.n	804a470 <etharp_query+0x90>
    ETHARP_SET_HINT(netif, i);
 804a4bc:	f882 40f0 	strb.w	r4, [r2, #240]	; 0xf0
    result = ethernet_output(netif, q, srcaddr, &(arp_table[i].ethaddr), ETHTYPE_IP);
 804a4c0:	eb07 0347 	add.w	r3, r7, r7, lsl #1
 804a4c4:	00db      	lsls	r3, r3, #3
 804a4c6:	3308      	adds	r3, #8
 804a4c8:	4413      	add	r3, r2
 804a4ca:	f44f 6200 	mov.w	r2, #2048	; 0x800
 804a4ce:	9200      	str	r2, [sp, #0]
 804a4d0:	3304      	adds	r3, #4
 804a4d2:	464a      	mov	r2, r9
 804a4d4:	4641      	mov	r1, r8
 804a4d6:	4630      	mov	r0, r6
 804a4d8:	f001 f8be 	bl	804b658 <ethernet_output>
 804a4dc:	4604      	mov	r4, r0
}
 804a4de:	4620      	mov	r0, r4
 804a4e0:	b002      	add	sp, #8
 804a4e2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      LWIP_ASSERT("no packet queues allowed!", (p->len != p->tot_len) || (p->next == 0));
 804a4e6:	4b28      	ldr	r3, [pc, #160]	; (804a588 <etharp_query+0x1a8>)
 804a4e8:	f44f 727b 	mov.w	r2, #1004	; 0x3ec
 804a4ec:	492a      	ldr	r1, [pc, #168]	; (804a598 <etharp_query+0x1b8>)
 804a4ee:	4828      	ldr	r0, [pc, #160]	; (804a590 <etharp_query+0x1b0>)
 804a4f0:	f007 faaa 	bl	8051a48 <printf>
      if (p->type != PBUF_ROM) {
 804a4f4:	7b23      	ldrb	r3, [r4, #12]
 804a4f6:	2b01      	cmp	r3, #1
 804a4f8:	d11e      	bne.n	804a538 <etharp_query+0x158>
      p = p->next;
 804a4fa:	6824      	ldr	r4, [r4, #0]
    while (p) {
 804a4fc:	b14c      	cbz	r4, 804a512 <etharp_query+0x132>
      LWIP_ASSERT("no packet queues allowed!", (p->len != p->tot_len) || (p->next == 0));
 804a4fe:	8962      	ldrh	r2, [r4, #10]
 804a500:	8923      	ldrh	r3, [r4, #8]
 804a502:	429a      	cmp	r2, r3
 804a504:	d1f6      	bne.n	804a4f4 <etharp_query+0x114>
 804a506:	6823      	ldr	r3, [r4, #0]
 804a508:	2b00      	cmp	r3, #0
 804a50a:	d1ec      	bne.n	804a4e6 <etharp_query+0x106>
 804a50c:	e7f2      	b.n	804a4f4 <etharp_query+0x114>
    p = q;
 804a50e:	4644      	mov	r4, r8
 804a510:	e7f4      	b.n	804a4fc <etharp_query+0x11c>
    int copy_needed = 0;
 804a512:	2300      	movs	r3, #0
    if (copy_needed) {
 804a514:	b193      	cbz	r3, 804a53c <etharp_query+0x15c>
      p = pbuf_alloc(PBUF_LINK, p->tot_len, PBUF_RAM);
 804a516:	2200      	movs	r2, #0
 804a518:	8921      	ldrh	r1, [r4, #8]
 804a51a:	2002      	movs	r0, #2
 804a51c:	f7fb fc42 	bl	8045da4 <pbuf_alloc>
      if (p != NULL) {
 804a520:	4604      	mov	r4, r0
 804a522:	b178      	cbz	r0, 804a544 <etharp_query+0x164>
        if (pbuf_copy(p, q) != ERR_OK) {
 804a524:	4641      	mov	r1, r8
 804a526:	f7fb fdff 	bl	8046128 <pbuf_copy>
 804a52a:	b158      	cbz	r0, 804a544 <etharp_query+0x164>
          pbuf_free(p);
 804a52c:	4620      	mov	r0, r4
 804a52e:	f7fb fbd5 	bl	8045cdc <pbuf_free>
      result = ERR_MEM;
 804a532:	f04f 34ff 	mov.w	r4, #4294967295
 804a536:	e7d2      	b.n	804a4de <etharp_query+0xfe>
        copy_needed = 1;
 804a538:	2301      	movs	r3, #1
 804a53a:	e7eb      	b.n	804a514 <etharp_query+0x134>
      pbuf_ref(p);
 804a53c:	4640      	mov	r0, r8
 804a53e:	f7fb fda1 	bl	8046084 <pbuf_ref>
      p = q;
 804a542:	4644      	mov	r4, r8
    if (p != NULL) {
 804a544:	b1d4      	cbz	r4, 804a57c <etharp_query+0x19c>
      if (arp_table[i].q != NULL) {
 804a546:	eb07 0347 	add.w	r3, r7, r7, lsl #1
 804a54a:	4a0e      	ldr	r2, [pc, #56]	; (804a584 <etharp_query+0x1a4>)
 804a54c:	f852 0033 	ldr.w	r0, [r2, r3, lsl #3]
 804a550:	b108      	cbz	r0, 804a556 <etharp_query+0x176>
        pbuf_free(arp_table[i].q);
 804a552:	f7fb fbc3 	bl	8045cdc <pbuf_free>
      arp_table[i].q = p;
 804a556:	eb07 0347 	add.w	r3, r7, r7, lsl #1
 804a55a:	4a0a      	ldr	r2, [pc, #40]	; (804a584 <etharp_query+0x1a4>)
 804a55c:	f842 4033 	str.w	r4, [r2, r3, lsl #3]
      result = ERR_OK;
 804a560:	2400      	movs	r4, #0
 804a562:	e7bc      	b.n	804a4de <etharp_query+0xfe>
    return ERR_ARG;
 804a564:	f06f 040f 	mvn.w	r4, #15
 804a568:	e7b9      	b.n	804a4de <etharp_query+0xfe>
 804a56a:	f06f 040f 	mvn.w	r4, #15
 804a56e:	e7b6      	b.n	804a4de <etharp_query+0xfe>
 804a570:	f06f 040f 	mvn.w	r4, #15
 804a574:	e7b3      	b.n	804a4de <etharp_query+0xfe>
 804a576:	f06f 040f 	mvn.w	r4, #15
 804a57a:	e7b0      	b.n	804a4de <etharp_query+0xfe>
      result = ERR_MEM;
 804a57c:	f04f 34ff 	mov.w	r4, #4294967295
 804a580:	e7ad      	b.n	804a4de <etharp_query+0xfe>
 804a582:	bf00      	nop
 804a584:	20004114 	.word	0x20004114
 804a588:	0805a2c0 	.word	0x0805a2c0
 804a58c:	0805a470 	.word	0x0805a470
 804a590:	08058ecc 	.word	0x08058ecc
 804a594:	0805a498 	.word	0x0805a498
 804a598:	0805a4a4 	.word	0x0805a4a4

0804a59c <etharp_output>:
{
 804a59c:	b5f0      	push	{r4, r5, r6, r7, lr}
 804a59e:	b085      	sub	sp, #20
 804a5a0:	460e      	mov	r6, r1
 804a5a2:	4615      	mov	r5, r2
  LWIP_ASSERT("netif != NULL", netif != NULL);
 804a5a4:	4607      	mov	r7, r0
 804a5a6:	2800      	cmp	r0, #0
 804a5a8:	d031      	beq.n	804a60e <etharp_output+0x72>
  LWIP_ASSERT("q != NULL", q != NULL);
 804a5aa:	2e00      	cmp	r6, #0
 804a5ac:	d037      	beq.n	804a61e <etharp_output+0x82>
  LWIP_ASSERT("ipaddr != NULL", ipaddr != NULL);
 804a5ae:	2d00      	cmp	r5, #0
 804a5b0:	d03d      	beq.n	804a62e <etharp_output+0x92>
  if (ip4_addr_isbroadcast(ipaddr, netif)) {
 804a5b2:	4639      	mov	r1, r7
 804a5b4:	6828      	ldr	r0, [r5, #0]
 804a5b6:	f000 fb38 	bl	804ac2a <ip4_addr_isbroadcast_u32>
 804a5ba:	2800      	cmp	r0, #0
 804a5bc:	d17e      	bne.n	804a6bc <etharp_output+0x120>
  } else if (ip4_addr_ismulticast(ipaddr)) {
 804a5be:	682b      	ldr	r3, [r5, #0]
 804a5c0:	f003 02f0 	and.w	r2, r3, #240	; 0xf0
 804a5c4:	2ae0      	cmp	r2, #224	; 0xe0
 804a5c6:	d03a      	beq.n	804a63e <etharp_output+0xa2>
    if (!ip4_addr_netcmp(ipaddr, netif_ip4_addr(netif), netif_ip4_netmask(netif)) &&
 804a5c8:	687a      	ldr	r2, [r7, #4]
 804a5ca:	68b9      	ldr	r1, [r7, #8]
 804a5cc:	405a      	eors	r2, r3
 804a5ce:	420a      	tst	r2, r1
 804a5d0:	d009      	beq.n	804a5e6 <etharp_output+0x4a>
        !ip4_addr_islinklocal(ipaddr)) {
 804a5d2:	b29b      	uxth	r3, r3
    if (!ip4_addr_netcmp(ipaddr, netif_ip4_addr(netif), netif_ip4_netmask(netif)) &&
 804a5d4:	f64f 62a9 	movw	r2, #65193	; 0xfea9
 804a5d8:	4293      	cmp	r3, r2
 804a5da:	d004      	beq.n	804a5e6 <etharp_output+0x4a>
          if (!ip4_addr_isany_val(*netif_ip4_gw(netif))) {
 804a5dc:	68fb      	ldr	r3, [r7, #12]
 804a5de:	2b00      	cmp	r3, #0
 804a5e0:	d078      	beq.n	804a6d4 <etharp_output+0x138>
            dst_addr = netif_ip4_gw(netif);
 804a5e2:	f107 050c 	add.w	r5, r7, #12
        if ((arp_table[etharp_cached_entry].state >= ETHARP_STATE_STABLE) &&
 804a5e6:	4b3d      	ldr	r3, [pc, #244]	; (804a6dc <etharp_output+0x140>)
 804a5e8:	f893 20f0 	ldrb.w	r2, [r3, #240]	; 0xf0
 804a5ec:	eb02 0142 	add.w	r1, r2, r2, lsl #1
 804a5f0:	eb03 03c1 	add.w	r3, r3, r1, lsl #3
 804a5f4:	7d1b      	ldrb	r3, [r3, #20]
 804a5f6:	2b01      	cmp	r3, #1
 804a5f8:	d958      	bls.n	804a6ac <etharp_output+0x110>
            (ip4_addr_cmp(dst_addr, &arp_table[etharp_cached_entry].ipaddr))) {
 804a5fa:	6828      	ldr	r0, [r5, #0]
 804a5fc:	460b      	mov	r3, r1
 804a5fe:	4937      	ldr	r1, [pc, #220]	; (804a6dc <etharp_output+0x140>)
 804a600:	eb01 03c3 	add.w	r3, r1, r3, lsl #3
 804a604:	685b      	ldr	r3, [r3, #4]
        if ((arp_table[etharp_cached_entry].state >= ETHARP_STATE_STABLE) &&
 804a606:	4298      	cmp	r0, r3
 804a608:	d02f      	beq.n	804a66a <etharp_output+0xce>
 804a60a:	2300      	movs	r3, #0
 804a60c:	e034      	b.n	804a678 <etharp_output+0xdc>
  LWIP_ASSERT("netif != NULL", netif != NULL);
 804a60e:	4b34      	ldr	r3, [pc, #208]	; (804a6e0 <etharp_output+0x144>)
 804a610:	f240 321b 	movw	r2, #795	; 0x31b
 804a614:	4933      	ldr	r1, [pc, #204]	; (804a6e4 <etharp_output+0x148>)
 804a616:	4834      	ldr	r0, [pc, #208]	; (804a6e8 <etharp_output+0x14c>)
 804a618:	f007 fa16 	bl	8051a48 <printf>
 804a61c:	e7c5      	b.n	804a5aa <etharp_output+0xe>
  LWIP_ASSERT("q != NULL", q != NULL);
 804a61e:	4b30      	ldr	r3, [pc, #192]	; (804a6e0 <etharp_output+0x144>)
 804a620:	f44f 7247 	mov.w	r2, #796	; 0x31c
 804a624:	4931      	ldr	r1, [pc, #196]	; (804a6ec <etharp_output+0x150>)
 804a626:	4830      	ldr	r0, [pc, #192]	; (804a6e8 <etharp_output+0x14c>)
 804a628:	f007 fa0e 	bl	8051a48 <printf>
 804a62c:	e7bf      	b.n	804a5ae <etharp_output+0x12>
  LWIP_ASSERT("ipaddr != NULL", ipaddr != NULL);
 804a62e:	4b2c      	ldr	r3, [pc, #176]	; (804a6e0 <etharp_output+0x144>)
 804a630:	f240 321d 	movw	r2, #797	; 0x31d
 804a634:	492e      	ldr	r1, [pc, #184]	; (804a6f0 <etharp_output+0x154>)
 804a636:	482c      	ldr	r0, [pc, #176]	; (804a6e8 <etharp_output+0x14c>)
 804a638:	f007 fa06 	bl	8051a48 <printf>
 804a63c:	e7b9      	b.n	804a5b2 <etharp_output+0x16>
    mcastaddr.addr[0] = LL_IP4_MULTICAST_ADDR_0;
 804a63e:	2301      	movs	r3, #1
 804a640:	f88d 3008 	strb.w	r3, [sp, #8]
    mcastaddr.addr[1] = LL_IP4_MULTICAST_ADDR_1;
 804a644:	2300      	movs	r3, #0
 804a646:	f88d 3009 	strb.w	r3, [sp, #9]
    mcastaddr.addr[2] = LL_IP4_MULTICAST_ADDR_2;
 804a64a:	235e      	movs	r3, #94	; 0x5e
 804a64c:	f88d 300a 	strb.w	r3, [sp, #10]
    mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
 804a650:	786b      	ldrb	r3, [r5, #1]
 804a652:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 804a656:	f88d 300b 	strb.w	r3, [sp, #11]
    mcastaddr.addr[4] = ip4_addr3(ipaddr);
 804a65a:	78ab      	ldrb	r3, [r5, #2]
 804a65c:	f88d 300c 	strb.w	r3, [sp, #12]
    mcastaddr.addr[5] = ip4_addr4(ipaddr);
 804a660:	78eb      	ldrb	r3, [r5, #3]
 804a662:	f88d 300d 	strb.w	r3, [sp, #13]
    dest = &mcastaddr;
 804a666:	ab02      	add	r3, sp, #8
 804a668:	e029      	b.n	804a6be <etharp_output+0x122>
          return etharp_output_to_arp_index(netif, q, etharp_cached_entry);
 804a66a:	4631      	mov	r1, r6
 804a66c:	4638      	mov	r0, r7
 804a66e:	f7ff fe49 	bl	804a304 <etharp_output_to_arp_index>
 804a672:	e02d      	b.n	804a6d0 <etharp_output+0x134>
    for (i = 0; i < ARP_TABLE_SIZE; i++) {
 804a674:	3301      	adds	r3, #1
 804a676:	b25b      	sxtb	r3, r3
 804a678:	2b09      	cmp	r3, #9
 804a67a:	dc19      	bgt.n	804a6b0 <etharp_output+0x114>
      if ((arp_table[i].state >= ETHARP_STATE_STABLE) &&
 804a67c:	eb03 0043 	add.w	r0, r3, r3, lsl #1
 804a680:	4c16      	ldr	r4, [pc, #88]	; (804a6dc <etharp_output+0x140>)
 804a682:	eb04 00c0 	add.w	r0, r4, r0, lsl #3
 804a686:	7d02      	ldrb	r2, [r0, #20]
 804a688:	2a01      	cmp	r2, #1
 804a68a:	d9f3      	bls.n	804a674 <etharp_output+0xd8>
          (ip4_addr_cmp(dst_addr, &arp_table[i].ipaddr))) {
 804a68c:	6828      	ldr	r0, [r5, #0]
 804a68e:	eb03 0243 	add.w	r2, r3, r3, lsl #1
 804a692:	eb04 02c2 	add.w	r2, r4, r2, lsl #3
 804a696:	6852      	ldr	r2, [r2, #4]
      if ((arp_table[i].state >= ETHARP_STATE_STABLE) &&
 804a698:	4290      	cmp	r0, r2
 804a69a:	d1eb      	bne.n	804a674 <etharp_output+0xd8>
        ETHARP_SET_HINT(netif, i);
 804a69c:	b2da      	uxtb	r2, r3
 804a69e:	f884 20f0 	strb.w	r2, [r4, #240]	; 0xf0
        return etharp_output_to_arp_index(netif, q, i);
 804a6a2:	4631      	mov	r1, r6
 804a6a4:	4638      	mov	r0, r7
 804a6a6:	f7ff fe2d 	bl	804a304 <etharp_output_to_arp_index>
 804a6aa:	e011      	b.n	804a6d0 <etharp_output+0x134>
 804a6ac:	2300      	movs	r3, #0
 804a6ae:	e7e3      	b.n	804a678 <etharp_output+0xdc>
    return etharp_query(netif, dst_addr, q);
 804a6b0:	4632      	mov	r2, r6
 804a6b2:	4629      	mov	r1, r5
 804a6b4:	4638      	mov	r0, r7
 804a6b6:	f7ff fe93 	bl	804a3e0 <etharp_query>
 804a6ba:	e009      	b.n	804a6d0 <etharp_output+0x134>
    dest = (const struct eth_addr *)&ethbroadcast;
 804a6bc:	4b0d      	ldr	r3, [pc, #52]	; (804a6f4 <etharp_output+0x158>)
  return ethernet_output(netif, q, (struct eth_addr*)(netif->hwaddr), dest, ETHTYPE_IP);
 804a6be:	f44f 6200 	mov.w	r2, #2048	; 0x800
 804a6c2:	9200      	str	r2, [sp, #0]
 804a6c4:	f107 0225 	add.w	r2, r7, #37	; 0x25
 804a6c8:	4631      	mov	r1, r6
 804a6ca:	4638      	mov	r0, r7
 804a6cc:	f000 ffc4 	bl	804b658 <ethernet_output>
}
 804a6d0:	b005      	add	sp, #20
 804a6d2:	bdf0      	pop	{r4, r5, r6, r7, pc}
            return ERR_RTE;
 804a6d4:	f06f 0003 	mvn.w	r0, #3
 804a6d8:	e7fa      	b.n	804a6d0 <etharp_output+0x134>
 804a6da:	bf00      	nop
 804a6dc:	20004114 	.word	0x20004114
 804a6e0:	0805a2c0 	.word	0x0805a2c0
 804a6e4:	0805a374 	.word	0x0805a374
 804a6e8:	08058ecc 	.word	0x08058ecc
 804a6ec:	0805a498 	.word	0x0805a498
 804a6f0:	0805a420 	.word	0x0805a420
 804a6f4:	08058e5c 	.word	0x08058e5c

0804a6f8 <icmp_send_response>:
 * @param type Type of the ICMP header
 * @param code Code of the ICMP header
 */
static void
icmp_send_response(struct pbuf *p, u8_t type, u8_t code)
{
 804a6f8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 804a6fc:	b086      	sub	sp, #24
 804a6fe:	4606      	mov	r6, r0
 804a700:	4688      	mov	r8, r1
 804a702:	4617      	mov	r7, r2

  /* increase number of messages attempted to send */
  MIB2_STATS_INC(mib2.icmpoutmsgs);

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
 804a704:	2200      	movs	r2, #0
 804a706:	2124      	movs	r1, #36	; 0x24
 804a708:	2001      	movs	r0, #1
 804a70a:	f7fb fb4b 	bl	8045da4 <pbuf_alloc>
                 PBUF_RAM);
  if (q == NULL) {
 804a70e:	b3a0      	cbz	r0, 804a77a <icmp_send_response+0x82>
 804a710:	4605      	mov	r5, r0
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_time_exceeded: failed to allocate pbuf for ICMP packet.\n"));
    MIB2_STATS_INC(mib2.icmpouterrors);
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
 804a712:	8943      	ldrh	r3, [r0, #10]
 804a714:	2b23      	cmp	r3, #35	; 0x23
 804a716:	d933      	bls.n	804a780 <icmp_send_response+0x88>
             (q->len >= (sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

  iphdr = (struct ip_hdr *)p->payload;
 804a718:	f8d6 c004 	ldr.w	ip, [r6, #4]
  ip4_addr_debug_print_val(ICMP_DEBUG, iphdr->src);
  LWIP_DEBUGF(ICMP_DEBUG, (" to "));
  ip4_addr_debug_print_val(ICMP_DEBUG, iphdr->dest);
  LWIP_DEBUGF(ICMP_DEBUG, ("\n"));

  icmphdr = (struct icmp_echo_hdr *)q->payload;
 804a71c:	686c      	ldr	r4, [r5, #4]
  icmphdr->type = type;
 804a71e:	f884 8000 	strb.w	r8, [r4]
  icmphdr->code = code;
 804a722:	7067      	strb	r7, [r4, #1]
  icmphdr->id = 0;
 804a724:	2300      	movs	r3, #0
 804a726:	7123      	strb	r3, [r4, #4]
 804a728:	7163      	strb	r3, [r4, #5]
  icmphdr->seqno = 0;
 804a72a:	71a3      	strb	r3, [r4, #6]
 804a72c:	71e3      	strb	r3, [r4, #7]

  /* copy fields from original packet */
  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_echo_hdr), (u8_t *)p->payload,
 804a72e:	686b      	ldr	r3, [r5, #4]
 804a730:	6872      	ldr	r2, [r6, #4]
 804a732:	6816      	ldr	r6, [r2, #0]
 804a734:	6850      	ldr	r0, [r2, #4]
 804a736:	6891      	ldr	r1, [r2, #8]
 804a738:	68d7      	ldr	r7, [r2, #12]
 804a73a:	609e      	str	r6, [r3, #8]
 804a73c:	60d8      	str	r0, [r3, #12]
 804a73e:	6119      	str	r1, [r3, #16]
 804a740:	615f      	str	r7, [r3, #20]
 804a742:	6916      	ldr	r6, [r2, #16]
 804a744:	6950      	ldr	r0, [r2, #20]
 804a746:	6991      	ldr	r1, [r2, #24]
 804a748:	619e      	str	r6, [r3, #24]
 804a74a:	61d8      	str	r0, [r3, #28]
 804a74c:	6219      	str	r1, [r3, #32]
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  ip4_addr_copy(iphdr_src, iphdr->src);
 804a74e:	f8dc 300c 	ldr.w	r3, [ip, #12]
 804a752:	9305      	str	r3, [sp, #20]
    ip4_addr_t iphdr_dst;
    ip4_addr_copy(iphdr_dst, iphdr->dest);
    netif = ip4_route_src(&iphdr_src, &iphdr_dst);
  }
#else
  netif = ip4_route(&iphdr_src);
 804a754:	a805      	add	r0, sp, #20
 804a756:	f000 f8cb 	bl	804a8f0 <ip4_route>
#endif
  if (netif != NULL) {
 804a75a:	b158      	cbz	r0, 804a774 <icmp_send_response+0x7c>
    /* calculate checksum */
    icmphdr->chksum = 0;
 804a75c:	2100      	movs	r1, #0
 804a75e:	70a1      	strb	r1, [r4, #2]
 804a760:	70e1      	strb	r1, [r4, #3]
    IF__NETIF_CHECKSUM_ENABLED(netif, NETIF_CHECKSUM_GEN_ICMP) {
      icmphdr->chksum = inet_chksum(icmphdr, q->len);
    }
#endif
    ICMP_STATS_INC(icmp.xmit);
    ip4_output_if(q, NULL, &iphdr_src, ICMP_TTL, 0, IP_PROTO_ICMP, netif);
 804a762:	9002      	str	r0, [sp, #8]
 804a764:	2301      	movs	r3, #1
 804a766:	9301      	str	r3, [sp, #4]
 804a768:	9100      	str	r1, [sp, #0]
 804a76a:	23ff      	movs	r3, #255	; 0xff
 804a76c:	aa05      	add	r2, sp, #20
 804a76e:	4628      	mov	r0, r5
 804a770:	f000 fa46 	bl	804ac00 <ip4_output_if>
  }
  pbuf_free(q);
 804a774:	4628      	mov	r0, r5
 804a776:	f7fb fab1 	bl	8045cdc <pbuf_free>
}
 804a77a:	b006      	add	sp, #24
 804a77c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  LWIP_ASSERT("check that first pbuf can hold icmp message",
 804a780:	4b03      	ldr	r3, [pc, #12]	; (804a790 <icmp_send_response+0x98>)
 804a782:	f240 1261 	movw	r2, #353	; 0x161
 804a786:	4903      	ldr	r1, [pc, #12]	; (804a794 <icmp_send_response+0x9c>)
 804a788:	4803      	ldr	r0, [pc, #12]	; (804a798 <icmp_send_response+0xa0>)
 804a78a:	f007 f95d 	bl	8051a48 <printf>
 804a78e:	e7c3      	b.n	804a718 <icmp_send_response+0x20>
 804a790:	0805a4c0 	.word	0x0805a4c0
 804a794:	0805a4f8 	.word	0x0805a4f8
 804a798:	08058ecc 	.word	0x08058ecc

0804a79c <icmp_input>:
{
 804a79c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 804a7a0:	b084      	sub	sp, #16
 804a7a2:	4605      	mov	r5, r0
  iphdr_in = ip4_current_header();
 804a7a4:	4b47      	ldr	r3, [pc, #284]	; (804a8c4 <icmp_input+0x128>)
 804a7a6:	689e      	ldr	r6, [r3, #8]
  hlen = IPH_HL(iphdr_in) * 4;
 804a7a8:	7834      	ldrb	r4, [r6, #0]
 804a7aa:	f004 040f 	and.w	r4, r4, #15
 804a7ae:	00a4      	lsls	r4, r4, #2
  if (hlen < IP_HLEN) {
 804a7b0:	2c13      	cmp	r4, #19
 804a7b2:	d915      	bls.n	804a7e0 <icmp_input+0x44>
 804a7b4:	460f      	mov	r7, r1
  if (p->len < sizeof(u16_t)*2) {
 804a7b6:	8943      	ldrh	r3, [r0, #10]
 804a7b8:	2b03      	cmp	r3, #3
 804a7ba:	d911      	bls.n	804a7e0 <icmp_input+0x44>
  type = *((u8_t *)p->payload);
 804a7bc:	6843      	ldr	r3, [r0, #4]
 804a7be:	781b      	ldrb	r3, [r3, #0]
  switch (type) {
 804a7c0:	2b08      	cmp	r3, #8
 804a7c2:	d15d      	bne.n	804a880 <icmp_input+0xe4>
    if (ip4_addr_ismulticast(ip4_current_dest_addr())) {
 804a7c4:	4b3f      	ldr	r3, [pc, #252]	; (804a8c4 <icmp_input+0x128>)
 804a7c6:	6958      	ldr	r0, [r3, #20]
 804a7c8:	f000 03f0 	and.w	r3, r0, #240	; 0xf0
 804a7cc:	2be0      	cmp	r3, #224	; 0xe0
 804a7ce:	d037      	beq.n	804a840 <icmp_input+0xa4>
    if (ip4_addr_isbroadcast(ip4_current_dest_addr(), ip_current_netif())) {
 804a7d0:	4b3c      	ldr	r3, [pc, #240]	; (804a8c4 <icmp_input+0x128>)
 804a7d2:	6819      	ldr	r1, [r3, #0]
 804a7d4:	f000 fa29 	bl	804ac2a <ip4_addr_isbroadcast_u32>
 804a7d8:	bb90      	cbnz	r0, 804a840 <icmp_input+0xa4>
    if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
 804a7da:	892b      	ldrh	r3, [r5, #8]
 804a7dc:	2b07      	cmp	r3, #7
 804a7de:	d805      	bhi.n	804a7ec <icmp_input+0x50>
  pbuf_free(p);
 804a7e0:	4628      	mov	r0, r5
 804a7e2:	f7fb fa7b 	bl	8045cdc <pbuf_free>
}
 804a7e6:	b004      	add	sp, #16
 804a7e8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if (pbuf_header(p, (s16_t)(hlen + PBUF_LINK_HLEN + PBUF_LINK_ENCAPSULATION_HLEN))) {
 804a7ec:	f104 010e 	add.w	r1, r4, #14
 804a7f0:	4628      	mov	r0, r5
 804a7f2:	f7fb fa69 	bl	8045cc8 <pbuf_header>
 804a7f6:	b3a8      	cbz	r0, 804a864 <icmp_input+0xc8>
      r = pbuf_alloc(PBUF_LINK, p->tot_len + hlen, PBUF_RAM);
 804a7f8:	8929      	ldrh	r1, [r5, #8]
 804a7fa:	4421      	add	r1, r4
 804a7fc:	2200      	movs	r2, #0
 804a7fe:	b289      	uxth	r1, r1
 804a800:	2002      	movs	r0, #2
 804a802:	f7fb facf 	bl	8045da4 <pbuf_alloc>
      if (r == NULL) {
 804a806:	4680      	mov	r8, r0
 804a808:	b1d0      	cbz	r0, 804a840 <icmp_input+0xa4>
      if (r->len < hlen + sizeof(struct icmp_echo_hdr)) {
 804a80a:	8942      	ldrh	r2, [r0, #10]
 804a80c:	f104 0308 	add.w	r3, r4, #8
 804a810:	429a      	cmp	r2, r3
 804a812:	d313      	bcc.n	804a83c <icmp_input+0xa0>
      MEMCPY(r->payload, iphdr_in, hlen);
 804a814:	4622      	mov	r2, r4
 804a816:	4631      	mov	r1, r6
 804a818:	6840      	ldr	r0, [r0, #4]
 804a81a:	f007 f8f3 	bl	8051a04 <memcpy>
      if (pbuf_header(r, (s16_t)-hlen)) {
 804a81e:	4261      	negs	r1, r4
 804a820:	4640      	mov	r0, r8
 804a822:	f7fb fa51 	bl	8045cc8 <pbuf_header>
 804a826:	b978      	cbnz	r0, 804a848 <icmp_input+0xac>
      if (pbuf_copy(r, p) != ERR_OK) {
 804a828:	4629      	mov	r1, r5
 804a82a:	4640      	mov	r0, r8
 804a82c:	f7fb fc7c 	bl	8046128 <pbuf_copy>
 804a830:	b9a0      	cbnz	r0, 804a85c <icmp_input+0xc0>
      pbuf_free(p);
 804a832:	4628      	mov	r0, r5
 804a834:	f7fb fa52 	bl	8045cdc <pbuf_free>
      p = r;
 804a838:	4645      	mov	r5, r8
 804a83a:	e01b      	b.n	804a874 <icmp_input+0xd8>
        pbuf_free(r);
 804a83c:	f7fb fa4e 	bl	8045cdc <pbuf_free>
  pbuf_free(p);
 804a840:	4628      	mov	r0, r5
 804a842:	f7fb fa4b 	bl	8045cdc <pbuf_free>
  return;
 804a846:	e7ce      	b.n	804a7e6 <icmp_input+0x4a>
        LWIP_ASSERT("icmp_input: moving r->payload to icmp header failed\n", 0);
 804a848:	4b1f      	ldr	r3, [pc, #124]	; (804a8c8 <icmp_input+0x12c>)
 804a84a:	22af      	movs	r2, #175	; 0xaf
 804a84c:	491f      	ldr	r1, [pc, #124]	; (804a8cc <icmp_input+0x130>)
 804a84e:	4820      	ldr	r0, [pc, #128]	; (804a8d0 <icmp_input+0x134>)
 804a850:	f007 f8fa 	bl	8051a48 <printf>
        pbuf_free(r);
 804a854:	4640      	mov	r0, r8
 804a856:	f7fb fa41 	bl	8045cdc <pbuf_free>
        goto icmperr;
 804a85a:	e7f1      	b.n	804a840 <icmp_input+0xa4>
        pbuf_free(r);
 804a85c:	4640      	mov	r0, r8
 804a85e:	f7fb fa3d 	bl	8045cdc <pbuf_free>
        goto icmperr;
 804a862:	e7ed      	b.n	804a840 <icmp_input+0xa4>
      if (pbuf_header(p, -(s16_t)(hlen + PBUF_LINK_HLEN + PBUF_LINK_ENCAPSULATION_HLEN))) {
 804a864:	f5c4 417f 	rsb	r1, r4, #65280	; 0xff00
 804a868:	31f2      	adds	r1, #242	; 0xf2
 804a86a:	b209      	sxth	r1, r1
 804a86c:	4628      	mov	r0, r5
 804a86e:	f7fb fa2b 	bl	8045cc8 <pbuf_header>
 804a872:	b948      	cbnz	r0, 804a888 <icmp_input+0xec>
    iecho = (struct icmp_echo_hdr *)p->payload;
 804a874:	686e      	ldr	r6, [r5, #4]
    if (pbuf_header(p, (s16_t)hlen)) {
 804a876:	4621      	mov	r1, r4
 804a878:	4628      	mov	r0, r5
 804a87a:	f7fb fa25 	bl	8045cc8 <pbuf_header>
 804a87e:	b150      	cbz	r0, 804a896 <icmp_input+0xfa>
  pbuf_free(p);
 804a880:	4628      	mov	r0, r5
 804a882:	f7fb fa2b 	bl	8045cdc <pbuf_free>
  return;
 804a886:	e7ae      	b.n	804a7e6 <icmp_input+0x4a>
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
 804a888:	4b0f      	ldr	r3, [pc, #60]	; (804a8c8 <icmp_input+0x12c>)
 804a88a:	22c0      	movs	r2, #192	; 0xc0
 804a88c:	4911      	ldr	r1, [pc, #68]	; (804a8d4 <icmp_input+0x138>)
 804a88e:	4810      	ldr	r0, [pc, #64]	; (804a8d0 <icmp_input+0x134>)
 804a890:	f007 f8da 	bl	8051a48 <printf>
        goto icmperr;
 804a894:	e7d4      	b.n	804a840 <icmp_input+0xa4>
      struct ip_hdr *iphdr = (struct ip_hdr*)p->payload;
 804a896:	6868      	ldr	r0, [r5, #4]
      ip4_addr_copy(iphdr->src, *src);
 804a898:	490a      	ldr	r1, [pc, #40]	; (804a8c4 <icmp_input+0x128>)
 804a89a:	694b      	ldr	r3, [r1, #20]
 804a89c:	60c3      	str	r3, [r0, #12]
      ip4_addr_copy(iphdr->dest, *ip4_current_src_addr());
 804a89e:	690b      	ldr	r3, [r1, #16]
 804a8a0:	6103      	str	r3, [r0, #16]
      ICMPH_TYPE_SET(iecho, ICMP_ER);
 804a8a2:	2200      	movs	r2, #0
 804a8a4:	7032      	strb	r2, [r6, #0]
      iecho->chksum = 0;
 804a8a6:	70b2      	strb	r2, [r6, #2]
 804a8a8:	70f2      	strb	r2, [r6, #3]
      IPH_TTL_SET(iphdr, ICMP_TTL);
 804a8aa:	23ff      	movs	r3, #255	; 0xff
 804a8ac:	7203      	strb	r3, [r0, #8]
      IPH_CHKSUM_SET(iphdr, 0);
 804a8ae:	7282      	strb	r2, [r0, #10]
 804a8b0:	72c2      	strb	r2, [r0, #11]
      ret = ip4_output_if(p, src, LWIP_IP_HDRINCL,
 804a8b2:	9702      	str	r7, [sp, #8]
 804a8b4:	2001      	movs	r0, #1
 804a8b6:	9001      	str	r0, [sp, #4]
 804a8b8:	9200      	str	r2, [sp, #0]
 804a8ba:	3114      	adds	r1, #20
 804a8bc:	4628      	mov	r0, r5
 804a8be:	f000 f99f 	bl	804ac00 <ip4_output_if>
      if (ret != ERR_OK) {
 804a8c2:	e7dd      	b.n	804a880 <icmp_input+0xe4>
 804a8c4:	200051f0 	.word	0x200051f0
 804a8c8:	0805a4c0 	.word	0x0805a4c0
 804a8cc:	0805a524 	.word	0x0805a524
 804a8d0:	08058ecc 	.word	0x08058ecc
 804a8d4:	0805a55c 	.word	0x0805a55c

0804a8d8 <icmp_dest_unreach>:
{
 804a8d8:	b508      	push	{r3, lr}
 804a8da:	460a      	mov	r2, r1
  icmp_send_response(p, ICMP_DUR, t);
 804a8dc:	2103      	movs	r1, #3
 804a8de:	f7ff ff0b 	bl	804a6f8 <icmp_send_response>
}
 804a8e2:	bd08      	pop	{r3, pc}

0804a8e4 <icmp_time_exceeded>:
{
 804a8e4:	b508      	push	{r3, lr}
 804a8e6:	460a      	mov	r2, r1
  icmp_send_response(p, ICMP_TE, t);
 804a8e8:	210b      	movs	r1, #11
 804a8ea:	f7ff ff05 	bl	804a6f8 <icmp_send_response>
}
 804a8ee:	bd08      	pop	{r3, pc}

0804a8f0 <ip4_route>:
 * @param dest the destination IP address for which to find the route
 * @return the netif on which to send to reach dest
 */
struct netif *
ip4_route(const ip4_addr_t *dest)
{
 804a8f0:	b430      	push	{r4, r5}
 804a8f2:	4604      	mov	r4, r0
    return ip4_default_multicast_netif;
  }
#endif /* LWIP_MULTICAST_TX_OPTIONS */

  /* iterate through netifs */
  for (netif = netif_list; netif != NULL; netif = netif->next) {
 804a8f4:	4b14      	ldr	r3, [pc, #80]	; (804a948 <ip4_route+0x58>)
 804a8f6:	6818      	ldr	r0, [r3, #0]
 804a8f8:	e000      	b.n	804a8fc <ip4_route+0xc>
 804a8fa:	6800      	ldr	r0, [r0, #0]
 804a8fc:	b1b0      	cbz	r0, 804a92c <ip4_route+0x3c>
    /* is the netif up, does it have a link and a valid address? */
    if (netif_is_up(netif) && netif_is_link_up(netif) && !ip4_addr_isany_val(*netif_ip4_addr(netif))) {
 804a8fe:	f890 302b 	ldrb.w	r3, [r0, #43]	; 0x2b
 804a902:	f013 0f01 	tst.w	r3, #1
 804a906:	d0f8      	beq.n	804a8fa <ip4_route+0xa>
 804a908:	f013 0f04 	tst.w	r3, #4
 804a90c:	d0f5      	beq.n	804a8fa <ip4_route+0xa>
 804a90e:	6842      	ldr	r2, [r0, #4]
 804a910:	2a00      	cmp	r2, #0
 804a912:	d0f2      	beq.n	804a8fa <ip4_route+0xa>
      /* network mask matches? */
      if (ip4_addr_netcmp(dest, netif_ip4_addr(netif), netif_ip4_netmask(netif))) {
 804a914:	6821      	ldr	r1, [r4, #0]
 804a916:	6885      	ldr	r5, [r0, #8]
 804a918:	404a      	eors	r2, r1
 804a91a:	422a      	tst	r2, r5
 804a91c:	d012      	beq.n	804a944 <ip4_route+0x54>
        /* return netif on which to forward IP packet */
        return netif;
      }
      /* gateway matches on a non broadcast interface? (i.e. peer in a point to point interface) */
      if (((netif->flags & NETIF_FLAG_BROADCAST) == 0) && ip4_addr_cmp(dest, netif_ip4_gw(netif))) {
 804a91e:	f013 0f02 	tst.w	r3, #2
 804a922:	d1ea      	bne.n	804a8fa <ip4_route+0xa>
 804a924:	68c3      	ldr	r3, [r0, #12]
 804a926:	4299      	cmp	r1, r3
 804a928:	d1e7      	bne.n	804a8fa <ip4_route+0xa>
 804a92a:	e00b      	b.n	804a944 <ip4_route+0x54>
  if (netif != NULL) {
    return netif;
  }
#endif

  if ((netif_default == NULL) || !netif_is_up(netif_default) || !netif_is_link_up(netif_default) ||
 804a92c:	4b07      	ldr	r3, [pc, #28]	; (804a94c <ip4_route+0x5c>)
 804a92e:	681b      	ldr	r3, [r3, #0]
 804a930:	b143      	cbz	r3, 804a944 <ip4_route+0x54>
 804a932:	f893 202b 	ldrb.w	r2, [r3, #43]	; 0x2b
 804a936:	f002 0205 	and.w	r2, r2, #5
 804a93a:	2a05      	cmp	r2, #5
 804a93c:	d102      	bne.n	804a944 <ip4_route+0x54>
      ip4_addr_isany_val(*netif_ip4_addr(netif_default))) {
 804a93e:	685a      	ldr	r2, [r3, #4]
  if ((netif_default == NULL) || !netif_is_up(netif_default) || !netif_is_link_up(netif_default) ||
 804a940:	b102      	cbz	r2, 804a944 <ip4_route+0x54>
    IP_STATS_INC(ip.rterr);
    MIB2_STATS_INC(mib2.ipoutnoroutes);
    return NULL;
  }

  return netif_default;
 804a942:	4618      	mov	r0, r3
}
 804a944:	bc30      	pop	{r4, r5}
 804a946:	4770      	bx	lr
 804a948:	20008710 	.word	0x20008710
 804a94c:	20008714 	.word	0x20008714

0804a950 <ip4_input>:
 * @return ERR_OK if the packet was processed (could return ERR_* if it wasn't
 *         processed, but currently always returns ERR_OK)
 */
err_t
ip4_input(struct pbuf *p, struct netif *inp)
{
 804a950:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 804a954:	4605      	mov	r5, r0

  IP_STATS_INC(ip.recv);
  MIB2_STATS_INC(mib2.ipinreceives);

  /* identify the IP header */
  iphdr = (struct ip_hdr *)p->payload;
 804a956:	f8d0 8004 	ldr.w	r8, [r0, #4]
  if (IPH_V(iphdr) != 4) {
 804a95a:	f898 3000 	ldrb.w	r3, [r8]
 804a95e:	091a      	lsrs	r2, r3, #4
 804a960:	2a04      	cmp	r2, #4
 804a962:	d004      	beq.n	804a96e <ip4_input+0x1e>
    LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_WARNING, ("IP packet dropped due to bad version number %"U16_F"\n", (u16_t)IPH_V(iphdr)));
    ip4_debug_print(p);
    pbuf_free(p);
 804a964:	f7fb f9ba 	bl	8045cdc <pbuf_free>
  ip_data.current_ip_header_tot_len = 0;
  ip4_addr_set_any(ip4_current_src_addr());
  ip4_addr_set_any(ip4_current_dest_addr());

  return ERR_OK;
}
 804a968:	2000      	movs	r0, #0
 804a96a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 804a96e:	460e      	mov	r6, r1
  iphdr_hlen = IPH_HL(iphdr);
 804a970:	f003 030f 	and.w	r3, r3, #15
  iphdr_hlen *= 4;
 804a974:	009f      	lsls	r7, r3, #2
  iphdr_len = lwip_ntohs(IPH_LEN(iphdr));
 804a976:	f8b8 0002 	ldrh.w	r0, [r8, #2]
 804a97a:	f7fa fd79 	bl	8045470 <lwip_htons>
 804a97e:	4604      	mov	r4, r0
  if (iphdr_len < p->tot_len) {
 804a980:	892b      	ldrh	r3, [r5, #8]
 804a982:	4283      	cmp	r3, r0
 804a984:	d816      	bhi.n	804a9b4 <ip4_input+0x64>
  if ((iphdr_hlen > p->len) || (iphdr_len > p->tot_len) || (iphdr_hlen < IP_HLEN)) {
 804a986:	896b      	ldrh	r3, [r5, #10]
 804a988:	42bb      	cmp	r3, r7
 804a98a:	d318      	bcc.n	804a9be <ip4_input+0x6e>
 804a98c:	892b      	ldrh	r3, [r5, #8]
 804a98e:	42a3      	cmp	r3, r4
 804a990:	d315      	bcc.n	804a9be <ip4_input+0x6e>
 804a992:	2f13      	cmp	r7, #19
 804a994:	d913      	bls.n	804a9be <ip4_input+0x6e>
  ip_addr_copy_from_ip4(ip_data.current_iphdr_dest, iphdr->dest);
 804a996:	f8d8 3010 	ldr.w	r3, [r8, #16]
 804a99a:	4a5a      	ldr	r2, [pc, #360]	; (804ab04 <ip4_input+0x1b4>)
 804a99c:	6153      	str	r3, [r2, #20]
  ip_addr_copy_from_ip4(ip_data.current_iphdr_src, iphdr->src);
 804a99e:	f8d8 100c 	ldr.w	r1, [r8, #12]
 804a9a2:	6111      	str	r1, [r2, #16]
  if (ip4_addr_ismulticast(ip4_current_dest_addr())) {
 804a9a4:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 804a9a8:	2be0      	cmp	r3, #224	; 0xe0
 804a9aa:	d00c      	beq.n	804a9c6 <ip4_input+0x76>
    netif = inp;
 804a9ac:	4634      	mov	r4, r6
    int first = 1;
 804a9ae:	f04f 0901 	mov.w	r9, #1
 804a9b2:	e016      	b.n	804a9e2 <ip4_input+0x92>
    pbuf_realloc(p, iphdr_len);
 804a9b4:	4601      	mov	r1, r0
 804a9b6:	4628      	mov	r0, r5
 804a9b8:	f7fb fae4 	bl	8045f84 <pbuf_realloc>
 804a9bc:	e7e3      	b.n	804a986 <ip4_input+0x36>
    pbuf_free(p);
 804a9be:	4628      	mov	r0, r5
 804a9c0:	f7fb f98c 	bl	8045cdc <pbuf_free>
    return ERR_OK;
 804a9c4:	e7d0      	b.n	804a968 <ip4_input+0x18>
    if ((netif_is_up(inp)) && (!ip4_addr_isany_val(*netif_ip4_addr(inp)))) {
 804a9c6:	f896 302b 	ldrb.w	r3, [r6, #43]	; 0x2b
 804a9ca:	f013 0f01 	tst.w	r3, #1
 804a9ce:	d025      	beq.n	804aa1c <ip4_input+0xcc>
 804a9d0:	6873      	ldr	r3, [r6, #4]
 804a9d2:	2b00      	cmp	r3, #0
 804a9d4:	d167      	bne.n	804aaa6 <ip4_input+0x156>
      netif = NULL;
 804a9d6:	2400      	movs	r4, #0
 804a9d8:	e021      	b.n	804aa1e <ip4_input+0xce>
        netif = netif->next;
 804a9da:	6824      	ldr	r4, [r4, #0]
      if (netif == inp) {
 804a9dc:	42b4      	cmp	r4, r6
 804a9de:	d01b      	beq.n	804aa18 <ip4_input+0xc8>
    } while (netif != NULL);
 804a9e0:	b1ec      	cbz	r4, 804aa1e <ip4_input+0xce>
      if ((netif_is_up(netif)) && (!ip4_addr_isany_val(*netif_ip4_addr(netif)))) {
 804a9e2:	f894 302b 	ldrb.w	r3, [r4, #43]	; 0x2b
 804a9e6:	f013 0f01 	tst.w	r3, #1
 804a9ea:	d009      	beq.n	804aa00 <ip4_input+0xb0>
 804a9ec:	6863      	ldr	r3, [r4, #4]
 804a9ee:	b13b      	cbz	r3, 804aa00 <ip4_input+0xb0>
        if (ip4_addr_cmp(ip4_current_dest_addr(), netif_ip4_addr(netif)) ||
 804a9f0:	4a44      	ldr	r2, [pc, #272]	; (804ab04 <ip4_input+0x1b4>)
 804a9f2:	6950      	ldr	r0, [r2, #20]
 804a9f4:	4283      	cmp	r3, r0
 804a9f6:	d012      	beq.n	804aa1e <ip4_input+0xce>
            ip4_addr_isbroadcast(ip4_current_dest_addr(), netif)
 804a9f8:	4621      	mov	r1, r4
 804a9fa:	f000 f916 	bl	804ac2a <ip4_addr_isbroadcast_u32>
        if (ip4_addr_cmp(ip4_current_dest_addr(), netif_ip4_addr(netif)) ||
 804a9fe:	b970      	cbnz	r0, 804aa1e <ip4_input+0xce>
      if (first) {
 804aa00:	f1b9 0f00 	cmp.w	r9, #0
 804aa04:	d0e9      	beq.n	804a9da <ip4_input+0x8a>
        if (ip4_addr_isloopback(ip4_current_dest_addr())) {
 804aa06:	4b3f      	ldr	r3, [pc, #252]	; (804ab04 <ip4_input+0x1b4>)
 804aa08:	7d1b      	ldrb	r3, [r3, #20]
 804aa0a:	2b7f      	cmp	r3, #127	; 0x7f
 804aa0c:	d04d      	beq.n	804aaaa <ip4_input+0x15a>
        netif = netif_list;
 804aa0e:	4b3e      	ldr	r3, [pc, #248]	; (804ab08 <ip4_input+0x1b8>)
 804aa10:	681c      	ldr	r4, [r3, #0]
        first = 0;
 804aa12:	f04f 0900 	mov.w	r9, #0
 804aa16:	e7e1      	b.n	804a9dc <ip4_input+0x8c>
        netif = netif->next;
 804aa18:	6824      	ldr	r4, [r4, #0]
 804aa1a:	e7e1      	b.n	804a9e0 <ip4_input+0x90>
      netif = NULL;
 804aa1c:	2400      	movs	r4, #0
    if ((ip4_addr_isbroadcast(ip4_current_src_addr(), inp)) ||
 804aa1e:	4631      	mov	r1, r6
 804aa20:	4b38      	ldr	r3, [pc, #224]	; (804ab04 <ip4_input+0x1b4>)
 804aa22:	6918      	ldr	r0, [r3, #16]
 804aa24:	f000 f901 	bl	804ac2a <ip4_addr_isbroadcast_u32>
 804aa28:	2800      	cmp	r0, #0
 804aa2a:	d140      	bne.n	804aaae <ip4_input+0x15e>
        (ip4_addr_ismulticast(ip4_current_src_addr()))) {
 804aa2c:	4b35      	ldr	r3, [pc, #212]	; (804ab04 <ip4_input+0x1b4>)
 804aa2e:	691b      	ldr	r3, [r3, #16]
 804aa30:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
    if ((ip4_addr_isbroadcast(ip4_current_src_addr(), inp)) ||
 804aa34:	2be0      	cmp	r3, #224	; 0xe0
 804aa36:	d03a      	beq.n	804aaae <ip4_input+0x15e>
  if (netif == NULL) {
 804aa38:	2c00      	cmp	r4, #0
 804aa3a:	d03c      	beq.n	804aab6 <ip4_input+0x166>
  if ((IPH_OFFSET(iphdr) & PP_HTONS(IP_OFFMASK | IP_MF)) != 0) {
 804aa3c:	f8b8 3006 	ldrh.w	r3, [r8, #6]
 804aa40:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
 804aa44:	b29b      	uxth	r3, r3
 804aa46:	b13b      	cbz	r3, 804aa58 <ip4_input+0x108>
    p = ip4_reass(p);
 804aa48:	4628      	mov	r0, r5
 804aa4a:	f000 fbeb 	bl	804b224 <ip4_reass>
    if (p == NULL) {
 804aa4e:	4605      	mov	r5, r0
 804aa50:	2800      	cmp	r0, #0
 804aa52:	d089      	beq.n	804a968 <ip4_input+0x18>
    iphdr = (struct ip_hdr *)p->payload;
 804aa54:	f8d0 8004 	ldr.w	r8, [r0, #4]
  ip_data.current_netif = netif;
 804aa58:	4a2a      	ldr	r2, [pc, #168]	; (804ab04 <ip4_input+0x1b4>)
 804aa5a:	6014      	str	r4, [r2, #0]
  ip_data.current_input_netif = inp;
 804aa5c:	6056      	str	r6, [r2, #4]
  ip_data.current_ip4_header = iphdr;
 804aa5e:	f8c2 8008 	str.w	r8, [r2, #8]
  ip_data.current_ip_header_tot_len = IPH_HL(iphdr) * 4;
 804aa62:	f898 3000 	ldrb.w	r3, [r8]
 804aa66:	f003 030f 	and.w	r3, r3, #15
 804aa6a:	009b      	lsls	r3, r3, #2
 804aa6c:	8193      	strh	r3, [r2, #12]
    pbuf_header(p, -(s16_t)iphdr_hlen); /* Move to payload, no check necessary. */
 804aa6e:	4279      	negs	r1, r7
 804aa70:	4628      	mov	r0, r5
 804aa72:	f7fb f929 	bl	8045cc8 <pbuf_header>
    switch (IPH_PROTO(iphdr)) {
 804aa76:	f898 3009 	ldrb.w	r3, [r8, #9]
 804aa7a:	2b06      	cmp	r3, #6
 804aa7c:	d02c      	beq.n	804aad8 <ip4_input+0x188>
 804aa7e:	2b11      	cmp	r3, #17
 804aa80:	d01d      	beq.n	804aabe <ip4_input+0x16e>
 804aa82:	2b01      	cmp	r3, #1
 804aa84:	d02d      	beq.n	804aae2 <ip4_input+0x192>
      if (!ip4_addr_isbroadcast(ip4_current_dest_addr(), netif) &&
 804aa86:	4621      	mov	r1, r4
 804aa88:	4b1e      	ldr	r3, [pc, #120]	; (804ab04 <ip4_input+0x1b4>)
 804aa8a:	6958      	ldr	r0, [r3, #20]
 804aa8c:	f000 f8cd 	bl	804ac2a <ip4_addr_isbroadcast_u32>
 804aa90:	b928      	cbnz	r0, 804aa9e <ip4_input+0x14e>
          !ip4_addr_ismulticast(ip4_current_dest_addr())) {
 804aa92:	4b1c      	ldr	r3, [pc, #112]	; (804ab04 <ip4_input+0x1b4>)
 804aa94:	695b      	ldr	r3, [r3, #20]
 804aa96:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
      if (!ip4_addr_isbroadcast(ip4_current_dest_addr(), netif) &&
 804aa9a:	2be0      	cmp	r3, #224	; 0xe0
 804aa9c:	d126      	bne.n	804aaec <ip4_input+0x19c>
      pbuf_free(p);
 804aa9e:	4628      	mov	r0, r5
 804aaa0:	f7fb f91c 	bl	8045cdc <pbuf_free>
 804aaa4:	e00f      	b.n	804aac6 <ip4_input+0x176>
      netif = inp;
 804aaa6:	4634      	mov	r4, r6
 804aaa8:	e7b9      	b.n	804aa1e <ip4_input+0xce>
          netif = NULL;
 804aaaa:	2400      	movs	r4, #0
 804aaac:	e7b7      	b.n	804aa1e <ip4_input+0xce>
      pbuf_free(p);
 804aaae:	4628      	mov	r0, r5
 804aab0:	f7fb f914 	bl	8045cdc <pbuf_free>
      return ERR_OK;
 804aab4:	e758      	b.n	804a968 <ip4_input+0x18>
    pbuf_free(p);
 804aab6:	4628      	mov	r0, r5
 804aab8:	f7fb f910 	bl	8045cdc <pbuf_free>
    return ERR_OK;
 804aabc:	e754      	b.n	804a968 <ip4_input+0x18>
      udp_input(p, inp);
 804aabe:	4631      	mov	r1, r6
 804aac0:	4628      	mov	r0, r5
 804aac2:	f7ff f8c9 	bl	8049c58 <udp_input>
  ip_data.current_netif = NULL;
 804aac6:	4b0f      	ldr	r3, [pc, #60]	; (804ab04 <ip4_input+0x1b4>)
 804aac8:	2200      	movs	r2, #0
 804aaca:	601a      	str	r2, [r3, #0]
  ip_data.current_input_netif = NULL;
 804aacc:	605a      	str	r2, [r3, #4]
  ip_data.current_ip4_header = NULL;
 804aace:	609a      	str	r2, [r3, #8]
  ip_data.current_ip_header_tot_len = 0;
 804aad0:	819a      	strh	r2, [r3, #12]
  ip4_addr_set_any(ip4_current_src_addr());
 804aad2:	611a      	str	r2, [r3, #16]
  ip4_addr_set_any(ip4_current_dest_addr());
 804aad4:	615a      	str	r2, [r3, #20]
  return ERR_OK;
 804aad6:	e747      	b.n	804a968 <ip4_input+0x18>
      tcp_input(p, inp);
 804aad8:	4631      	mov	r1, r6
 804aada:	4628      	mov	r0, r5
 804aadc:	f7fd fd58 	bl	8048590 <tcp_input>
      break;
 804aae0:	e7f1      	b.n	804aac6 <ip4_input+0x176>
      icmp_input(p, inp);
 804aae2:	4631      	mov	r1, r6
 804aae4:	4628      	mov	r0, r5
 804aae6:	f7ff fe59 	bl	804a79c <icmp_input>
      break;
 804aaea:	e7ec      	b.n	804aac6 <ip4_input+0x176>
        pbuf_header_force(p, iphdr_hlen); /* Move to ip header, no check necessary. */
 804aaec:	4639      	mov	r1, r7
 804aaee:	4628      	mov	r0, r5
 804aaf0:	f7fb f8ef 	bl	8045cd2 <pbuf_header_force>
        p->payload = iphdr;
 804aaf4:	f8c5 8004 	str.w	r8, [r5, #4]
        icmp_dest_unreach(p, ICMP_DUR_PROTO);
 804aaf8:	2102      	movs	r1, #2
 804aafa:	4628      	mov	r0, r5
 804aafc:	f7ff feec 	bl	804a8d8 <icmp_dest_unreach>
 804ab00:	e7cd      	b.n	804aa9e <ip4_input+0x14e>
 804ab02:	bf00      	nop
 804ab04:	200051f0 	.word	0x200051f0
 804ab08:	20008710 	.word	0x20008710

0804ab0c <ip4_output_if_src>:
 */
err_t
ip4_output_if_src(struct pbuf *p, const ip4_addr_t *src, const ip4_addr_t *dest,
             u8_t ttl, u8_t tos,
             u8_t proto, struct netif *netif)
{
 804ab0c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 804ab10:	b083      	sub	sp, #12
 804ab12:	4604      	mov	r4, r0
 804ab14:	460f      	mov	r7, r1
 804ab16:	4616      	mov	r6, r2
 804ab18:	4699      	mov	r9, r3
 804ab1a:	f8dd 8030 	ldr.w	r8, [sp, #48]	; 0x30
  ip4_addr_t dest_addr;
#if CHECKSUM_GEN_IP_INLINE
  u32_t chk_sum = 0;
#endif /* CHECKSUM_GEN_IP_INLINE */

  LWIP_IP_CHECK_PBUF_REF_COUNT_FOR_TX(p);
 804ab1e:	89c2      	ldrh	r2, [r0, #14]
 804ab20:	2a01      	cmp	r2, #1
 804ab22:	d13f      	bne.n	804aba4 <ip4_output_if_src+0x98>

  MIB2_STATS_INC(mib2.ipoutrequests);

  /* Should the IP header be generated or is it already included in p? */
  if (dest != LWIP_IP_HDRINCL) {
 804ab24:	2e00      	cmp	r6, #0
 804ab26:	d051      	beq.n	804abcc <ip4_output_if_src+0xc0>
      }
#endif /* CHECKSUM_GEN_IP_INLINE */
    }
#endif /* IP_OPTIONS_SEND */
    /* generate IP header */
    if (pbuf_header(p, IP_HLEN)) {
 804ab28:	2114      	movs	r1, #20
 804ab2a:	4620      	mov	r0, r4
 804ab2c:	f7fb f8cc 	bl	8045cc8 <pbuf_header>
 804ab30:	2800      	cmp	r0, #0
 804ab32:	d156      	bne.n	804abe2 <ip4_output_if_src+0xd6>
      IP_STATS_INC(ip.err);
      MIB2_STATS_INC(mib2.ipoutdiscards);
      return ERR_BUF;
    }

    iphdr = (struct ip_hdr *)p->payload;
 804ab34:	6865      	ldr	r5, [r4, #4]
    LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
 804ab36:	8963      	ldrh	r3, [r4, #10]
 804ab38:	2b13      	cmp	r3, #19
 804ab3a:	d93b      	bls.n	804abb4 <ip4_output_if_src+0xa8>
               (p->len >= sizeof(struct ip_hdr)));

    IPH_TTL_SET(iphdr, ttl);
 804ab3c:	f885 9008 	strb.w	r9, [r5, #8]
    IPH_PROTO_SET(iphdr, proto);
 804ab40:	f89d 302c 	ldrb.w	r3, [sp, #44]	; 0x2c
 804ab44:	726b      	strb	r3, [r5, #9]
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += PP_NTOHS(proto | (ttl << 8));
#endif /* CHECKSUM_GEN_IP_INLINE */

    /* dest cannot be NULL here */
    ip4_addr_copy(iphdr->dest, *dest);
 804ab46:	6833      	ldr	r3, [r6, #0]
 804ab48:	612b      	str	r3, [r5, #16]
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += ip4_addr_get_u32(&iphdr->dest) & 0xFFFF;
    chk_sum += ip4_addr_get_u32(&iphdr->dest) >> 16;
#endif /* CHECKSUM_GEN_IP_INLINE */

    IPH_VHL_SET(iphdr, 4, ip_hlen / 4);
 804ab4a:	2345      	movs	r3, #69	; 0x45
 804ab4c:	702b      	strb	r3, [r5, #0]
    IPH_TOS_SET(iphdr, tos);
 804ab4e:	f89d 3028 	ldrb.w	r3, [sp, #40]	; 0x28
 804ab52:	706b      	strb	r3, [r5, #1]
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += PP_NTOHS(tos | (iphdr->_v_hl << 8));
#endif /* CHECKSUM_GEN_IP_INLINE */
    IPH_LEN_SET(iphdr, lwip_htons(p->tot_len));
 804ab54:	8920      	ldrh	r0, [r4, #8]
 804ab56:	f7fa fc8b 	bl	8045470 <lwip_htons>
 804ab5a:	8068      	strh	r0, [r5, #2]
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += iphdr->_len;
#endif /* CHECKSUM_GEN_IP_INLINE */
    IPH_OFFSET_SET(iphdr, 0);
 804ab5c:	2300      	movs	r3, #0
 804ab5e:	71ab      	strb	r3, [r5, #6]
 804ab60:	71eb      	strb	r3, [r5, #7]
    IPH_ID_SET(iphdr, lwip_htons(ip_id));
 804ab62:	f8df 9098 	ldr.w	r9, [pc, #152]	; 804abfc <ip4_output_if_src+0xf0>
 804ab66:	f8b9 0000 	ldrh.w	r0, [r9]
 804ab6a:	f7fa fc81 	bl	8045470 <lwip_htons>
 804ab6e:	80a8      	strh	r0, [r5, #4]
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += iphdr->_id;
#endif /* CHECKSUM_GEN_IP_INLINE */
    ++ip_id;
 804ab70:	f8b9 3000 	ldrh.w	r3, [r9]
 804ab74:	3301      	adds	r3, #1
 804ab76:	f8a9 3000 	strh.w	r3, [r9]

    if (src == NULL) {
 804ab7a:	b31f      	cbz	r7, 804abc4 <ip4_output_if_src+0xb8>
      ip4_addr_copy(iphdr->src, *IP4_ADDR_ANY4);
    } else {
      /* src cannot be NULL here */
      ip4_addr_copy(iphdr->src, *src);
 804ab7c:	683b      	ldr	r3, [r7, #0]
 804ab7e:	60eb      	str	r3, [r5, #12]
    else {
      IPH_CHKSUM_SET(iphdr, 0);
    }
#endif /* LWIP_CHECKSUM_CTRL_PER_NETIF*/
#else /* CHECKSUM_GEN_IP_INLINE */
    IPH_CHKSUM_SET(iphdr, 0);
 804ab80:	2300      	movs	r3, #0
 804ab82:	72ab      	strb	r3, [r5, #10]
 804ab84:	72eb      	strb	r3, [r5, #11]
  }
#endif /* LWIP_MULTICAST_TX_OPTIONS */
#endif /* ENABLE_LOOPBACK */
#if IP_FRAG
  /* don't fragment if interface has mtu set to 0 [loopif] */
  if (netif->mtu && (p->tot_len > netif->mtu)) {
 804ab86:	f8b8 3022 	ldrh.w	r3, [r8, #34]	; 0x22
 804ab8a:	b113      	cbz	r3, 804ab92 <ip4_output_if_src+0x86>
 804ab8c:	8922      	ldrh	r2, [r4, #8]
 804ab8e:	4293      	cmp	r3, r2
 804ab90:	d321      	bcc.n	804abd6 <ip4_output_if_src+0xca>
    return ip4_frag(p, netif, dest);
  }
#endif /* IP_FRAG */

  LWIP_DEBUGF(IP_DEBUG, ("ip4_output_if: call netif->output()\n"));
  return netif->output(netif, p, dest);
 804ab92:	f8d8 3014 	ldr.w	r3, [r8, #20]
 804ab96:	4632      	mov	r2, r6
 804ab98:	4621      	mov	r1, r4
 804ab9a:	4640      	mov	r0, r8
 804ab9c:	4798      	blx	r3
}
 804ab9e:	b003      	add	sp, #12
 804aba0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  LWIP_IP_CHECK_PBUF_REF_COUNT_FOR_TX(p);
 804aba4:	4b10      	ldr	r3, [pc, #64]	; (804abe8 <ip4_output_if_src+0xdc>)
 804aba6:	f240 3233 	movw	r2, #819	; 0x333
 804abaa:	4910      	ldr	r1, [pc, #64]	; (804abec <ip4_output_if_src+0xe0>)
 804abac:	4810      	ldr	r0, [pc, #64]	; (804abf0 <ip4_output_if_src+0xe4>)
 804abae:	f006 ff4b 	bl	8051a48 <printf>
 804abb2:	e7b7      	b.n	804ab24 <ip4_output_if_src+0x18>
    LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
 804abb4:	4b0c      	ldr	r3, [pc, #48]	; (804abe8 <ip4_output_if_src+0xdc>)
 804abb6:	f44f 7258 	mov.w	r2, #864	; 0x360
 804abba:	490e      	ldr	r1, [pc, #56]	; (804abf4 <ip4_output_if_src+0xe8>)
 804abbc:	480c      	ldr	r0, [pc, #48]	; (804abf0 <ip4_output_if_src+0xe4>)
 804abbe:	f006 ff43 	bl	8051a48 <printf>
 804abc2:	e7bb      	b.n	804ab3c <ip4_output_if_src+0x30>
      ip4_addr_copy(iphdr->src, *IP4_ADDR_ANY4);
 804abc4:	4b0c      	ldr	r3, [pc, #48]	; (804abf8 <ip4_output_if_src+0xec>)
 804abc6:	681b      	ldr	r3, [r3, #0]
 804abc8:	60eb      	str	r3, [r5, #12]
 804abca:	e7d9      	b.n	804ab80 <ip4_output_if_src+0x74>
    iphdr = (struct ip_hdr *)p->payload;
 804abcc:	6863      	ldr	r3, [r4, #4]
    ip4_addr_copy(dest_addr, iphdr->dest);
 804abce:	691b      	ldr	r3, [r3, #16]
 804abd0:	9301      	str	r3, [sp, #4]
    dest = &dest_addr;
 804abd2:	ae01      	add	r6, sp, #4
 804abd4:	e7d7      	b.n	804ab86 <ip4_output_if_src+0x7a>
    return ip4_frag(p, netif, dest);
 804abd6:	4632      	mov	r2, r6
 804abd8:	4641      	mov	r1, r8
 804abda:	4620      	mov	r0, r4
 804abdc:	f000 fbf2 	bl	804b3c4 <ip4_frag>
 804abe0:	e7dd      	b.n	804ab9e <ip4_output_if_src+0x92>
      return ERR_BUF;
 804abe2:	f06f 0001 	mvn.w	r0, #1
 804abe6:	e7da      	b.n	804ab9e <ip4_output_if_src+0x92>
 804abe8:	0805a590 	.word	0x0805a590
 804abec:	0805a5c4 	.word	0x0805a5c4
 804abf0:	08058ecc 	.word	0x08058ecc
 804abf4:	0805a5d0 	.word	0x0805a5d0
 804abf8:	08058e58 	.word	0x08058e58
 804abfc:	20004206 	.word	0x20004206

0804ac00 <ip4_output_if>:
{
 804ac00:	b530      	push	{r4, r5, lr}
 804ac02:	b085      	sub	sp, #20
 804ac04:	9c0a      	ldr	r4, [sp, #40]	; 0x28
  if (dest != LWIP_IP_HDRINCL) {
 804ac06:	4615      	mov	r5, r2
 804ac08:	b11a      	cbz	r2, 804ac12 <ip4_output_if+0x12>
    if (ip4_addr_isany(src)) {
 804ac0a:	b109      	cbz	r1, 804ac10 <ip4_output_if+0x10>
 804ac0c:	680a      	ldr	r2, [r1, #0]
 804ac0e:	b902      	cbnz	r2, 804ac12 <ip4_output_if+0x12>
      src_used = netif_ip4_addr(netif);
 804ac10:	1d21      	adds	r1, r4, #4
  return ip4_output_if_src(p, src_used, dest, ttl, tos, proto, netif);
 804ac12:	9402      	str	r4, [sp, #8]
 804ac14:	f89d 2024 	ldrb.w	r2, [sp, #36]	; 0x24
 804ac18:	9201      	str	r2, [sp, #4]
 804ac1a:	f89d 2020 	ldrb.w	r2, [sp, #32]
 804ac1e:	9200      	str	r2, [sp, #0]
 804ac20:	462a      	mov	r2, r5
 804ac22:	f7ff ff73 	bl	804ab0c <ip4_output_if_src>
}
 804ac26:	b005      	add	sp, #20
 804ac28:	bd30      	pop	{r4, r5, pc}

0804ac2a <ip4_addr_isbroadcast_u32>:
 * @param netif the network interface against which the address is checked
 * @return returns non-zero if the address is a broadcast address
 */
u8_t
ip4_addr_isbroadcast_u32(u32_t addr, const struct netif *netif)
{
 804ac2a:	4603      	mov	r3, r0
  ip4_addr_t ipaddr;
  ip4_addr_set_u32(&ipaddr, addr);

  /* all ones (broadcast) or all zeroes (old skool broadcast) */
  if ((~addr == IPADDR_ANY) ||
 804ac2c:	1e42      	subs	r2, r0, #1
 804ac2e:	f112 0f03 	cmn.w	r2, #3
 804ac32:	d812      	bhi.n	804ac5a <ip4_addr_isbroadcast_u32+0x30>
      (addr == IPADDR_ANY)) {
    return 1;
  /* no broadcast support on this network interface? */
  } else if ((netif->flags & NETIF_FLAG_BROADCAST) == 0) {
 804ac34:	f891 002b 	ldrb.w	r0, [r1, #43]	; 0x2b
 804ac38:	f010 0002 	ands.w	r0, r0, #2
 804ac3c:	d014      	beq.n	804ac68 <ip4_addr_isbroadcast_u32+0x3e>
    /* the given address cannot be a broadcast address
     * nor can we check against any broadcast addresses */
    return 0;
  /* address matches network interface address exactly? => no broadcast */
  } else if (addr == ip4_addr_get_u32(netif_ip4_addr(netif))) {
 804ac3e:	684a      	ldr	r2, [r1, #4]
 804ac40:	429a      	cmp	r2, r3
 804ac42:	d00c      	beq.n	804ac5e <ip4_addr_isbroadcast_u32+0x34>
    return 0;
  /*  on the same (sub) network... */
  } else if (ip4_addr_netcmp(&ipaddr, netif_ip4_addr(netif), netif_ip4_netmask(netif))
 804ac44:	6888      	ldr	r0, [r1, #8]
 804ac46:	405a      	eors	r2, r3
 804ac48:	4202      	tst	r2, r0
 804ac4a:	d10a      	bne.n	804ac62 <ip4_addr_isbroadcast_u32+0x38>
         /* ...and host identifier bits are all ones? =>... */
          && ((addr & ~ip4_addr_get_u32(netif_ip4_netmask(netif))) ==
 804ac4c:	43c2      	mvns	r2, r0
 804ac4e:	ea23 0300 	bic.w	r3, r3, r0
 804ac52:	429a      	cmp	r2, r3
 804ac54:	d007      	beq.n	804ac66 <ip4_addr_isbroadcast_u32+0x3c>
           (IPADDR_BROADCAST & ~ip4_addr_get_u32(netif_ip4_netmask(netif))))) {
    /* => network broadcast address */
    return 1;
  } else {
    return 0;
 804ac56:	2000      	movs	r0, #0
 804ac58:	4770      	bx	lr
    return 1;
 804ac5a:	2001      	movs	r0, #1
 804ac5c:	4770      	bx	lr
    return 0;
 804ac5e:	2000      	movs	r0, #0
 804ac60:	4770      	bx	lr
    return 0;
 804ac62:	2000      	movs	r0, #0
 804ac64:	4770      	bx	lr
    return 1;
 804ac66:	2001      	movs	r0, #1
  }
}
 804ac68:	4770      	bx	lr
	...

0804ac6c <ip4addr_aton>:
 * @param addr pointer to which to save the ip address in network order
 * @return 1 if cp could be converted to addr, 0 on failure
 */
int
ip4addr_aton(const char *cp, ip4_addr_t *addr)
{
 804ac6c:	b570      	push	{r4, r5, r6, lr}
 804ac6e:	b084      	sub	sp, #16
 804ac70:	460c      	mov	r4, r1
  u8_t base;
  char c;
  u32_t parts[4];
  u32_t *pp = parts;

  c = *cp;
 804ac72:	7803      	ldrb	r3, [r0, #0]
  u32_t *pp = parts;
 804ac74:	466e      	mov	r6, sp
 804ac76:	e03b      	b.n	804acf0 <ip4addr_aton+0x84>
      return 0;
    }
    val = 0;
    base = 10;
    if (c == '0') {
      c = *++cp;
 804ac78:	1c42      	adds	r2, r0, #1
 804ac7a:	7843      	ldrb	r3, [r0, #1]
      if (c == 'x' || c == 'X') {
 804ac7c:	2b78      	cmp	r3, #120	; 0x78
 804ac7e:	d004      	beq.n	804ac8a <ip4addr_aton+0x1e>
 804ac80:	2b58      	cmp	r3, #88	; 0x58
 804ac82:	d002      	beq.n	804ac8a <ip4addr_aton+0x1e>
      c = *++cp;
 804ac84:	4610      	mov	r0, r2
        base = 16;
        c = *++cp;
      } else {
        base = 8;
 804ac86:	2108      	movs	r1, #8
 804ac88:	e03a      	b.n	804ad00 <ip4addr_aton+0x94>
        c = *++cp;
 804ac8a:	7883      	ldrb	r3, [r0, #2]
 804ac8c:	3002      	adds	r0, #2
        base = 16;
 804ac8e:	2110      	movs	r1, #16
        c = *++cp;
 804ac90:	e036      	b.n	804ad00 <ip4addr_aton+0x94>
    }
    for (;;) {
      if (isdigit(c)) {
        val = (val * base) + (u32_t)(c - '0');
        c = *++cp;
      } else if (base == 16 && isxdigit(c)) {
 804ac92:	2910      	cmp	r1, #16
 804ac94:	d123      	bne.n	804acde <ip4addr_aton+0x72>
 804ac96:	f1a3 0261 	sub.w	r2, r3, #97	; 0x61
 804ac9a:	b2d2      	uxtb	r2, r2
 804ac9c:	2a05      	cmp	r2, #5
 804ac9e:	d904      	bls.n	804acaa <ip4addr_aton+0x3e>
 804aca0:	f1a3 0241 	sub.w	r2, r3, #65	; 0x41
 804aca4:	b2d2      	uxtb	r2, r2
 804aca6:	2a05      	cmp	r2, #5
 804aca8:	d819      	bhi.n	804acde <ip4addr_aton+0x72>
        val = (val << 4) | (u32_t)(c + 10 - (islower(c) ? 'a' : 'A'));
 804acaa:	012d      	lsls	r5, r5, #4
 804acac:	f103 020a 	add.w	r2, r3, #10
 804acb0:	3b61      	subs	r3, #97	; 0x61
 804acb2:	b2db      	uxtb	r3, r3
 804acb4:	2b19      	cmp	r3, #25
 804acb6:	d810      	bhi.n	804acda <ip4addr_aton+0x6e>
 804acb8:	2361      	movs	r3, #97	; 0x61
 804acba:	1ad2      	subs	r2, r2, r3
 804acbc:	4315      	orrs	r5, r2
        c = *++cp;
 804acbe:	f810 3f01 	ldrb.w	r3, [r0, #1]!
      if (isdigit(c)) {
 804acc2:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
 804acc6:	b2d2      	uxtb	r2, r2
 804acc8:	2a09      	cmp	r2, #9
 804acca:	d8e2      	bhi.n	804ac92 <ip4addr_aton+0x26>
        val = (val * base) + (u32_t)(c - '0');
 804accc:	fb05 3201 	mla	r2, r5, r1, r3
 804acd0:	f1a2 0530 	sub.w	r5, r2, #48	; 0x30
        c = *++cp;
 804acd4:	f810 3f01 	ldrb.w	r3, [r0, #1]!
 804acd8:	e7f3      	b.n	804acc2 <ip4addr_aton+0x56>
        val = (val << 4) | (u32_t)(c + 10 - (islower(c) ? 'a' : 'A'));
 804acda:	2341      	movs	r3, #65	; 0x41
 804acdc:	e7ed      	b.n	804acba <ip4addr_aton+0x4e>
      } else {
        break;
      }
    }
    if (c == '.') {
 804acde:	2b2e      	cmp	r3, #46	; 0x2e
 804ace0:	d110      	bne.n	804ad04 <ip4addr_aton+0x98>
       * Internet format:
       *  a.b.c.d
       *  a.b.c   (with c treated as 16 bits)
       *  a.b (with b treated as 24 bits)
       */
      if (pp >= parts + 3) {
 804ace2:	ab03      	add	r3, sp, #12
 804ace4:	429e      	cmp	r6, r3
 804ace6:	d25f      	bcs.n	804ada8 <ip4addr_aton+0x13c>
        return 0;
      }
      *pp++ = val;
 804ace8:	f846 5b04 	str.w	r5, [r6], #4
      c = *++cp;
 804acec:	7843      	ldrb	r3, [r0, #1]
 804acee:	3001      	adds	r0, #1
    if (!isdigit(c)) {
 804acf0:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
 804acf4:	b2d2      	uxtb	r2, r2
 804acf6:	2a09      	cmp	r2, #9
 804acf8:	d854      	bhi.n	804ada4 <ip4addr_aton+0x138>
    if (c == '0') {
 804acfa:	2b30      	cmp	r3, #48	; 0x30
 804acfc:	d0bc      	beq.n	804ac78 <ip4addr_aton+0xc>
    base = 10;
 804acfe:	210a      	movs	r1, #10
        base = 8;
 804ad00:	2500      	movs	r5, #0
 804ad02:	e7de      	b.n	804acc2 <ip4addr_aton+0x56>
    }
  }
  /*
   * Check for trailing characters.
   */
  if (c != '\0' && !isspace(c)) {
 804ad04:	b15b      	cbz	r3, 804ad1e <ip4addr_aton+0xb2>
 804ad06:	2b20      	cmp	r3, #32
 804ad08:	d009      	beq.n	804ad1e <ip4addr_aton+0xb2>
 804ad0a:	2b0c      	cmp	r3, #12
 804ad0c:	d007      	beq.n	804ad1e <ip4addr_aton+0xb2>
 804ad0e:	2b0a      	cmp	r3, #10
 804ad10:	d005      	beq.n	804ad1e <ip4addr_aton+0xb2>
 804ad12:	2b0d      	cmp	r3, #13
 804ad14:	d003      	beq.n	804ad1e <ip4addr_aton+0xb2>
 804ad16:	2b09      	cmp	r3, #9
 804ad18:	d001      	beq.n	804ad1e <ip4addr_aton+0xb2>
 804ad1a:	2b0b      	cmp	r3, #11
 804ad1c:	d147      	bne.n	804adae <ip4addr_aton+0x142>
  }
  /*
   * Concoct the address according to
   * the number of parts specified.
   */
  switch (pp - parts + 1) {
 804ad1e:	4668      	mov	r0, sp
 804ad20:	1a30      	subs	r0, r6, r0
 804ad22:	1080      	asrs	r0, r0, #2
 804ad24:	3001      	adds	r0, #1
 804ad26:	2804      	cmp	r0, #4
 804ad28:	d834      	bhi.n	804ad94 <ip4addr_aton+0x128>
 804ad2a:	e8df f000 	tbb	[pc, r0]
 804ad2e:	0b3e      	.short	0x0b3e
 804ad30:	1303      	.short	0x1303
 804ad32:	21          	.byte	0x21
 804ad33:	00          	.byte	0x00

  case 1:             /* a -- 32 bits */
    break;

  case 2:             /* a.b -- 8.24 bits */
    if (val > 0xffffffUL) {
 804ad34:	f1b5 7f80 	cmp.w	r5, #16777216	; 0x1000000
 804ad38:	d23b      	bcs.n	804adb2 <ip4addr_aton+0x146>
      return 0;
    }
    if (parts[0] > 0xff) {
 804ad3a:	9b00      	ldr	r3, [sp, #0]
 804ad3c:	2bff      	cmp	r3, #255	; 0xff
 804ad3e:	d83a      	bhi.n	804adb6 <ip4addr_aton+0x14a>
      return 0;
    }
    val |= parts[0] << 24;
 804ad40:	ea45 6503 	orr.w	r5, r5, r3, lsl #24
    break;
  default:
    LWIP_ASSERT("unhandled", 0);
    break;
  }
  if (addr) {
 804ad44:	2c00      	cmp	r4, #0
 804ad46:	d046      	beq.n	804add6 <ip4addr_aton+0x16a>
    ip4_addr_set_u32(addr, lwip_htonl(val));
 804ad48:	4628      	mov	r0, r5
 804ad4a:	f7fa fb94 	bl	8045476 <lwip_htonl>
 804ad4e:	6020      	str	r0, [r4, #0]
  }
  return 1;
 804ad50:	2001      	movs	r0, #1
 804ad52:	e02a      	b.n	804adaa <ip4addr_aton+0x13e>
    if (val > 0xffff) {
 804ad54:	f5b5 3f80 	cmp.w	r5, #65536	; 0x10000
 804ad58:	d22f      	bcs.n	804adba <ip4addr_aton+0x14e>
    if ((parts[0] > 0xff) || (parts[1] > 0xff)) {
 804ad5a:	9a00      	ldr	r2, [sp, #0]
 804ad5c:	2aff      	cmp	r2, #255	; 0xff
 804ad5e:	d82e      	bhi.n	804adbe <ip4addr_aton+0x152>
 804ad60:	9b01      	ldr	r3, [sp, #4]
 804ad62:	2bff      	cmp	r3, #255	; 0xff
 804ad64:	d82d      	bhi.n	804adc2 <ip4addr_aton+0x156>
    val |= (parts[0] << 24) | (parts[1] << 16);
 804ad66:	041b      	lsls	r3, r3, #16
 804ad68:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 804ad6c:	431d      	orrs	r5, r3
    break;
 804ad6e:	e7e9      	b.n	804ad44 <ip4addr_aton+0xd8>
    if (val > 0xff) {
 804ad70:	2dff      	cmp	r5, #255	; 0xff
 804ad72:	d828      	bhi.n	804adc6 <ip4addr_aton+0x15a>
    if ((parts[0] > 0xff) || (parts[1] > 0xff) || (parts[2] > 0xff)) {
 804ad74:	9900      	ldr	r1, [sp, #0]
 804ad76:	29ff      	cmp	r1, #255	; 0xff
 804ad78:	d827      	bhi.n	804adca <ip4addr_aton+0x15e>
 804ad7a:	9b01      	ldr	r3, [sp, #4]
 804ad7c:	2bff      	cmp	r3, #255	; 0xff
 804ad7e:	d826      	bhi.n	804adce <ip4addr_aton+0x162>
 804ad80:	9a02      	ldr	r2, [sp, #8]
 804ad82:	2aff      	cmp	r2, #255	; 0xff
 804ad84:	d825      	bhi.n	804add2 <ip4addr_aton+0x166>
    val |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);
 804ad86:	041b      	lsls	r3, r3, #16
 804ad88:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
 804ad8c:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 804ad90:	431d      	orrs	r5, r3
    break;
 804ad92:	e7d7      	b.n	804ad44 <ip4addr_aton+0xd8>
    LWIP_ASSERT("unhandled", 0);
 804ad94:	4b11      	ldr	r3, [pc, #68]	; (804addc <ip4addr_aton+0x170>)
 804ad96:	f240 1203 	movw	r2, #259	; 0x103
 804ad9a:	4911      	ldr	r1, [pc, #68]	; (804ade0 <ip4addr_aton+0x174>)
 804ad9c:	4811      	ldr	r0, [pc, #68]	; (804ade4 <ip4addr_aton+0x178>)
 804ad9e:	f006 fe53 	bl	8051a48 <printf>
    break;
 804ada2:	e7cf      	b.n	804ad44 <ip4addr_aton+0xd8>
      return 0;
 804ada4:	2000      	movs	r0, #0
 804ada6:	e000      	b.n	804adaa <ip4addr_aton+0x13e>
        return 0;
 804ada8:	2000      	movs	r0, #0
}
 804adaa:	b004      	add	sp, #16
 804adac:	bd70      	pop	{r4, r5, r6, pc}
    return 0;
 804adae:	2000      	movs	r0, #0
 804adb0:	e7fb      	b.n	804adaa <ip4addr_aton+0x13e>
      return 0;
 804adb2:	2000      	movs	r0, #0
 804adb4:	e7f9      	b.n	804adaa <ip4addr_aton+0x13e>
      return 0;
 804adb6:	2000      	movs	r0, #0
 804adb8:	e7f7      	b.n	804adaa <ip4addr_aton+0x13e>
      return 0;
 804adba:	2000      	movs	r0, #0
 804adbc:	e7f5      	b.n	804adaa <ip4addr_aton+0x13e>
      return 0;
 804adbe:	2000      	movs	r0, #0
 804adc0:	e7f3      	b.n	804adaa <ip4addr_aton+0x13e>
 804adc2:	2000      	movs	r0, #0
 804adc4:	e7f1      	b.n	804adaa <ip4addr_aton+0x13e>
      return 0;
 804adc6:	2000      	movs	r0, #0
 804adc8:	e7ef      	b.n	804adaa <ip4addr_aton+0x13e>
      return 0;
 804adca:	2000      	movs	r0, #0
 804adcc:	e7ed      	b.n	804adaa <ip4addr_aton+0x13e>
 804adce:	2000      	movs	r0, #0
 804add0:	e7eb      	b.n	804adaa <ip4addr_aton+0x13e>
 804add2:	2000      	movs	r0, #0
 804add4:	e7e9      	b.n	804adaa <ip4addr_aton+0x13e>
  return 1;
 804add6:	2001      	movs	r0, #1
 804add8:	e7e7      	b.n	804adaa <ip4addr_aton+0x13e>
 804adda:	bf00      	nop
 804addc:	0805a600 	.word	0x0805a600
 804ade0:	0805a63c 	.word	0x0805a63c
 804ade4:	08058ecc 	.word	0x08058ecc

0804ade8 <ip_reass_dequeue_datagram>:
 * Dequeues a datagram from the datagram queue. Doesn't deallocate the pbufs.
 * @param ipr points to the queue entry to dequeue
 */
static void
ip_reass_dequeue_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
 804ade8:	b538      	push	{r3, r4, r5, lr}
 804adea:	4604      	mov	r4, r0
  /* dequeue the reass struct  */
  if (reassdatagrams == ipr) {
 804adec:	4b0c      	ldr	r3, [pc, #48]	; (804ae20 <ip_reass_dequeue_datagram+0x38>)
 804adee:	681b      	ldr	r3, [r3, #0]
 804adf0:	4283      	cmp	r3, r0
 804adf2:	d008      	beq.n	804ae06 <ip_reass_dequeue_datagram+0x1e>
 804adf4:	460d      	mov	r5, r1
    /* it was the first in the list */
    reassdatagrams = ipr->next;
  } else {
    /* it wasn't the first, so it must have a valid 'prev' */
    LWIP_ASSERT("sanity check linked list", prev != NULL);
 804adf6:	b151      	cbz	r1, 804ae0e <ip_reass_dequeue_datagram+0x26>
    prev->next = ipr->next;
 804adf8:	6823      	ldr	r3, [r4, #0]
 804adfa:	602b      	str	r3, [r5, #0]
  }

  /* now we can free the ip_reassdata struct */
  memp_free(MEMP_REASSDATA, ipr);
 804adfc:	4621      	mov	r1, r4
 804adfe:	2004      	movs	r0, #4
 804ae00:	f7fa fdb8 	bl	8045974 <memp_free>
}
 804ae04:	bd38      	pop	{r3, r4, r5, pc}
    reassdatagrams = ipr->next;
 804ae06:	6802      	ldr	r2, [r0, #0]
 804ae08:	4b05      	ldr	r3, [pc, #20]	; (804ae20 <ip_reass_dequeue_datagram+0x38>)
 804ae0a:	601a      	str	r2, [r3, #0]
 804ae0c:	e7f6      	b.n	804adfc <ip_reass_dequeue_datagram+0x14>
    LWIP_ASSERT("sanity check linked list", prev != NULL);
 804ae0e:	4b05      	ldr	r3, [pc, #20]	; (804ae24 <ip_reass_dequeue_datagram+0x3c>)
 804ae10:	f240 1245 	movw	r2, #325	; 0x145
 804ae14:	4904      	ldr	r1, [pc, #16]	; (804ae28 <ip_reass_dequeue_datagram+0x40>)
 804ae16:	4805      	ldr	r0, [pc, #20]	; (804ae2c <ip_reass_dequeue_datagram+0x44>)
 804ae18:	f006 fe16 	bl	8051a48 <printf>
 804ae1c:	e7ec      	b.n	804adf8 <ip_reass_dequeue_datagram+0x10>
 804ae1e:	bf00      	nop
 804ae20:	20004208 	.word	0x20004208
 804ae24:	0805a648 	.word	0x0805a648
 804ae28:	0805a684 	.word	0x0805a684
 804ae2c:	08058ecc 	.word	0x08058ecc

0804ae30 <ip_reass_free_complete_datagram>:
{
 804ae30:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 804ae34:	4680      	mov	r8, r0
 804ae36:	4689      	mov	r9, r1
  LWIP_ASSERT("prev != ipr", prev != ipr);
 804ae38:	4281      	cmp	r1, r0
 804ae3a:	d015      	beq.n	804ae68 <ip_reass_free_complete_datagram+0x38>
  if (prev != NULL) {
 804ae3c:	f1b9 0f00 	cmp.w	r9, #0
 804ae40:	d009      	beq.n	804ae56 <ip_reass_free_complete_datagram+0x26>
    LWIP_ASSERT("prev->next == ipr", prev->next == ipr);
 804ae42:	f8d9 3000 	ldr.w	r3, [r9]
 804ae46:	4543      	cmp	r3, r8
 804ae48:	d005      	beq.n	804ae56 <ip_reass_free_complete_datagram+0x26>
 804ae4a:	4b30      	ldr	r3, [pc, #192]	; (804af0c <ip_reass_free_complete_datagram+0xdc>)
 804ae4c:	22ad      	movs	r2, #173	; 0xad
 804ae4e:	4930      	ldr	r1, [pc, #192]	; (804af10 <ip_reass_free_complete_datagram+0xe0>)
 804ae50:	4830      	ldr	r0, [pc, #192]	; (804af14 <ip_reass_free_complete_datagram+0xe4>)
 804ae52:	f006 fdf9 	bl	8051a48 <printf>
  iprh = (struct ip_reass_helper *)ipr->p->payload;
 804ae56:	f8d8 5004 	ldr.w	r5, [r8, #4]
 804ae5a:	686b      	ldr	r3, [r5, #4]
  if (iprh->start == 0) {
 804ae5c:	889a      	ldrh	r2, [r3, #4]
 804ae5e:	b152      	cbz	r2, 804ae76 <ip_reass_free_complete_datagram+0x46>
  u16_t pbufs_freed = 0;
 804ae60:	2600      	movs	r6, #0
  p = ipr->p;
 804ae62:	f8d8 5004 	ldr.w	r5, [r8, #4]
  while (p != NULL) {
 804ae66:	e02e      	b.n	804aec6 <ip_reass_free_complete_datagram+0x96>
  LWIP_ASSERT("prev != ipr", prev != ipr);
 804ae68:	4b28      	ldr	r3, [pc, #160]	; (804af0c <ip_reass_free_complete_datagram+0xdc>)
 804ae6a:	22ab      	movs	r2, #171	; 0xab
 804ae6c:	492a      	ldr	r1, [pc, #168]	; (804af18 <ip_reass_free_complete_datagram+0xe8>)
 804ae6e:	4829      	ldr	r0, [pc, #164]	; (804af14 <ip_reass_free_complete_datagram+0xe4>)
 804ae70:	f006 fdea 	bl	8051a48 <printf>
 804ae74:	e7e2      	b.n	804ae3c <ip_reass_free_complete_datagram+0xc>
    ipr->p = iprh->next_pbuf;
 804ae76:	681b      	ldr	r3, [r3, #0]
 804ae78:	f8c8 3004 	str.w	r3, [r8, #4]
    SMEMCPY(p->payload, &ipr->iphdr, IP_HLEN);
 804ae7c:	4643      	mov	r3, r8
 804ae7e:	686a      	ldr	r2, [r5, #4]
 804ae80:	f853 1f08 	ldr.w	r1, [r3, #8]!
 804ae84:	685e      	ldr	r6, [r3, #4]
 804ae86:	689c      	ldr	r4, [r3, #8]
 804ae88:	68d8      	ldr	r0, [r3, #12]
 804ae8a:	6011      	str	r1, [r2, #0]
 804ae8c:	6056      	str	r6, [r2, #4]
 804ae8e:	6094      	str	r4, [r2, #8]
 804ae90:	60d0      	str	r0, [r2, #12]
 804ae92:	6919      	ldr	r1, [r3, #16]
 804ae94:	6111      	str	r1, [r2, #16]
    icmp_time_exceeded(p, ICMP_TE_FRAG);
 804ae96:	2101      	movs	r1, #1
 804ae98:	4628      	mov	r0, r5
 804ae9a:	f7ff fd23 	bl	804a8e4 <icmp_time_exceeded>
    clen = pbuf_clen(p);
 804ae9e:	4628      	mov	r0, r5
 804aea0:	f7fb f8e8 	bl	8046074 <pbuf_clen>
 804aea4:	4606      	mov	r6, r0
    pbuf_free(p);
 804aea6:	4628      	mov	r0, r5
 804aea8:	f7fa ff18 	bl	8045cdc <pbuf_free>
 804aeac:	e7d9      	b.n	804ae62 <ip_reass_free_complete_datagram+0x32>
    LWIP_ASSERT("pbufs_freed + clen <= 0xffff", pbufs_freed + clen <= 0xffff);
 804aeae:	4b17      	ldr	r3, [pc, #92]	; (804af0c <ip_reass_free_complete_datagram+0xdc>)
 804aeb0:	22cc      	movs	r2, #204	; 0xcc
 804aeb2:	491a      	ldr	r1, [pc, #104]	; (804af1c <ip_reass_free_complete_datagram+0xec>)
 804aeb4:	4817      	ldr	r0, [pc, #92]	; (804af14 <ip_reass_free_complete_datagram+0xe4>)
 804aeb6:	f006 fdc7 	bl	8051a48 <printf>
    pbufs_freed += clen;
 804aeba:	4434      	add	r4, r6
 804aebc:	b2a6      	uxth	r6, r4
    pbuf_free(pcur);
 804aebe:	4628      	mov	r0, r5
 804aec0:	f7fa ff0c 	bl	8045cdc <pbuf_free>
    p = iprh->next_pbuf;
 804aec4:	463d      	mov	r5, r7
  while (p != NULL) {
 804aec6:	b155      	cbz	r5, 804aede <ip_reass_free_complete_datagram+0xae>
    iprh = (struct ip_reass_helper *)p->payload;
 804aec8:	686b      	ldr	r3, [r5, #4]
    p = iprh->next_pbuf;
 804aeca:	681f      	ldr	r7, [r3, #0]
    clen = pbuf_clen(pcur);
 804aecc:	4628      	mov	r0, r5
 804aece:	f7fb f8d1 	bl	8046074 <pbuf_clen>
 804aed2:	4604      	mov	r4, r0
    LWIP_ASSERT("pbufs_freed + clen <= 0xffff", pbufs_freed + clen <= 0xffff);
 804aed4:	1833      	adds	r3, r6, r0
 804aed6:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 804aeda:	dbee      	blt.n	804aeba <ip_reass_free_complete_datagram+0x8a>
 804aedc:	e7e7      	b.n	804aeae <ip_reass_free_complete_datagram+0x7e>
  ip_reass_dequeue_datagram(ipr, prev);
 804aede:	4649      	mov	r1, r9
 804aee0:	4640      	mov	r0, r8
 804aee2:	f7ff ff81 	bl	804ade8 <ip_reass_dequeue_datagram>
  LWIP_ASSERT("ip_reass_pbufcount >= clen", ip_reass_pbufcount >= pbufs_freed);
 804aee6:	4b0e      	ldr	r3, [pc, #56]	; (804af20 <ip_reass_free_complete_datagram+0xf0>)
 804aee8:	889b      	ldrh	r3, [r3, #4]
 804aeea:	42b3      	cmp	r3, r6
 804aeec:	d306      	bcc.n	804aefc <ip_reass_free_complete_datagram+0xcc>
  ip_reass_pbufcount -= pbufs_freed;
 804aeee:	4a0c      	ldr	r2, [pc, #48]	; (804af20 <ip_reass_free_complete_datagram+0xf0>)
 804aef0:	8893      	ldrh	r3, [r2, #4]
 804aef2:	1b9b      	subs	r3, r3, r6
 804aef4:	8093      	strh	r3, [r2, #4]
}
 804aef6:	4630      	mov	r0, r6
 804aef8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  LWIP_ASSERT("ip_reass_pbufcount >= clen", ip_reass_pbufcount >= pbufs_freed);
 804aefc:	4b03      	ldr	r3, [pc, #12]	; (804af0c <ip_reass_free_complete_datagram+0xdc>)
 804aefe:	22d2      	movs	r2, #210	; 0xd2
 804af00:	4908      	ldr	r1, [pc, #32]	; (804af24 <ip_reass_free_complete_datagram+0xf4>)
 804af02:	4804      	ldr	r0, [pc, #16]	; (804af14 <ip_reass_free_complete_datagram+0xe4>)
 804af04:	f006 fda0 	bl	8051a48 <printf>
 804af08:	e7f1      	b.n	804aeee <ip_reass_free_complete_datagram+0xbe>
 804af0a:	bf00      	nop
 804af0c:	0805a648 	.word	0x0805a648
 804af10:	0805a6ac 	.word	0x0805a6ac
 804af14:	08058ecc 	.word	0x08058ecc
 804af18:	0805a6a0 	.word	0x0805a6a0
 804af1c:	0805a6c0 	.word	0x0805a6c0
 804af20:	20004208 	.word	0x20004208
 804af24:	0805a6e0 	.word	0x0805a6e0

0804af28 <ip_reass_remove_oldest_datagram>:
{
 804af28:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 804af2c:	4606      	mov	r6, r0
 804af2e:	4688      	mov	r8, r1
  int pbufs_freed = 0, pbufs_freed_current;
 804af30:	2700      	movs	r7, #0
 804af32:	e02b      	b.n	804af8c <ip_reass_remove_oldest_datagram+0x64>
      if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
 804af34:	699a      	ldr	r2, [r3, #24]
 804af36:	f8d6 c010 	ldr.w	ip, [r6, #16]
 804af3a:	4562      	cmp	r2, ip
 804af3c:	d111      	bne.n	804af62 <ip_reass_remove_oldest_datagram+0x3a>
 804af3e:	f8b3 c00c 	ldrh.w	ip, [r3, #12]
 804af42:	88b2      	ldrh	r2, [r6, #4]
 804af44:	4594      	cmp	ip, r2
 804af46:	d10c      	bne.n	804af62 <ip_reass_remove_oldest_datagram+0x3a>
 804af48:	e001      	b.n	804af4e <ip_reass_remove_oldest_datagram+0x26>
          oldest_prev = prev;
 804af4a:	4629      	mov	r1, r5
          oldest = r;
 804af4c:	4618      	mov	r0, r3
      if (r->next != NULL) {
 804af4e:	681a      	ldr	r2, [r3, #0]
 804af50:	b192      	cbz	r2, 804af78 <ip_reass_remove_oldest_datagram+0x50>
 804af52:	461d      	mov	r5, r3
 804af54:	4613      	mov	r3, r2
    while (r != NULL) {
 804af56:	b18b      	cbz	r3, 804af7c <ip_reass_remove_oldest_datagram+0x54>
      if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
 804af58:	695a      	ldr	r2, [r3, #20]
 804af5a:	f8d6 c00c 	ldr.w	ip, [r6, #12]
 804af5e:	4562      	cmp	r2, ip
 804af60:	d0e8      	beq.n	804af34 <ip_reass_remove_oldest_datagram+0xc>
        other_datagrams++;
 804af62:	3401      	adds	r4, #1
        if (oldest == NULL) {
 804af64:	2800      	cmp	r0, #0
 804af66:	d0f0      	beq.n	804af4a <ip_reass_remove_oldest_datagram+0x22>
        } else if (r->timer <= oldest->timer) {
 804af68:	f893 c01f 	ldrb.w	ip, [r3, #31]
 804af6c:	7fc2      	ldrb	r2, [r0, #31]
 804af6e:	4594      	cmp	ip, r2
 804af70:	d8ed      	bhi.n	804af4e <ip_reass_remove_oldest_datagram+0x26>
          oldest_prev = prev;
 804af72:	4629      	mov	r1, r5
          oldest = r;
 804af74:	4618      	mov	r0, r3
 804af76:	e7ea      	b.n	804af4e <ip_reass_remove_oldest_datagram+0x26>
      if (r->next != NULL) {
 804af78:	462b      	mov	r3, r5
 804af7a:	e7ea      	b.n	804af52 <ip_reass_remove_oldest_datagram+0x2a>
    if (oldest != NULL) {
 804af7c:	b110      	cbz	r0, 804af84 <ip_reass_remove_oldest_datagram+0x5c>
      pbufs_freed_current = ip_reass_free_complete_datagram(oldest, oldest_prev);
 804af7e:	f7ff ff57 	bl	804ae30 <ip_reass_free_complete_datagram>
      pbufs_freed += pbufs_freed_current;
 804af82:	4407      	add	r7, r0
  } while ((pbufs_freed < pbufs_needed) && (other_datagrams > 1));
 804af84:	4547      	cmp	r7, r8
 804af86:	da08      	bge.n	804af9a <ip_reass_remove_oldest_datagram+0x72>
 804af88:	2c01      	cmp	r4, #1
 804af8a:	dd06      	ble.n	804af9a <ip_reass_remove_oldest_datagram+0x72>
    r = reassdatagrams;
 804af8c:	4b04      	ldr	r3, [pc, #16]	; (804afa0 <ip_reass_remove_oldest_datagram+0x78>)
 804af8e:	681b      	ldr	r3, [r3, #0]
    other_datagrams = 0;
 804af90:	2400      	movs	r4, #0
    oldest_prev = NULL;
 804af92:	4621      	mov	r1, r4
    prev = NULL;
 804af94:	4625      	mov	r5, r4
    oldest = NULL;
 804af96:	4620      	mov	r0, r4
    while (r != NULL) {
 804af98:	e7dd      	b.n	804af56 <ip_reass_remove_oldest_datagram+0x2e>
}
 804af9a:	4638      	mov	r0, r7
 804af9c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 804afa0:	20004208 	.word	0x20004208

0804afa4 <ip_frag_free_pbuf_custom_ref>:
}

/** Free a struct pbuf_custom_ref */
static void
ip_frag_free_pbuf_custom_ref(struct pbuf_custom_ref* p)
{
 804afa4:	b510      	push	{r4, lr}
  LWIP_ASSERT("p != NULL", p != NULL);
 804afa6:	4604      	mov	r4, r0
 804afa8:	b120      	cbz	r0, 804afb4 <ip_frag_free_pbuf_custom_ref+0x10>
  memp_free(MEMP_FRAG_PBUF, p);
 804afaa:	4621      	mov	r1, r4
 804afac:	2005      	movs	r0, #5
 804afae:	f7fa fce1 	bl	8045974 <memp_free>
}
 804afb2:	bd10      	pop	{r4, pc}
  LWIP_ASSERT("p != NULL", p != NULL);
 804afb4:	4b03      	ldr	r3, [pc, #12]	; (804afc4 <ip_frag_free_pbuf_custom_ref+0x20>)
 804afb6:	f240 22ae 	movw	r2, #686	; 0x2ae
 804afba:	4903      	ldr	r1, [pc, #12]	; (804afc8 <ip_frag_free_pbuf_custom_ref+0x24>)
 804afbc:	4803      	ldr	r0, [pc, #12]	; (804afcc <ip_frag_free_pbuf_custom_ref+0x28>)
 804afbe:	f006 fd43 	bl	8051a48 <printf>
 804afc2:	e7f2      	b.n	804afaa <ip_frag_free_pbuf_custom_ref+0x6>
 804afc4:	0805a648 	.word	0x0805a648
 804afc8:	080591c0 	.word	0x080591c0
 804afcc:	08058ecc 	.word	0x08058ecc

0804afd0 <ipfrag_free_pbuf_custom>:

/** Free-callback function to free a 'struct pbuf_custom_ref', called by
 * pbuf_free. */
static void
ipfrag_free_pbuf_custom(struct pbuf *p)
{
 804afd0:	b510      	push	{r4, lr}
  struct pbuf_custom_ref *pcr = (struct pbuf_custom_ref*)p;
  LWIP_ASSERT("pcr != NULL", pcr != NULL);
 804afd2:	4604      	mov	r4, r0
 804afd4:	b138      	cbz	r0, 804afe6 <ipfrag_free_pbuf_custom+0x16>
  LWIP_ASSERT("pcr == p", (void*)pcr == (void*)p);
  if (pcr->original != NULL) {
 804afd6:	6960      	ldr	r0, [r4, #20]
 804afd8:	b108      	cbz	r0, 804afde <ipfrag_free_pbuf_custom+0xe>
    pbuf_free(pcr->original);
 804afda:	f7fa fe7f 	bl	8045cdc <pbuf_free>
  }
  ip_frag_free_pbuf_custom_ref(pcr);
 804afde:	4620      	mov	r0, r4
 804afe0:	f7ff ffe0 	bl	804afa4 <ip_frag_free_pbuf_custom_ref>
}
 804afe4:	bd10      	pop	{r4, pc}
  LWIP_ASSERT("pcr != NULL", pcr != NULL);
 804afe6:	4b04      	ldr	r3, [pc, #16]	; (804aff8 <ipfrag_free_pbuf_custom+0x28>)
 804afe8:	f44f 722e 	mov.w	r2, #696	; 0x2b8
 804afec:	4903      	ldr	r1, [pc, #12]	; (804affc <ipfrag_free_pbuf_custom+0x2c>)
 804afee:	4804      	ldr	r0, [pc, #16]	; (804b000 <ipfrag_free_pbuf_custom+0x30>)
 804aff0:	f006 fd2a 	bl	8051a48 <printf>
 804aff4:	e7ef      	b.n	804afd6 <ipfrag_free_pbuf_custom+0x6>
 804aff6:	bf00      	nop
 804aff8:	0805a648 	.word	0x0805a648
 804affc:	0805a6fc 	.word	0x0805a6fc
 804b000:	08058ecc 	.word	0x08058ecc

0804b004 <ip_reass_chain_frag_into_datagram_and_validate>:
{
 804b004:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 804b008:	4681      	mov	r9, r0
 804b00a:	4688      	mov	r8, r1
 804b00c:	4692      	mov	sl, r2
  fraghdr = (struct ip_hdr*)new_p->payload;
 804b00e:	684c      	ldr	r4, [r1, #4]
  len = lwip_ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
 804b010:	8860      	ldrh	r0, [r4, #2]
 804b012:	f7fa fa2d 	bl	8045470 <lwip_htons>
 804b016:	7823      	ldrb	r3, [r4, #0]
 804b018:	f003 030f 	and.w	r3, r3, #15
 804b01c:	eba0 0383 	sub.w	r3, r0, r3, lsl #2
 804b020:	b29f      	uxth	r7, r3
  offset = (lwip_ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
 804b022:	88e0      	ldrh	r0, [r4, #6]
 804b024:	f7fa fa24 	bl	8045470 <lwip_htons>
 804b028:	f3c0 040c 	ubfx	r4, r0, #0, #13
 804b02c:	00e4      	lsls	r4, r4, #3
  iprh = (struct ip_reass_helper*)new_p->payload;
 804b02e:	f8d8 6004 	ldr.w	r6, [r8, #4]
  iprh->next_pbuf = NULL;
 804b032:	2500      	movs	r5, #0
 804b034:	7035      	strb	r5, [r6, #0]
 804b036:	7075      	strb	r5, [r6, #1]
 804b038:	70b5      	strb	r5, [r6, #2]
 804b03a:	70f5      	strb	r5, [r6, #3]
  iprh->start = offset;
 804b03c:	80b4      	strh	r4, [r6, #4]
  iprh->end = offset + len;
 804b03e:	193b      	adds	r3, r7, r4
 804b040:	b298      	uxth	r0, r3
 804b042:	80f3      	strh	r3, [r6, #6]
  for (q = ipr->p; q != NULL;) {
 804b044:	f8d9 1004 	ldr.w	r1, [r9, #4]
  int valid = 1;
 804b048:	2701      	movs	r7, #1
  for (q = ipr->p; q != NULL;) {
 804b04a:	e020      	b.n	804b08e <ip_reass_chain_frag_into_datagram_and_validate+0x8a>
      iprh->next_pbuf = q;
 804b04c:	6031      	str	r1, [r6, #0]
      if (iprh_prev != NULL) {
 804b04e:	b1b5      	cbz	r5, 804b07e <ip_reass_chain_frag_into_datagram_and_validate+0x7a>
        if ((iprh->start < iprh_prev->end) || (iprh->end > iprh_tmp->start)) {
 804b050:	88ea      	ldrh	r2, [r5, #6]
 804b052:	42a2      	cmp	r2, r4
 804b054:	d87c      	bhi.n	804b150 <ip_reass_chain_frag_into_datagram_and_validate+0x14c>
 804b056:	889b      	ldrh	r3, [r3, #4]
 804b058:	4298      	cmp	r0, r3
 804b05a:	d879      	bhi.n	804b150 <ip_reass_chain_frag_into_datagram_and_validate+0x14c>
        iprh_prev->next_pbuf = new_p;
 804b05c:	f8c5 8000 	str.w	r8, [r5]
        if (iprh_prev->end != iprh->start) {
 804b060:	88b3      	ldrh	r3, [r6, #4]
 804b062:	429a      	cmp	r2, r3
 804b064:	d000      	beq.n	804b068 <ip_reass_chain_frag_into_datagram_and_validate+0x64>
          valid = 0;
 804b066:	2700      	movs	r7, #0
  if (q == NULL) {
 804b068:	b319      	cbz	r1, 804b0b2 <ip_reass_chain_frag_into_datagram_and_validate+0xae>
  if (is_last || ((ipr->flags & IP_REASS_FLAG_LASTFRAG) != 0)) {
 804b06a:	f1ba 0f00 	cmp.w	sl, #0
 804b06e:	d142      	bne.n	804b0f6 <ip_reass_chain_frag_into_datagram_and_validate+0xf2>
 804b070:	f899 301e 	ldrb.w	r3, [r9, #30]
 804b074:	f013 0f01 	tst.w	r3, #1
 804b078:	d13d      	bne.n	804b0f6 <ip_reass_chain_frag_into_datagram_and_validate+0xf2>
  return IP_REASS_VALIDATE_PBUF_QUEUED; /* not yet valid! */
 804b07a:	4650      	mov	r0, sl
 804b07c:	e074      	b.n	804b168 <ip_reass_chain_frag_into_datagram_and_validate+0x164>
        if (iprh->end > iprh_tmp->start) {
 804b07e:	889b      	ldrh	r3, [r3, #4]
 804b080:	4298      	cmp	r0, r3
 804b082:	d865      	bhi.n	804b150 <ip_reass_chain_frag_into_datagram_and_validate+0x14c>
        ipr->p = new_p;
 804b084:	f8c9 8004 	str.w	r8, [r9, #4]
 804b088:	e7ee      	b.n	804b068 <ip_reass_chain_frag_into_datagram_and_validate+0x64>
    q = iprh_tmp->next_pbuf;
 804b08a:	6819      	ldr	r1, [r3, #0]
    iprh_prev = iprh_tmp;
 804b08c:	461d      	mov	r5, r3
  for (q = ipr->p; q != NULL;) {
 804b08e:	2900      	cmp	r1, #0
 804b090:	d0ea      	beq.n	804b068 <ip_reass_chain_frag_into_datagram_and_validate+0x64>
    iprh_tmp = (struct ip_reass_helper*)q->payload;
 804b092:	684b      	ldr	r3, [r1, #4]
    if (iprh->start < iprh_tmp->start) {
 804b094:	889a      	ldrh	r2, [r3, #4]
 804b096:	42a2      	cmp	r2, r4
 804b098:	d8d8      	bhi.n	804b04c <ip_reass_chain_frag_into_datagram_and_validate+0x48>
    } else if (iprh->start == iprh_tmp->start) {
 804b09a:	42a2      	cmp	r2, r4
 804b09c:	d058      	beq.n	804b150 <ip_reass_chain_frag_into_datagram_and_validate+0x14c>
    } else if (iprh->start < iprh_tmp->end) {
 804b09e:	88d9      	ldrh	r1, [r3, #6]
 804b0a0:	42a1      	cmp	r1, r4
 804b0a2:	d855      	bhi.n	804b150 <ip_reass_chain_frag_into_datagram_and_validate+0x14c>
      if (iprh_prev != NULL) {
 804b0a4:	2d00      	cmp	r5, #0
 804b0a6:	d0f0      	beq.n	804b08a <ip_reass_chain_frag_into_datagram_and_validate+0x86>
        if (iprh_prev->end != iprh_tmp->start) {
 804b0a8:	88e9      	ldrh	r1, [r5, #6]
 804b0aa:	428a      	cmp	r2, r1
 804b0ac:	d0ed      	beq.n	804b08a <ip_reass_chain_frag_into_datagram_and_validate+0x86>
          valid = 0;
 804b0ae:	2700      	movs	r7, #0
 804b0b0:	e7eb      	b.n	804b08a <ip_reass_chain_frag_into_datagram_and_validate+0x86>
    if (iprh_prev != NULL) {
 804b0b2:	b19d      	cbz	r5, 804b0dc <ip_reass_chain_frag_into_datagram_and_validate+0xd8>
      LWIP_ASSERT("check fragments don't overlap", iprh_prev->end <= iprh->start);
 804b0b4:	88ea      	ldrh	r2, [r5, #6]
 804b0b6:	88b3      	ldrh	r3, [r6, #4]
 804b0b8:	429a      	cmp	r2, r3
 804b0ba:	d807      	bhi.n	804b0cc <ip_reass_chain_frag_into_datagram_and_validate+0xc8>
      iprh_prev->next_pbuf = new_p;
 804b0bc:	f8c5 8000 	str.w	r8, [r5]
      if (iprh_prev->end != iprh->start) {
 804b0c0:	88ea      	ldrh	r2, [r5, #6]
 804b0c2:	88b3      	ldrh	r3, [r6, #4]
 804b0c4:	429a      	cmp	r2, r3
 804b0c6:	d0d0      	beq.n	804b06a <ip_reass_chain_frag_into_datagram_and_validate+0x66>
        valid = 0;
 804b0c8:	2700      	movs	r7, #0
 804b0ca:	e7ce      	b.n	804b06a <ip_reass_chain_frag_into_datagram_and_validate+0x66>
      LWIP_ASSERT("check fragments don't overlap", iprh_prev->end <= iprh->start);
 804b0cc:	4b27      	ldr	r3, [pc, #156]	; (804b16c <ip_reass_chain_frag_into_datagram_and_validate+0x168>)
 804b0ce:	f240 12ab 	movw	r2, #427	; 0x1ab
 804b0d2:	4927      	ldr	r1, [pc, #156]	; (804b170 <ip_reass_chain_frag_into_datagram_and_validate+0x16c>)
 804b0d4:	4827      	ldr	r0, [pc, #156]	; (804b174 <ip_reass_chain_frag_into_datagram_and_validate+0x170>)
 804b0d6:	f006 fcb7 	bl	8051a48 <printf>
 804b0da:	e7ef      	b.n	804b0bc <ip_reass_chain_frag_into_datagram_and_validate+0xb8>
      LWIP_ASSERT("no previous fragment, this must be the first fragment!",
 804b0dc:	f8d9 3004 	ldr.w	r3, [r9, #4]
 804b0e0:	b133      	cbz	r3, 804b0f0 <ip_reass_chain_frag_into_datagram_and_validate+0xec>
 804b0e2:	4b22      	ldr	r3, [pc, #136]	; (804b16c <ip_reass_chain_frag_into_datagram_and_validate+0x168>)
 804b0e4:	f240 12b3 	movw	r2, #435	; 0x1b3
 804b0e8:	4923      	ldr	r1, [pc, #140]	; (804b178 <ip_reass_chain_frag_into_datagram_and_validate+0x174>)
 804b0ea:	4822      	ldr	r0, [pc, #136]	; (804b174 <ip_reass_chain_frag_into_datagram_and_validate+0x170>)
 804b0ec:	f006 fcac 	bl	8051a48 <printf>
      ipr->p = new_p;
 804b0f0:	f8c9 8004 	str.w	r8, [r9, #4]
 804b0f4:	e7b9      	b.n	804b06a <ip_reass_chain_frag_into_datagram_and_validate+0x66>
    if (valid) {
 804b0f6:	b34f      	cbz	r7, 804b14c <ip_reass_chain_frag_into_datagram_and_validate+0x148>
      if ((ipr->p == NULL) || (((struct ip_reass_helper*)ipr->p->payload)->start != 0)) {
 804b0f8:	f8d9 3004 	ldr.w	r3, [r9, #4]
 804b0fc:	b31b      	cbz	r3, 804b146 <ip_reass_chain_frag_into_datagram_and_validate+0x142>
 804b0fe:	6858      	ldr	r0, [r3, #4]
 804b100:	8883      	ldrh	r3, [r0, #4]
 804b102:	bb13      	cbnz	r3, 804b14a <ip_reass_chain_frag_into_datagram_and_validate+0x146>
        q = iprh->next_pbuf;
 804b104:	6832      	ldr	r2, [r6, #0]
        while (q != NULL) {
 804b106:	b14a      	cbz	r2, 804b11c <ip_reass_chain_frag_into_datagram_and_validate+0x118>
          iprh = (struct ip_reass_helper*)q->payload;
 804b108:	6853      	ldr	r3, [r2, #4]
          if (iprh_prev->end != iprh->start) {
 804b10a:	88f1      	ldrh	r1, [r6, #6]
 804b10c:	889a      	ldrh	r2, [r3, #4]
 804b10e:	4291      	cmp	r1, r2
 804b110:	d102      	bne.n	804b118 <ip_reass_chain_frag_into_datagram_and_validate+0x114>
          q = iprh->next_pbuf;
 804b112:	681a      	ldr	r2, [r3, #0]
          iprh = (struct ip_reass_helper*)q->payload;
 804b114:	461e      	mov	r6, r3
 804b116:	e7f6      	b.n	804b106 <ip_reass_chain_frag_into_datagram_and_validate+0x102>
 804b118:	461e      	mov	r6, r3
            valid = 0;
 804b11a:	2700      	movs	r7, #0
        if (valid) {
 804b11c:	b1b7      	cbz	r7, 804b14c <ip_reass_chain_frag_into_datagram_and_validate+0x148>
          LWIP_ASSERT("sanity check",
 804b11e:	42b0      	cmp	r0, r6
 804b120:	d009      	beq.n	804b136 <ip_reass_chain_frag_into_datagram_and_validate+0x132>
          LWIP_ASSERT("validate_datagram:next_pbuf!=NULL",
 804b122:	6833      	ldr	r3, [r6, #0]
 804b124:	b193      	cbz	r3, 804b14c <ip_reass_chain_frag_into_datagram_and_validate+0x148>
 804b126:	4b11      	ldr	r3, [pc, #68]	; (804b16c <ip_reass_chain_frag_into_datagram_and_validate+0x168>)
 804b128:	f240 12d7 	movw	r2, #471	; 0x1d7
 804b12c:	4913      	ldr	r1, [pc, #76]	; (804b17c <ip_reass_chain_frag_into_datagram_and_validate+0x178>)
 804b12e:	4811      	ldr	r0, [pc, #68]	; (804b174 <ip_reass_chain_frag_into_datagram_and_validate+0x170>)
 804b130:	f006 fc8a 	bl	8051a48 <printf>
 804b134:	e00a      	b.n	804b14c <ip_reass_chain_frag_into_datagram_and_validate+0x148>
          LWIP_ASSERT("sanity check",
 804b136:	4b0d      	ldr	r3, [pc, #52]	; (804b16c <ip_reass_chain_frag_into_datagram_and_validate+0x168>)
 804b138:	f240 12d5 	movw	r2, #469	; 0x1d5
 804b13c:	4910      	ldr	r1, [pc, #64]	; (804b180 <ip_reass_chain_frag_into_datagram_and_validate+0x17c>)
 804b13e:	480d      	ldr	r0, [pc, #52]	; (804b174 <ip_reass_chain_frag_into_datagram_and_validate+0x170>)
 804b140:	f006 fc82 	bl	8051a48 <printf>
 804b144:	e7ed      	b.n	804b122 <ip_reass_chain_frag_into_datagram_and_validate+0x11e>
        valid = 0;
 804b146:	2700      	movs	r7, #0
 804b148:	e000      	b.n	804b14c <ip_reass_chain_frag_into_datagram_and_validate+0x148>
 804b14a:	2700      	movs	r7, #0
    return valid ? IP_REASS_VALIDATE_TELEGRAM_FINISHED : IP_REASS_VALIDATE_PBUF_QUEUED;
 804b14c:	4638      	mov	r0, r7
 804b14e:	e00b      	b.n	804b168 <ip_reass_chain_frag_into_datagram_and_validate+0x164>
  ip_reass_pbufcount -= pbuf_clen(new_p);
 804b150:	4640      	mov	r0, r8
 804b152:	f7fa ff8f 	bl	8046074 <pbuf_clen>
 804b156:	4a0b      	ldr	r2, [pc, #44]	; (804b184 <ip_reass_chain_frag_into_datagram_and_validate+0x180>)
 804b158:	8893      	ldrh	r3, [r2, #4]
 804b15a:	1a1b      	subs	r3, r3, r0
 804b15c:	8093      	strh	r3, [r2, #4]
  pbuf_free(new_p);
 804b15e:	4640      	mov	r0, r8
 804b160:	f7fa fdbc 	bl	8045cdc <pbuf_free>
  return IP_REASS_VALIDATE_PBUF_DROPPED;
 804b164:	f04f 30ff 	mov.w	r0, #4294967295
}
 804b168:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 804b16c:	0805a648 	.word	0x0805a648
 804b170:	0805a708 	.word	0x0805a708
 804b174:	08058ecc 	.word	0x08058ecc
 804b178:	0805a728 	.word	0x0805a728
 804b17c:	0805a770 	.word	0x0805a770
 804b180:	0805a760 	.word	0x0805a760
 804b184:	20004208 	.word	0x20004208

0804b188 <ip_frag_alloc_pbuf_custom_ref>:
{
 804b188:	b508      	push	{r3, lr}
  return (struct pbuf_custom_ref*)memp_malloc(MEMP_FRAG_PBUF);
 804b18a:	2005      	movs	r0, #5
 804b18c:	f7fa fbd8 	bl	8045940 <memp_malloc>
}
 804b190:	bd08      	pop	{r3, pc}
	...

0804b194 <ip_reass_enqueue_new_datagram>:
{
 804b194:	b570      	push	{r4, r5, r6, lr}
 804b196:	4605      	mov	r5, r0
 804b198:	460e      	mov	r6, r1
  ipr = (struct ip_reassdata *)memp_malloc(MEMP_REASSDATA);
 804b19a:	2004      	movs	r0, #4
 804b19c:	f7fa fbd0 	bl	8045940 <memp_malloc>
  if (ipr == NULL) {
 804b1a0:	4604      	mov	r4, r0
 804b1a2:	b1c8      	cbz	r0, 804b1d8 <ip_reass_enqueue_new_datagram+0x44>
  memset(ipr, 0, sizeof(struct ip_reassdata));
 804b1a4:	2300      	movs	r3, #0
 804b1a6:	6063      	str	r3, [r4, #4]
 804b1a8:	60a3      	str	r3, [r4, #8]
 804b1aa:	60e3      	str	r3, [r4, #12]
 804b1ac:	6123      	str	r3, [r4, #16]
 804b1ae:	6163      	str	r3, [r4, #20]
 804b1b0:	61a3      	str	r3, [r4, #24]
 804b1b2:	61e3      	str	r3, [r4, #28]
  ipr->timer = IP_REASS_MAXAGE;
 804b1b4:	2303      	movs	r3, #3
 804b1b6:	77e3      	strb	r3, [r4, #31]
  ipr->next = reassdatagrams;
 804b1b8:	4b0e      	ldr	r3, [pc, #56]	; (804b1f4 <ip_reass_enqueue_new_datagram+0x60>)
 804b1ba:	681a      	ldr	r2, [r3, #0]
 804b1bc:	6022      	str	r2, [r4, #0]
  reassdatagrams = ipr;
 804b1be:	601c      	str	r4, [r3, #0]
  SMEMCPY(&(ipr->iphdr), fraghdr, IP_HLEN);
 804b1c0:	682b      	ldr	r3, [r5, #0]
 804b1c2:	6868      	ldr	r0, [r5, #4]
 804b1c4:	68a9      	ldr	r1, [r5, #8]
 804b1c6:	68ea      	ldr	r2, [r5, #12]
 804b1c8:	60a3      	str	r3, [r4, #8]
 804b1ca:	60e0      	str	r0, [r4, #12]
 804b1cc:	6121      	str	r1, [r4, #16]
 804b1ce:	6162      	str	r2, [r4, #20]
 804b1d0:	692b      	ldr	r3, [r5, #16]
 804b1d2:	61a3      	str	r3, [r4, #24]
}
 804b1d4:	4620      	mov	r0, r4
 804b1d6:	bd70      	pop	{r4, r5, r6, pc}
    if (ip_reass_remove_oldest_datagram(fraghdr, clen) >= clen) {
 804b1d8:	4631      	mov	r1, r6
 804b1da:	4628      	mov	r0, r5
 804b1dc:	f7ff fea4 	bl	804af28 <ip_reass_remove_oldest_datagram>
 804b1e0:	42b0      	cmp	r0, r6
 804b1e2:	da02      	bge.n	804b1ea <ip_reass_enqueue_new_datagram+0x56>
    if (ipr == NULL)
 804b1e4:	2c00      	cmp	r4, #0
 804b1e6:	d1dd      	bne.n	804b1a4 <ip_reass_enqueue_new_datagram+0x10>
 804b1e8:	e7f4      	b.n	804b1d4 <ip_reass_enqueue_new_datagram+0x40>
      ipr = (struct ip_reassdata *)memp_malloc(MEMP_REASSDATA);
 804b1ea:	2004      	movs	r0, #4
 804b1ec:	f7fa fba8 	bl	8045940 <memp_malloc>
 804b1f0:	4604      	mov	r4, r0
 804b1f2:	e7f7      	b.n	804b1e4 <ip_reass_enqueue_new_datagram+0x50>
 804b1f4:	20004208 	.word	0x20004208

0804b1f8 <ip_reass_tmr>:
{
 804b1f8:	b538      	push	{r3, r4, r5, lr}
  r = reassdatagrams;
 804b1fa:	4b09      	ldr	r3, [pc, #36]	; (804b220 <ip_reass_tmr+0x28>)
 804b1fc:	6818      	ldr	r0, [r3, #0]
  struct ip_reassdata *r, *prev = NULL;
 804b1fe:	2400      	movs	r4, #0
  while (r != NULL) {
 804b200:	e004      	b.n	804b20c <ip_reass_tmr+0x14>
      r = r->next;
 804b202:	6805      	ldr	r5, [r0, #0]
      ip_reass_free_complete_datagram(tmp, prev);
 804b204:	4621      	mov	r1, r4
 804b206:	f7ff fe13 	bl	804ae30 <ip_reass_free_complete_datagram>
      r = r->next;
 804b20a:	4628      	mov	r0, r5
  while (r != NULL) {
 804b20c:	b138      	cbz	r0, 804b21e <ip_reass_tmr+0x26>
    if (r->timer > 0) {
 804b20e:	7fc3      	ldrb	r3, [r0, #31]
 804b210:	2b00      	cmp	r3, #0
 804b212:	d0f6      	beq.n	804b202 <ip_reass_tmr+0xa>
      r->timer--;
 804b214:	3b01      	subs	r3, #1
 804b216:	77c3      	strb	r3, [r0, #31]
      prev = r;
 804b218:	4604      	mov	r4, r0
      r = r->next;
 804b21a:	6800      	ldr	r0, [r0, #0]
 804b21c:	e7f6      	b.n	804b20c <ip_reass_tmr+0x14>
}
 804b21e:	bd38      	pop	{r3, r4, r5, pc}
 804b220:	20004208 	.word	0x20004208

0804b224 <ip4_reass>:
{
 804b224:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 804b228:	4606      	mov	r6, r0
  fraghdr = (struct ip_hdr*)p->payload;
 804b22a:	6845      	ldr	r5, [r0, #4]
  if ((IPH_HL(fraghdr) * 4) != IP_HLEN) {
 804b22c:	782b      	ldrb	r3, [r5, #0]
 804b22e:	f003 030f 	and.w	r3, r3, #15
 804b232:	2b05      	cmp	r3, #5
 804b234:	d126      	bne.n	804b284 <ip4_reass+0x60>
  offset = (lwip_ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
 804b236:	88e8      	ldrh	r0, [r5, #6]
 804b238:	f7fa f91a 	bl	8045470 <lwip_htons>
 804b23c:	f3c0 070c 	ubfx	r7, r0, #0, #13
 804b240:	00ff      	lsls	r7, r7, #3
  len = lwip_ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
 804b242:	8868      	ldrh	r0, [r5, #2]
 804b244:	f7fa f914 	bl	8045470 <lwip_htons>
 804b248:	f895 9000 	ldrb.w	r9, [r5]
 804b24c:	f009 090f 	and.w	r9, r9, #15
 804b250:	eba0 0989 	sub.w	r9, r0, r9, lsl #2
 804b254:	fa1f f989 	uxth.w	r9, r9
  clen = pbuf_clen(p);
 804b258:	4630      	mov	r0, r6
 804b25a:	f7fa ff0b 	bl	8046074 <pbuf_clen>
 804b25e:	4680      	mov	r8, r0
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
 804b260:	4b57      	ldr	r3, [pc, #348]	; (804b3c0 <ip4_reass+0x19c>)
 804b262:	889b      	ldrh	r3, [r3, #4]
 804b264:	4403      	add	r3, r0
 804b266:	2b0a      	cmp	r3, #10
 804b268:	dc02      	bgt.n	804b270 <ip4_reass+0x4c>
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
 804b26a:	4b55      	ldr	r3, [pc, #340]	; (804b3c0 <ip4_reass+0x19c>)
 804b26c:	681c      	ldr	r4, [r3, #0]
 804b26e:	e011      	b.n	804b294 <ip4_reass+0x70>
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
 804b270:	4601      	mov	r1, r0
 804b272:	4628      	mov	r0, r5
 804b274:	f7ff fe58 	bl	804af28 <ip_reass_remove_oldest_datagram>
 804b278:	b120      	cbz	r0, 804b284 <ip4_reass+0x60>
        ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS))
 804b27a:	4b51      	ldr	r3, [pc, #324]	; (804b3c0 <ip4_reass+0x19c>)
 804b27c:	889b      	ldrh	r3, [r3, #4]
 804b27e:	4443      	add	r3, r8
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
 804b280:	2b0a      	cmp	r3, #10
 804b282:	ddf2      	ble.n	804b26a <ip4_reass+0x46>
  pbuf_free(p);
 804b284:	4630      	mov	r0, r6
 804b286:	f7fa fd29 	bl	8045cdc <pbuf_free>
  return NULL;
 804b28a:	2600      	movs	r6, #0
}
 804b28c:	4630      	mov	r0, r6
 804b28e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
 804b292:	6824      	ldr	r4, [r4, #0]
 804b294:	b15c      	cbz	r4, 804b2ae <ip4_reass+0x8a>
    if (IP_ADDRESSES_AND_ID_MATCH(&ipr->iphdr, fraghdr)) {
 804b296:	6962      	ldr	r2, [r4, #20]
 804b298:	68eb      	ldr	r3, [r5, #12]
 804b29a:	429a      	cmp	r2, r3
 804b29c:	d1f9      	bne.n	804b292 <ip4_reass+0x6e>
 804b29e:	69a2      	ldr	r2, [r4, #24]
 804b2a0:	692b      	ldr	r3, [r5, #16]
 804b2a2:	429a      	cmp	r2, r3
 804b2a4:	d1f5      	bne.n	804b292 <ip4_reass+0x6e>
 804b2a6:	89a2      	ldrh	r2, [r4, #12]
 804b2a8:	88ab      	ldrh	r3, [r5, #4]
 804b2aa:	429a      	cmp	r2, r3
 804b2ac:	d1f1      	bne.n	804b292 <ip4_reass+0x6e>
  if (ipr == NULL) {
 804b2ae:	b36c      	cbz	r4, 804b30c <ip4_reass+0xe8>
    if (((lwip_ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) &&
 804b2b0:	88e8      	ldrh	r0, [r5, #6]
 804b2b2:	f7fa f8dd 	bl	8045470 <lwip_htons>
 804b2b6:	f3c0 000c 	ubfx	r0, r0, #0, #13
 804b2ba:	b378      	cbz	r0, 804b31c <ip4_reass+0xf8>
  is_last = (IPH_OFFSET(fraghdr) & PP_NTOHS(IP_MF)) == 0;
 804b2bc:	88ed      	ldrh	r5, [r5, #6]
 804b2be:	f005 0520 	and.w	r5, r5, #32
 804b2c2:	2d00      	cmp	r5, #0
 804b2c4:	bf0c      	ite	eq
 804b2c6:	2201      	moveq	r2, #1
 804b2c8:	2200      	movne	r2, #0
  if (is_last) {
 804b2ca:	d108      	bne.n	804b2de <ip4_reass+0xba>
    u16_t datagram_len = (u16_t)(offset + len);
 804b2cc:	eb07 0309 	add.w	r3, r7, r9
 804b2d0:	b29b      	uxth	r3, r3
    if ((datagram_len < offset) || (datagram_len > (0xFFFF - IP_HLEN))) {
 804b2d2:	429f      	cmp	r7, r3
 804b2d4:	d8d6      	bhi.n	804b284 <ip4_reass+0x60>
 804b2d6:	f64f 71eb 	movw	r1, #65515	; 0xffeb
 804b2da:	428b      	cmp	r3, r1
 804b2dc:	d8d2      	bhi.n	804b284 <ip4_reass+0x60>
  valid = ip_reass_chain_frag_into_datagram_and_validate(ipr, p, is_last);
 804b2de:	4631      	mov	r1, r6
 804b2e0:	4620      	mov	r0, r4
 804b2e2:	f7ff fe8f 	bl	804b004 <ip_reass_chain_frag_into_datagram_and_validate>
  if (valid == IP_REASS_VALIDATE_PBUF_DROPPED) {
 804b2e6:	f1b0 3fff 	cmp.w	r0, #4294967295
 804b2ea:	d0cb      	beq.n	804b284 <ip4_reass+0x60>
  ip_reass_pbufcount = (u16_t)(ip_reass_pbufcount + clen);
 804b2ec:	4b34      	ldr	r3, [pc, #208]	; (804b3c0 <ip4_reass+0x19c>)
 804b2ee:	889a      	ldrh	r2, [r3, #4]
 804b2f0:	4490      	add	r8, r2
 804b2f2:	f8a3 8004 	strh.w	r8, [r3, #4]
  if (is_last) {
 804b2f6:	b92d      	cbnz	r5, 804b304 <ip4_reass+0xe0>
    u16_t datagram_len = (u16_t)(offset + len);
 804b2f8:	444f      	add	r7, r9
    ipr->datagram_len = datagram_len;
 804b2fa:	83a7      	strh	r7, [r4, #28]
    ipr->flags |= IP_REASS_FLAG_LASTFRAG;
 804b2fc:	7fa3      	ldrb	r3, [r4, #30]
 804b2fe:	f043 0301 	orr.w	r3, r3, #1
 804b302:	77a3      	strb	r3, [r4, #30]
  if (valid == IP_REASS_VALIDATE_TELEGRAM_FINISHED) {
 804b304:	2801      	cmp	r0, #1
 804b306:	d01b      	beq.n	804b340 <ip4_reass+0x11c>
  return NULL;
 804b308:	2600      	movs	r6, #0
 804b30a:	e7bf      	b.n	804b28c <ip4_reass+0x68>
    ipr = ip_reass_enqueue_new_datagram(fraghdr, clen);
 804b30c:	4641      	mov	r1, r8
 804b30e:	4628      	mov	r0, r5
 804b310:	f7ff ff40 	bl	804b194 <ip_reass_enqueue_new_datagram>
    if (ipr == NULL) {
 804b314:	4604      	mov	r4, r0
 804b316:	2800      	cmp	r0, #0
 804b318:	d1d0      	bne.n	804b2bc <ip4_reass+0x98>
 804b31a:	e7b3      	b.n	804b284 <ip4_reass+0x60>
      ((lwip_ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
 804b31c:	89e0      	ldrh	r0, [r4, #14]
 804b31e:	f7fa f8a7 	bl	8045470 <lwip_htons>
    if (((lwip_ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) &&
 804b322:	f3c0 000c 	ubfx	r0, r0, #0, #13
 804b326:	2800      	cmp	r0, #0
 804b328:	d0c8      	beq.n	804b2bc <ip4_reass+0x98>
      SMEMCPY(&ipr->iphdr, fraghdr, IP_HLEN);
 804b32a:	682b      	ldr	r3, [r5, #0]
 804b32c:	6868      	ldr	r0, [r5, #4]
 804b32e:	68a9      	ldr	r1, [r5, #8]
 804b330:	68ea      	ldr	r2, [r5, #12]
 804b332:	60a3      	str	r3, [r4, #8]
 804b334:	60e0      	str	r0, [r4, #12]
 804b336:	6121      	str	r1, [r4, #16]
 804b338:	6162      	str	r2, [r4, #20]
 804b33a:	692b      	ldr	r3, [r5, #16]
 804b33c:	61a3      	str	r3, [r4, #24]
 804b33e:	e7bd      	b.n	804b2bc <ip4_reass+0x98>
    ipr->datagram_len += IP_HLEN;
 804b340:	8ba3      	ldrh	r3, [r4, #28]
 804b342:	3314      	adds	r3, #20
 804b344:	83a3      	strh	r3, [r4, #28]
    r = ((struct ip_reass_helper*)ipr->p->payload)->next_pbuf;
 804b346:	6863      	ldr	r3, [r4, #4]
 804b348:	685e      	ldr	r6, [r3, #4]
 804b34a:	6835      	ldr	r5, [r6, #0]
    SMEMCPY(fraghdr, &ipr->iphdr, IP_HLEN);
 804b34c:	4623      	mov	r3, r4
 804b34e:	f853 2f08 	ldr.w	r2, [r3, #8]!
 804b352:	685f      	ldr	r7, [r3, #4]
 804b354:	6898      	ldr	r0, [r3, #8]
 804b356:	68d9      	ldr	r1, [r3, #12]
 804b358:	6032      	str	r2, [r6, #0]
 804b35a:	6077      	str	r7, [r6, #4]
 804b35c:	60b0      	str	r0, [r6, #8]
 804b35e:	60f1      	str	r1, [r6, #12]
 804b360:	691a      	ldr	r2, [r3, #16]
 804b362:	6132      	str	r2, [r6, #16]
    IPH_LEN_SET(fraghdr, lwip_htons(ipr->datagram_len));
 804b364:	8ba0      	ldrh	r0, [r4, #28]
 804b366:	f7fa f883 	bl	8045470 <lwip_htons>
 804b36a:	8070      	strh	r0, [r6, #2]
    IPH_OFFSET_SET(fraghdr, 0);
 804b36c:	2300      	movs	r3, #0
 804b36e:	71b3      	strb	r3, [r6, #6]
 804b370:	71f3      	strb	r3, [r6, #7]
    IPH_CHKSUM_SET(fraghdr, 0);
 804b372:	72b3      	strb	r3, [r6, #10]
 804b374:	72f3      	strb	r3, [r6, #11]
    p = ipr->p;
 804b376:	6866      	ldr	r6, [r4, #4]
    while (r != NULL) {
 804b378:	e00a      	b.n	804b390 <ip4_reass+0x16c>
      iprh = (struct ip_reass_helper*)r->payload;
 804b37a:	686f      	ldr	r7, [r5, #4]
      pbuf_header(r, -IP_HLEN);
 804b37c:	f06f 0113 	mvn.w	r1, #19
 804b380:	4628      	mov	r0, r5
 804b382:	f7fa fca1 	bl	8045cc8 <pbuf_header>
      pbuf_cat(p, r);
 804b386:	4629      	mov	r1, r5
 804b388:	4630      	mov	r0, r6
 804b38a:	f7fa fe93 	bl	80460b4 <pbuf_cat>
      r = iprh->next_pbuf;
 804b38e:	683d      	ldr	r5, [r7, #0]
    while (r != NULL) {
 804b390:	2d00      	cmp	r5, #0
 804b392:	d1f2      	bne.n	804b37a <ip4_reass+0x156>
    if (ipr == reassdatagrams) {
 804b394:	4b0a      	ldr	r3, [pc, #40]	; (804b3c0 <ip4_reass+0x19c>)
 804b396:	6819      	ldr	r1, [r3, #0]
 804b398:	42a1      	cmp	r1, r4
 804b39a:	d005      	beq.n	804b3a8 <ip4_reass+0x184>
      for (ipr_prev = reassdatagrams; ipr_prev != NULL; ipr_prev = ipr_prev->next) {
 804b39c:	b129      	cbz	r1, 804b3aa <ip4_reass+0x186>
        if (ipr_prev->next == ipr) {
 804b39e:	680b      	ldr	r3, [r1, #0]
 804b3a0:	42a3      	cmp	r3, r4
 804b3a2:	d002      	beq.n	804b3aa <ip4_reass+0x186>
      for (ipr_prev = reassdatagrams; ipr_prev != NULL; ipr_prev = ipr_prev->next) {
 804b3a4:	4619      	mov	r1, r3
 804b3a6:	e7f9      	b.n	804b39c <ip4_reass+0x178>
      ipr_prev = NULL;
 804b3a8:	4629      	mov	r1, r5
    ip_reass_dequeue_datagram(ipr, ipr_prev);
 804b3aa:	4620      	mov	r0, r4
 804b3ac:	f7ff fd1c 	bl	804ade8 <ip_reass_dequeue_datagram>
    ip_reass_pbufcount -= pbuf_clen(p);
 804b3b0:	4630      	mov	r0, r6
 804b3b2:	f7fa fe5f 	bl	8046074 <pbuf_clen>
 804b3b6:	4a02      	ldr	r2, [pc, #8]	; (804b3c0 <ip4_reass+0x19c>)
 804b3b8:	8893      	ldrh	r3, [r2, #4]
 804b3ba:	1a1b      	subs	r3, r3, r0
 804b3bc:	8093      	strh	r3, [r2, #4]
    return p;
 804b3be:	e765      	b.n	804b28c <ip4_reass+0x68>
 804b3c0:	20004208 	.word	0x20004208

0804b3c4 <ip4_frag>:
 *
 * @return ERR_OK if sent successfully, err_t otherwise
 */
err_t
ip4_frag(struct pbuf *p, struct netif *netif, const ip4_addr_t *dest)
{
 804b3c4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 804b3c8:	b08d      	sub	sp, #52	; 0x34
 804b3ca:	4606      	mov	r6, r0
 804b3cc:	9107      	str	r1, [sp, #28]
 804b3ce:	920b      	str	r2, [sp, #44]	; 0x2c
  u16_t newpbuflen = 0;
  u16_t left_to_copy;
#endif
  struct ip_hdr *original_iphdr;
  struct ip_hdr *iphdr;
  const u16_t nfb = (netif->mtu - IP_HLEN) / 8;
 804b3d0:	8c4b      	ldrh	r3, [r1, #34]	; 0x22
 804b3d2:	3b14      	subs	r3, #20
 804b3d4:	d451      	bmi.n	804b47a <ip4_frag+0xb6>
 804b3d6:	10da      	asrs	r2, r3, #3
 804b3d8:	9206      	str	r2, [sp, #24]
 804b3da:	f3c3 03cf 	ubfx	r3, r3, #3, #16
 804b3de:	930a      	str	r3, [sp, #40]	; 0x28
  u16_t ofo;
  int last;
  u16_t poff = IP_HLEN;
  u16_t tmp;

  original_iphdr = (struct ip_hdr *)p->payload;
 804b3e0:	f8d6 8004 	ldr.w	r8, [r6, #4]
  iphdr = original_iphdr;
  LWIP_ERROR("ip4_frag() does not support IP options", IPH_HL(iphdr) * 4 == IP_HLEN, return ERR_VAL);
 804b3e4:	f898 3000 	ldrb.w	r3, [r8]
 804b3e8:	f003 030f 	and.w	r3, r3, #15
 804b3ec:	2b05      	cmp	r3, #5
 804b3ee:	d146      	bne.n	804b47e <ip4_frag+0xba>

  /* Save original offset */
  tmp = lwip_ntohs(IPH_OFFSET(iphdr));
 804b3f0:	f8b8 0006 	ldrh.w	r0, [r8, #6]
 804b3f4:	f7fa f83c 	bl	8045470 <lwip_htons>
  ofo = tmp & IP_OFFMASK;
 804b3f8:	f3c0 030c 	ubfx	r3, r0, #0, #13
 804b3fc:	9305      	str	r3, [sp, #20]
  LWIP_ERROR("ip_frag(): MF already set", (tmp & IP_MF) == 0, return ERR_VAL);
 804b3fe:	f410 5300 	ands.w	r3, r0, #8192	; 0x2000
 804b402:	9302      	str	r3, [sp, #8]
 804b404:	d145      	bne.n	804b492 <ip4_frag+0xce>

  left = p->tot_len - IP_HLEN;
 804b406:	f8b6 9008 	ldrh.w	r9, [r6, #8]
 804b40a:	f1a9 0914 	sub.w	r9, r9, #20
 804b40e:	fa1f f389 	uxth.w	r3, r9
 804b412:	9303      	str	r3, [sp, #12]
  u16_t newpbuflen = 0;
 804b414:	9c02      	ldr	r4, [sp, #8]
  u16_t poff = IP_HLEN;
 804b416:	f04f 0a14 	mov.w	sl, #20

  while (left) {
 804b41a:	9b03      	ldr	r3, [sp, #12]
 804b41c:	2b00      	cmp	r3, #0
 804b41e:	f000 80b6 	beq.w	804b58e <ip4_frag+0x1ca>
    /* Fill this fragment */
    fragsize = LWIP_MIN(left, nfb * 8);
 804b422:	f8bd 3018 	ldrh.w	r3, [sp, #24]
 804b426:	00db      	lsls	r3, r3, #3
 804b428:	9a03      	ldr	r2, [sp, #12]
 804b42a:	9208      	str	r2, [sp, #32]
 804b42c:	4293      	cmp	r3, r2
 804b42e:	bfa8      	it	ge
 804b430:	4613      	movge	r3, r2
 804b432:	b29b      	uxth	r3, r3
 804b434:	9304      	str	r3, [sp, #16]
    /* When not using a static buffer, create a chain of pbufs.
     * The first will be a PBUF_RAM holding the link and IP header.
     * The rest will be PBUF_REFs mirroring the pbuf chain to be fragged,
     * but limited to the size of an mtu.
     */
    rambuf = pbuf_alloc(PBUF_LINK, IP_HLEN, PBUF_RAM);
 804b436:	2200      	movs	r2, #0
 804b438:	2114      	movs	r1, #20
 804b43a:	2002      	movs	r0, #2
 804b43c:	f7fa fcb2 	bl	8045da4 <pbuf_alloc>
    if (rambuf == NULL) {
 804b440:	4683      	mov	fp, r0
 804b442:	2800      	cmp	r0, #0
 804b444:	f000 80a5 	beq.w	804b592 <ip4_frag+0x1ce>
      goto memerr;
    }
    LWIP_ASSERT("this needs a pbuf in one piece!",
 804b448:	8973      	ldrh	r3, [r6, #10]
 804b44a:	2b13      	cmp	r3, #19
 804b44c:	d92b      	bls.n	804b4a6 <ip4_frag+0xe2>
                (p->len >= (IP_HLEN)));
    SMEMCPY(rambuf->payload, original_iphdr, IP_HLEN);
 804b44e:	f8db 3004 	ldr.w	r3, [fp, #4]
 804b452:	f8d8 2000 	ldr.w	r2, [r8]
 804b456:	f8d8 5004 	ldr.w	r5, [r8, #4]
 804b45a:	f8d8 0008 	ldr.w	r0, [r8, #8]
 804b45e:	f8d8 100c 	ldr.w	r1, [r8, #12]
 804b462:	601a      	str	r2, [r3, #0]
 804b464:	605d      	str	r5, [r3, #4]
 804b466:	6098      	str	r0, [r3, #8]
 804b468:	60d9      	str	r1, [r3, #12]
 804b46a:	f8d8 2010 	ldr.w	r2, [r8, #16]
 804b46e:	611a      	str	r2, [r3, #16]
    iphdr = (struct ip_hdr *)rambuf->payload;
 804b470:	f8db 3004 	ldr.w	r3, [fp, #4]
 804b474:	9309      	str	r3, [sp, #36]	; 0x24

    left_to_copy = fragsize;
 804b476:	9d04      	ldr	r5, [sp, #16]
    while (left_to_copy) {
 804b478:	e03d      	b.n	804b4f6 <ip4_frag+0x132>
  const u16_t nfb = (netif->mtu - IP_HLEN) / 8;
 804b47a:	3307      	adds	r3, #7
 804b47c:	e7ab      	b.n	804b3d6 <ip4_frag+0x12>
  LWIP_ERROR("ip4_frag() does not support IP options", IPH_HL(iphdr) * 4 == IP_HLEN, return ERR_VAL);
 804b47e:	4b46      	ldr	r3, [pc, #280]	; (804b598 <ip4_frag+0x1d4>)
 804b480:	f240 22e1 	movw	r2, #737	; 0x2e1
 804b484:	4945      	ldr	r1, [pc, #276]	; (804b59c <ip4_frag+0x1d8>)
 804b486:	4846      	ldr	r0, [pc, #280]	; (804b5a0 <ip4_frag+0x1dc>)
 804b488:	f006 fade 	bl	8051a48 <printf>
 804b48c:	f06f 0005 	mvn.w	r0, #5
 804b490:	e043      	b.n	804b51a <ip4_frag+0x156>
  LWIP_ERROR("ip_frag(): MF already set", (tmp & IP_MF) == 0, return ERR_VAL);
 804b492:	4b41      	ldr	r3, [pc, #260]	; (804b598 <ip4_frag+0x1d4>)
 804b494:	f240 22e6 	movw	r2, #742	; 0x2e6
 804b498:	4942      	ldr	r1, [pc, #264]	; (804b5a4 <ip4_frag+0x1e0>)
 804b49a:	4841      	ldr	r0, [pc, #260]	; (804b5a0 <ip4_frag+0x1dc>)
 804b49c:	f006 fad4 	bl	8051a48 <printf>
 804b4a0:	f06f 0005 	mvn.w	r0, #5
 804b4a4:	e039      	b.n	804b51a <ip4_frag+0x156>
    LWIP_ASSERT("this needs a pbuf in one piece!",
 804b4a6:	4b3c      	ldr	r3, [pc, #240]	; (804b598 <ip4_frag+0x1d4>)
 804b4a8:	f44f 7242 	mov.w	r2, #776	; 0x308
 804b4ac:	493e      	ldr	r1, [pc, #248]	; (804b5a8 <ip4_frag+0x1e4>)
 804b4ae:	483c      	ldr	r0, [pc, #240]	; (804b5a0 <ip4_frag+0x1dc>)
 804b4b0:	f006 faca 	bl	8051a48 <printf>
 804b4b4:	e7cb      	b.n	804b44e <ip4_frag+0x8a>
      if (!newpbuflen) {
        poff = 0;
        p = p->next;
        continue;
      }
      pcr = ip_frag_alloc_pbuf_custom_ref();
 804b4b6:	f7ff fe67 	bl	804b188 <ip_frag_alloc_pbuf_custom_ref>
      if (pcr == NULL) {
 804b4ba:	4607      	mov	r7, r0
 804b4bc:	b340      	cbz	r0, 804b510 <ip4_frag+0x14c>
        pbuf_free(rambuf);
        goto memerr;
      }
      /* Mirror this pbuf, although we might not need all of it. */
      newpbuf = pbuf_alloced_custom(PBUF_RAW, newpbuflen, PBUF_REF, &pcr->pc,
        (u8_t*)p->payload + poff, newpbuflen);
 804b4be:	6873      	ldr	r3, [r6, #4]
      newpbuf = pbuf_alloced_custom(PBUF_RAW, newpbuflen, PBUF_REF, &pcr->pc,
 804b4c0:	9401      	str	r4, [sp, #4]
 804b4c2:	4453      	add	r3, sl
 804b4c4:	9300      	str	r3, [sp, #0]
 804b4c6:	4603      	mov	r3, r0
 804b4c8:	2202      	movs	r2, #2
 804b4ca:	4621      	mov	r1, r4
 804b4cc:	2004      	movs	r0, #4
 804b4ce:	f7fa fbbf 	bl	8045c50 <pbuf_alloced_custom>
      if (newpbuf == NULL) {
 804b4d2:	4681      	mov	r9, r0
 804b4d4:	b320      	cbz	r0, 804b520 <ip4_frag+0x15c>
        ip_frag_free_pbuf_custom_ref(pcr);
        pbuf_free(rambuf);
        goto memerr;
      }
      pbuf_ref(p);
 804b4d6:	4630      	mov	r0, r6
 804b4d8:	f7fa fdd4 	bl	8046084 <pbuf_ref>
      pcr->original = p;
 804b4dc:	617e      	str	r6, [r7, #20]
      pcr->pc.custom_free_function = ipfrag_free_pbuf_custom;
 804b4de:	4b33      	ldr	r3, [pc, #204]	; (804b5ac <ip4_frag+0x1e8>)
 804b4e0:	613b      	str	r3, [r7, #16]

      /* Add it to end of rambuf's chain, but using pbuf_cat, not pbuf_chain
       * so that it is removed when pbuf_dechain is later called on rambuf.
       */
      pbuf_cat(rambuf, newpbuf);
 804b4e2:	4649      	mov	r1, r9
 804b4e4:	4658      	mov	r0, fp
 804b4e6:	f7fa fde5 	bl	80460b4 <pbuf_cat>
      left_to_copy -= newpbuflen;
 804b4ea:	1b2d      	subs	r5, r5, r4
 804b4ec:	b2ad      	uxth	r5, r5
      if (left_to_copy) {
 804b4ee:	b115      	cbz	r5, 804b4f6 <ip4_frag+0x132>
        poff = 0;
        p = p->next;
 804b4f0:	6836      	ldr	r6, [r6, #0]
        poff = 0;
 804b4f2:	f8dd a008 	ldr.w	sl, [sp, #8]
    while (left_to_copy) {
 804b4f6:	b1e5      	cbz	r5, 804b532 <ip4_frag+0x16e>
      u16_t plen = p->len - poff;
 804b4f8:	8974      	ldrh	r4, [r6, #10]
 804b4fa:	eba4 040a 	sub.w	r4, r4, sl
 804b4fe:	b2a4      	uxth	r4, r4
      newpbuflen = LWIP_MIN(left_to_copy, plen);
 804b500:	42ac      	cmp	r4, r5
 804b502:	bf28      	it	cs
 804b504:	462c      	movcs	r4, r5
      if (!newpbuflen) {
 804b506:	2c00      	cmp	r4, #0
 804b508:	d1d5      	bne.n	804b4b6 <ip4_frag+0xf2>
        p = p->next;
 804b50a:	6836      	ldr	r6, [r6, #0]
        poff = 0;
 804b50c:	46a2      	mov	sl, r4
        continue;
 804b50e:	e7f2      	b.n	804b4f6 <ip4_frag+0x132>
        pbuf_free(rambuf);
 804b510:	4658      	mov	r0, fp
 804b512:	f7fa fbe3 	bl	8045cdc <pbuf_free>
  }
  MIB2_STATS_INC(mib2.ipfragoks);
  return ERR_OK;
memerr:
  MIB2_STATS_INC(mib2.ipfragfails);
  return ERR_MEM;
 804b516:	f04f 30ff 	mov.w	r0, #4294967295
}
 804b51a:	b00d      	add	sp, #52	; 0x34
 804b51c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        ip_frag_free_pbuf_custom_ref(pcr);
 804b520:	4638      	mov	r0, r7
 804b522:	f7ff fd3f 	bl	804afa4 <ip_frag_free_pbuf_custom_ref>
        pbuf_free(rambuf);
 804b526:	4658      	mov	r0, fp
 804b528:	f7fa fbd8 	bl	8045cdc <pbuf_free>
  return ERR_MEM;
 804b52c:	f04f 30ff 	mov.w	r0, #4294967295
        goto memerr;
 804b530:	e7f3      	b.n	804b51a <ip4_frag+0x156>
    poff += newpbuflen;
 804b532:	44a2      	add	sl, r4
 804b534:	fa1f fa8a 	uxth.w	sl, sl
    last = (left <= netif->mtu - IP_HLEN);
 804b538:	9b07      	ldr	r3, [sp, #28]
 804b53a:	8c5b      	ldrh	r3, [r3, #34]	; 0x22
 804b53c:	3b13      	subs	r3, #19
    tmp = (IP_OFFMASK & (ofo));
 804b53e:	9a05      	ldr	r2, [sp, #20]
 804b540:	f3c2 000c 	ubfx	r0, r2, #0, #13
    if (!last) {
 804b544:	9a08      	ldr	r2, [sp, #32]
 804b546:	429a      	cmp	r2, r3
 804b548:	db01      	blt.n	804b54e <ip4_frag+0x18a>
      tmp = tmp | IP_MF;
 804b54a:	f440 5000 	orr.w	r0, r0, #8192	; 0x2000
    IPH_OFFSET_SET(iphdr, lwip_htons(tmp));
 804b54e:	f7f9 ff8f 	bl	8045470 <lwip_htons>
 804b552:	9d09      	ldr	r5, [sp, #36]	; 0x24
 804b554:	80e8      	strh	r0, [r5, #6]
    IPH_LEN_SET(iphdr, lwip_htons(fragsize + IP_HLEN));
 804b556:	9f04      	ldr	r7, [sp, #16]
 804b558:	f107 0014 	add.w	r0, r7, #20
 804b55c:	b280      	uxth	r0, r0
 804b55e:	f7f9 ff87 	bl	8045470 <lwip_htons>
 804b562:	8068      	strh	r0, [r5, #2]
    IPH_CHKSUM_SET(iphdr, 0);
 804b564:	2300      	movs	r3, #0
 804b566:	72ab      	strb	r3, [r5, #10]
 804b568:	72eb      	strb	r3, [r5, #11]
    netif->output(netif, rambuf, dest);
 804b56a:	9807      	ldr	r0, [sp, #28]
 804b56c:	6943      	ldr	r3, [r0, #20]
 804b56e:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 804b570:	4659      	mov	r1, fp
 804b572:	4798      	blx	r3
    pbuf_free(rambuf);
 804b574:	4658      	mov	r0, fp
 804b576:	f7fa fbb1 	bl	8045cdc <pbuf_free>
    left -= fragsize;
 804b57a:	9b03      	ldr	r3, [sp, #12]
 804b57c:	1bdb      	subs	r3, r3, r7
 804b57e:	b29b      	uxth	r3, r3
 804b580:	9303      	str	r3, [sp, #12]
    ofo += nfb;
 804b582:	9b05      	ldr	r3, [sp, #20]
 804b584:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 804b586:	4413      	add	r3, r2
 804b588:	b29b      	uxth	r3, r3
 804b58a:	9305      	str	r3, [sp, #20]
 804b58c:	e745      	b.n	804b41a <ip4_frag+0x56>
  return ERR_OK;
 804b58e:	2000      	movs	r0, #0
 804b590:	e7c3      	b.n	804b51a <ip4_frag+0x156>
  return ERR_MEM;
 804b592:	f04f 30ff 	mov.w	r0, #4294967295
 804b596:	e7c0      	b.n	804b51a <ip4_frag+0x156>
 804b598:	0805a648 	.word	0x0805a648
 804b59c:	0805a794 	.word	0x0805a794
 804b5a0:	08058ecc 	.word	0x08058ecc
 804b5a4:	0805a7bc 	.word	0x0805a7bc
 804b5a8:	0805a7d8 	.word	0x0805a7d8
 804b5ac:	0804afd1 	.word	0x0804afd1

0804b5b0 <ethernet_input>:
 * @see ETHARP_SUPPORT_VLAN
 * @see LWIP_HOOK_VLAN_CHECK
 */
err_t
ethernet_input(struct pbuf *p, struct netif *netif)
{
 804b5b0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 804b5b2:	4604      	mov	r4, r0
  u16_t type;
#if LWIP_ARP || ETHARP_SUPPORT_VLAN || LWIP_IPV6
  s16_t ip_hdr_offset = SIZEOF_ETH_HDR;
#endif /* LWIP_ARP || ETHARP_SUPPORT_VLAN */

  if (p->len <= SIZEOF_ETH_HDR) {
 804b5b4:	8946      	ldrh	r6, [r0, #10]
 804b5b6:	2e0e      	cmp	r6, #14
 804b5b8:	d916      	bls.n	804b5e8 <ethernet_input+0x38>
 804b5ba:	460d      	mov	r5, r1
    MIB2_STATS_NETIF_INC(netif, ifinerrors);
    goto free_and_return;
  }

  /* points to packet payload, which starts with an Ethernet header */
  ethhdr = (struct eth_hdr *)p->payload;
 804b5bc:	6840      	ldr	r0, [r0, #4]
     (unsigned)ethhdr->dest.addr[3], (unsigned)ethhdr->dest.addr[4], (unsigned)ethhdr->dest.addr[5],
     (unsigned)ethhdr->src.addr[0],  (unsigned)ethhdr->src.addr[1],  (unsigned)ethhdr->src.addr[2],
     (unsigned)ethhdr->src.addr[3],  (unsigned)ethhdr->src.addr[4],  (unsigned)ethhdr->src.addr[5],
     lwip_htons(ethhdr->type)));

  type = ethhdr->type;
 804b5be:	8987      	ldrh	r7, [r0, #12]

#if LWIP_ARP_FILTER_NETIF
  netif = LWIP_ARP_FILTER_NETIF_FN(p, netif, lwip_htons(type));
#endif /* LWIP_ARP_FILTER_NETIF*/

  if (ethhdr->dest.addr[0] & 1) {
 804b5c0:	7803      	ldrb	r3, [r0, #0]
 804b5c2:	f013 0f01 	tst.w	r3, #1
 804b5c6:	d00a      	beq.n	804b5de <ethernet_input+0x2e>
    /* this might be a multicast or broadcast packet */
    if (ethhdr->dest.addr[0] == LL_IP4_MULTICAST_ADDR_0) {
 804b5c8:	2b01      	cmp	r3, #1
 804b5ca:	d012      	beq.n	804b5f2 <ethernet_input+0x42>
             (ethhdr->dest.addr[1] == LL_IP6_MULTICAST_ADDR_1)) {
        /* mark the pbuf as link-layer multicast */
        p->flags |= PBUF_FLAG_LLMCAST;
    }
#endif /* LWIP_IPV6 */
    else if (eth_addr_cmp(&ethhdr->dest, &ethbroadcast)) {
 804b5cc:	2206      	movs	r2, #6
 804b5ce:	4921      	ldr	r1, [pc, #132]	; (804b654 <ethernet_input+0xa4>)
 804b5d0:	f006 fa0a 	bl	80519e8 <memcmp>
 804b5d4:	b918      	cbnz	r0, 804b5de <ethernet_input+0x2e>
      /* mark the pbuf as link-layer broadcast */
      p->flags |= PBUF_FLAG_LLBCAST;
 804b5d6:	7b63      	ldrb	r3, [r4, #13]
 804b5d8:	f043 0308 	orr.w	r3, r3, #8
 804b5dc:	7363      	strb	r3, [r4, #13]
    }
  }

  switch (type) {
 804b5de:	2f08      	cmp	r7, #8
 804b5e0:	d012      	beq.n	804b608 <ethernet_input+0x58>
 804b5e2:	f5b7 6fc1 	cmp.w	r7, #1544	; 0x608
 804b5e6:	d022      	beq.n	804b62e <ethernet_input+0x7e>
  /* This means the pbuf is freed or consumed,
     so the caller doesn't have to free it again */
  return ERR_OK;

free_and_return:
  pbuf_free(p);
 804b5e8:	4620      	mov	r0, r4
 804b5ea:	f7fa fb77 	bl	8045cdc <pbuf_free>
  return ERR_OK;
}
 804b5ee:	2000      	movs	r0, #0
 804b5f0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      if ((ethhdr->dest.addr[1] == LL_IP4_MULTICAST_ADDR_1) &&
 804b5f2:	7843      	ldrb	r3, [r0, #1]
 804b5f4:	2b00      	cmp	r3, #0
 804b5f6:	d1f2      	bne.n	804b5de <ethernet_input+0x2e>
          (ethhdr->dest.addr[2] == LL_IP4_MULTICAST_ADDR_2)) {
 804b5f8:	7883      	ldrb	r3, [r0, #2]
      if ((ethhdr->dest.addr[1] == LL_IP4_MULTICAST_ADDR_1) &&
 804b5fa:	2b5e      	cmp	r3, #94	; 0x5e
 804b5fc:	d1ef      	bne.n	804b5de <ethernet_input+0x2e>
        p->flags |= PBUF_FLAG_LLMCAST;
 804b5fe:	7b63      	ldrb	r3, [r4, #13]
 804b600:	f043 0310 	orr.w	r3, r3, #16
 804b604:	7363      	strb	r3, [r4, #13]
 804b606:	e7ea      	b.n	804b5de <ethernet_input+0x2e>
      if (!(netif->flags & NETIF_FLAG_ETHARP)) {
 804b608:	f895 302b 	ldrb.w	r3, [r5, #43]	; 0x2b
 804b60c:	f013 0f08 	tst.w	r3, #8
 804b610:	d0ea      	beq.n	804b5e8 <ethernet_input+0x38>
      if ((p->len < ip_hdr_offset) || pbuf_header(p, (s16_t)-ip_hdr_offset)) {
 804b612:	2e0d      	cmp	r6, #13
 804b614:	d9e8      	bls.n	804b5e8 <ethernet_input+0x38>
 804b616:	f06f 010d 	mvn.w	r1, #13
 804b61a:	4620      	mov	r0, r4
 804b61c:	f7fa fb54 	bl	8045cc8 <pbuf_header>
 804b620:	2800      	cmp	r0, #0
 804b622:	d1e1      	bne.n	804b5e8 <ethernet_input+0x38>
        ip4_input(p, netif);
 804b624:	4629      	mov	r1, r5
 804b626:	4620      	mov	r0, r4
 804b628:	f7ff f992 	bl	804a950 <ip4_input>
      break;
 804b62c:	e7df      	b.n	804b5ee <ethernet_input+0x3e>
      if (!(netif->flags & NETIF_FLAG_ETHARP)) {
 804b62e:	f895 302b 	ldrb.w	r3, [r5, #43]	; 0x2b
 804b632:	f013 0f08 	tst.w	r3, #8
 804b636:	d0d7      	beq.n	804b5e8 <ethernet_input+0x38>
      if ((p->len < ip_hdr_offset) || pbuf_header(p, (s16_t)-ip_hdr_offset)) {
 804b638:	2e0d      	cmp	r6, #13
 804b63a:	d9d5      	bls.n	804b5e8 <ethernet_input+0x38>
 804b63c:	f06f 010d 	mvn.w	r1, #13
 804b640:	4620      	mov	r0, r4
 804b642:	f7fa fb41 	bl	8045cc8 <pbuf_header>
 804b646:	2800      	cmp	r0, #0
 804b648:	d1ce      	bne.n	804b5e8 <ethernet_input+0x38>
        etharp_input(p, netif);
 804b64a:	4629      	mov	r1, r5
 804b64c:	4620      	mov	r0, r4
 804b64e:	f7fe fda9 	bl	804a1a4 <etharp_input>
      break;
 804b652:	e7cc      	b.n	804b5ee <ethernet_input+0x3e>
 804b654:	08058e5c 	.word	0x08058e5c

0804b658 <ethernet_output>:
 */
err_t
ethernet_output(struct netif* netif, struct pbuf* p,
                const struct eth_addr* src, const struct eth_addr* dst,
                u16_t eth_type)
{
 804b658:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 804b65c:	4605      	mov	r5, r0
 804b65e:	460c      	mov	r4, r1
 804b660:	4616      	mov	r6, r2
 804b662:	461f      	mov	r7, r3
  struct eth_hdr* ethhdr;
  u16_t eth_type_be = lwip_htons(eth_type);
 804b664:	f8bd 0018 	ldrh.w	r0, [sp, #24]
 804b668:	f7f9 ff02 	bl	8045470 <lwip_htons>
 804b66c:	4680      	mov	r8, r0

    eth_type_be = PP_HTONS(ETHTYPE_VLAN);
  } else
#endif /* ETHARP_SUPPORT_VLAN && defined(LWIP_HOOK_VLAN_SET) */
  {
    if (pbuf_header(p, SIZEOF_ETH_HDR) != 0) {
 804b66e:	210e      	movs	r1, #14
 804b670:	4620      	mov	r0, r4
 804b672:	f7fa fb29 	bl	8045cc8 <pbuf_header>
 804b676:	b9e8      	cbnz	r0, 804b6b4 <ethernet_output+0x5c>
      goto pbuf_header_failed;
    }
  }

  ethhdr = (struct eth_hdr*)p->payload;
 804b678:	6861      	ldr	r1, [r4, #4]
  ethhdr->type = eth_type_be;
 804b67a:	f8a1 800c 	strh.w	r8, [r1, #12]
  ETHADDR32_COPY(&ethhdr->dest, dst);
 804b67e:	683b      	ldr	r3, [r7, #0]
 804b680:	600b      	str	r3, [r1, #0]
 804b682:	88bb      	ldrh	r3, [r7, #4]
 804b684:	808b      	strh	r3, [r1, #4]
  ETHADDR16_COPY(&ethhdr->src,  src);
 804b686:	6833      	ldr	r3, [r6, #0]
 804b688:	f8c1 3006 	str.w	r3, [r1, #6]
 804b68c:	88b3      	ldrh	r3, [r6, #4]
 804b68e:	814b      	strh	r3, [r1, #10]

  LWIP_ASSERT("netif->hwaddr_len must be 6 for ethernet_output!",
 804b690:	f895 3024 	ldrb.w	r3, [r5, #36]	; 0x24
 804b694:	2b06      	cmp	r3, #6
 804b696:	d105      	bne.n	804b6a4 <ethernet_output+0x4c>
    (netif->hwaddr_len == ETH_HWADDR_LEN));
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE,
    ("ethernet_output: sending packet %p\n", (void *)p));

  /* send the packet */
  return netif->linkoutput(netif, p);
 804b698:	69ab      	ldr	r3, [r5, #24]
 804b69a:	4621      	mov	r1, r4
 804b69c:	4628      	mov	r0, r5
 804b69e:	4798      	blx	r3
pbuf_header_failed:
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
    ("ethernet_output: could not allocate room for header.\n"));
  LINK_STATS_INC(link.lenerr);
  return ERR_BUF;
}
 804b6a0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  LWIP_ASSERT("netif->hwaddr_len must be 6 for ethernet_output!",
 804b6a4:	4b05      	ldr	r3, [pc, #20]	; (804b6bc <ethernet_output+0x64>)
 804b6a6:	f240 122b 	movw	r2, #299	; 0x12b
 804b6aa:	4905      	ldr	r1, [pc, #20]	; (804b6c0 <ethernet_output+0x68>)
 804b6ac:	4805      	ldr	r0, [pc, #20]	; (804b6c4 <ethernet_output+0x6c>)
 804b6ae:	f006 f9cb 	bl	8051a48 <printf>
 804b6b2:	e7f1      	b.n	804b698 <ethernet_output+0x40>
  return ERR_BUF;
 804b6b4:	f06f 0001 	mvn.w	r0, #1
 804b6b8:	e7f2      	b.n	804b6a0 <ethernet_output+0x48>
 804b6ba:	bf00      	nop
 804b6bc:	0805a7f8 	.word	0x0805a7f8
 804b6c0:	0805a830 	.word	0x0805a830
 804b6c4:	08058ecc 	.word	0x08058ecc

0804b6c8 <MX_ADC1_Init>:
ADC_HandleTypeDef hadc1;
DMA_HandleTypeDef hdma_adc1;

/* ADC1 init function */
void MX_ADC1_Init(void)
{
 804b6c8:	b500      	push	{lr}
 804b6ca:	b085      	sub	sp, #20
  ADC_ChannelConfTypeDef sConfig = {0};
 804b6cc:	2300      	movs	r3, #0
 804b6ce:	9300      	str	r3, [sp, #0]
 804b6d0:	9301      	str	r3, [sp, #4]
 804b6d2:	9302      	str	r3, [sp, #8]
 804b6d4:	9303      	str	r3, [sp, #12]

  /** Configure the global features of the ADC (Clock, Resolution, Data Alignment and number of conversion)
  */
  hadc1.Instance = ADC1;
 804b6d6:	481c      	ldr	r0, [pc, #112]	; (804b748 <MX_ADC1_Init+0x80>)
 804b6d8:	4a1c      	ldr	r2, [pc, #112]	; (804b74c <MX_ADC1_Init+0x84>)
 804b6da:	6002      	str	r2, [r0, #0]
  hadc1.Init.ClockPrescaler = ADC_CLOCK_SYNC_PCLK_DIV8;
 804b6dc:	f44f 3240 	mov.w	r2, #196608	; 0x30000
 804b6e0:	6042      	str	r2, [r0, #4]
  hadc1.Init.Resolution = ADC_RESOLUTION_12B;
 804b6e2:	6083      	str	r3, [r0, #8]
  hadc1.Init.ScanConvMode = ENABLE;
 804b6e4:	2201      	movs	r2, #1
 804b6e6:	6102      	str	r2, [r0, #16]
  hadc1.Init.ContinuousConvMode = ENABLE;
 804b6e8:	7602      	strb	r2, [r0, #24]
  hadc1.Init.DiscontinuousConvMode = DISABLE;
 804b6ea:	f880 3020 	strb.w	r3, [r0, #32]
  hadc1.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
 804b6ee:	62c3      	str	r3, [r0, #44]	; 0x2c
  hadc1.Init.ExternalTrigConv = ADC_SOFTWARE_START;
 804b6f0:	4917      	ldr	r1, [pc, #92]	; (804b750 <MX_ADC1_Init+0x88>)
 804b6f2:	6281      	str	r1, [r0, #40]	; 0x28
  hadc1.Init.DataAlign = ADC_DATAALIGN_RIGHT;
 804b6f4:	60c3      	str	r3, [r0, #12]
  hadc1.Init.NbrOfConversion = 2;
 804b6f6:	2102      	movs	r1, #2
 804b6f8:	61c1      	str	r1, [r0, #28]
  hadc1.Init.DMAContinuousRequests = ENABLE;
 804b6fa:	f880 2030 	strb.w	r2, [r0, #48]	; 0x30
  hadc1.Init.EOCSelection = ADC_EOC_SEQ_CONV;
 804b6fe:	6143      	str	r3, [r0, #20]
  if (HAL_ADC_Init(&hadc1) != HAL_OK)
 804b700:	f7f5 fd92 	bl	8041228 <HAL_ADC_Init>
 804b704:	b9b0      	cbnz	r0, 804b734 <MX_ADC1_Init+0x6c>
  {
    Error_Handler();
  }
  /** Configure for the selected ADC regular channel its corresponding rank in the sequencer and its sample time.
  */
  sConfig.Channel = ADC_CHANNEL_VBAT;
 804b706:	2312      	movs	r3, #18
 804b708:	9300      	str	r3, [sp, #0]
  sConfig.Rank = 1;
 804b70a:	2301      	movs	r3, #1
 804b70c:	9301      	str	r3, [sp, #4]
  sConfig.SamplingTime = ADC_SAMPLETIME_480CYCLES;
 804b70e:	2307      	movs	r3, #7
 804b710:	9302      	str	r3, [sp, #8]
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
 804b712:	4669      	mov	r1, sp
 804b714:	480c      	ldr	r0, [pc, #48]	; (804b748 <MX_ADC1_Init+0x80>)
 804b716:	f7f6 f805 	bl	8041724 <HAL_ADC_ConfigChannel>
 804b71a:	b970      	cbnz	r0, 804b73a <MX_ADC1_Init+0x72>
  {
    Error_Handler();
  }
  /** Configure for the selected ADC regular channel its corresponding rank in the sequencer and its sample time.
  */
  sConfig.Channel = ADC_CHANNEL_3;
 804b71c:	2303      	movs	r3, #3
 804b71e:	9300      	str	r3, [sp, #0]
  sConfig.Rank = 2;
 804b720:	2302      	movs	r3, #2
 804b722:	9301      	str	r3, [sp, #4]
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
 804b724:	4669      	mov	r1, sp
 804b726:	4808      	ldr	r0, [pc, #32]	; (804b748 <MX_ADC1_Init+0x80>)
 804b728:	f7f5 fffc 	bl	8041724 <HAL_ADC_ConfigChannel>
 804b72c:	b940      	cbnz	r0, 804b740 <MX_ADC1_Init+0x78>
  {
    Error_Handler();
  }

}
 804b72e:	b005      	add	sp, #20
 804b730:	f85d fb04 	ldr.w	pc, [sp], #4
    Error_Handler();
 804b734:	f002 f892 	bl	804d85c <Error_Handler>
 804b738:	e7e5      	b.n	804b706 <MX_ADC1_Init+0x3e>
    Error_Handler();
 804b73a:	f002 f88f 	bl	804d85c <Error_Handler>
 804b73e:	e7ed      	b.n	804b71c <MX_ADC1_Init+0x54>
    Error_Handler();
 804b740:	f002 f88c 	bl	804d85c <Error_Handler>
}
 804b744:	e7f3      	b.n	804b72e <MX_ADC1_Init+0x66>
 804b746:	bf00      	nop
 804b748:	2000873c 	.word	0x2000873c
 804b74c:	40012000 	.word	0x40012000
 804b750:	0f000001 	.word	0x0f000001

0804b754 <HAL_ADC_MspInit>:

void HAL_ADC_MspInit(ADC_HandleTypeDef* adcHandle)
{
 804b754:	b530      	push	{r4, r5, lr}
 804b756:	b089      	sub	sp, #36	; 0x24

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 804b758:	2300      	movs	r3, #0
 804b75a:	9303      	str	r3, [sp, #12]
 804b75c:	9304      	str	r3, [sp, #16]
 804b75e:	9305      	str	r3, [sp, #20]
 804b760:	9306      	str	r3, [sp, #24]
 804b762:	9307      	str	r3, [sp, #28]
  if(adcHandle->Instance==ADC1)
 804b764:	6802      	ldr	r2, [r0, #0]
 804b766:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 804b76a:	f503 3390 	add.w	r3, r3, #73728	; 0x12000
 804b76e:	429a      	cmp	r2, r3
 804b770:	d001      	beq.n	804b776 <HAL_ADC_MspInit+0x22>
    HAL_NVIC_EnableIRQ(ADC_IRQn);
  /* USER CODE BEGIN ADC1_MspInit 1 */

  /* USER CODE END ADC1_MspInit 1 */
  }
}
 804b772:	b009      	add	sp, #36	; 0x24
 804b774:	bd30      	pop	{r4, r5, pc}
 804b776:	4604      	mov	r4, r0
    __HAL_RCC_ADC1_CLK_ENABLE();
 804b778:	2500      	movs	r5, #0
 804b77a:	9501      	str	r5, [sp, #4]
 804b77c:	f503 338c 	add.w	r3, r3, #71680	; 0x11800
 804b780:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 804b782:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 804b786:	645a      	str	r2, [r3, #68]	; 0x44
 804b788:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 804b78a:	f402 7280 	and.w	r2, r2, #256	; 0x100
 804b78e:	9201      	str	r2, [sp, #4]
 804b790:	9a01      	ldr	r2, [sp, #4]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 804b792:	9502      	str	r5, [sp, #8]
 804b794:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 804b796:	f042 0201 	orr.w	r2, r2, #1
 804b79a:	631a      	str	r2, [r3, #48]	; 0x30
 804b79c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 804b79e:	f003 0301 	and.w	r3, r3, #1
 804b7a2:	9302      	str	r3, [sp, #8]
 804b7a4:	9b02      	ldr	r3, [sp, #8]
    GPIO_InitStruct.Pin = VinSys_Pin;
 804b7a6:	2308      	movs	r3, #8
 804b7a8:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 804b7aa:	2303      	movs	r3, #3
 804b7ac:	9304      	str	r3, [sp, #16]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 804b7ae:	9505      	str	r5, [sp, #20]
    HAL_GPIO_Init(VinSys_GPIO_Port, &GPIO_InitStruct);
 804b7b0:	a903      	add	r1, sp, #12
 804b7b2:	4814      	ldr	r0, [pc, #80]	; (804b804 <HAL_ADC_MspInit+0xb0>)
 804b7b4:	f7f7 f9c2 	bl	8042b3c <HAL_GPIO_Init>
    hdma_adc1.Instance = DMA2_Stream4;
 804b7b8:	4813      	ldr	r0, [pc, #76]	; (804b808 <HAL_ADC_MspInit+0xb4>)
 804b7ba:	4b14      	ldr	r3, [pc, #80]	; (804b80c <HAL_ADC_MspInit+0xb8>)
 804b7bc:	6003      	str	r3, [r0, #0]
    hdma_adc1.Init.Channel = DMA_CHANNEL_0;
 804b7be:	6045      	str	r5, [r0, #4]
    hdma_adc1.Init.Direction = DMA_PERIPH_TO_MEMORY;
 804b7c0:	6085      	str	r5, [r0, #8]
    hdma_adc1.Init.PeriphInc = DMA_PINC_DISABLE;
 804b7c2:	60c5      	str	r5, [r0, #12]
    hdma_adc1.Init.MemInc = DMA_MINC_ENABLE;
 804b7c4:	f44f 6380 	mov.w	r3, #1024	; 0x400
 804b7c8:	6103      	str	r3, [r0, #16]
    hdma_adc1.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
 804b7ca:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 804b7ce:	6143      	str	r3, [r0, #20]
    hdma_adc1.Init.MemDataAlignment = DMA_MDATAALIGN_WORD;
 804b7d0:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 804b7d4:	6183      	str	r3, [r0, #24]
    hdma_adc1.Init.Mode = DMA_CIRCULAR;
 804b7d6:	f44f 7380 	mov.w	r3, #256	; 0x100
 804b7da:	61c3      	str	r3, [r0, #28]
    hdma_adc1.Init.Priority = DMA_PRIORITY_LOW;
 804b7dc:	6205      	str	r5, [r0, #32]
    hdma_adc1.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
 804b7de:	6245      	str	r5, [r0, #36]	; 0x24
    if (HAL_DMA_Init(&hdma_adc1) != HAL_OK)
 804b7e0:	f7f6 f970 	bl	8041ac4 <HAL_DMA_Init>
 804b7e4:	b958      	cbnz	r0, 804b7fe <HAL_ADC_MspInit+0xaa>
    __HAL_LINKDMA(adcHandle,DMA_Handle,hdma_adc1);
 804b7e6:	4b08      	ldr	r3, [pc, #32]	; (804b808 <HAL_ADC_MspInit+0xb4>)
 804b7e8:	63a3      	str	r3, [r4, #56]	; 0x38
 804b7ea:	639c      	str	r4, [r3, #56]	; 0x38
    HAL_NVIC_SetPriority(ADC_IRQn, 7, 0);
 804b7ec:	2200      	movs	r2, #0
 804b7ee:	2107      	movs	r1, #7
 804b7f0:	2012      	movs	r0, #18
 804b7f2:	f7f6 f87d 	bl	80418f0 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(ADC_IRQn);
 804b7f6:	2012      	movs	r0, #18
 804b7f8:	f7f6 f8ae 	bl	8041958 <HAL_NVIC_EnableIRQ>
}
 804b7fc:	e7b9      	b.n	804b772 <HAL_ADC_MspInit+0x1e>
      Error_Handler();
 804b7fe:	f002 f82d 	bl	804d85c <Error_Handler>
 804b802:	e7f0      	b.n	804b7e6 <HAL_ADC_MspInit+0x92>
 804b804:	40020000 	.word	0x40020000
 804b808:	20008784 	.word	0x20008784
 804b80c:	40026470 	.word	0x40026470

0804b810 <updateDeviceSignature>:
* </table><br><br>
* <hr>
*
*******************************************************************************/
void updateDeviceSignature(void)
{
 804b810:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}

	uint32_t u32UUID0 = 0;
	uint32_t u32UUID1 = 0;
	uint32_t u32UUID2 = 0;

	u32UUID0 = STM32_UUID[0];
 804b814:	f8df 809c 	ldr.w	r8, [pc, #156]	; 804b8b4 <updateDeviceSignature+0xa4>
 804b818:	f8d8 4000 	ldr.w	r4, [r8]
	u32UUID1 = STM32_UUID[1];
 804b81c:	4f1e      	ldr	r7, [pc, #120]	; (804b898 <updateDeviceSignature+0x88>)
 804b81e:	683d      	ldr	r5, [r7, #0]
	u32UUID2 = STM32_UUID[2];
 804b820:	4e1e      	ldr	r6, [pc, #120]	; (804b89c <updateDeviceSignature+0x8c>)
 804b822:	6830      	ldr	r0, [r6, #0]

	/* Variable for production */
	gu32DeviceId = STM32_UUID[0];
 804b824:	4b1e      	ldr	r3, [pc, #120]	; (804b8a0 <updateDeviceSignature+0x90>)
 804b826:	601c      	str	r4, [r3, #0]
	/*Integer to ASCII UUID 2 */
	itoa(u32UUID2,buffuuid2,10);
 804b828:	f8df b08c 	ldr.w	fp, [pc, #140]	; 804b8b8 <updateDeviceSignature+0xa8>
 804b82c:	220a      	movs	r2, #10
 804b82e:	4659      	mov	r1, fp
 804b830:	f005 fe86 	bl	8051540 <itoa>
	/*Integer to ASCII UUID 1 */
	itoa(u32UUID1,buffuuid1,10);
 804b834:	f8df a084 	ldr.w	sl, [pc, #132]	; 804b8bc <updateDeviceSignature+0xac>
 804b838:	220a      	movs	r2, #10
 804b83a:	4651      	mov	r1, sl
 804b83c:	4628      	mov	r0, r5
 804b83e:	f005 fe7f 	bl	8051540 <itoa>
	/*Integer to ASCII UUID 0 */
	itoa(u32UUID0,buffuuid0,10);
 804b842:	f8df 907c 	ldr.w	r9, [pc, #124]	; 804b8c0 <updateDeviceSignature+0xb0>
 804b846:	220a      	movs	r2, #10
 804b848:	4649      	mov	r1, r9
 804b84a:	4620      	mov	r0, r4
 804b84c:	f005 fe78 	bl	8051540 <itoa>

	/*Integer to ASCII Flash Size */
#if (USEFLASHSIZEINDEVINFO == TRUE)
	itoa(deviceSign.u32FlashSize,buffflash,10);
 804b850:	4c14      	ldr	r4, [pc, #80]	; (804b8a4 <updateDeviceSignature+0x94>)
 804b852:	220a      	movs	r2, #10
 804b854:	4914      	ldr	r1, [pc, #80]	; (804b8a8 <updateDeviceSignature+0x98>)
 804b856:	89a0      	ldrh	r0, [r4, #12]
 804b858:	f005 fe72 	bl	8051540 <itoa>
#endif

	/* Append Device Info to Array */
	strcat(dinfo,buffuuid2);
 804b85c:	4d13      	ldr	r5, [pc, #76]	; (804b8ac <updateDeviceSignature+0x9c>)
 804b85e:	4659      	mov	r1, fp
 804b860:	4628      	mov	r0, r5
 804b862:	f006 f933 	bl	8051acc <strcat>
	strcat(dinfo,buffuuid1);
 804b866:	4651      	mov	r1, sl
 804b868:	4628      	mov	r0, r5
 804b86a:	f006 f92f 	bl	8051acc <strcat>
	strcat(dinfo,buffuuid0);
 804b86e:	4649      	mov	r1, r9
 804b870:	4628      	mov	r0, r5
 804b872:	f006 f92b 	bl	8051acc <strcat>

#if (USEFLASHSIZEINDEVINFO == TRUE)
	strcat(dinfo,buffflash);
 804b876:	490c      	ldr	r1, [pc, #48]	; (804b8a8 <updateDeviceSignature+0x98>)
 804b878:	4628      	mov	r0, r5
 804b87a:	f006 f927 	bl	8051acc <strcat>
#endif
	/* Update Structure */
	/* 96 Bit UUID */
	deviceSign.u32UUID0 = STM32_UUID[0];
 804b87e:	f8d8 3000 	ldr.w	r3, [r8]
 804b882:	6023      	str	r3, [r4, #0]
	deviceSign.u32UUID1 = STM32_UUID[1];
 804b884:	683b      	ldr	r3, [r7, #0]
 804b886:	6063      	str	r3, [r4, #4]
	deviceSign.u32UUID2 = STM32_UUID[2];
 804b888:	6833      	ldr	r3, [r6, #0]
 804b88a:	60a3      	str	r3, [r4, #8]
	/* 16 Bit Flash Size */
	deviceSign.u32FlashSize = STM32_FLASHSIZE;
 804b88c:	4b08      	ldr	r3, [pc, #32]	; (804b8b0 <updateDeviceSignature+0xa0>)
 804b88e:	881b      	ldrh	r3, [r3, #0]
 804b890:	81a3      	strh	r3, [r4, #12]
}
 804b892:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 804b896:	bf00      	nop
 804b898:	1fff7a14 	.word	0x1fff7a14
 804b89c:	1fff7a18 	.word	0x1fff7a18
 804b8a0:	20004210 	.word	0x20004210
 804b8a4:	200088c8 	.word	0x200088c8
 804b8a8:	20008848 	.word	0x20008848
 804b8ac:	200087e4 	.word	0x200087e4
 804b8b0:	1fff7a22 	.word	0x1fff7a22
 804b8b4:	1fff7a10 	.word	0x1fff7a10
 804b8b8:	200088a8 	.word	0x200088a8
 804b8bc:	20008868 	.word	0x20008868
 804b8c0:	20008888 	.word	0x20008888

0804b8c4 <MX_DMA_Init>:

/**
  * Enable DMA controller clock
  */
void MX_DMA_Init(void)
{
 804b8c4:	b500      	push	{lr}
 804b8c6:	b083      	sub	sp, #12
  /* DMA controller clock enable */
  __HAL_RCC_DMA2_CLK_ENABLE();
 804b8c8:	2100      	movs	r1, #0
 804b8ca:	9101      	str	r1, [sp, #4]
 804b8cc:	4b09      	ldr	r3, [pc, #36]	; (804b8f4 <MX_DMA_Init+0x30>)
 804b8ce:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 804b8d0:	f442 0280 	orr.w	r2, r2, #4194304	; 0x400000
 804b8d4:	631a      	str	r2, [r3, #48]	; 0x30
 804b8d6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 804b8d8:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 804b8dc:	9301      	str	r3, [sp, #4]
 804b8de:	9b01      	ldr	r3, [sp, #4]

  /* DMA interrupt init */
  /* DMA2_Stream4_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA2_Stream4_IRQn, 0, 0);
 804b8e0:	460a      	mov	r2, r1
 804b8e2:	203c      	movs	r0, #60	; 0x3c
 804b8e4:	f7f6 f804 	bl	80418f0 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA2_Stream4_IRQn);
 804b8e8:	203c      	movs	r0, #60	; 0x3c
 804b8ea:	f7f6 f835 	bl	8041958 <HAL_NVIC_EnableIRQ>

}
 804b8ee:	b003      	add	sp, #12
 804b8f0:	f85d fb04 	ldr.w	pc, [sp], #4
 804b8f4:	40023800 	.word	0x40023800

0804b8f8 <assertError>:
			/* Unwanted / Undefined Error Occured
			 * System Will Halt Completely */
			//while(1);
			break;
	}
}
 804b8f8:	4770      	bx	lr
	...

0804b8fc <low_level_input>:
 * @param netif the lwip network interface structure for this ethernetif
 * @return a pbuf filled with the received packet (including MAC header)
 *         NULL on memory error
   */
static struct pbuf * low_level_input(struct netif *netif)
{
 804b8fc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  uint32_t payloadoffset = 0;
  uint32_t byteslefttocopy = 0;
  uint32_t i=0;

  /* get received frame */
  if (HAL_ETH_GetReceivedFrame(&heth) != HAL_OK)
 804b900:	4833      	ldr	r0, [pc, #204]	; (804b9d0 <low_level_input+0xd4>)
 804b902:	f7f6 fc93 	bl	804222c <HAL_ETH_GetReceivedFrame>
 804b906:	2800      	cmp	r0, #0
 804b908:	d15e      	bne.n	804b9c8 <low_level_input+0xcc>
    return NULL;

  /* Obtain the size of the packet and put it into the "len" variable. */
  len = heth.RxFrameInfos.length;
 804b90a:	4b31      	ldr	r3, [pc, #196]	; (804b9d0 <low_level_input+0xd4>)
 804b90c:	8f99      	ldrh	r1, [r3, #60]	; 0x3c
  buffer = (uint8_t *)heth.RxFrameInfos.buffer;
 804b90e:	f8d3 8040 	ldr.w	r8, [r3, #64]	; 0x40

  if (len > 0)
 804b912:	b979      	cbnz	r1, 804b934 <low_level_input+0x38>
  struct pbuf *p = NULL;
 804b914:	f04f 0a00 	mov.w	sl, #0
    }
  }

    /* Release descriptors to DMA */
    /* Point to first descriptor */
    dmarxdesc = heth.RxFrameInfos.FSRxDesc;
 804b918:	4b2d      	ldr	r3, [pc, #180]	; (804b9d0 <low_level_input+0xd4>)
 804b91a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    /* Set Own bit in Rx descriptors: gives the buffers back to DMA */
    for (i=0; i< heth.RxFrameInfos.SegCount; i++)
 804b91c:	2100      	movs	r1, #0
 804b91e:	4a2c      	ldr	r2, [pc, #176]	; (804b9d0 <low_level_input+0xd4>)
 804b920:	6b92      	ldr	r2, [r2, #56]	; 0x38
 804b922:	428a      	cmp	r2, r1
 804b924:	d93b      	bls.n	804b99e <low_level_input+0xa2>
    {
      dmarxdesc->Status |= ETH_DMARXDESC_OWN;
 804b926:	681a      	ldr	r2, [r3, #0]
 804b928:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
 804b92c:	601a      	str	r2, [r3, #0]
      dmarxdesc = (ETH_DMADescTypeDef *)(dmarxdesc->Buffer2NextDescAddr);
 804b92e:	68db      	ldr	r3, [r3, #12]
    for (i=0; i< heth.RxFrameInfos.SegCount; i++)
 804b930:	3101      	adds	r1, #1
 804b932:	e7f4      	b.n	804b91e <low_level_input+0x22>
    p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
 804b934:	2203      	movs	r2, #3
 804b936:	2004      	movs	r0, #4
 804b938:	f7fa fa34 	bl	8045da4 <pbuf_alloc>
  if (p != NULL)
 804b93c:	4682      	mov	sl, r0
 804b93e:	2800      	cmp	r0, #0
 804b940:	d0ea      	beq.n	804b918 <low_level_input+0x1c>
    dmarxdesc = heth.RxFrameInfos.FSRxDesc;
 804b942:	4b23      	ldr	r3, [pc, #140]	; (804b9d0 <low_level_input+0xd4>)
 804b944:	6b1f      	ldr	r7, [r3, #48]	; 0x30
    p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
 804b946:	4681      	mov	r9, r0
    bufferoffset = 0;
 804b948:	2400      	movs	r4, #0
    for(q = p; q != NULL; q = q->next)
 804b94a:	e021      	b.n	804b990 <low_level_input+0x94>
        memcpy( (uint8_t*)((uint8_t*)q->payload + payloadoffset), (uint8_t*)((uint8_t*)buffer + bufferoffset), (ETH_RX_BUF_SIZE - bufferoffset));
 804b94c:	f8d9 0004 	ldr.w	r0, [r9, #4]
 804b950:	f5c4 62be 	rsb	r2, r4, #1520	; 0x5f0
 804b954:	3204      	adds	r2, #4
 804b956:	eb08 0104 	add.w	r1, r8, r4
 804b95a:	4430      	add	r0, r6
 804b95c:	f006 f852 	bl	8051a04 <memcpy>
        dmarxdesc = (ETH_DMADescTypeDef *)(dmarxdesc->Buffer2NextDescAddr);
 804b960:	68ff      	ldr	r7, [r7, #12]
        buffer = (uint8_t *)(dmarxdesc->Buffer1Addr);
 804b962:	f8d7 8008 	ldr.w	r8, [r7, #8]
        byteslefttocopy = byteslefttocopy - (ETH_RX_BUF_SIZE - bufferoffset);
 804b966:	f2a5 52f4 	subw	r2, r5, #1524	; 0x5f4
        payloadoffset = payloadoffset + (ETH_RX_BUF_SIZE - bufferoffset);
 804b96a:	1b36      	subs	r6, r6, r4
 804b96c:	f206 56f4 	addw	r6, r6, #1524	; 0x5f4
        bufferoffset = 0;
 804b970:	2400      	movs	r4, #0
      while( (byteslefttocopy + bufferoffset) > ETH_RX_BUF_SIZE )
 804b972:	18a5      	adds	r5, r4, r2
 804b974:	f240 53f4 	movw	r3, #1524	; 0x5f4
 804b978:	429d      	cmp	r5, r3
 804b97a:	d8e7      	bhi.n	804b94c <low_level_input+0x50>
      memcpy( (uint8_t*)((uint8_t*)q->payload + payloadoffset), (uint8_t*)((uint8_t*)buffer + bufferoffset), byteslefttocopy);
 804b97c:	f8d9 0004 	ldr.w	r0, [r9, #4]
 804b980:	eb08 0104 	add.w	r1, r8, r4
 804b984:	4430      	add	r0, r6
 804b986:	f006 f83d 	bl	8051a04 <memcpy>
    for(q = p; q != NULL; q = q->next)
 804b98a:	f8d9 9000 	ldr.w	r9, [r9]
      bufferoffset = bufferoffset + byteslefttocopy;
 804b98e:	462c      	mov	r4, r5
    for(q = p; q != NULL; q = q->next)
 804b990:	f1b9 0f00 	cmp.w	r9, #0
 804b994:	d0c0      	beq.n	804b918 <low_level_input+0x1c>
      byteslefttocopy = q->len;
 804b996:	f8b9 200a 	ldrh.w	r2, [r9, #10]
      payloadoffset = 0;
 804b99a:	2600      	movs	r6, #0
      while( (byteslefttocopy + bufferoffset) > ETH_RX_BUF_SIZE )
 804b99c:	e7e9      	b.n	804b972 <low_level_input+0x76>
    }

    /* Clear Segment_Count */
    heth.RxFrameInfos.SegCount =0;
 804b99e:	4b0c      	ldr	r3, [pc, #48]	; (804b9d0 <low_level_input+0xd4>)
 804b9a0:	2200      	movs	r2, #0
 804b9a2:	639a      	str	r2, [r3, #56]	; 0x38

  /* When Rx Buffer unavailable flag is set: clear it and resume reception */
  if ((heth.Instance->DMASR & ETH_DMASR_RBUS) != (uint32_t)RESET)
 804b9a4:	681b      	ldr	r3, [r3, #0]
 804b9a6:	f241 0214 	movw	r2, #4116	; 0x1014
 804b9aa:	589a      	ldr	r2, [r3, r2]
 804b9ac:	f012 0f80 	tst.w	r2, #128	; 0x80
 804b9b0:	d007      	beq.n	804b9c2 <low_level_input+0xc6>
  {
    /* Clear RBUS ETHERNET DMA flag */
    heth.Instance->DMASR = ETH_DMASR_RBUS;
 804b9b2:	f241 0214 	movw	r2, #4116	; 0x1014
 804b9b6:	2180      	movs	r1, #128	; 0x80
 804b9b8:	5099      	str	r1, [r3, r2]
    /* Resume DMA reception */
    heth.Instance->DMARPDR = 0;
 804b9ba:	f241 0208 	movw	r2, #4104	; 0x1008
 804b9be:	2100      	movs	r1, #0
 804b9c0:	5099      	str	r1, [r3, r2]
  }
  return p;
}
 804b9c2:	4650      	mov	r0, sl
 804b9c4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    return NULL;
 804b9c8:	f04f 0a00 	mov.w	sl, #0
 804b9cc:	e7f9      	b.n	804b9c2 <low_level_input+0xc6>
 804b9ce:	bf00      	nop
 804b9d0:	2000a1bc 	.word	0x2000a1bc

0804b9d4 <low_level_output>:
{
 804b9d4:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 804b9d8:	468b      	mov	fp, r1
  uint8_t *buffer = (uint8_t *)(heth.TxDesc->Buffer1Addr);
 804b9da:	4b2c      	ldr	r3, [pc, #176]	; (804ba8c <low_level_output+0xb8>)
 804b9dc:	6ade      	ldr	r6, [r3, #44]	; 0x2c
 804b9de:	f8d6 a008 	ldr.w	sl, [r6, #8]
  bufferoffset = 0;
 804b9e2:	2400      	movs	r4, #0
  uint32_t framelength = 0;
 804b9e4:	4627      	mov	r7, r4
  for(q = p; q != NULL; q = q->next)
 804b9e6:	f1bb 0f00 	cmp.w	fp, #0
 804b9ea:	d032      	beq.n	804ba52 <low_level_output+0x7e>
      if((DmaTxDesc->Status & ETH_DMATXDESC_OWN) != (uint32_t)RESET)
 804b9ec:	6833      	ldr	r3, [r6, #0]
 804b9ee:	2b00      	cmp	r3, #0
 804b9f0:	db35      	blt.n	804ba5e <low_level_output+0x8a>
      byteslefttocopy = q->len;
 804b9f2:	f8bb 900a 	ldrh.w	r9, [fp, #10]
      payloadoffset = 0;
 804b9f6:	2500      	movs	r5, #0
      while( (byteslefttocopy + bufferoffset) > ETH_TX_BUF_SIZE )
 804b9f8:	eb04 0809 	add.w	r8, r4, r9
 804b9fc:	f240 53f4 	movw	r3, #1524	; 0x5f4
 804ba00:	4598      	cmp	r8, r3
 804ba02:	d919      	bls.n	804ba38 <low_level_output+0x64>
        memcpy( (uint8_t*)((uint8_t*)buffer + bufferoffset), (uint8_t*)((uint8_t*)q->payload + payloadoffset), (ETH_TX_BUF_SIZE - bufferoffset) );
 804ba04:	f8db 1004 	ldr.w	r1, [fp, #4]
 804ba08:	f5c4 62be 	rsb	r2, r4, #1520	; 0x5f0
 804ba0c:	3204      	adds	r2, #4
 804ba0e:	4429      	add	r1, r5
 804ba10:	eb0a 0004 	add.w	r0, sl, r4
 804ba14:	f005 fff6 	bl	8051a04 <memcpy>
        DmaTxDesc = (ETH_DMADescTypeDef *)(DmaTxDesc->Buffer2NextDescAddr);
 804ba18:	68f6      	ldr	r6, [r6, #12]
        if((DmaTxDesc->Status & ETH_DMATXDESC_OWN) != (uint32_t)RESET)
 804ba1a:	6833      	ldr	r3, [r6, #0]
 804ba1c:	2b00      	cmp	r3, #0
 804ba1e:	db21      	blt.n	804ba64 <low_level_output+0x90>
        buffer = (uint8_t *)(DmaTxDesc->Buffer1Addr);
 804ba20:	f8d6 a008 	ldr.w	sl, [r6, #8]
        byteslefttocopy = byteslefttocopy - (ETH_TX_BUF_SIZE - bufferoffset);
 804ba24:	f2a8 59f4 	subw	r9, r8, #1524	; 0x5f4
        payloadoffset = payloadoffset + (ETH_TX_BUF_SIZE - bufferoffset);
 804ba28:	1b2d      	subs	r5, r5, r4
 804ba2a:	f205 55f4 	addw	r5, r5, #1524	; 0x5f4
        framelength = framelength + (ETH_TX_BUF_SIZE - bufferoffset);
 804ba2e:	1b3f      	subs	r7, r7, r4
 804ba30:	f207 57f4 	addw	r7, r7, #1524	; 0x5f4
        bufferoffset = 0;
 804ba34:	2400      	movs	r4, #0
 804ba36:	e7df      	b.n	804b9f8 <low_level_output+0x24>
      memcpy( (uint8_t*)((uint8_t*)buffer + bufferoffset), (uint8_t*)((uint8_t*)q->payload + payloadoffset), byteslefttocopy );
 804ba38:	f8db 1004 	ldr.w	r1, [fp, #4]
 804ba3c:	464a      	mov	r2, r9
 804ba3e:	4429      	add	r1, r5
 804ba40:	eb0a 0004 	add.w	r0, sl, r4
 804ba44:	f005 ffde 	bl	8051a04 <memcpy>
      framelength = framelength + byteslefttocopy;
 804ba48:	444f      	add	r7, r9
  for(q = p; q != NULL; q = q->next)
 804ba4a:	f8db b000 	ldr.w	fp, [fp]
      bufferoffset = bufferoffset + byteslefttocopy;
 804ba4e:	4644      	mov	r4, r8
 804ba50:	e7c9      	b.n	804b9e6 <low_level_output+0x12>
  HAL_ETH_TransmitFrame(&heth, framelength);
 804ba52:	4639      	mov	r1, r7
 804ba54:	480d      	ldr	r0, [pc, #52]	; (804ba8c <low_level_output+0xb8>)
 804ba56:	f7f6 fb59 	bl	804210c <HAL_ETH_TransmitFrame>
  errval = ERR_OK;
 804ba5a:	2000      	movs	r0, #0
 804ba5c:	e004      	b.n	804ba68 <low_level_output+0x94>
        errval = ERR_USE;
 804ba5e:	f06f 0007 	mvn.w	r0, #7
 804ba62:	e001      	b.n	804ba68 <low_level_output+0x94>
          errval = ERR_USE;
 804ba64:	f06f 0007 	mvn.w	r0, #7
  if ((heth.Instance->DMASR & ETH_DMASR_TUS) != (uint32_t)RESET)
 804ba68:	4b08      	ldr	r3, [pc, #32]	; (804ba8c <low_level_output+0xb8>)
 804ba6a:	681b      	ldr	r3, [r3, #0]
 804ba6c:	f241 0214 	movw	r2, #4116	; 0x1014
 804ba70:	589a      	ldr	r2, [r3, r2]
 804ba72:	f012 0f20 	tst.w	r2, #32
 804ba76:	d007      	beq.n	804ba88 <low_level_output+0xb4>
    heth.Instance->DMASR = ETH_DMASR_TUS;
 804ba78:	f241 0214 	movw	r2, #4116	; 0x1014
 804ba7c:	2120      	movs	r1, #32
 804ba7e:	5099      	str	r1, [r3, r2]
    heth.Instance->DMATPDR = 0;
 804ba80:	f241 0204 	movw	r2, #4100	; 0x1004
 804ba84:	2100      	movs	r1, #0
 804ba86:	5099      	str	r1, [r3, r2]
}
 804ba88:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 804ba8c:	2000a1bc 	.word	0x2000a1bc

0804ba90 <low_level_init>:
{
 804ba90:	b530      	push	{r4, r5, lr}
 804ba92:	b085      	sub	sp, #20
 804ba94:	4604      	mov	r4, r0
  uint32_t regvalue = 0;
 804ba96:	2300      	movs	r3, #0
 804ba98:	9303      	str	r3, [sp, #12]
  heth.Instance = ETH;
 804ba9a:	4833      	ldr	r0, [pc, #204]	; (804bb68 <low_level_init+0xd8>)
 804ba9c:	4a33      	ldr	r2, [pc, #204]	; (804bb6c <low_level_init+0xdc>)
 804ba9e:	6002      	str	r2, [r0, #0]
  heth.Init.AutoNegotiation = ETH_AUTONEGOTIATION_ENABLE;
 804baa0:	2201      	movs	r2, #1
 804baa2:	6042      	str	r2, [r0, #4]
  heth.Init.PhyAddress = LAN8742A_PHY_ADDRESS;
 804baa4:	8202      	strh	r2, [r0, #16]
  MACAddr[0] = 0x00;
 804baa6:	f88d 3004 	strb.w	r3, [sp, #4]
  MACAddr[1] = 0x80;
 804baaa:	2280      	movs	r2, #128	; 0x80
 804baac:	f88d 2005 	strb.w	r2, [sp, #5]
  MACAddr[2] = 0xE1;
 804bab0:	22e1      	movs	r2, #225	; 0xe1
 804bab2:	f88d 2006 	strb.w	r2, [sp, #6]
  MACAddr[3] = 0x00;
 804bab6:	f88d 3007 	strb.w	r3, [sp, #7]
  MACAddr[4] = 0x00;
 804baba:	f88d 3008 	strb.w	r3, [sp, #8]
  MACAddr[5] = 0x00;
 804babe:	f88d 3009 	strb.w	r3, [sp, #9]
  heth.Init.MACAddr = &MACAddr[0];
 804bac2:	aa01      	add	r2, sp, #4
 804bac4:	6142      	str	r2, [r0, #20]
  heth.Init.RxMode = ETH_RXPOLLING_MODE;
 804bac6:	6183      	str	r3, [r0, #24]
  heth.Init.ChecksumMode = ETH_CHECKSUM_BY_HARDWARE;
 804bac8:	61c3      	str	r3, [r0, #28]
  heth.Init.MediaInterface = ETH_MEDIA_INTERFACE_RMII;
 804baca:	f44f 0300 	mov.w	r3, #8388608	; 0x800000
 804bace:	6203      	str	r3, [r0, #32]
  hal_eth_init_status = HAL_ETH_Init(&heth);
 804bad0:	f7f6 fc6a 	bl	80423a8 <HAL_ETH_Init>
  if (hal_eth_init_status == HAL_OK)
 804bad4:	b928      	cbnz	r0, 804bae2 <low_level_init+0x52>
    netif->flags |= NETIF_FLAG_LINK_UP;
 804bad6:	f894 302b 	ldrb.w	r3, [r4, #43]	; 0x2b
 804bada:	f043 0304 	orr.w	r3, r3, #4
 804bade:	f884 302b 	strb.w	r3, [r4, #43]	; 0x2b
  HAL_ETH_DMATxDescListInit(&heth, DMATxDscrTab, &Tx_Buff[0][0], ETH_TXBUFNB);
 804bae2:	4d21      	ldr	r5, [pc, #132]	; (804bb68 <low_level_init+0xd8>)
 804bae4:	2304      	movs	r3, #4
 804bae6:	4a22      	ldr	r2, [pc, #136]	; (804bb70 <low_level_init+0xe0>)
 804bae8:	4922      	ldr	r1, [pc, #136]	; (804bb74 <low_level_init+0xe4>)
 804baea:	4628      	mov	r0, r5
 804baec:	f7f6 fa9c 	bl	8042028 <HAL_ETH_DMATxDescListInit>
  HAL_ETH_DMARxDescListInit(&heth, DMARxDscrTab, &Rx_Buff[0][0], ETH_RXBUFNB);
 804baf0:	2304      	movs	r3, #4
 804baf2:	4a21      	ldr	r2, [pc, #132]	; (804bb78 <low_level_init+0xe8>)
 804baf4:	4921      	ldr	r1, [pc, #132]	; (804bb7c <low_level_init+0xec>)
 804baf6:	4628      	mov	r0, r5
 804baf8:	f7f6 fad0 	bl	804209c <HAL_ETH_DMARxDescListInit>
  netif->hwaddr_len = ETH_HWADDR_LEN;
 804bafc:	2306      	movs	r3, #6
 804bafe:	f884 3024 	strb.w	r3, [r4, #36]	; 0x24
  netif->hwaddr[0] =  heth.Init.MACAddr[0];
 804bb02:	696b      	ldr	r3, [r5, #20]
 804bb04:	781a      	ldrb	r2, [r3, #0]
 804bb06:	f884 2025 	strb.w	r2, [r4, #37]	; 0x25
  netif->hwaddr[1] =  heth.Init.MACAddr[1];
 804bb0a:	785a      	ldrb	r2, [r3, #1]
 804bb0c:	f884 2026 	strb.w	r2, [r4, #38]	; 0x26
  netif->hwaddr[2] =  heth.Init.MACAddr[2];
 804bb10:	789a      	ldrb	r2, [r3, #2]
 804bb12:	f884 2027 	strb.w	r2, [r4, #39]	; 0x27
  netif->hwaddr[3] =  heth.Init.MACAddr[3];
 804bb16:	78da      	ldrb	r2, [r3, #3]
 804bb18:	f884 2028 	strb.w	r2, [r4, #40]	; 0x28
  netif->hwaddr[4] =  heth.Init.MACAddr[4];
 804bb1c:	791a      	ldrb	r2, [r3, #4]
 804bb1e:	f884 2029 	strb.w	r2, [r4, #41]	; 0x29
  netif->hwaddr[5] =  heth.Init.MACAddr[5];
 804bb22:	795b      	ldrb	r3, [r3, #5]
 804bb24:	f884 302a 	strb.w	r3, [r4, #42]	; 0x2a
  netif->mtu = 1500;
 804bb28:	f240 53dc 	movw	r3, #1500	; 0x5dc
 804bb2c:	8463      	strh	r3, [r4, #34]	; 0x22
    netif->flags |= NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP;
 804bb2e:	f894 302b 	ldrb.w	r3, [r4, #43]	; 0x2b
 804bb32:	f043 030a 	orr.w	r3, r3, #10
 804bb36:	f884 302b 	strb.w	r3, [r4, #43]	; 0x2b
  HAL_ETH_Start(&heth);
 804bb3a:	4628      	mov	r0, r5
 804bb3c:	f7f6 fd60 	bl	8042600 <HAL_ETH_Start>
  HAL_ETH_ReadPHYRegister(&heth, PHY_ISFR, &regvalue);
 804bb40:	aa03      	add	r2, sp, #12
 804bb42:	211d      	movs	r1, #29
 804bb44:	4628      	mov	r0, r5
 804bb46:	f7f6 fbb8 	bl	80422ba <HAL_ETH_ReadPHYRegister>
  regvalue |= (PHY_ISFR_INT4);
 804bb4a:	9a03      	ldr	r2, [sp, #12]
 804bb4c:	f042 020b 	orr.w	r2, r2, #11
 804bb50:	9203      	str	r2, [sp, #12]
  HAL_ETH_WritePHYRegister(&heth, PHY_ISFR , regvalue );
 804bb52:	211d      	movs	r1, #29
 804bb54:	4628      	mov	r0, r5
 804bb56:	f7f6 fbec 	bl	8042332 <HAL_ETH_WritePHYRegister>
  HAL_ETH_ReadPHYRegister(&heth, PHY_ISFR , &regvalue);
 804bb5a:	aa03      	add	r2, sp, #12
 804bb5c:	211d      	movs	r1, #29
 804bb5e:	4628      	mov	r0, r5
 804bb60:	f7f6 fbab 	bl	80422ba <HAL_ETH_ReadPHYRegister>
}
 804bb64:	b005      	add	sp, #20
 804bb66:	bd30      	pop	{r4, r5, pc}
 804bb68:	2000a1bc 	.word	0x2000a1bc
 804bb6c:	40028000 	.word	0x40028000
 804bb70:	2000a204 	.word	0x2000a204
 804bb74:	200088ec 	.word	0x200088ec
 804bb78:	2000896c 	.word	0x2000896c
 804bb7c:	2000a13c 	.word	0x2000a13c

0804bb80 <HAL_ETH_MspInit>:
{
 804bb80:	b5f0      	push	{r4, r5, r6, r7, lr}
 804bb82:	b08d      	sub	sp, #52	; 0x34
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 804bb84:	2300      	movs	r3, #0
 804bb86:	9307      	str	r3, [sp, #28]
 804bb88:	9308      	str	r3, [sp, #32]
 804bb8a:	9309      	str	r3, [sp, #36]	; 0x24
 804bb8c:	930a      	str	r3, [sp, #40]	; 0x28
 804bb8e:	930b      	str	r3, [sp, #44]	; 0x2c
  if(ethHandle->Instance==ETH)
 804bb90:	6802      	ldr	r2, [r0, #0]
 804bb92:	4b33      	ldr	r3, [pc, #204]	; (804bc60 <HAL_ETH_MspInit+0xe0>)
 804bb94:	429a      	cmp	r2, r3
 804bb96:	d001      	beq.n	804bb9c <HAL_ETH_MspInit+0x1c>
}
 804bb98:	b00d      	add	sp, #52	; 0x34
 804bb9a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    __HAL_RCC_ETH_CLK_ENABLE();
 804bb9c:	2400      	movs	r4, #0
 804bb9e:	9401      	str	r4, [sp, #4]
 804bba0:	f5a3 4390 	sub.w	r3, r3, #18432	; 0x4800
 804bba4:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 804bba6:	f042 7200 	orr.w	r2, r2, #33554432	; 0x2000000
 804bbaa:	631a      	str	r2, [r3, #48]	; 0x30
 804bbac:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 804bbae:	f002 7200 	and.w	r2, r2, #33554432	; 0x2000000
 804bbb2:	9201      	str	r2, [sp, #4]
 804bbb4:	9a01      	ldr	r2, [sp, #4]
 804bbb6:	9402      	str	r4, [sp, #8]
 804bbb8:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 804bbba:	f042 6280 	orr.w	r2, r2, #67108864	; 0x4000000
 804bbbe:	631a      	str	r2, [r3, #48]	; 0x30
 804bbc0:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 804bbc2:	f002 6280 	and.w	r2, r2, #67108864	; 0x4000000
 804bbc6:	9202      	str	r2, [sp, #8]
 804bbc8:	9a02      	ldr	r2, [sp, #8]
 804bbca:	9403      	str	r4, [sp, #12]
 804bbcc:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 804bbce:	f042 6200 	orr.w	r2, r2, #134217728	; 0x8000000
 804bbd2:	631a      	str	r2, [r3, #48]	; 0x30
 804bbd4:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 804bbd6:	f002 6200 	and.w	r2, r2, #134217728	; 0x8000000
 804bbda:	9203      	str	r2, [sp, #12]
 804bbdc:	9a03      	ldr	r2, [sp, #12]
    __HAL_RCC_GPIOC_CLK_ENABLE();
 804bbde:	9404      	str	r4, [sp, #16]
 804bbe0:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 804bbe2:	f042 0204 	orr.w	r2, r2, #4
 804bbe6:	631a      	str	r2, [r3, #48]	; 0x30
 804bbe8:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 804bbea:	f002 0204 	and.w	r2, r2, #4
 804bbee:	9204      	str	r2, [sp, #16]
 804bbf0:	9a04      	ldr	r2, [sp, #16]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 804bbf2:	9405      	str	r4, [sp, #20]
 804bbf4:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 804bbf6:	f042 0201 	orr.w	r2, r2, #1
 804bbfa:	631a      	str	r2, [r3, #48]	; 0x30
 804bbfc:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 804bbfe:	f002 0201 	and.w	r2, r2, #1
 804bc02:	9205      	str	r2, [sp, #20]
 804bc04:	9a05      	ldr	r2, [sp, #20]
    __HAL_RCC_GPIOB_CLK_ENABLE();
 804bc06:	9406      	str	r4, [sp, #24]
 804bc08:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 804bc0a:	f042 0202 	orr.w	r2, r2, #2
 804bc0e:	631a      	str	r2, [r3, #48]	; 0x30
 804bc10:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 804bc12:	f003 0302 	and.w	r3, r3, #2
 804bc16:	9306      	str	r3, [sp, #24]
 804bc18:	9b06      	ldr	r3, [sp, #24]
    GPIO_InitStruct.Pin = GPIO_PIN_1|GPIO_PIN_4|GPIO_PIN_5;
 804bc1a:	2332      	movs	r3, #50	; 0x32
 804bc1c:	9307      	str	r3, [sp, #28]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 804bc1e:	2702      	movs	r7, #2
 804bc20:	9708      	str	r7, [sp, #32]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 804bc22:	9409      	str	r4, [sp, #36]	; 0x24
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 804bc24:	2603      	movs	r6, #3
 804bc26:	960a      	str	r6, [sp, #40]	; 0x28
    GPIO_InitStruct.Alternate = GPIO_AF11_ETH;
 804bc28:	250b      	movs	r5, #11
 804bc2a:	950b      	str	r5, [sp, #44]	; 0x2c
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 804bc2c:	a907      	add	r1, sp, #28
 804bc2e:	480d      	ldr	r0, [pc, #52]	; (804bc64 <HAL_ETH_MspInit+0xe4>)
 804bc30:	f7f6 ff84 	bl	8042b3c <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_7;
 804bc34:	2386      	movs	r3, #134	; 0x86
 804bc36:	9307      	str	r3, [sp, #28]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 804bc38:	9708      	str	r7, [sp, #32]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 804bc3a:	9409      	str	r4, [sp, #36]	; 0x24
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 804bc3c:	960a      	str	r6, [sp, #40]	; 0x28
    GPIO_InitStruct.Alternate = GPIO_AF11_ETH;
 804bc3e:	950b      	str	r5, [sp, #44]	; 0x2c
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 804bc40:	a907      	add	r1, sp, #28
 804bc42:	4809      	ldr	r0, [pc, #36]	; (804bc68 <HAL_ETH_MspInit+0xe8>)
 804bc44:	f7f6 ff7a 	bl	8042b3c <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = GPIO_PIN_11|GPIO_PIN_12|GPIO_PIN_13;
 804bc48:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 804bc4c:	9307      	str	r3, [sp, #28]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 804bc4e:	9708      	str	r7, [sp, #32]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 804bc50:	9409      	str	r4, [sp, #36]	; 0x24
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 804bc52:	960a      	str	r6, [sp, #40]	; 0x28
    GPIO_InitStruct.Alternate = GPIO_AF11_ETH;
 804bc54:	950b      	str	r5, [sp, #44]	; 0x2c
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 804bc56:	a907      	add	r1, sp, #28
 804bc58:	4804      	ldr	r0, [pc, #16]	; (804bc6c <HAL_ETH_MspInit+0xec>)
 804bc5a:	f7f6 ff6f 	bl	8042b3c <HAL_GPIO_Init>
}
 804bc5e:	e79b      	b.n	804bb98 <HAL_ETH_MspInit+0x18>
 804bc60:	40028000 	.word	0x40028000
 804bc64:	40020800 	.word	0x40020800
 804bc68:	40020000 	.word	0x40020000
 804bc6c:	40020400 	.word	0x40020400

0804bc70 <ethernetif_input>:
 * the appropriate input function is called.
 *
 * @param netif the lwip network interface structure for this ethernetif
 */
void ethernetif_input(struct netif *netif)
{
 804bc70:	b538      	push	{r3, r4, r5, lr}
 804bc72:	4604      	mov	r4, r0
  err_t err;
  struct pbuf *p;

  /* move received packet into a new pbuf */
  p = low_level_input(netif);
 804bc74:	f7ff fe42 	bl	804b8fc <low_level_input>

  /* no packet could be read, silently ignore this */
  if (p == NULL) return;
 804bc78:	b120      	cbz	r0, 804bc84 <ethernetif_input+0x14>
 804bc7a:	4605      	mov	r5, r0

  /* entry point to the LwIP stack */
  err = netif->input(p, netif);
 804bc7c:	6923      	ldr	r3, [r4, #16]
 804bc7e:	4621      	mov	r1, r4
 804bc80:	4798      	blx	r3

  if (err != ERR_OK)
 804bc82:	b900      	cbnz	r0, 804bc86 <ethernetif_input+0x16>
  {
    LWIP_DEBUGF(NETIF_DEBUG, ("ethernetif_input: IP input error\n"));
    pbuf_free(p);
    p = NULL;
  }
}
 804bc84:	bd38      	pop	{r3, r4, r5, pc}
    pbuf_free(p);
 804bc86:	4628      	mov	r0, r5
 804bc88:	f7fa f828 	bl	8045cdc <pbuf_free>
    p = NULL;
 804bc8c:	e7fa      	b.n	804bc84 <ethernetif_input+0x14>
	...

0804bc90 <ethernetif_init>:
 * @return ERR_OK if the loopif is initialized
 *         ERR_MEM if private data couldn't be allocated
 *         any other err_t on error
 */
err_t ethernetif_init(struct netif *netif)
{
 804bc90:	b510      	push	{r4, lr}
  LWIP_ASSERT("netif != NULL", (netif != NULL));
 804bc92:	4604      	mov	r4, r0
 804bc94:	b170      	cbz	r0, 804bcb4 <ethernetif_init+0x24>
#if LWIP_NETIF_HOSTNAME
  /* Initialize interface hostname */
  netif->hostname = "lwip";
#endif /* LWIP_NETIF_HOSTNAME */

  netif->name[0] = IFNAME0;
 804bc96:	2373      	movs	r3, #115	; 0x73
 804bc98:	f884 302c 	strb.w	r3, [r4, #44]	; 0x2c
  netif->name[1] = IFNAME1;
 804bc9c:	2374      	movs	r3, #116	; 0x74
 804bc9e:	f884 302d 	strb.w	r3, [r4, #45]	; 0x2d
   * is available...) */

#if LWIP_IPV4
#if LWIP_ARP || LWIP_ETHERNET
#if LWIP_ARP
  netif->output = etharp_output;
 804bca2:	4b08      	ldr	r3, [pc, #32]	; (804bcc4 <ethernetif_init+0x34>)
 804bca4:	6163      	str	r3, [r4, #20]

#if LWIP_IPV6
  netif->output_ip6 = ethip6_output;
#endif /* LWIP_IPV6 */

  netif->linkoutput = low_level_output;
 804bca6:	4b08      	ldr	r3, [pc, #32]	; (804bcc8 <ethernetif_init+0x38>)
 804bca8:	61a3      	str	r3, [r4, #24]

  /* initialize the hardware */
  low_level_init(netif);
 804bcaa:	4620      	mov	r0, r4
 804bcac:	f7ff fef0 	bl	804ba90 <low_level_init>

  return ERR_OK;
}
 804bcb0:	2000      	movs	r0, #0
 804bcb2:	bd10      	pop	{r4, pc}
  LWIP_ASSERT("netif != NULL", (netif != NULL));
 804bcb4:	4b05      	ldr	r3, [pc, #20]	; (804bccc <ethernetif_init+0x3c>)
 804bcb6:	f44f 7201 	mov.w	r2, #516	; 0x204
 804bcba:	4905      	ldr	r1, [pc, #20]	; (804bcd0 <ethernetif_init+0x40>)
 804bcbc:	4805      	ldr	r0, [pc, #20]	; (804bcd4 <ethernetif_init+0x44>)
 804bcbe:	f005 fec3 	bl	8051a48 <printf>
 804bcc2:	e7e8      	b.n	804bc96 <ethernetif_init+0x6>
 804bcc4:	0804a59d 	.word	0x0804a59d
 804bcc8:	0804b9d5 	.word	0x0804b9d5
 804bccc:	0805a864 	.word	0x0805a864
 804bcd0:	0805a374 	.word	0x0805a374
 804bcd4:	08058ecc 	.word	0x08058ecc

0804bcd8 <sys_now>:
*         when LWIP_TIMERS == 1 and NO_SYS == 1
* @param  None
* @retval Time
*/
u32_t sys_now(void)
{
 804bcd8:	b508      	push	{r3, lr}
  return HAL_GetTick();
 804bcda:	f7f5 f9f1 	bl	80410c0 <HAL_GetTick>
}
 804bcde:	bd08      	pop	{r3, pc}

0804bce0 <MX_GPIO_Init>:
        * Output
        * EVENT_OUT
        * EXTI
*/
void MX_GPIO_Init(void)
{
 804bce0:	b5f0      	push	{r4, r5, r6, r7, lr}
 804bce2:	b08d      	sub	sp, #52	; 0x34

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 804bce4:	2400      	movs	r4, #0
 804bce6:	9407      	str	r4, [sp, #28]
 804bce8:	9408      	str	r4, [sp, #32]
 804bcea:	9409      	str	r4, [sp, #36]	; 0x24
 804bcec:	940a      	str	r4, [sp, #40]	; 0x28
 804bcee:	940b      	str	r4, [sp, #44]	; 0x2c

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOH_CLK_ENABLE();
 804bcf0:	9401      	str	r4, [sp, #4]
 804bcf2:	4b30      	ldr	r3, [pc, #192]	; (804bdb4 <MX_GPIO_Init+0xd4>)
 804bcf4:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 804bcf6:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 804bcfa:	631a      	str	r2, [r3, #48]	; 0x30
 804bcfc:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 804bcfe:	f002 0280 	and.w	r2, r2, #128	; 0x80
 804bd02:	9201      	str	r2, [sp, #4]
 804bd04:	9a01      	ldr	r2, [sp, #4]
  __HAL_RCC_GPIOC_CLK_ENABLE();
 804bd06:	9402      	str	r4, [sp, #8]
 804bd08:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 804bd0a:	f042 0204 	orr.w	r2, r2, #4
 804bd0e:	631a      	str	r2, [r3, #48]	; 0x30
 804bd10:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 804bd12:	f002 0204 	and.w	r2, r2, #4
 804bd16:	9202      	str	r2, [sp, #8]
 804bd18:	9a02      	ldr	r2, [sp, #8]
  __HAL_RCC_GPIOA_CLK_ENABLE();
 804bd1a:	9403      	str	r4, [sp, #12]
 804bd1c:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 804bd1e:	f042 0201 	orr.w	r2, r2, #1
 804bd22:	631a      	str	r2, [r3, #48]	; 0x30
 804bd24:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 804bd26:	f002 0201 	and.w	r2, r2, #1
 804bd2a:	9203      	str	r2, [sp, #12]
 804bd2c:	9a03      	ldr	r2, [sp, #12]
  __HAL_RCC_GPIOE_CLK_ENABLE();
 804bd2e:	9404      	str	r4, [sp, #16]
 804bd30:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 804bd32:	f042 0210 	orr.w	r2, r2, #16
 804bd36:	631a      	str	r2, [r3, #48]	; 0x30
 804bd38:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 804bd3a:	f002 0210 	and.w	r2, r2, #16
 804bd3e:	9204      	str	r2, [sp, #16]
 804bd40:	9a04      	ldr	r2, [sp, #16]
  __HAL_RCC_GPIOB_CLK_ENABLE();
 804bd42:	9405      	str	r4, [sp, #20]
 804bd44:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 804bd46:	f042 0202 	orr.w	r2, r2, #2
 804bd4a:	631a      	str	r2, [r3, #48]	; 0x30
 804bd4c:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 804bd4e:	f002 0202 	and.w	r2, r2, #2
 804bd52:	9205      	str	r2, [sp, #20]
 804bd54:	9a05      	ldr	r2, [sp, #20]
  __HAL_RCC_GPIOD_CLK_ENABLE();
 804bd56:	9406      	str	r4, [sp, #24]
 804bd58:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 804bd5a:	f042 0208 	orr.w	r2, r2, #8
 804bd5e:	631a      	str	r2, [r3, #48]	; 0x30
 804bd60:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 804bd62:	f003 0308 	and.w	r3, r3, #8
 804bd66:	9306      	str	r3, [sp, #24]
 804bd68:	9b06      	ldr	r3, [sp, #24]

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOE, MB_DE_Pin|MB_RE_Pin, GPIO_PIN_RESET);
 804bd6a:	4f13      	ldr	r7, [pc, #76]	; (804bdb8 <MX_GPIO_Init+0xd8>)
 804bd6c:	4622      	mov	r2, r4
 804bd6e:	f44f 51c0 	mov.w	r1, #6144	; 0x1800
 804bd72:	4638      	mov	r0, r7
 804bd74:	f7f6 ffd4 	bl	8042d20 <HAL_GPIO_WritePin>

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOD, LED_1_Pin|HEARTBEAT_Pin|LED_3_Pin|LED_2_Pin
 804bd78:	4d10      	ldr	r5, [pc, #64]	; (804bdbc <MX_GPIO_Init+0xdc>)
 804bd7a:	4622      	mov	r2, r4
 804bd7c:	f44f 611e 	mov.w	r1, #2528	; 0x9e0
 804bd80:	4628      	mov	r0, r5
 804bd82:	f7f6 ffcd 	bl	8042d20 <HAL_GPIO_WritePin>
                          |GSM_PWR_KEY_Pin, GPIO_PIN_RESET);

  /*Configure GPIO pins : PEPin PEPin */
  GPIO_InitStruct.Pin = MB_DE_Pin|MB_RE_Pin;
 804bd86:	f44f 53c0 	mov.w	r3, #6144	; 0x1800
 804bd8a:	9307      	str	r3, [sp, #28]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 804bd8c:	2601      	movs	r6, #1
 804bd8e:	9608      	str	r6, [sp, #32]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 804bd90:	9409      	str	r4, [sp, #36]	; 0x24
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 804bd92:	940a      	str	r4, [sp, #40]	; 0x28
  HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 804bd94:	a907      	add	r1, sp, #28
 804bd96:	4638      	mov	r0, r7
 804bd98:	f7f6 fed0 	bl	8042b3c <HAL_GPIO_Init>

  /*Configure GPIO pins : PDPin PDPin PDPin PDPin
                           PDPin */
  GPIO_InitStruct.Pin = LED_1_Pin|HEARTBEAT_Pin|LED_3_Pin|LED_2_Pin
 804bd9c:	f44f 631e 	mov.w	r3, #2528	; 0x9e0
 804bda0:	9307      	str	r3, [sp, #28]
                          |GSM_PWR_KEY_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 804bda2:	9608      	str	r6, [sp, #32]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 804bda4:	9409      	str	r4, [sp, #36]	; 0x24
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 804bda6:	940a      	str	r4, [sp, #40]	; 0x28
  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 804bda8:	a907      	add	r1, sp, #28
 804bdaa:	4628      	mov	r0, r5
 804bdac:	f7f6 fec6 	bl	8042b3c <HAL_GPIO_Init>

}
 804bdb0:	b00d      	add	sp, #52	; 0x34
 804bdb2:	bdf0      	pop	{r4, r5, r6, r7, pc}
 804bdb4:	40023800 	.word	0x40023800
 804bdb8:	40021000 	.word	0x40021000
 804bdbc:	40020c00 	.word	0x40020c00

0804bdc0 <initGSMSIM868>:
* </table><br><br>
* <hr>
*
*******************************************************************************/
void initGSMSIM868(void)
{
 804bdc0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	/* Init Buffers */

	memset(gsmInstance.agpsLocationData, GSM_ARRAY_INIT_CHAR, (GPS_LOCATION_ARRAY_SIZE * sizeof(char)));
 804bdc4:	4c68      	ldr	r4, [pc, #416]	; (804bf68 <initGSMSIM868+0x1a8>)
 804bdc6:	2296      	movs	r2, #150	; 0x96
 804bdc8:	2100      	movs	r1, #0
 804bdca:	4620      	mov	r0, r4
 804bdcc:	f005 fe28 	bl	8051a20 <memset>
	memset(gsmInstance.agsmNetworkIP, GSM_ARRAY_INIT_CHAR, (GPRS_NETWORKIP_ARRAY_SIZE * sizeof(char)));
 804bdd0:	2223      	movs	r2, #35	; 0x23
 804bdd2:	2100      	movs	r1, #0
 804bdd4:	f104 00a0 	add.w	r0, r4, #160	; 0xa0
 804bdd8:	f005 fe22 	bl	8051a20 <memset>
	memset(gsmInstance.agsmSignalStrength, GSM_ARRAY_INIT_CHAR, (GSM_SIGSTRGTH_ARRAY_SIZE * sizeof(char)));
 804bddc:	2500      	movs	r5, #0
 804bdde:	f8c4 5096 	str.w	r5, [r4, #150]	; 0x96
 804bde2:	f8c4 509a 	str.w	r5, [r4, #154]	; 0x9a
 804bde6:	f8a4 509e 	strh.w	r5, [r4, #158]	; 0x9e
	memset((char *)gsmInstance.as8GSM_Response_Buff,GSM_ARRAY_INIT_CHAR,(GSM_RESPONSE_ARRAY_SIZE * sizeof(char)));
 804bdea:	f640 12c4 	movw	r2, #2500	; 0x9c4
 804bdee:	4629      	mov	r1, r5
 804bdf0:	f204 4052 	addw	r0, r4, #1106	; 0x452
 804bdf4:	f005 fe14 	bl	8051a20 <memset>
	memset(gsmInstance.agsmCommandResponse, DATA_UNKNOWN, sizeof(gsmInstance.agsmCommandResponse[0][0])
 804bdf8:	f44f 7261 	mov.w	r2, #900	; 0x384
 804bdfc:	213f      	movs	r1, #63	; 0x3f
 804bdfe:	f104 00c3 	add.w	r0, r4, #195	; 0xc3
 804be02:	f005 fe0d 	bl	8051a20 <memset>
		   * GSM_TOTAL_COMMANDS * GSM_TOTAL_COMMANDS);
	memset(gsmInstance.agsmHTTPRequestStatus,DATA_UNKNOWN,GSM_HTTP_RESPONSE_CODE_SIZE * sizeof(char));
 804be06:	f04f 333f 	mov.w	r3, #1061109567	; 0x3f3f3f3f
 804be0a:	f8c4 3447 	str.w	r3, [r4, #1095]	; 0x447
 804be0e:	f8c4 344b 	str.w	r3, [r4, #1099]	; 0x44b
	memset(gsmInstance.strSystemSMS.agsmSMSRecipient,DATA_UNKNOWN,SMS_MOB_NO_LENGTH * sizeof(char));
 804be12:	f8c4 3e41 	str.w	r3, [r4, #3649]	; 0xe41
 804be16:	f8c4 3e45 	str.w	r3, [r4, #3653]	; 0xe45
 804be1a:	f8c4 3e49 	str.w	r3, [r4, #3657]	; 0xe49
 804be1e:	f884 3e4d 	strb.w	r3, [r4, #3661]	; 0xe4d
	memset(gsmInstance.strSystemSMS.agsmSMSMessageBody,0x00,SMS_MAX_MSG_LENGTH * sizeof(char));
 804be22:	f44f 7248 	mov.w	r2, #800	; 0x320
 804be26:	4629      	mov	r1, r5
 804be28:	f604 604e 	addw	r0, r4, #3662	; 0xe4e
 804be2c:	f005 fdf8 	bl	8051a20 <memset>
	memset(gsmInstance.u32GSMHttpResponseCode,0x00,sizeof(char) * 3);
 804be30:	f8a4 544f 	strh.w	r5, [r4, #1103]	; 0x44f
 804be34:	f884 5451 	strb.w	r5, [r4, #1105]	; 0x451
	memset(gau8GSM_ATAPN, 0x00, (180 * sizeof(char)));
 804be38:	4e4c      	ldr	r6, [pc, #304]	; (804bf6c <initGSMSIM868+0x1ac>)
 804be3a:	f04f 09b4 	mov.w	r9, #180	; 0xb4
 804be3e:	464a      	mov	r2, r9
 804be40:	4629      	mov	r1, r5
 804be42:	4630      	mov	r0, r6
 804be44:	f005 fdec 	bl	8051a20 <memset>
	memset(gau8GSM_ATURL, 0x00, (180 * sizeof(char)));
 804be48:	eb06 0809 	add.w	r8, r6, r9
 804be4c:	464a      	mov	r2, r9
 804be4e:	4629      	mov	r1, r5
 804be50:	4640      	mov	r0, r8
 804be52:	f005 fde5 	bl	8051a20 <memset>
	memset(gau8GSM_SMSRecepient, 0x00, ( 180 * sizeof(char)));
 804be56:	f506 77b4 	add.w	r7, r6, #360	; 0x168
 804be5a:	464a      	mov	r2, r9
 804be5c:	4629      	mov	r1, r5
 804be5e:	4638      	mov	r0, r7
 804be60:	f005 fdde 	bl	8051a20 <memset>

	strcat((char *)gau8GSM_SMSRecepient,(char *)gau8GSM_ATCMGS);
 804be64:	f506 7107 	add.w	r1, r6, #540	; 0x21c
 804be68:	4638      	mov	r0, r7
 804be6a:	f005 fe2f 	bl	8051acc <strcat>
	strcat((char *)gau8GSM_SMSRecepient,(char *)"\"");
 804be6e:	4638      	mov	r0, r7
 804be70:	f7f4 f9c8 	bl	8040204 <strlen>
 804be74:	4b3e      	ldr	r3, [pc, #248]	; (804bf70 <initGSMSIM868+0x1b0>)
 804be76:	f8b3 9000 	ldrh.w	r9, [r3]
 804be7a:	f827 9000 	strh.w	r9, [r7, r0]
	strcat((char *)gau8GSM_SMSRecepient,(char *)gau8GSM_smsto);
 804be7e:	f506 710e 	add.w	r1, r6, #568	; 0x238
 804be82:	4638      	mov	r0, r7
 804be84:	f005 fe22 	bl	8051acc <strcat>
	strcat((char *)gau8GSM_SMSRecepient,(char *)"\"");
 804be88:	4638      	mov	r0, r7
 804be8a:	f7f4 f9bb 	bl	8040204 <strlen>
 804be8e:	f827 9000 	strh.w	r9, [r7, r0]
	//strcat((char *)gau8GSM_ATAPN,(char *)gau8GSM_ATSAPRBAPN);
	strcat((char *)gau8GSM_ATAPN,(char *)"\"");
 804be92:	4630      	mov	r0, r6
 804be94:	f7f4 f9b6 	bl	8040204 <strlen>
 804be98:	f826 9000 	strh.w	r9, [r6, r0]
	strcat((char *)gau8GSM_ATAPN,(char *)gau8GSM_apn);
 804be9c:	f506 7112 	add.w	r1, r6, #584	; 0x248
 804bea0:	4630      	mov	r0, r6
 804bea2:	f005 fe13 	bl	8051acc <strcat>
	strcat((char *)gau8GSM_ATAPN,(char *)"\"");
 804bea6:	4630      	mov	r0, r6
 804bea8:	f7f4 f9ac 	bl	8040204 <strlen>
 804beac:	f826 9000 	strh.w	r9, [r6, r0]
	strcat((char *)gau8GSM_ATURL,(char *)gau8GSM_ATHTTPPARAURL);
 804beb0:	f506 712b 	add.w	r1, r6, #684	; 0x2ac
 804beb4:	4640      	mov	r0, r8
 804beb6:	f005 fe09 	bl	8051acc <strcat>
	strcat((char *)gau8GSM_ATURL,(char *)"\"");
 804beba:	4640      	mov	r0, r8
 804bebc:	f7f4 f9a2 	bl	8040204 <strlen>
 804bec0:	f828 9000 	strh.w	r9, [r8, r0]
	strcat((char *)gau8GSM_ATURL,(char *)gau8GSM_url);
 804bec4:	f506 7151 	add.w	r1, r6, #836	; 0x344
 804bec8:	4640      	mov	r0, r8
 804beca:	f005 fdff 	bl	8051acc <strcat>
	strcat((char *)gau8GSM_ATURL,(char *)"\"");
 804bece:	4640      	mov	r0, r8
 804bed0:	f7f4 f998 	bl	8040204 <strlen>
 804bed4:	f828 9000 	strh.w	r9, [r8, r0]
	strcat(gau8GSM_ATAPN,"\r\n");
 804bed8:	4630      	mov	r0, r6
 804beda:	f7f4 f993 	bl	8040204 <strlen>
 804bede:	1832      	adds	r2, r6, r0
 804bee0:	4b24      	ldr	r3, [pc, #144]	; (804bf74 <initGSMSIM868+0x1b4>)
 804bee2:	f8b3 a000 	ldrh.w	sl, [r3]
 804bee6:	f893 9002 	ldrb.w	r9, [r3, #2]
 804beea:	f826 a000 	strh.w	sl, [r6, r0]
 804beee:	f882 9002 	strb.w	r9, [r2, #2]
	strcat(gau8GSM_ATURL,"\r\n");
 804bef2:	4640      	mov	r0, r8
 804bef4:	f7f4 f986 	bl	8040204 <strlen>
 804bef8:	eb08 0300 	add.w	r3, r8, r0
 804befc:	f828 a000 	strh.w	sl, [r8, r0]
 804bf00:	f883 9002 	strb.w	r9, [r3, #2]
	strcat(gau8GSM_SMSRecepient,"\r\n");
 804bf04:	4638      	mov	r0, r7
 804bf06:	f7f4 f97d 	bl	8040204 <strlen>
 804bf0a:	183b      	adds	r3, r7, r0
 804bf0c:	f827 a000 	strh.w	sl, [r7, r0]
 804bf10:	f883 9002 	strb.w	r9, [r3, #2]

	gsmInstance.strSystemSMS.u8NewMessage = FALSE;
 804bf14:	f241 136e 	movw	r3, #4462	; 0x116e
 804bf18:	54e5      	strb	r5, [r4, r3]
	gsmInstance.enmcurrentTask = enmGSMTASK_RESET;
 804bf1a:	f884 5e3e 	strb.w	r5, [r4, #3646]	; 0xe3e
	gsmInstance.enmGSMPwrState = enmGSM_PWRNOTSTARTED;
 804bf1e:	f884 5e40 	strb.w	r5, [r4, #3648]	; 0xe40
	gsmInstance.u8isConnected = FALSE;
 804bf22:	f884 5e19 	strb.w	r5, [r4, #3609]	; 0xe19
	gsmInstance.u8GSM_Response_Character_Counter = 0;
 804bf26:	f8c4 5e38 	str.w	r5, [r4, #3640]	; 0xe38
	gsmInstance.u8gsmRegistrationStatus = FALSE;
 804bf2a:	f884 5e17 	strb.w	r5, [r4, #3607]	; 0xe17
	gsmInstance.u8gsmSIMReadyStatus = FALSE;
 804bf2e:	f884 5e16 	strb.w	r5, [r4, #3606]	; 0xe16
	gsmInstance.u8gsmRetryCount = GSM_MAX_RETRY;
 804bf32:	2305      	movs	r3, #5
 804bf34:	f884 3e18 	strb.w	r3, [r4, #3608]	; 0xe18
	gsmInstance.u8AttemptFota = FALSE;
 804bf38:	f884 5e1b 	strb.w	r5, [r4, #3611]	; 0xe1b
	gsmInstance.u32GSMTimer = ONE_SEC;
 804bf3c:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 804bf40:	f8c4 3e20 	str.w	r3, [r4, #3616]	; 0xe20
	gu32GSMHangTimer = THREE_MIN;
 804bf44:	4b0c      	ldr	r3, [pc, #48]	; (804bf78 <initGSMSIM868+0x1b8>)
 804bf46:	4a0d      	ldr	r2, [pc, #52]	; (804bf7c <initGSMSIM868+0x1bc>)
 804bf48:	601a      	str	r2, [r3, #0]
	gsmInstance.u32GSMHeartbeatTimer = 0;
 804bf4a:	f8c4 5e2c 	str.w	r5, [r4, #3628]	; 0xe2c
	gsmInstance.u8IllegalHttpResponseCounter = 0;
 804bf4e:	f884 5e1d 	strb.w	r5, [r4, #3613]	; 0xe1d
	gsmInstance.enmGSMCommandResponseState = enmGSM_SENDCMD;
 804bf52:	f884 5e3c 	strb.w	r5, [r4, #3644]	; 0xe3c
	gsmInstance.enmGSMCommand = enmGSMSTATE_ATE0;
 804bf56:	2301      	movs	r3, #1
 804bf58:	f884 3e3f 	strb.w	r3, [r4, #3647]	; 0xe3f
	gsmInstance.enmGSMCommandState = enmGSM_CMDSEND;
 804bf5c:	f884 3e3d 	strb.w	r3, [r4, #3645]	; 0xe3d
	gu8FlagNoTerminate = 1;
 804bf60:	f886 33da 	strb.w	r3, [r6, #986]	; 0x3da
}
 804bf64:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 804bf68:	2000c398 	.word	0x2000c398
 804bf6c:	20000010 	.word	0x20000010
 804bf70:	0805a878 	.word	0x0805a878
 804bf74:	0805a898 	.word	0x0805a898
 804bf78:	2000515c 	.word	0x2000515c
 804bf7c:	0002bf20 	.word	0x0002bf20

0804bf80 <updateHttpDataLength>:
* </table><br><br>
* <hr>
*
*******************************************************************************/
void updateHttpDataLength()
{
 804bf80:	b5b0      	push	{r4, r5, r7, lr}
 804bf82:	af00      	add	r7, sp, #0
	char * tempdata = "";
	tempdata = gsmPayload.data[gsmPayload.tail];
 804bf84:	4a19      	ldr	r2, [pc, #100]	; (804bfec <updateHttpDataLength+0x6c>)
 804bf86:	6853      	ldr	r3, [r2, #4]
 804bf88:	3302      	adds	r3, #2

	uint32_t payloadLength = strlen(tempdata);
 804bf8a:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
 804bf8e:	f7f4 f939 	bl	8040204 <strlen>
 804bf92:	4604      	mov	r4, r0
	char buffer[payloadLength];
 804bf94:	1dc3      	adds	r3, r0, #7
 804bf96:	f023 0307 	bic.w	r3, r3, #7
 804bf9a:	ebad 0d03 	sub.w	sp, sp, r3
	memset(buffer, 0x00, (payloadLength * sizeof(char))); /* Clear Response Buffer */
 804bf9e:	4602      	mov	r2, r0
 804bfa0:	2100      	movs	r1, #0
 804bfa2:	4668      	mov	r0, sp
 804bfa4:	f005 fd3c 	bl	8051a20 <memset>

	/* Convert Integer to ASCII ( Decimal) */
	memset(gau8GSM_ATHTTPDATACOMMAND, 0x00, ( 30 * sizeof(char)));
 804bfa8:	4d11      	ldr	r5, [pc, #68]	; (804bff0 <updateHttpDataLength+0x70>)
 804bfaa:	221e      	movs	r2, #30
 804bfac:	2100      	movs	r1, #0
 804bfae:	4628      	mov	r0, r5
 804bfb0:	f005 fd36 	bl	8051a20 <memset>
	itoa(payloadLength,buffer,PAYLOAD_DATA_STRING_RADIX);
 804bfb4:	220a      	movs	r2, #10
 804bfb6:	4669      	mov	r1, sp
 804bfb8:	4620      	mov	r0, r4
 804bfba:	f005 fac1 	bl	8051540 <itoa>
	strcat(buffer,gu8GSMDataTimeout);
 804bfbe:	4668      	mov	r0, sp
 804bfc0:	f7f4 f920 	bl	8040204 <strlen>
 804bfc4:	4602      	mov	r2, r0
 804bfc6:	eb0d 0400 	add.w	r4, sp, r0
 804bfca:	4b0a      	ldr	r3, [pc, #40]	; (804bff4 <updateHttpDataLength+0x74>)
 804bfcc:	cb03      	ldmia	r3!, {r0, r1}
 804bfce:	f84d 0002 	str.w	r0, [sp, r2]
 804bfd2:	6061      	str	r1, [r4, #4]
 804bfd4:	781b      	ldrb	r3, [r3, #0]
 804bfd6:	7223      	strb	r3, [r4, #8]
	strcat((char *)gau8GSM_ATHTTPDATACOMMAND,(char *)gau8GSM_ATHTTPDATA);
 804bfd8:	4907      	ldr	r1, [pc, #28]	; (804bff8 <updateHttpDataLength+0x78>)
 804bfda:	4628      	mov	r0, r5
 804bfdc:	f005 fd76 	bl	8051acc <strcat>
	strcat((char *)gau8GSM_ATHTTPDATACOMMAND,buffer);
 804bfe0:	4669      	mov	r1, sp
 804bfe2:	4628      	mov	r0, r5
 804bfe4:	f005 fd72 	bl	8051acc <strcat>
}
 804bfe8:	46bd      	mov	sp, r7
 804bfea:	bdb0      	pop	{r4, r5, r7, pc}
 804bfec:	2000d508 	.word	0x2000d508
 804bff0:	20004214 	.word	0x20004214
 804bff4:	0805a87c 	.word	0x0805a87c
 804bff8:	200003ec 	.word	0x200003ec

0804bffc <sendSystemConfigurationSMS>:
* </table><br><br>
* <hr>
*
*******************************************************************************/
void sendSystemConfigurationSMS(void)
{
 804bffc:	b5f0      	push	{r4, r5, r6, r7, lr}
 804bffe:	b089      	sub	sp, #36	; 0x24
	/* Tor Signature */
	strcpy(gsmInstance.strSystemSMS.agsmSMSMessageBody,(char *)KLOUDQ_SIGNATURE);
 804c000:	4c91      	ldr	r4, [pc, #580]	; (804c248 <sendSystemConfigurationSMS+0x24c>)
 804c002:	4d92      	ldr	r5, [pc, #584]	; (804c24c <sendSystemConfigurationSMS+0x250>)
 804c004:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 804c006:	6020      	str	r0, [r4, #0]
 804c008:	6061      	str	r1, [r4, #4]
 804c00a:	60a2      	str	r2, [r4, #8]
 804c00c:	60e3      	str	r3, [r4, #12]
 804c00e:	882a      	ldrh	r2, [r5, #0]
 804c010:	78ab      	ldrb	r3, [r5, #2]
 804c012:	8222      	strh	r2, [r4, #16]
 804c014:	74a3      	strb	r3, [r4, #18]
	strcat(gsmInstance.strSystemSMS.agsmSMSMessageBody,(char *)"Config: \r\n");
 804c016:	4620      	mov	r0, r4
 804c018:	f7f4 f8f4 	bl	8040204 <strlen>
 804c01c:	4602      	mov	r2, r0
 804c01e:	1905      	adds	r5, r0, r4
 804c020:	4b8b      	ldr	r3, [pc, #556]	; (804c250 <sendSystemConfigurationSMS+0x254>)
 804c022:	cb03      	ldmia	r3!, {r0, r1}
 804c024:	5110      	str	r0, [r2, r4]
 804c026:	6069      	str	r1, [r5, #4]
 804c028:	881a      	ldrh	r2, [r3, #0]
 804c02a:	789b      	ldrb	r3, [r3, #2]
 804c02c:	812a      	strh	r2, [r5, #8]
 804c02e:	72ab      	strb	r3, [r5, #10]
	/*Tor Version */
	strcat(gsmInstance.strSystemSMS.agsmSMSMessageBody,(char *)"Version: \r\n");
 804c030:	4620      	mov	r0, r4
 804c032:	f7f4 f8e7 	bl	8040204 <strlen>
 804c036:	4605      	mov	r5, r0
 804c038:	1906      	adds	r6, r0, r4
 804c03a:	4b86      	ldr	r3, [pc, #536]	; (804c254 <sendSystemConfigurationSMS+0x258>)
 804c03c:	cb07      	ldmia	r3!, {r0, r1, r2}
 804c03e:	5128      	str	r0, [r5, r4]
 804c040:	6071      	str	r1, [r6, #4]
 804c042:	60b2      	str	r2, [r6, #8]
	strcat(gsmInstance.strSystemSMS.agsmSMSMessageBody,(char *)MODEL_NUMBER);
 804c044:	4620      	mov	r0, r4
 804c046:	f7f4 f8dd 	bl	8040204 <strlen>
 804c04a:	4603      	mov	r3, r0
 804c04c:	1905      	adds	r5, r0, r4
 804c04e:	4a82      	ldr	r2, [pc, #520]	; (804c258 <sendSystemConfigurationSMS+0x25c>)
 804c050:	ca03      	ldmia	r2!, {r0, r1}
 804c052:	5118      	str	r0, [r3, r4]
 804c054:	6069      	str	r1, [r5, #4]
	strcat(gsmInstance.strSystemSMS.agsmSMSMessageBody,"\r\n");
 804c056:	4620      	mov	r0, r4
 804c058:	f7f4 f8d4 	bl	8040204 <strlen>
 804c05c:	1902      	adds	r2, r0, r4
 804c05e:	4b7f      	ldr	r3, [pc, #508]	; (804c25c <sendSystemConfigurationSMS+0x260>)
 804c060:	881e      	ldrh	r6, [r3, #0]
 804c062:	789d      	ldrb	r5, [r3, #2]
 804c064:	5306      	strh	r6, [r0, r4]
 804c066:	7095      	strb	r5, [r2, #2]
	/* Tor Device Id */
	strcat(gsmInstance.strSystemSMS.agsmSMSMessageBody,(char *)"Id: ");
 804c068:	4620      	mov	r0, r4
 804c06a:	f7f4 f8cb 	bl	8040204 <strlen>
 804c06e:	4603      	mov	r3, r0
 804c070:	1901      	adds	r1, r0, r4
 804c072:	4a7b      	ldr	r2, [pc, #492]	; (804c260 <sendSystemConfigurationSMS+0x264>)
 804c074:	6810      	ldr	r0, [r2, #0]
 804c076:	5118      	str	r0, [r3, r4]
 804c078:	7913      	ldrb	r3, [r2, #4]
 804c07a:	710b      	strb	r3, [r1, #4]
	strcat(gsmInstance.strSystemSMS.agsmSMSMessageBody,buffuuid2);
 804c07c:	4979      	ldr	r1, [pc, #484]	; (804c264 <sendSystemConfigurationSMS+0x268>)
 804c07e:	4620      	mov	r0, r4
 804c080:	f005 fd24 	bl	8051acc <strcat>
	strcat(gsmInstance.strSystemSMS.agsmSMSMessageBody,buffuuid1);
 804c084:	4978      	ldr	r1, [pc, #480]	; (804c268 <sendSystemConfigurationSMS+0x26c>)
 804c086:	4620      	mov	r0, r4
 804c088:	f005 fd20 	bl	8051acc <strcat>
	strcat(gsmInstance.strSystemSMS.agsmSMSMessageBody,buffuuid0);
 804c08c:	4977      	ldr	r1, [pc, #476]	; (804c26c <sendSystemConfigurationSMS+0x270>)
 804c08e:	4620      	mov	r0, r4
 804c090:	f005 fd1c 	bl	8051acc <strcat>
	strcat(gsmInstance.strSystemSMS.agsmSMSMessageBody,"\r\n");
 804c094:	4620      	mov	r0, r4
 804c096:	f7f4 f8b5 	bl	8040204 <strlen>
 804c09a:	1903      	adds	r3, r0, r4
 804c09c:	5306      	strh	r6, [r0, r4]
 804c09e:	709d      	strb	r5, [r3, #2]
	/* Tor Signal Strength in RSSI */
	strcat(gsmInstance.strSystemSMS.agsmSMSMessageBody,(char *)"RSSI: ");
 804c0a0:	4620      	mov	r0, r4
 804c0a2:	f7f4 f8af 	bl	8040204 <strlen>
 804c0a6:	4603      	mov	r3, r0
 804c0a8:	1901      	adds	r1, r0, r4
 804c0aa:	4a71      	ldr	r2, [pc, #452]	; (804c270 <sendSystemConfigurationSMS+0x274>)
 804c0ac:	6810      	ldr	r0, [r2, #0]
 804c0ae:	5118      	str	r0, [r3, r4]
 804c0b0:	8890      	ldrh	r0, [r2, #4]
 804c0b2:	7993      	ldrb	r3, [r2, #6]
 804c0b4:	8088      	strh	r0, [r1, #4]
 804c0b6:	718b      	strb	r3, [r1, #6]
	strcat(gsmInstance.strSystemSMS.agsmSMSMessageBody,gsmInstance.agsmSignalStrength);
 804c0b8:	f6a4 51b8 	subw	r1, r4, #3512	; 0xdb8
 804c0bc:	4620      	mov	r0, r4
 804c0be:	f005 fd05 	bl	8051acc <strcat>
	strcat(gsmInstance.strSystemSMS.agsmSMSMessageBody,"\r\n");
 804c0c2:	4620      	mov	r0, r4
 804c0c4:	f7f4 f89e 	bl	8040204 <strlen>
 804c0c8:	1903      	adds	r3, r0, r4
 804c0ca:	5306      	strh	r6, [r0, r4]
 804c0cc:	709d      	strb	r5, [r3, #2]
	/* Tor Network IP , if connected */
	strcat(gsmInstance.strSystemSMS.agsmSMSMessageBody,(char *)"IP: ");
 804c0ce:	4620      	mov	r0, r4
 804c0d0:	f7f4 f898 	bl	8040204 <strlen>
 804c0d4:	4603      	mov	r3, r0
 804c0d6:	1901      	adds	r1, r0, r4
 804c0d8:	4a66      	ldr	r2, [pc, #408]	; (804c274 <sendSystemConfigurationSMS+0x278>)
 804c0da:	6810      	ldr	r0, [r2, #0]
 804c0dc:	5118      	str	r0, [r3, r4]
 804c0de:	7913      	ldrb	r3, [r2, #4]
 804c0e0:	710b      	strb	r3, [r1, #4]
	strcat(gsmInstance.strSystemSMS.agsmSMSMessageBody,gsmInstance.agsmNetworkIP);
 804c0e2:	f6a4 51ae 	subw	r1, r4, #3502	; 0xdae
 804c0e6:	4620      	mov	r0, r4
 804c0e8:	f005 fcf0 	bl	8051acc <strcat>
	strcat(gsmInstance.strSystemSMS.agsmSMSMessageBody,"\r\n");
 804c0ec:	4620      	mov	r0, r4
 804c0ee:	f7f4 f889 	bl	8040204 <strlen>
 804c0f2:	1903      	adds	r3, r0, r4
 804c0f4:	5306      	strh	r6, [r0, r4]
 804c0f6:	709d      	strb	r5, [r3, #2]
	/* Tor Network APN */
	strcat(gsmInstance.strSystemSMS.agsmSMSMessageBody,(char *)"APN: ");
 804c0f8:	4620      	mov	r0, r4
 804c0fa:	f7f4 f883 	bl	8040204 <strlen>
 804c0fe:	4603      	mov	r3, r0
 804c100:	1901      	adds	r1, r0, r4
 804c102:	4a5d      	ldr	r2, [pc, #372]	; (804c278 <sendSystemConfigurationSMS+0x27c>)
 804c104:	6810      	ldr	r0, [r2, #0]
 804c106:	5118      	str	r0, [r3, r4]
 804c108:	8893      	ldrh	r3, [r2, #4]
 804c10a:	808b      	strh	r3, [r1, #4]
	strcat(gsmInstance.strSystemSMS.agsmSMSMessageBody,gau8GSM_apn);
 804c10c:	4f5b      	ldr	r7, [pc, #364]	; (804c27c <sendSystemConfigurationSMS+0x280>)
 804c10e:	f507 7112 	add.w	r1, r7, #584	; 0x248
 804c112:	4620      	mov	r0, r4
 804c114:	f005 fcda 	bl	8051acc <strcat>
	strcat(gsmInstance.strSystemSMS.agsmSMSMessageBody,"\r\n");
 804c118:	4620      	mov	r0, r4
 804c11a:	f7f4 f873 	bl	8040204 <strlen>
 804c11e:	1903      	adds	r3, r0, r4
 804c120:	5306      	strh	r6, [r0, r4]
 804c122:	709d      	strb	r5, [r3, #2]
	/* Tor Server URL */
	strcat(gsmInstance.strSystemSMS.agsmSMSMessageBody,(char *)"URL: ");
 804c124:	4620      	mov	r0, r4
 804c126:	f7f4 f86d 	bl	8040204 <strlen>
 804c12a:	4603      	mov	r3, r0
 804c12c:	1901      	adds	r1, r0, r4
 804c12e:	4a54      	ldr	r2, [pc, #336]	; (804c280 <sendSystemConfigurationSMS+0x284>)
 804c130:	6810      	ldr	r0, [r2, #0]
 804c132:	5118      	str	r0, [r3, r4]
 804c134:	8893      	ldrh	r3, [r2, #4]
 804c136:	808b      	strh	r3, [r1, #4]
	strcat(gsmInstance.strSystemSMS.agsmSMSMessageBody,gau8GSM_url);
 804c138:	f507 7151 	add.w	r1, r7, #836	; 0x344
 804c13c:	4620      	mov	r0, r4
 804c13e:	f005 fcc5 	bl	8051acc <strcat>
	strcat(gsmInstance.strSystemSMS.agsmSMSMessageBody,"\r\n");
 804c142:	4620      	mov	r0, r4
 804c144:	f7f4 f85e 	bl	8040204 <strlen>
 804c148:	1903      	adds	r3, r0, r4
 804c14a:	5306      	strh	r6, [r0, r4]
 804c14c:	709d      	strb	r5, [r3, #2]

	/* Tor Upload Frequency */
	char ontime[10];
	char offtime[10];
	itoa(gsmInstance.u32ONPayloadUploadFreq,ontime,10);
 804c14e:	f6a4 674e 	subw	r7, r4, #3662	; 0xe4e
 804c152:	220a      	movs	r2, #10
 804c154:	a905      	add	r1, sp, #20
 804c156:	f854 0c2a 	ldr.w	r0, [r4, #-42]
 804c15a:	f005 f9f1 	bl	8051540 <itoa>
	itoa(gsmInstance.u32OFFPayloadUploadFreq,offtime,10);
 804c15e:	220a      	movs	r2, #10
 804c160:	a902      	add	r1, sp, #8
 804c162:	f854 0c26 	ldr.w	r0, [r4, #-38]
 804c166:	f005 f9eb 	bl	8051540 <itoa>
	strcat(gsmInstance.strSystemSMS.agsmSMSMessageBody,(char *)"Up Freq ON: ");
 804c16a:	4620      	mov	r0, r4
 804c16c:	f7f4 f84a 	bl	8040204 <strlen>
 804c170:	4684      	mov	ip, r0
 804c172:	eb00 0e04 	add.w	lr, r0, r4
 804c176:	4b43      	ldr	r3, [pc, #268]	; (804c284 <sendSystemConfigurationSMS+0x288>)
 804c178:	cb07      	ldmia	r3!, {r0, r1, r2}
 804c17a:	f84c 0004 	str.w	r0, [ip, r4]
 804c17e:	f8ce 1004 	str.w	r1, [lr, #4]
 804c182:	f8ce 2008 	str.w	r2, [lr, #8]
 804c186:	781b      	ldrb	r3, [r3, #0]
 804c188:	f88e 300c 	strb.w	r3, [lr, #12]
	strcat(gsmInstance.strSystemSMS.agsmSMSMessageBody,ontime);
 804c18c:	a905      	add	r1, sp, #20
 804c18e:	4620      	mov	r0, r4
 804c190:	f005 fc9c 	bl	8051acc <strcat>
	strcat(gsmInstance.strSystemSMS.agsmSMSMessageBody,"\r\n");
 804c194:	4620      	mov	r0, r4
 804c196:	f7f4 f835 	bl	8040204 <strlen>
 804c19a:	1903      	adds	r3, r0, r4
 804c19c:	5306      	strh	r6, [r0, r4]
 804c19e:	709d      	strb	r5, [r3, #2]
	strcat(gsmInstance.strSystemSMS.agsmSMSMessageBody,(char *)"Up Freq OFF: ");
 804c1a0:	4620      	mov	r0, r4
 804c1a2:	f7f4 f82f 	bl	8040204 <strlen>
 804c1a6:	4684      	mov	ip, r0
 804c1a8:	eb00 0e04 	add.w	lr, r0, r4
 804c1ac:	4b36      	ldr	r3, [pc, #216]	; (804c288 <sendSystemConfigurationSMS+0x28c>)
 804c1ae:	cb07      	ldmia	r3!, {r0, r1, r2}
 804c1b0:	f84c 0004 	str.w	r0, [ip, r4]
 804c1b4:	f8ce 1004 	str.w	r1, [lr, #4]
 804c1b8:	f8ce 2008 	str.w	r2, [lr, #8]
 804c1bc:	881b      	ldrh	r3, [r3, #0]
 804c1be:	f8ae 300c 	strh.w	r3, [lr, #12]
	strcat(gsmInstance.strSystemSMS.agsmSMSMessageBody,offtime);
 804c1c2:	a902      	add	r1, sp, #8
 804c1c4:	4620      	mov	r0, r4
 804c1c6:	f005 fc81 	bl	8051acc <strcat>
	strcat(gsmInstance.strSystemSMS.agsmSMSMessageBody,"\r\n");
 804c1ca:	4620      	mov	r0, r4
 804c1cc:	f7f4 f81a 	bl	8040204 <strlen>
 804c1d0:	1903      	adds	r3, r0, r4
 804c1d2:	5306      	strh	r6, [r0, r4]
 804c1d4:	709d      	strb	r5, [r3, #2]

	/* Last Known Location and time */
	strcat(gsmInstance.strSystemSMS.agsmSMSMessageBody,(char *)"Location: ");
 804c1d6:	4620      	mov	r0, r4
 804c1d8:	f7f4 f814 	bl	8040204 <strlen>
 804c1dc:	4602      	mov	r2, r0
 804c1de:	eb00 0c04 	add.w	ip, r0, r4
 804c1e2:	4b2a      	ldr	r3, [pc, #168]	; (804c28c <sendSystemConfigurationSMS+0x290>)
 804c1e4:	cb03      	ldmia	r3!, {r0, r1}
 804c1e6:	5110      	str	r0, [r2, r4]
 804c1e8:	f8cc 1004 	str.w	r1, [ip, #4]
 804c1ec:	881a      	ldrh	r2, [r3, #0]
 804c1ee:	789b      	ldrb	r3, [r3, #2]
 804c1f0:	f8ac 2008 	strh.w	r2, [ip, #8]
 804c1f4:	f88c 300a 	strb.w	r3, [ip, #10]
	strcat(gsmInstance.strSystemSMS.agsmSMSMessageBody,gsmInstance.agpsLocationData);
 804c1f8:	4639      	mov	r1, r7
 804c1fa:	4620      	mov	r0, r4
 804c1fc:	f005 fc66 	bl	8051acc <strcat>
	strcat(gsmInstance.strSystemSMS.agsmSMSMessageBody,"\r\n");
 804c200:	4620      	mov	r0, r4
 804c202:	f7f3 ffff 	bl	8040204 <strlen>
 804c206:	1903      	adds	r3, r0, r4
 804c208:	5306      	strh	r6, [r0, r4]
 804c20a:	709d      	strb	r5, [r3, #2]

	/*Last HTTP Status Code */
	char httpresp[5];
	itoa(u8LastHttpResponseCode,httpresp,10);
 804c20c:	220a      	movs	r2, #10
 804c20e:	4669      	mov	r1, sp
 804c210:	4b1f      	ldr	r3, [pc, #124]	; (804c290 <sendSystemConfigurationSMS+0x294>)
 804c212:	6a18      	ldr	r0, [r3, #32]
 804c214:	f005 f994 	bl	8051540 <itoa>
	strcat(gsmInstance.strSystemSMS.agsmSMSMessageBody,(char *)"HTTP Code : ");
 804c218:	4620      	mov	r0, r4
 804c21a:	f7f3 fff3 	bl	8040204 <strlen>
 804c21e:	4605      	mov	r5, r0
 804c220:	1906      	adds	r6, r0, r4
 804c222:	4b1c      	ldr	r3, [pc, #112]	; (804c294 <sendSystemConfigurationSMS+0x298>)
 804c224:	cb07      	ldmia	r3!, {r0, r1, r2}
 804c226:	5128      	str	r0, [r5, r4]
 804c228:	6071      	str	r1, [r6, #4]
 804c22a:	60b2      	str	r2, [r6, #8]
 804c22c:	781b      	ldrb	r3, [r3, #0]
 804c22e:	7333      	strb	r3, [r6, #12]
	strcat(gsmInstance.strSystemSMS.agsmSMSMessageBody,httpresp);
 804c230:	4669      	mov	r1, sp
 804c232:	4620      	mov	r0, r4
 804c234:	f005 fc4a 	bl	8051acc <strcat>
	strcat(gsmInstance.strSystemSMS.agsmSMSMessageBody,"\n");
 804c238:	4620      	mov	r0, r4
 804c23a:	f7f3 ffe3 	bl	8040204 <strlen>
 804c23e:	4b16      	ldr	r3, [pc, #88]	; (804c298 <sendSystemConfigurationSMS+0x29c>)
 804c240:	881b      	ldrh	r3, [r3, #0]
 804c242:	5223      	strh	r3, [r4, r0]
}
 804c244:	b009      	add	sp, #36	; 0x24
 804c246:	bdf0      	pop	{r4, r5, r6, r7, pc}
 804c248:	2000d1e6 	.word	0x2000d1e6
 804c24c:	0805a888 	.word	0x0805a888
 804c250:	0805a89c 	.word	0x0805a89c
 804c254:	0805a8a8 	.word	0x0805a8a8
 804c258:	0805a8b4 	.word	0x0805a8b4
 804c25c:	0805a898 	.word	0x0805a898
 804c260:	0805a8bc 	.word	0x0805a8bc
 804c264:	200088a8 	.word	0x200088a8
 804c268:	20008868 	.word	0x20008868
 804c26c:	20008888 	.word	0x20008888
 804c270:	0805a8c4 	.word	0x0805a8c4
 804c274:	0805a8cc 	.word	0x0805a8cc
 804c278:	0805a8d4 	.word	0x0805a8d4
 804c27c:	20000010 	.word	0x20000010
 804c280:	0805a8dc 	.word	0x0805a8dc
 804c284:	0805a8e4 	.word	0x0805a8e4
 804c288:	0805a8f4 	.word	0x0805a8f4
 804c28c:	0805a904 	.word	0x0805a904
 804c290:	20004214 	.word	0x20004214
 804c294:	0805a910 	.word	0x0805a910
 804c298:	080597e0 	.word	0x080597e0

0804c29c <syncrtcwithNetworkTime>:
uint32_t gu32Date = 0;
uint32_t gu32Hours = 0;
uint32_t gu32Minutes = 0;
uint32_t gu32Seconds = 0;
void syncrtcwithNetworkTime(void)
{
 804c29c:	b570      	push	{r4, r5, r6, lr}

//	if(gu32TimeSyncFlag == 1)
//		return;

	gu32Year = (((gau8GSM_TimeStamp[0]-'0') * 10) + (gau8GSM_TimeStamp[1]-'0'));
 804c29e:	4b39      	ldr	r3, [pc, #228]	; (804c384 <syncrtcwithNetworkTime+0xe8>)
 804c2a0:	f893 03fc 	ldrb.w	r0, [r3, #1020]	; 0x3fc
 804c2a4:	3830      	subs	r0, #48	; 0x30
 804c2a6:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 804c2aa:	f893 23fd 	ldrb.w	r2, [r3, #1021]	; 0x3fd
 804c2ae:	3a30      	subs	r2, #48	; 0x30
 804c2b0:	eb02 0040 	add.w	r0, r2, r0, lsl #1
 804c2b4:	4c34      	ldr	r4, [pc, #208]	; (804c388 <syncrtcwithNetworkTime+0xec>)
 804c2b6:	62a0      	str	r0, [r4, #40]	; 0x28
	gu32Month = (((gau8GSM_TimeStamp[3]-'0') * 10) + (gau8GSM_TimeStamp[4]-'0'));
 804c2b8:	f893 23ff 	ldrb.w	r2, [r3, #1023]	; 0x3ff
 804c2bc:	3a30      	subs	r2, #48	; 0x30
 804c2be:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 804c2c2:	f893 1400 	ldrb.w	r1, [r3, #1024]	; 0x400
 804c2c6:	3930      	subs	r1, #48	; 0x30
 804c2c8:	eb01 0242 	add.w	r2, r1, r2, lsl #1
 804c2cc:	62e2      	str	r2, [r4, #44]	; 0x2c
	gu32Date = (((gau8GSM_TimeStamp[6]-'0') * 10) + (gau8GSM_TimeStamp[7]-'0'));
 804c2ce:	f893 2402 	ldrb.w	r2, [r3, #1026]	; 0x402
 804c2d2:	3a30      	subs	r2, #48	; 0x30
 804c2d4:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 804c2d8:	f893 1403 	ldrb.w	r1, [r3, #1027]	; 0x403
 804c2dc:	3930      	subs	r1, #48	; 0x30
 804c2de:	eb01 0242 	add.w	r2, r1, r2, lsl #1
 804c2e2:	6322      	str	r2, [r4, #48]	; 0x30

	gu32Hours = (((gau8GSM_TimeStamp[9]-'0') * 10) + (gau8GSM_TimeStamp[10]-'0'));
 804c2e4:	f893 2405 	ldrb.w	r2, [r3, #1029]	; 0x405
 804c2e8:	3a30      	subs	r2, #48	; 0x30
 804c2ea:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 804c2ee:	f893 1406 	ldrb.w	r1, [r3, #1030]	; 0x406
 804c2f2:	3930      	subs	r1, #48	; 0x30
 804c2f4:	eb01 0242 	add.w	r2, r1, r2, lsl #1
 804c2f8:	6362      	str	r2, [r4, #52]	; 0x34
	gu32Minutes = (((gau8GSM_TimeStamp[12]-'0') * 10) + (gau8GSM_TimeStamp[13]-'0'));
 804c2fa:	f893 2408 	ldrb.w	r2, [r3, #1032]	; 0x408
 804c2fe:	3a30      	subs	r2, #48	; 0x30
 804c300:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 804c304:	f893 1409 	ldrb.w	r1, [r3, #1033]	; 0x409
 804c308:	3930      	subs	r1, #48	; 0x30
 804c30a:	eb01 0242 	add.w	r2, r1, r2, lsl #1
 804c30e:	63a2      	str	r2, [r4, #56]	; 0x38
	gu32Seconds = (((gau8GSM_TimeStamp[15]-'0') * 10) + (gau8GSM_TimeStamp[16]-'0'));
 804c310:	f893 240b 	ldrb.w	r2, [r3, #1035]	; 0x40b
 804c314:	3a30      	subs	r2, #48	; 0x30
 804c316:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 804c31a:	f893 340c 	ldrb.w	r3, [r3, #1036]	; 0x40c
 804c31e:	3b30      	subs	r3, #48	; 0x30
 804c320:	eb03 0242 	add.w	r2, r3, r2, lsl #1
 804c324:	63e2      	str	r2, [r4, #60]	; 0x3c

	SDate1.Year = DecimalToBCD(gu32Year);
 804c326:	f004 ff71 	bl	805120c <DecimalToBCD>
 804c32a:	4d18      	ldr	r5, [pc, #96]	; (804c38c <syncrtcwithNetworkTime+0xf0>)
 804c32c:	70e8      	strb	r0, [r5, #3]
	SDate1.Month = DecimalToBCD(gu32Month);
 804c32e:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 804c330:	f004 ff6c 	bl	805120c <DecimalToBCD>
 804c334:	7068      	strb	r0, [r5, #1]
	SDate1.Date = DecimalToBCD(gu32Date);
 804c336:	6b20      	ldr	r0, [r4, #48]	; 0x30
 804c338:	f004 ff68 	bl	805120c <DecimalToBCD>
 804c33c:	70a8      	strb	r0, [r5, #2]
	STime1.Hours = DecimalToBCD(gu32Hours);
 804c33e:	6b60      	ldr	r0, [r4, #52]	; 0x34
 804c340:	f004 ff64 	bl	805120c <DecimalToBCD>
 804c344:	4e12      	ldr	r6, [pc, #72]	; (804c390 <syncrtcwithNetworkTime+0xf4>)
 804c346:	7030      	strb	r0, [r6, #0]
	STime1.Minutes = DecimalToBCD(gu32Minutes);
 804c348:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 804c34a:	f004 ff5f 	bl	805120c <DecimalToBCD>
 804c34e:	7070      	strb	r0, [r6, #1]
	STime1.Seconds = DecimalToBCD(gu32Seconds);
 804c350:	6be0      	ldr	r0, [r4, #60]	; 0x3c
 804c352:	f004 ff5b 	bl	805120c <DecimalToBCD>
 804c356:	70b0      	strb	r0, [r6, #2]

	strTimeUpdate.u32RefTimeHH = gu32Hours;
 804c358:	4b0e      	ldr	r3, [pc, #56]	; (804c394 <syncrtcwithNetworkTime+0xf8>)
 804c35a:	6b62      	ldr	r2, [r4, #52]	; 0x34
 804c35c:	601a      	str	r2, [r3, #0]
	strTimeUpdate.u32RefTimeMin = gu32Minutes;
 804c35e:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 804c360:	605a      	str	r2, [r3, #4]
	strTimeUpdate.u32RefTimeSec = gu32Seconds;
 804c362:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 804c364:	609a      	str	r2, [r3, #8]

	/* Update/ Set RTC Structure */
	HAL_RTC_SetTime(&hrtc,&STime1,RTC_FORMAT_BCD);
 804c366:	4c0c      	ldr	r4, [pc, #48]	; (804c398 <syncrtcwithNetworkTime+0xfc>)
 804c368:	2201      	movs	r2, #1
 804c36a:	4631      	mov	r1, r6
 804c36c:	4620      	mov	r0, r4
 804c36e:	f7f8 fa95 	bl	804489c <HAL_RTC_SetTime>
	HAL_RTC_SetDate(&hrtc,&SDate1,RTC_FORMAT_BCD);
 804c372:	2201      	movs	r2, #1
 804c374:	4629      	mov	r1, r5
 804c376:	4620      	mov	r0, r4
 804c378:	f7f8 fb0f 	bl	804499a <HAL_RTC_SetDate>

	/* Network Time Sync complete (Indicator) */
	gu32TimeSyncFlag = 1;
 804c37c:	4b07      	ldr	r3, [pc, #28]	; (804c39c <syncrtcwithNetworkTime+0x100>)
 804c37e:	2201      	movs	r2, #1
 804c380:	601a      	str	r2, [r3, #0]
}
 804c382:	bd70      	pop	{r4, r5, r6, pc}
 804c384:	20000010 	.word	0x20000010
 804c388:	20004214 	.word	0x20004214
 804c38c:	20004f74 	.word	0x20004f74
 804c390:	20004f60 	.word	0x20004f60
 804c394:	200050bc 	.word	0x200050bc
 804c398:	2000f330 	.word	0x2000f330
 804c39c:	200050b8 	.word	0x200050b8

0804c3a0 <initHTTPURLforRemoteConfig>:
* </table><br><br>
* <hr>
*
*******************************************************************************/
void initHTTPURLforRemoteConfig(void )
{
 804c3a0:	b570      	push	{r4, r5, r6, lr}
	if(gu32OTATaskNumber == 0)
 804c3a2:	4b3c      	ldr	r3, [pc, #240]	; (804c494 <initHTTPURLforRemoteConfig+0xf4>)
 804c3a4:	f8d3 3418 	ldr.w	r3, [r3, #1048]	; 0x418
 804c3a8:	b113      	cbz	r3, 804c3b0 <initHTTPURLforRemoteConfig+0x10>
		strcat((char *)gau8GSM_ATURL,(char *)"?id=");
		strcat((char *)gau8GSM_ATURL,(char *)dinfo);
		strcat((char *)gau8GSM_ATURL,(char *)"\"");
		strcat((char *)gau8GSM_ATURL,"\r\n");
	}
	else if(gu32OTATaskNumber == 1)
 804c3aa:	2b01      	cmp	r3, #1
 804c3ac:	d034      	beq.n	804c418 <initHTTPURLforRemoteConfig+0x78>
		strcat((char *)gau8GSM_ATURL,(char *)dinfo);
		strcat((char *)gau8GSM_ATURL,(char *)"&fota=1");
		strcat((char *)gau8GSM_ATURL,(char *)"\"");
		strcat((char *)gau8GSM_ATURL,"\r\n");
	}
}
 804c3ae:	bd70      	pop	{r4, r5, r6, pc}
		memset(gau8GSM_ATURL, 0, sizeof(gau8GSM_ATURL) * sizeof(char));
 804c3b0:	4d38      	ldr	r5, [pc, #224]	; (804c494 <initHTTPURLforRemoteConfig+0xf4>)
 804c3b2:	f105 04b4 	add.w	r4, r5, #180	; 0xb4
 804c3b6:	22b4      	movs	r2, #180	; 0xb4
 804c3b8:	2100      	movs	r1, #0
 804c3ba:	4620      	mov	r0, r4
 804c3bc:	f005 fb30 	bl	8051a20 <memset>
		strcpy((char *)gau8GSM_ATURL,(char *)gau8GSM_ATHTTPPARAURL);
 804c3c0:	f505 712b 	add.w	r1, r5, #684	; 0x2ac
 804c3c4:	4620      	mov	r0, r4
 804c3c6:	f005 fb9d 	bl	8051b04 <strcpy>
		strcat((char *)gau8GSM_ATURL,(char *)"\"");
 804c3ca:	4620      	mov	r0, r4
 804c3cc:	f7f3 ff1a 	bl	8040204 <strlen>
 804c3d0:	4b31      	ldr	r3, [pc, #196]	; (804c498 <initHTTPURLforRemoteConfig+0xf8>)
 804c3d2:	881e      	ldrh	r6, [r3, #0]
 804c3d4:	5226      	strh	r6, [r4, r0]
		strcat((char *)gau8GSM_ATURL,(char *)gau8RemoteConfigurationURL);
 804c3d6:	f205 411c 	addw	r1, r5, #1052	; 0x41c
 804c3da:	4620      	mov	r0, r4
 804c3dc:	f005 fb76 	bl	8051acc <strcat>
		strcat((char *)gau8GSM_ATURL,(char *)"?id=");
 804c3e0:	4620      	mov	r0, r4
 804c3e2:	f7f3 ff0f 	bl	8040204 <strlen>
 804c3e6:	4603      	mov	r3, r0
 804c3e8:	1821      	adds	r1, r4, r0
 804c3ea:	4a2c      	ldr	r2, [pc, #176]	; (804c49c <initHTTPURLforRemoteConfig+0xfc>)
 804c3ec:	6810      	ldr	r0, [r2, #0]
 804c3ee:	50e0      	str	r0, [r4, r3]
 804c3f0:	7913      	ldrb	r3, [r2, #4]
 804c3f2:	710b      	strb	r3, [r1, #4]
		strcat((char *)gau8GSM_ATURL,(char *)dinfo);
 804c3f4:	492a      	ldr	r1, [pc, #168]	; (804c4a0 <initHTTPURLforRemoteConfig+0x100>)
 804c3f6:	4620      	mov	r0, r4
 804c3f8:	f005 fb68 	bl	8051acc <strcat>
		strcat((char *)gau8GSM_ATURL,(char *)"\"");
 804c3fc:	4620      	mov	r0, r4
 804c3fe:	f7f3 ff01 	bl	8040204 <strlen>
 804c402:	5226      	strh	r6, [r4, r0]
		strcat((char *)gau8GSM_ATURL,"\r\n");
 804c404:	4620      	mov	r0, r4
 804c406:	f7f3 fefd 	bl	8040204 <strlen>
 804c40a:	1822      	adds	r2, r4, r0
 804c40c:	4b25      	ldr	r3, [pc, #148]	; (804c4a4 <initHTTPURLforRemoteConfig+0x104>)
 804c40e:	8819      	ldrh	r1, [r3, #0]
 804c410:	789b      	ldrb	r3, [r3, #2]
 804c412:	5221      	strh	r1, [r4, r0]
 804c414:	7093      	strb	r3, [r2, #2]
 804c416:	e7ca      	b.n	804c3ae <initHTTPURLforRemoteConfig+0xe>
		memset(gau8GSM_ATURL, 0, sizeof(gau8GSM_ATURL) * sizeof(char));
 804c418:	4d1e      	ldr	r5, [pc, #120]	; (804c494 <initHTTPURLforRemoteConfig+0xf4>)
 804c41a:	f105 04b4 	add.w	r4, r5, #180	; 0xb4
 804c41e:	22b4      	movs	r2, #180	; 0xb4
 804c420:	2100      	movs	r1, #0
 804c422:	4620      	mov	r0, r4
 804c424:	f005 fafc 	bl	8051a20 <memset>
		strcpy((char *)gau8GSM_ATURL,(char *)gau8GSM_ATHTTPPARAURL);
 804c428:	f505 712b 	add.w	r1, r5, #684	; 0x2ac
 804c42c:	4620      	mov	r0, r4
 804c42e:	f005 fb69 	bl	8051b04 <strcpy>
		strcat((char *)gau8GSM_ATURL,(char *)"\"");
 804c432:	4620      	mov	r0, r4
 804c434:	f7f3 fee6 	bl	8040204 <strlen>
 804c438:	4b17      	ldr	r3, [pc, #92]	; (804c498 <initHTTPURLforRemoteConfig+0xf8>)
 804c43a:	881e      	ldrh	r6, [r3, #0]
 804c43c:	5226      	strh	r6, [r4, r0]
		strcat((char *)gau8GSM_ATURL,(char *)gau8FotaURL);
 804c43e:	f205 41b4 	addw	r1, r5, #1204	; 0x4b4
 804c442:	4620      	mov	r0, r4
 804c444:	f005 fb42 	bl	8051acc <strcat>
		strcat((char *)gau8GSM_ATURL,(char *)"?id=");
 804c448:	4620      	mov	r0, r4
 804c44a:	f7f3 fedb 	bl	8040204 <strlen>
 804c44e:	4603      	mov	r3, r0
 804c450:	1821      	adds	r1, r4, r0
 804c452:	4a12      	ldr	r2, [pc, #72]	; (804c49c <initHTTPURLforRemoteConfig+0xfc>)
 804c454:	6810      	ldr	r0, [r2, #0]
 804c456:	50e0      	str	r0, [r4, r3]
 804c458:	7913      	ldrb	r3, [r2, #4]
 804c45a:	710b      	strb	r3, [r1, #4]
		strcat((char *)gau8GSM_ATURL,(char *)dinfo);
 804c45c:	4910      	ldr	r1, [pc, #64]	; (804c4a0 <initHTTPURLforRemoteConfig+0x100>)
 804c45e:	4620      	mov	r0, r4
 804c460:	f005 fb34 	bl	8051acc <strcat>
		strcat((char *)gau8GSM_ATURL,(char *)"&fota=1");
 804c464:	4620      	mov	r0, r4
 804c466:	f7f3 fecd 	bl	8040204 <strlen>
 804c46a:	4603      	mov	r3, r0
 804c46c:	1825      	adds	r5, r4, r0
 804c46e:	4a0e      	ldr	r2, [pc, #56]	; (804c4a8 <initHTTPURLforRemoteConfig+0x108>)
 804c470:	ca03      	ldmia	r2!, {r0, r1}
 804c472:	50e0      	str	r0, [r4, r3]
 804c474:	6069      	str	r1, [r5, #4]
		strcat((char *)gau8GSM_ATURL,(char *)"\"");
 804c476:	4620      	mov	r0, r4
 804c478:	f7f3 fec4 	bl	8040204 <strlen>
 804c47c:	5226      	strh	r6, [r4, r0]
		strcat((char *)gau8GSM_ATURL,"\r\n");
 804c47e:	4620      	mov	r0, r4
 804c480:	f7f3 fec0 	bl	8040204 <strlen>
 804c484:	1822      	adds	r2, r4, r0
 804c486:	4b07      	ldr	r3, [pc, #28]	; (804c4a4 <initHTTPURLforRemoteConfig+0x104>)
 804c488:	8819      	ldrh	r1, [r3, #0]
 804c48a:	789b      	ldrb	r3, [r3, #2]
 804c48c:	5221      	strh	r1, [r4, r0]
 804c48e:	7093      	strb	r3, [r2, #2]
}
 804c490:	e78d      	b.n	804c3ae <initHTTPURLforRemoteConfig+0xe>
 804c492:	bf00      	nop
 804c494:	20000010 	.word	0x20000010
 804c498:	0805a878 	.word	0x0805a878
 804c49c:	0805a924 	.word	0x0805a924
 804c4a0:	200087e4 	.word	0x200087e4
 804c4a4:	0805a898 	.word	0x0805a898
 804c4a8:	0805a92c 	.word	0x0805a92c

0804c4ac <restoreHTTPURLforData>:
* </table><br><br>
* <hr>
*
*******************************************************************************/
void restoreHTTPURLforData(void)
{
 804c4ac:	b570      	push	{r4, r5, r6, lr}
	strcpy((char *)gau8GSM_ATURL,(char *)gau8GSM_ATHTTPPARAURL);
 804c4ae:	4d10      	ldr	r5, [pc, #64]	; (804c4f0 <restoreHTTPURLforData+0x44>)
 804c4b0:	f105 04b4 	add.w	r4, r5, #180	; 0xb4
 804c4b4:	f505 712b 	add.w	r1, r5, #684	; 0x2ac
 804c4b8:	4620      	mov	r0, r4
 804c4ba:	f005 fb23 	bl	8051b04 <strcpy>
	strcat((char *)gau8GSM_ATURL,(char *)"\"");
 804c4be:	4620      	mov	r0, r4
 804c4c0:	f7f3 fea0 	bl	8040204 <strlen>
 804c4c4:	4b0b      	ldr	r3, [pc, #44]	; (804c4f4 <restoreHTTPURLforData+0x48>)
 804c4c6:	881e      	ldrh	r6, [r3, #0]
 804c4c8:	5226      	strh	r6, [r4, r0]
	strcat((char *)gau8GSM_ATURL,(char *)gau8GSM_url);
 804c4ca:	f505 7151 	add.w	r1, r5, #836	; 0x344
 804c4ce:	4620      	mov	r0, r4
 804c4d0:	f005 fafc 	bl	8051acc <strcat>
	strcat((char *)gau8GSM_ATURL,(char *)"\"");
 804c4d4:	4620      	mov	r0, r4
 804c4d6:	f7f3 fe95 	bl	8040204 <strlen>
 804c4da:	5226      	strh	r6, [r4, r0]
	strcat((char *)gau8GSM_ATURL,"\r\n");
 804c4dc:	4620      	mov	r0, r4
 804c4de:	f7f3 fe91 	bl	8040204 <strlen>
 804c4e2:	1822      	adds	r2, r4, r0
 804c4e4:	4b04      	ldr	r3, [pc, #16]	; (804c4f8 <restoreHTTPURLforData+0x4c>)
 804c4e6:	8819      	ldrh	r1, [r3, #0]
 804c4e8:	789b      	ldrb	r3, [r3, #2]
 804c4ea:	5221      	strh	r1, [r4, r0]
 804c4ec:	7093      	strb	r3, [r2, #2]
}
 804c4ee:	bd70      	pop	{r4, r5, r6, pc}
 804c4f0:	20000010 	.word	0x20000010
 804c4f4:	0805a878 	.word	0x0805a878
 804c4f8:	0805a898 	.word	0x0805a898

0804c4fc <updateNetworkAPN>:
* </table><br><br>
* <hr>
*
*******************************************************************************/
void updateNetworkAPN(void)
{
 804c4fc:	b570      	push	{r4, r5, r6, lr}
	memset(gau8GSM_NewSetAPN, 0x00, sizeof(gau8GSM_NewSetAPN) * sizeof(char));
 804c4fe:	4c12      	ldr	r4, [pc, #72]	; (804c548 <updateNetworkAPN+0x4c>)
 804c500:	2232      	movs	r2, #50	; 0x32
 804c502:	2100      	movs	r1, #0
 804c504:	4620      	mov	r0, r4
 804c506:	f005 fa8b 	bl	8051a20 <memset>
	//gau8GSM_NewSetAPN
	strcpy((char *)gau8GSM_NewSetAPN,(char *)gau8GSM_ATSETAPN);
 804c50a:	4e10      	ldr	r6, [pc, #64]	; (804c54c <updateNetworkAPN+0x50>)
 804c50c:	f206 514c 	addw	r1, r6, #1356	; 0x54c
 804c510:	4620      	mov	r0, r4
 804c512:	f005 faf7 	bl	8051b04 <strcpy>
	strcat((char *)gau8GSM_NewSetAPN,(char *)"\"");
 804c516:	4620      	mov	r0, r4
 804c518:	f7f3 fe74 	bl	8040204 <strlen>
 804c51c:	4b0c      	ldr	r3, [pc, #48]	; (804c550 <updateNetworkAPN+0x54>)
 804c51e:	881d      	ldrh	r5, [r3, #0]
 804c520:	5225      	strh	r5, [r4, r0]
	strcat((char *)gau8GSM_NewSetAPN,(char *)gau8GSM4G_apn);
 804c522:	f506 61ac 	add.w	r1, r6, #1376	; 0x560
 804c526:	4620      	mov	r0, r4
 804c528:	f005 fad0 	bl	8051acc <strcat>
	strcat((char *)gau8GSM_NewSetAPN,(char *)"\"");
 804c52c:	4620      	mov	r0, r4
 804c52e:	f7f3 fe69 	bl	8040204 <strlen>
 804c532:	5225      	strh	r5, [r4, r0]
	strcat((char *)gau8GSM_NewSetAPN,"\r\n");
 804c534:	4620      	mov	r0, r4
 804c536:	f7f3 fe65 	bl	8040204 <strlen>
 804c53a:	1822      	adds	r2, r4, r0
 804c53c:	4b05      	ldr	r3, [pc, #20]	; (804c554 <updateNetworkAPN+0x58>)
 804c53e:	8819      	ldrh	r1, [r3, #0]
 804c540:	789b      	ldrb	r3, [r3, #2]
 804c542:	5221      	strh	r1, [r4, r0]
 804c544:	7093      	strb	r3, [r2, #2]
}
 804c546:	bd70      	pop	{r4, r5, r6, pc}
 804c548:	20004254 	.word	0x20004254
 804c54c:	20000010 	.word	0x20000010
 804c550:	0805a878 	.word	0x0805a878
 804c554:	0805a898 	.word	0x0805a898

0804c558 <updateHTTPReadLength>:
*******************************************************************************/
#define FOTAFILECHUNKSIZEBYTES	(1024)
uint32_t updateHTTPReadLength(uint32_t ConfigFileSizeBytes)
{

	if(ConfigFileSizeBytes != 0)
 804c558:	2800      	cmp	r0, #0
 804c55a:	f000 8088 	beq.w	804c66e <updateHTTPReadLength+0x116>
{
 804c55e:	b570      	push	{r4, r5, r6, lr}
	{
		/* Start of File */
		if(u32ConfigFileBaseAddress == 0)
 804c560:	4a43      	ldr	r2, [pc, #268]	; (804c670 <updateHTTPReadLength+0x118>)
 804c562:	6f52      	ldr	r2, [r2, #116]	; 0x74
 804c564:	2a00      	cmp	r2, #0
 804c566:	d041      	beq.n	804c5ec <updateHTTPReadLength+0x94>
			u32ConfigFileRemainingBytes = (ConfigFileSizeBytes % FOTAFILECHUNKSIZEBYTES);
			itoa(FOTAFILECHUNKSIZEBYTES,ConfigbufferChunkBytes,PAYLOAD_DATA_STRING_RADIX);
			itoa(u32ConfigFileRemainingBytes,bufferRemBytes,PAYLOAD_DATA_STRING_RADIX);
		}

		strcpy(gau8GSM_ATHTTPREAD,(char *)"AT+HTTPREAD=");
 804c568:	4d42      	ldr	r5, [pc, #264]	; (804c674 <updateHTTPReadLength+0x11c>)
 804c56a:	4b43      	ldr	r3, [pc, #268]	; (804c678 <updateHTTPReadLength+0x120>)
 804c56c:	f205 54d4 	addw	r4, r5, #1492	; 0x5d4
 804c570:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 804c572:	c407      	stmia	r4!, {r0, r1, r2}
 804c574:	7023      	strb	r3, [r4, #0]
		memset(buffer,0x00,sizeof(char) * sizeof(buffer));
 804c576:	f505 62be 	add.w	r2, r5, #1520	; 0x5f0
 804c57a:	2300      	movs	r3, #0
 804c57c:	f8c5 35f0 	str.w	r3, [r5, #1520]	; 0x5f0
 804c580:	f8a5 35f4 	strh.w	r3, [r5, #1524]	; 0x5f4

		if(u32ConfigFileBaseAddress < u32ConfigFileChunkCounter)
 804c584:	4b3a      	ldr	r3, [pc, #232]	; (804c670 <updateHTTPReadLength+0x118>)
 804c586:	6f5c      	ldr	r4, [r3, #116]	; 0x74
 804c588:	6f98      	ldr	r0, [r3, #120]	; 0x78
 804c58a:	4284      	cmp	r4, r0
 804c58c:	d343      	bcc.n	804c616 <updateHTTPReadLength+0xbe>
			return 2;
		}
		else
		{
//			itoa(u32ConfigFileChunkCounter * 2000,buffer,PAYLOAD_DATA_STRING_RADIX);
			itoa(u32ConfigFileChunkCounter * FOTAFILECHUNKSIZEBYTES,buffer,PAYLOAD_DATA_STRING_RADIX);
 804c58e:	4d39      	ldr	r5, [pc, #228]	; (804c674 <updateHTTPReadLength+0x11c>)
 804c590:	f505 66be 	add.w	r6, r5, #1520	; 0x5f0
 804c594:	220a      	movs	r2, #10
 804c596:	4631      	mov	r1, r6
 804c598:	4090      	lsls	r0, r2
 804c59a:	f004 ffd1 	bl	8051540 <itoa>
			strcat(gau8GSM_ATHTTPREAD,(char *)buffer);
 804c59e:	f205 54d4 	addw	r4, r5, #1492	; 0x5d4
 804c5a2:	4631      	mov	r1, r6
 804c5a4:	4620      	mov	r0, r4
 804c5a6:	f005 fa91 	bl	8051acc <strcat>
			strcat(gau8GSM_ATHTTPREAD,(char *)",");
 804c5aa:	4620      	mov	r0, r4
 804c5ac:	f7f3 fe2a 	bl	8040204 <strlen>
 804c5b0:	4b32      	ldr	r3, [pc, #200]	; (804c67c <updateHTTPReadLength+0x124>)
 804c5b2:	881b      	ldrh	r3, [r3, #0]
 804c5b4:	5223      	strh	r3, [r4, r0]
			strcat(gau8GSM_ATHTTPREAD,(char *)bufferRemBytes); /* Byte(s) Chunk to read*/
 804c5b6:	f205 51cc 	addw	r1, r5, #1484	; 0x5cc
 804c5ba:	4620      	mov	r0, r4
 804c5bc:	f005 fa86 	bl	8051acc <strcat>
			strcat(gau8GSM_ATHTTPREAD,(char *)"\r\n");
 804c5c0:	4620      	mov	r0, r4
 804c5c2:	f7f3 fe1f 	bl	8040204 <strlen>
 804c5c6:	1822      	adds	r2, r4, r0
 804c5c8:	4b2d      	ldr	r3, [pc, #180]	; (804c680 <updateHTTPReadLength+0x128>)
 804c5ca:	8819      	ldrh	r1, [r3, #0]
 804c5cc:	789b      	ldrb	r3, [r3, #2]
 804c5ce:	5221      	strh	r1, [r4, r0]
 804c5d0:	7093      	strb	r3, [r2, #2]
			gsmInstance.gu32RemoteConfigSizeinBytes = u32ConfigFileRemainingBytes;
 804c5d2:	4b27      	ldr	r3, [pc, #156]	; (804c670 <updateHTTPReadLength+0x118>)
 804c5d4:	6fd9      	ldr	r1, [r3, #124]	; 0x7c
 804c5d6:	4a2b      	ldr	r2, [pc, #172]	; (804c684 <updateHTTPReadLength+0x12c>)
 804c5d8:	f8c2 1e30 	str.w	r1, [r2, #3632]	; 0xe30
			u32ConfigFileBaseAddress = 0;
 804c5dc:	2200      	movs	r2, #0
 804c5de:	675a      	str	r2, [r3, #116]	; 0x74
			u32ConfigFileChunkCounter = 0;
 804c5e0:	679a      	str	r2, [r3, #120]	; 0x78
			u32ConfigFileRemainingBytes = 0;
 804c5e2:	67da      	str	r2, [r3, #124]	; 0x7c
			u32ConfigFileReadComplete = 1;
 804c5e4:	2001      	movs	r0, #1
 804c5e6:	f8c3 0080 	str.w	r0, [r3, #128]	; 0x80
			return 1;
		}
	}
	else
		return 0;
}
 804c5ea:	bd70      	pop	{r4, r5, r6, pc}
			u32ConfigFileChunkCounter = (ConfigFileSizeBytes / FOTAFILECHUNKSIZEBYTES);
 804c5ec:	0a82      	lsrs	r2, r0, #10
 804c5ee:	4c20      	ldr	r4, [pc, #128]	; (804c670 <updateHTTPReadLength+0x118>)
 804c5f0:	67a2      	str	r2, [r4, #120]	; 0x78
			u32ConfigFileRemainingBytes = (ConfigFileSizeBytes % FOTAFILECHUNKSIZEBYTES);
 804c5f2:	f3c0 0309 	ubfx	r3, r0, #0, #10
 804c5f6:	67e3      	str	r3, [r4, #124]	; 0x7c
			itoa(FOTAFILECHUNKSIZEBYTES,ConfigbufferChunkBytes,PAYLOAD_DATA_STRING_RADIX);
 804c5f8:	4d1e      	ldr	r5, [pc, #120]	; (804c674 <updateHTTPReadLength+0x11c>)
 804c5fa:	220a      	movs	r2, #10
 804c5fc:	f205 51c4 	addw	r1, r5, #1476	; 0x5c4
 804c600:	f44f 6080 	mov.w	r0, #1024	; 0x400
 804c604:	f004 ff9c 	bl	8051540 <itoa>
			itoa(u32ConfigFileRemainingBytes,bufferRemBytes,PAYLOAD_DATA_STRING_RADIX);
 804c608:	220a      	movs	r2, #10
 804c60a:	f205 51cc 	addw	r1, r5, #1484	; 0x5cc
 804c60e:	6fe0      	ldr	r0, [r4, #124]	; 0x7c
 804c610:	f004 ff96 	bl	8051540 <itoa>
 804c614:	e7a8      	b.n	804c568 <updateHTTPReadLength+0x10>
			itoa((u32ConfigFileBaseAddress * FOTAFILECHUNKSIZEBYTES),buffer,PAYLOAD_DATA_STRING_RADIX);
 804c616:	4616      	mov	r6, r2
 804c618:	220a      	movs	r2, #10
 804c61a:	4631      	mov	r1, r6
 804c61c:	fa04 f002 	lsl.w	r0, r4, r2
 804c620:	f004 ff8e 	bl	8051540 <itoa>
			strcat(gau8GSM_ATHTTPREAD,(char *)buffer);
 804c624:	f205 54d4 	addw	r4, r5, #1492	; 0x5d4
 804c628:	4631      	mov	r1, r6
 804c62a:	4620      	mov	r0, r4
 804c62c:	f005 fa4e 	bl	8051acc <strcat>
			strcat(gau8GSM_ATHTTPREAD,(char *)",");
 804c630:	4620      	mov	r0, r4
 804c632:	f7f3 fde7 	bl	8040204 <strlen>
 804c636:	4b11      	ldr	r3, [pc, #68]	; (804c67c <updateHTTPReadLength+0x124>)
 804c638:	881b      	ldrh	r3, [r3, #0]
 804c63a:	5223      	strh	r3, [r4, r0]
			strcat(gau8GSM_ATHTTPREAD,(char *)ConfigbufferChunkBytes); /* Byte(s) Chunk to read*/
 804c63c:	f205 51c4 	addw	r1, r5, #1476	; 0x5c4
 804c640:	4620      	mov	r0, r4
 804c642:	f005 fa43 	bl	8051acc <strcat>
			strcat(gau8GSM_ATHTTPREAD,(char *)"\r\n");
 804c646:	4620      	mov	r0, r4
 804c648:	f7f3 fddc 	bl	8040204 <strlen>
 804c64c:	1822      	adds	r2, r4, r0
 804c64e:	4b0c      	ldr	r3, [pc, #48]	; (804c680 <updateHTTPReadLength+0x128>)
 804c650:	8819      	ldrh	r1, [r3, #0]
 804c652:	789b      	ldrb	r3, [r3, #2]
 804c654:	5221      	strh	r1, [r4, r0]
 804c656:	7093      	strb	r3, [r2, #2]
			u32ConfigFileBaseAddress++;
 804c658:	4a05      	ldr	r2, [pc, #20]	; (804c670 <updateHTTPReadLength+0x118>)
 804c65a:	6f53      	ldr	r3, [r2, #116]	; 0x74
 804c65c:	3301      	adds	r3, #1
 804c65e:	6753      	str	r3, [r2, #116]	; 0x74
			gsmInstance.gu32RemoteConfigSizeinBytes = FOTAFILECHUNKSIZEBYTES;
 804c660:	4b08      	ldr	r3, [pc, #32]	; (804c684 <updateHTTPReadLength+0x12c>)
 804c662:	f44f 6280 	mov.w	r2, #1024	; 0x400
 804c666:	f8c3 2e30 	str.w	r2, [r3, #3632]	; 0xe30
			return 2;
 804c66a:	2002      	movs	r0, #2
 804c66c:	e7bd      	b.n	804c5ea <updateHTTPReadLength+0x92>
}
 804c66e:	4770      	bx	lr
 804c670:	20004214 	.word	0x20004214
 804c674:	20000010 	.word	0x20000010
 804c678:	0805a934 	.word	0x0805a934
 804c67c:	0805a920 	.word	0x0805a920
 804c680:	0805a898 	.word	0x0805a898
 804c684:	2000c398 	.word	0x2000c398

0804c688 <sendGSMCommand>:
{
 804c688:	b570      	push	{r4, r5, r6, lr}
	switch (gsmInstance.enmGSMCommandResponseState)
 804c68a:	4ba8      	ldr	r3, [pc, #672]	; (804c92c <sendGSMCommand+0x2a4>)
 804c68c:	f893 3e3c 	ldrb.w	r3, [r3, #3644]	; 0xe3c
 804c690:	b123      	cbz	r3, 804c69c <sendGSMCommand+0x14>
 804c692:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 804c696:	2a01      	cmp	r2, #1
 804c698:	d076      	beq.n	804c788 <sendGSMCommand+0x100>
}
 804c69a:	bd70      	pop	{r4, r5, r6, pc}
			if(gsmInstance.enmGSMCommandState == enmGSM_CMDSEND)
 804c69c:	4ba3      	ldr	r3, [pc, #652]	; (804c92c <sendGSMCommand+0x2a4>)
 804c69e:	f893 3e3d 	ldrb.w	r3, [r3, #3645]	; 0xe3d
 804c6a2:	b2db      	uxtb	r3, r3
 804c6a4:	2b01      	cmp	r3, #1
 804c6a6:	d01b      	beq.n	804c6e0 <sendGSMCommand+0x58>
			else if(gsmInstance.enmGSMCommandState == enmGSM_CMDINPROCESS)
 804c6a8:	4ba0      	ldr	r3, [pc, #640]	; (804c92c <sendGSMCommand+0x2a4>)
 804c6aa:	f893 3e3d 	ldrb.w	r3, [r3, #3645]	; 0xe3d
 804c6ae:	b2db      	uxtb	r3, r3
 804c6b0:	2b02      	cmp	r3, #2
 804c6b2:	d166      	bne.n	804c782 <sendGSMCommand+0xfa>
  * @param  USARTx USART Instance
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_USART_IsActiveFlag_TXE(USART_TypeDef *USARTx)
{
  return (READ_BIT(USARTx->SR, USART_SR_TXE) == (USART_SR_TXE));
 804c6b4:	4b9e      	ldr	r3, [pc, #632]	; (804c930 <sendGSMCommand+0x2a8>)
 804c6b6:	681b      	ldr	r3, [r3, #0]
				if(!LL_USART_IsActiveFlag_TXE(UART4))
 804c6b8:	f013 0f80 	tst.w	r3, #128	; 0x80
 804c6bc:	d0ed      	beq.n	804c69a <sendGSMCommand+0x12>
					if(u8LoopCounter < (u8CharacterCounter))
 804c6be:	4a9d      	ldr	r2, [pc, #628]	; (804c934 <sendGSMCommand+0x2ac>)
 804c6c0:	f8d2 3084 	ldr.w	r3, [r2, #132]	; 0x84
 804c6c4:	f8d2 208c 	ldr.w	r2, [r2, #140]	; 0x8c
 804c6c8:	4293      	cmp	r3, r2
 804c6ca:	d236      	bcs.n	804c73a <sendGSMCommand+0xb2>
						LL_USART_TransmitData8(UART4,command[u8LoopCounter++]);
 804c6cc:	4a99      	ldr	r2, [pc, #612]	; (804c934 <sendGSMCommand+0x2ac>)
 804c6ce:	f8d2 1088 	ldr.w	r1, [r2, #136]	; 0x88
 804c6d2:	1c58      	adds	r0, r3, #1
 804c6d4:	f8c2 0084 	str.w	r0, [r2, #132]	; 0x84
 804c6d8:	5cca      	ldrb	r2, [r1, r3]
  * @param  Value between Min_Data=0x00 and Max_Data=0xFF
  * @retval None
  */
__STATIC_INLINE void LL_USART_TransmitData8(USART_TypeDef *USARTx, uint8_t Value)
{
  USARTx->DR = Value;
 804c6da:	4b95      	ldr	r3, [pc, #596]	; (804c930 <sendGSMCommand+0x2a8>)
 804c6dc:	605a      	str	r2, [r3, #4]
}
 804c6de:	e7dc      	b.n	804c69a <sendGSMCommand+0x12>
				u8LoopCounter = 0;
 804c6e0:	4b94      	ldr	r3, [pc, #592]	; (804c934 <sendGSMCommand+0x2ac>)
 804c6e2:	2200      	movs	r2, #0
 804c6e4:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
				if(gsmInstance.enmGSMCommand == enmGSMSTATE_SENDDATA)
 804c6e8:	4b90      	ldr	r3, [pc, #576]	; (804c92c <sendGSMCommand+0x2a4>)
 804c6ea:	f893 3e3f 	ldrb.w	r3, [r3, #3647]	; 0xe3f
 804c6ee:	2b15      	cmp	r3, #21
 804c6f0:	d01a      	beq.n	804c728 <sendGSMCommand+0xa0>
					command = gsmStateTableArray[gsmInstance.enmGSMCommand].atCommand;
 804c6f2:	4a91      	ldr	r2, [pc, #580]	; (804c938 <sendGSMCommand+0x2b0>)
 804c6f4:	eb02 1303 	add.w	r3, r2, r3, lsl #4
 804c6f8:	f8d3 25f8 	ldr.w	r2, [r3, #1528]	; 0x5f8
 804c6fc:	4b8d      	ldr	r3, [pc, #564]	; (804c934 <sendGSMCommand+0x2ac>)
 804c6fe:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
				u8CharacterCounter = strlen((const char *)command);
 804c702:	4c8c      	ldr	r4, [pc, #560]	; (804c934 <sendGSMCommand+0x2ac>)
 804c704:	f8d4 5088 	ldr.w	r5, [r4, #136]	; 0x88
 804c708:	4628      	mov	r0, r5
 804c70a:	f7f3 fd7b 	bl	8040204 <strlen>
 804c70e:	f8c4 008c 	str.w	r0, [r4, #140]	; 0x8c
				LL_USART_TransmitData8(UART4,command[u8LoopCounter++]);
 804c712:	2301      	movs	r3, #1
 804c714:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
 804c718:	782a      	ldrb	r2, [r5, #0]
  USARTx->DR = Value;
 804c71a:	4b85      	ldr	r3, [pc, #532]	; (804c930 <sendGSMCommand+0x2a8>)
 804c71c:	605a      	str	r2, [r3, #4]
				gsmInstance.enmGSMCommandState = enmGSM_CMDINPROCESS;
 804c71e:	4b83      	ldr	r3, [pc, #524]	; (804c92c <sendGSMCommand+0x2a4>)
 804c720:	2202      	movs	r2, #2
 804c722:	f883 2e3d 	strb.w	r2, [r3, #3645]	; 0xe3d
 804c726:	e7b8      	b.n	804c69a <sendGSMCommand+0x12>
					command = gsmPayload.data[gsmPayload.tail];
 804c728:	4a84      	ldr	r2, [pc, #528]	; (804c93c <sendGSMCommand+0x2b4>)
 804c72a:	6853      	ldr	r3, [r2, #4]
 804c72c:	3302      	adds	r3, #2
 804c72e:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 804c732:	4b80      	ldr	r3, [pc, #512]	; (804c934 <sendGSMCommand+0x2ac>)
 804c734:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
 804c738:	e7e3      	b.n	804c702 <sendGSMCommand+0x7a>
						u8LoopCounter = 0;
 804c73a:	4b7e      	ldr	r3, [pc, #504]	; (804c934 <sendGSMCommand+0x2ac>)
 804c73c:	2200      	movs	r2, #0
 804c73e:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
						gu32GSMCharacterTimeout = FIVEHUNDRED_MS;
 804c742:	497f      	ldr	r1, [pc, #508]	; (804c940 <sendGSMCommand+0x2b8>)
 804c744:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 804c748:	6008      	str	r0, [r1, #0]
						u8CharacterCounter = 0;
 804c74a:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
						gsmInstance.enmGSMCommandResponseState = enmGSM_CHKRESPONSE;
 804c74e:	4b77      	ldr	r3, [pc, #476]	; (804c92c <sendGSMCommand+0x2a4>)
 804c750:	2201      	movs	r2, #1
 804c752:	f883 2e3c 	strb.w	r2, [r3, #3644]	; 0xe3c
						gsmInstance.u32GSMResponseTimer = gsmStateTableArray[gsmInstance.enmGSMCommand].msTimeOut;
 804c756:	f893 1e3f 	ldrb.w	r1, [r3, #3647]	; 0xe3f
 804c75a:	4a77      	ldr	r2, [pc, #476]	; (804c938 <sendGSMCommand+0x2b0>)
 804c75c:	eb02 1201 	add.w	r2, r2, r1, lsl #4
 804c760:	f8d2 2600 	ldr.w	r2, [r2, #1536]	; 0x600
 804c764:	f8c3 2e34 	str.w	r2, [r3, #3636]	; 0xe34
						if((gsmInstance.enmGSMCommand == enmGSMSTATE_FOTAHTTPACTION) || (gsmInstance.enmGSMCommand == enmGSMSTATE_HTTPACTION))
 804c768:	2922      	cmp	r1, #34	; 0x22
 804c76a:	d005      	beq.n	804c778 <sendGSMCommand+0xf0>
 804c76c:	2916      	cmp	r1, #22
 804c76e:	d003      	beq.n	804c778 <sendGSMCommand+0xf0>
							gu32FotaFileReadTimer = 0;
 804c770:	4b74      	ldr	r3, [pc, #464]	; (804c944 <sendGSMCommand+0x2bc>)
 804c772:	2200      	movs	r2, #0
 804c774:	601a      	str	r2, [r3, #0]
 804c776:	e790      	b.n	804c69a <sendGSMCommand+0x12>
							gu32FotaFileReadTimer = FIFTEEN_SEC;
 804c778:	4b72      	ldr	r3, [pc, #456]	; (804c944 <sendGSMCommand+0x2bc>)
 804c77a:	f643 2298 	movw	r2, #15000	; 0x3a98
 804c77e:	601a      	str	r2, [r3, #0]
 804c780:	e78b      	b.n	804c69a <sendGSMCommand+0x12>
				initGSMSIM868();
 804c782:	f7ff fb1d 	bl	804bdc0 <initGSMSIM868>
 804c786:	e788      	b.n	804c69a <sendGSMCommand+0x12>
			if((gu32GSMCharacterTimeout == 0) && (gsmInstance.u32GSMResponseTimer != 0) && (u8GSMCharRcv == 1) && (gu32FotaFileReadTimer == 0))
 804c788:	4b6d      	ldr	r3, [pc, #436]	; (804c940 <sendGSMCommand+0x2b8>)
 804c78a:	681b      	ldr	r3, [r3, #0]
 804c78c:	b93b      	cbnz	r3, 804c79e <sendGSMCommand+0x116>
 804c78e:	4b67      	ldr	r3, [pc, #412]	; (804c92c <sendGSMCommand+0x2a4>)
 804c790:	f8d3 3e34 	ldr.w	r3, [r3, #3636]	; 0xe34
 804c794:	b11b      	cbz	r3, 804c79e <sendGSMCommand+0x116>
 804c796:	4b6c      	ldr	r3, [pc, #432]	; (804c948 <sendGSMCommand+0x2c0>)
 804c798:	681b      	ldr	r3, [r3, #0]
 804c79a:	2b01      	cmp	r3, #1
 804c79c:	d026      	beq.n	804c7ec <sendGSMCommand+0x164>
			else if(gsmInstance.u32GSMResponseTimer == 0)
 804c79e:	4b63      	ldr	r3, [pc, #396]	; (804c92c <sendGSMCommand+0x2a4>)
 804c7a0:	f8d3 3e34 	ldr.w	r3, [r3, #3636]	; 0xe34
 804c7a4:	2b00      	cmp	r3, #0
 804c7a6:	f47f af78 	bne.w	804c69a <sendGSMCommand+0x12>
				gsmInstance.u8gsmRetryCount--;
 804c7aa:	4a60      	ldr	r2, [pc, #384]	; (804c92c <sendGSMCommand+0x2a4>)
 804c7ac:	f892 3e18 	ldrb.w	r3, [r2, #3608]	; 0xe18
 804c7b0:	3b01      	subs	r3, #1
 804c7b2:	b2db      	uxtb	r3, r3
 804c7b4:	f882 3e18 	strb.w	r3, [r2, #3608]	; 0xe18
				if(gsmInstance.u8gsmRetryCount == 0)
 804c7b8:	2b00      	cmp	r3, #0
 804c7ba:	f040 8447 	bne.w	804d04c <sendGSMCommand+0x9c4>
					memset((char *)gsmInstance.as8GSM_Response_Buff, GSM_ARRAY_INIT_CHAR, (GSM_RESPONSE_ARRAY_SIZE));
 804c7be:	f202 4452 	addw	r4, r2, #1106	; 0x452
 804c7c2:	f640 12c4 	movw	r2, #2500	; 0x9c4
 804c7c6:	2100      	movs	r1, #0
 804c7c8:	4620      	mov	r0, r4
 804c7ca:	f005 f929 	bl	8051a20 <memset>
					if(gsmInstance.enmcurrentTask == enmGSMTASK_UPLOADDATA)
 804c7ce:	f894 39ec 	ldrb.w	r3, [r4, #2540]	; 0x9ec
 804c7d2:	b2db      	uxtb	r3, r3
 804c7d4:	2b03      	cmp	r3, #3
 804c7d6:	f000 8433 	beq.w	804d040 <sendGSMCommand+0x9b8>
					initGSMSIM868();
 804c7da:	f7ff faf1 	bl	804bdc0 <initGSMSIM868>
				gsmInstance.u32GSMResponseTimer = 0;
 804c7de:	2300      	movs	r3, #0
 804c7e0:	4a52      	ldr	r2, [pc, #328]	; (804c92c <sendGSMCommand+0x2a4>)
 804c7e2:	f8c2 3e34 	str.w	r3, [r2, #3636]	; 0xe34
				u8GSMCharRcv = 0;
 804c7e6:	4a58      	ldr	r2, [pc, #352]	; (804c948 <sendGSMCommand+0x2c0>)
 804c7e8:	6013      	str	r3, [r2, #0]
}
 804c7ea:	e756      	b.n	804c69a <sendGSMCommand+0x12>
			if((gu32GSMCharacterTimeout == 0) && (gsmInstance.u32GSMResponseTimer != 0) && (u8GSMCharRcv == 1) && (gu32FotaFileReadTimer == 0))
 804c7ec:	4b55      	ldr	r3, [pc, #340]	; (804c944 <sendGSMCommand+0x2bc>)
 804c7ee:	681b      	ldr	r3, [r3, #0]
 804c7f0:	2b00      	cmp	r3, #0
 804c7f2:	d1d4      	bne.n	804c79e <sendGSMCommand+0x116>
						,(const char *)gsmStateTableArray[gsmInstance.enmGSMCommand].atCommandResponse) != NULL)
 804c7f4:	484d      	ldr	r0, [pc, #308]	; (804c92c <sendGSMCommand+0x2a4>)
 804c7f6:	f890 4e3f 	ldrb.w	r4, [r0, #3647]	; 0xe3f
				if(strstr((const char *)gsmInstance.as8GSM_Response_Buff
 804c7fa:	4b4f      	ldr	r3, [pc, #316]	; (804c938 <sendGSMCommand+0x2b0>)
 804c7fc:	eb03 1304 	add.w	r3, r3, r4, lsl #4
 804c800:	f8d3 15fc 	ldr.w	r1, [r3, #1532]	; 0x5fc
 804c804:	f200 4052 	addw	r0, r0, #1106	; 0x452
 804c808:	f005 f9a9 	bl	8051b5e <strstr>
 804c80c:	2800      	cmp	r0, #0
 804c80e:	f000 83f9 	beq.w	804d004 <sendGSMCommand+0x97c>
					switch(gsmInstance.enmGSMCommand)
 804c812:	2c23      	cmp	r4, #35	; 0x23
 804c814:	f200 83c3 	bhi.w	804cf9e <sendGSMCommand+0x916>
 804c818:	e8df f014 	tbh	[pc, r4, lsl #1]
 804c81c:	004e0024 	.word	0x004e0024
 804c820:	005300de 	.word	0x005300de
 804c824:	00790074 	.word	0x00790074
 804c828:	0083007e 	.word	0x0083007e
 804c82c:	00cf00a0 	.word	0x00cf00a0
 804c830:	00d900d4 	.word	0x00d900d4
 804c834:	00ed00e8 	.word	0x00ed00e8
 804c838:	010400ff 	.word	0x010400ff
 804c83c:	01930109 	.word	0x01930109
 804c840:	0121011c 	.word	0x0121011c
 804c844:	01390128 	.word	0x01390128
 804c848:	0198013e 	.word	0x0198013e
 804c84c:	01e300e3 	.word	0x01e300e3
 804c850:	01e801de 	.word	0x01e801de
 804c854:	002801fe 	.word	0x002801fe
 804c858:	02170203 	.word	0x02170203
 804c85c:	0221021c 	.word	0x0221021c
 804c860:	02990246 	.word	0x02990246
							gsmInstance.u8IncrementGsmState = TRUE;
 804c864:	4b31      	ldr	r3, [pc, #196]	; (804c92c <sendGSMCommand+0x2a4>)
 804c866:	2201      	movs	r2, #1
 804c868:	f883 2e1c 	strb.w	r2, [r3, #3612]	; 0xe1c
					gsmInstance.u8GSM_Response_Character_Counter = 0;
 804c86c:	4b2f      	ldr	r3, [pc, #188]	; (804c92c <sendGSMCommand+0x2a4>)
 804c86e:	2200      	movs	r2, #0
 804c870:	f8c3 2e38 	str.w	r2, [r3, #3640]	; 0xe38
					gsmInstance.enmGSMCommandState = enmGSM_CMDSEND;
 804c874:	2101      	movs	r1, #1
 804c876:	f883 1e3d 	strb.w	r1, [r3, #3645]	; 0xe3d
					gsmInstance.enmGSMCommandResponseState = enmGSM_SENDCMD;
 804c87a:	f883 2e3c 	strb.w	r2, [r3, #3644]	; 0xe3c
					gsmInstance.u8gsmRetryCount = GSM_MAX_RETRY;
 804c87e:	2105      	movs	r1, #5
 804c880:	f883 1e18 	strb.w	r1, [r3, #3608]	; 0xe18
					gsmInstance.u32GSMResponseTimer = 0;
 804c884:	f8c3 2e34 	str.w	r2, [r3, #3636]	; 0xe34
					u8GSMCharRcv = 0;
 804c888:	492f      	ldr	r1, [pc, #188]	; (804c948 <sendGSMCommand+0x2c0>)
 804c88a:	600a      	str	r2, [r1, #0]
					gsmInstance.u8GSM_Response_Character_Counter = 0;
 804c88c:	f8c3 2e38 	str.w	r2, [r3, #3640]	; 0xe38
					if(gsmInstance.enmGSMCommand != enmGSMSTATE_READFILE)
 804c890:	f893 4e3f 	ldrb.w	r4, [r3, #3647]	; 0xe3f
 804c894:	2c23      	cmp	r4, #35	; 0x23
 804c896:	f040 83ad 	bne.w	804cff4 <sendGSMCommand+0x96c>
					if(gsmInstance.u8IncrementGsmState == TRUE)
 804c89a:	4b24      	ldr	r3, [pc, #144]	; (804c92c <sendGSMCommand+0x2a4>)
 804c89c:	f893 3e1c 	ldrb.w	r3, [r3, #3612]	; 0xe1c
 804c8a0:	2b01      	cmp	r3, #1
 804c8a2:	f47f aefa 	bne.w	804c69a <sendGSMCommand+0x12>
						gsmInstance.enmGSMCommand++;
 804c8a6:	4b21      	ldr	r3, [pc, #132]	; (804c92c <sendGSMCommand+0x2a4>)
 804c8a8:	3401      	adds	r4, #1
 804c8aa:	f883 4e3f 	strb.w	r4, [r3, #3647]	; 0xe3f
						gsmInstance.u32GSMTimer = ONE_SEC;
 804c8ae:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 804c8b2:	f8c3 2e20 	str.w	r2, [r3, #3616]	; 0xe20
 804c8b6:	e6f0      	b.n	804c69a <sendGSMCommand+0x12>
							gsmInstance.u8IncrementGsmState = TRUE;
 804c8b8:	4b1c      	ldr	r3, [pc, #112]	; (804c92c <sendGSMCommand+0x2a4>)
 804c8ba:	2201      	movs	r2, #1
 804c8bc:	f883 2e1c 	strb.w	r2, [r3, #3612]	; 0xe1c
							break;
 804c8c0:	e7d4      	b.n	804c86c <sendGSMCommand+0x1e4>
								char * strLoc = strstr((const char *)gsmInstance.as8GSM_Response_Buff
 804c8c2:	4e22      	ldr	r6, [pc, #136]	; (804c94c <sendGSMCommand+0x2c4>)
 804c8c4:	4922      	ldr	r1, [pc, #136]	; (804c950 <sendGSMCommand+0x2c8>)
 804c8c6:	4630      	mov	r0, r6
 804c8c8:	f005 f949 	bl	8051b5e <strstr>
 804c8cc:	4604      	mov	r4, r0
								memset(gau8GSM_TimeStamp,0x00,(sizeof(char ) * strlen(gau8GSM_TimeStamp)));
 804c8ce:	4d21      	ldr	r5, [pc, #132]	; (804c954 <sendGSMCommand+0x2cc>)
 804c8d0:	4628      	mov	r0, r5
 804c8d2:	f7f3 fc97 	bl	8040204 <strlen>
 804c8d6:	4602      	mov	r2, r0
 804c8d8:	2100      	movs	r1, #0
 804c8da:	4628      	mov	r0, r5
 804c8dc:	f005 f8a0 	bl	8051a20 <memset>
								memcpy( gau8GSM_TimeStamp, &strLoc[8], strlen(strtok(&strLoc[8],"\r")));
 804c8e0:	3408      	adds	r4, #8
 804c8e2:	491d      	ldr	r1, [pc, #116]	; (804c958 <sendGSMCommand+0x2d0>)
 804c8e4:	4620      	mov	r0, r4
 804c8e6:	f005 ff85 	bl	80527f4 <strtok>
 804c8ea:	f7f3 fc8b 	bl	8040204 <strlen>
 804c8ee:	4602      	mov	r2, r0
 804c8f0:	4621      	mov	r1, r4
 804c8f2:	4628      	mov	r0, r5
 804c8f4:	f005 f886 	bl	8051a04 <memcpy>
								syncrtcwithNetworkTime();
 804c8f8:	f7ff fcd0 	bl	804c29c <syncrtcwithNetworkTime>
								gsmInstance.u8IncrementGsmState = TRUE;
 804c8fc:	2301      	movs	r3, #1
 804c8fe:	f886 39ca 	strb.w	r3, [r6, #2506]	; 0x9ca
							break;
 804c902:	e7b3      	b.n	804c86c <sendGSMCommand+0x1e4>
							gsmInstance.u8IncrementGsmState = TRUE;
 804c904:	4b09      	ldr	r3, [pc, #36]	; (804c92c <sendGSMCommand+0x2a4>)
 804c906:	2201      	movs	r2, #1
 804c908:	f883 2e1c 	strb.w	r2, [r3, #3612]	; 0xe1c
							break;
 804c90c:	e7ae      	b.n	804c86c <sendGSMCommand+0x1e4>
							gsmInstance.u8IncrementGsmState = TRUE;
 804c90e:	4b07      	ldr	r3, [pc, #28]	; (804c92c <sendGSMCommand+0x2a4>)
 804c910:	2201      	movs	r2, #1
 804c912:	f883 2e1c 	strb.w	r2, [r3, #3612]	; 0xe1c
							break;
 804c916:	e7a9      	b.n	804c86c <sendGSMCommand+0x1e4>
							gsmInstance.u8IncrementGsmState = TRUE;
 804c918:	4b04      	ldr	r3, [pc, #16]	; (804c92c <sendGSMCommand+0x2a4>)
 804c91a:	2201      	movs	r2, #1
 804c91c:	f883 2e1c 	strb.w	r2, [r3, #3612]	; 0xe1c
							break;
 804c920:	e7a4      	b.n	804c86c <sendGSMCommand+0x1e4>
							gsmInstance.u8IncrementGsmState = TRUE;
 804c922:	4b02      	ldr	r3, [pc, #8]	; (804c92c <sendGSMCommand+0x2a4>)
 804c924:	2201      	movs	r2, #1
 804c926:	f883 2e1c 	strb.w	r2, [r3, #3612]	; 0xe1c
							break;
 804c92a:	e79f      	b.n	804c86c <sendGSMCommand+0x1e4>
 804c92c:	2000c398 	.word	0x2000c398
 804c930:	40004c00 	.word	0x40004c00
 804c934:	20004214 	.word	0x20004214
 804c938:	20000010 	.word	0x20000010
 804c93c:	2000d508 	.word	0x2000d508
 804c940:	20005158 	.word	0x20005158
 804c944:	2000516c 	.word	0x2000516c
 804c948:	20004f7c 	.word	0x20004f7c
 804c94c:	2000c7ea 	.word	0x2000c7ea
 804c950:	0805a944 	.word	0x0805a944
 804c954:	2000040c 	.word	0x2000040c
 804c958:	0805a94c 	.word	0x0805a94c
								char * strLoc = strstr((const char *)gsmInstance.as8GSM_Response_Buff
 804c95c:	4cc2      	ldr	r4, [pc, #776]	; (804cc68 <sendGSMCommand+0x5e0>)
 804c95e:	49c3      	ldr	r1, [pc, #780]	; (804cc6c <sendGSMCommand+0x5e4>)
 804c960:	4620      	mov	r0, r4
 804c962:	f005 f8fc 	bl	8051b5e <strstr>
								memcpy(gsmInstance.agsmSignalStrength, &strLoc[6], strlen(strtok(strLoc,"\r")));
 804c966:	1d85      	adds	r5, r0, #6
 804c968:	49c1      	ldr	r1, [pc, #772]	; (804cc70 <sendGSMCommand+0x5e8>)
 804c96a:	f005 ff43 	bl	80527f4 <strtok>
 804c96e:	f7f3 fc49 	bl	8040204 <strlen>
 804c972:	4602      	mov	r2, r0
 804c974:	4629      	mov	r1, r5
 804c976:	f5a4 706f 	sub.w	r0, r4, #956	; 0x3bc
 804c97a:	f005 f843 	bl	8051a04 <memcpy>
								if(gsmInstance.enmcurrentTask == enmGSMTASK_ISALIVE)
 804c97e:	f894 39ec 	ldrb.w	r3, [r4, #2540]	; 0x9ec
 804c982:	f2a4 4452 	subw	r4, r4, #1106	; 0x452
 804c986:	b2db      	uxtb	r3, r3
 804c988:	2b06      	cmp	r3, #6
 804c98a:	d004      	beq.n	804c996 <sendGSMCommand+0x30e>
									gsmInstance.u8IncrementGsmState = TRUE;
 804c98c:	4bb9      	ldr	r3, [pc, #740]	; (804cc74 <sendGSMCommand+0x5ec>)
 804c98e:	2201      	movs	r2, #1
 804c990:	f883 2e1c 	strb.w	r2, [r3, #3612]	; 0xe1c
 804c994:	e76a      	b.n	804c86c <sendGSMCommand+0x1e4>
									gsmInstance.u32GSMHeartbeatTimer = ONE_MIN;
 804c996:	f64e 2260 	movw	r2, #60000	; 0xea60
 804c99a:	f8c4 2e2c 	str.w	r2, [r4, #3628]	; 0xe2c
									gsmInstance.u32GSMTimer = FIVE_SEC;
 804c99e:	f241 3288 	movw	r2, #5000	; 0x1388
 804c9a2:	f8c4 2e20 	str.w	r2, [r4, #3616]	; 0xe20
									gsmInstance.enmcurrentTask = enmGSMTASK_UPLOADDATA;
 804c9a6:	2203      	movs	r2, #3
 804c9a8:	f884 2e3e 	strb.w	r2, [r4, #3646]	; 0xe3e
									gsmInstance.enmGSMCommand = enmGSMSTATE_ATHTTPDATACOMMAND;
 804c9ac:	2214      	movs	r2, #20
 804c9ae:	f884 2e3f 	strb.w	r2, [r4, #3647]	; 0xe3f
									gsmInstance.u8IncrementGsmState = FALSE;
 804c9b2:	2200      	movs	r2, #0
 804c9b4:	f884 2e1c 	strb.w	r2, [r4, #3612]	; 0xe1c
 804c9b8:	e758      	b.n	804c86c <sendGSMCommand+0x1e4>
							gsmInstance.u8IncrementGsmState = TRUE;
 804c9ba:	4bae      	ldr	r3, [pc, #696]	; (804cc74 <sendGSMCommand+0x5ec>)
 804c9bc:	2201      	movs	r2, #1
 804c9be:	f883 2e1c 	strb.w	r2, [r3, #3612]	; 0xe1c
							break;
 804c9c2:	e753      	b.n	804c86c <sendGSMCommand+0x1e4>
							gsmInstance.u8IncrementGsmState = TRUE;
 804c9c4:	4bab      	ldr	r3, [pc, #684]	; (804cc74 <sendGSMCommand+0x5ec>)
 804c9c6:	2201      	movs	r2, #1
 804c9c8:	f883 2e1c 	strb.w	r2, [r3, #3612]	; 0xe1c
							break;
 804c9cc:	e74e      	b.n	804c86c <sendGSMCommand+0x1e4>
							gsmInstance.u8IncrementGsmState = TRUE;
 804c9ce:	4ba9      	ldr	r3, [pc, #676]	; (804cc74 <sendGSMCommand+0x5ec>)
 804c9d0:	2201      	movs	r2, #1
 804c9d2:	f883 2e1c 	strb.w	r2, [r3, #3612]	; 0xe1c
							break;
 804c9d6:	e749      	b.n	804c86c <sendGSMCommand+0x1e4>
							gsmInstance.u8IncrementGsmState = TRUE;
 804c9d8:	4ba6      	ldr	r3, [pc, #664]	; (804cc74 <sendGSMCommand+0x5ec>)
 804c9da:	2201      	movs	r2, #1
 804c9dc:	f883 2e1c 	strb.w	r2, [r3, #3612]	; 0xe1c
							break;
 804c9e0:	e744      	b.n	804c86c <sendGSMCommand+0x1e4>
							gsmInstance.u8IncrementGsmState = TRUE;
 804c9e2:	4ba4      	ldr	r3, [pc, #656]	; (804cc74 <sendGSMCommand+0x5ec>)
 804c9e4:	2201      	movs	r2, #1
 804c9e6:	f883 2e1c 	strb.w	r2, [r3, #3612]	; 0xe1c
							break;
 804c9ea:	e73f      	b.n	804c86c <sendGSMCommand+0x1e4>
							gsmInstance.u8IncrementGsmState = TRUE;
 804c9ec:	4ba1      	ldr	r3, [pc, #644]	; (804cc74 <sendGSMCommand+0x5ec>)
 804c9ee:	2201      	movs	r2, #1
 804c9f0:	f883 2e1c 	strb.w	r2, [r3, #3612]	; 0xe1c
							break;
 804c9f4:	e73a      	b.n	804c86c <sendGSMCommand+0x1e4>
							if(strstr((const char *)gsmInstance.as8GSM_Response_Buff
 804c9f6:	49a0      	ldr	r1, [pc, #640]	; (804cc78 <sendGSMCommand+0x5f0>)
 804c9f8:	489b      	ldr	r0, [pc, #620]	; (804cc68 <sendGSMCommand+0x5e0>)
 804c9fa:	f005 f8b0 	bl	8051b5e <strstr>
 804c9fe:	b138      	cbz	r0, 804ca10 <sendGSMCommand+0x388>
								gsmInstance.u8IncrementGsmState = FALSE;
 804ca00:	4b9c      	ldr	r3, [pc, #624]	; (804cc74 <sendGSMCommand+0x5ec>)
 804ca02:	2200      	movs	r2, #0
 804ca04:	f883 2e1c 	strb.w	r2, [r3, #3612]	; 0xe1c
								gsmInstance.enmGSMCommand += 2;
 804ca08:	3402      	adds	r4, #2
 804ca0a:	f883 4e3f 	strb.w	r4, [r3, #3647]	; 0xe3f
 804ca0e:	e72d      	b.n	804c86c <sendGSMCommand+0x1e4>
								gsmInstance.u8IncrementGsmState = TRUE;
 804ca10:	4b98      	ldr	r3, [pc, #608]	; (804cc74 <sendGSMCommand+0x5ec>)
 804ca12:	2201      	movs	r2, #1
 804ca14:	f883 2e1c 	strb.w	r2, [r3, #3612]	; 0xe1c
 804ca18:	e728      	b.n	804c86c <sendGSMCommand+0x1e4>
							gsmInstance.u8IncrementGsmState = TRUE;
 804ca1a:	4b96      	ldr	r3, [pc, #600]	; (804cc74 <sendGSMCommand+0x5ec>)
 804ca1c:	2201      	movs	r2, #1
 804ca1e:	f883 2e1c 	strb.w	r2, [r3, #3612]	; 0xe1c
							break;
 804ca22:	e723      	b.n	804c86c <sendGSMCommand+0x1e4>
							gsmInstance.u8IncrementGsmState = TRUE;
 804ca24:	4b93      	ldr	r3, [pc, #588]	; (804cc74 <sendGSMCommand+0x5ec>)
 804ca26:	2201      	movs	r2, #1
 804ca28:	f883 2e1c 	strb.w	r2, [r3, #3612]	; 0xe1c
							break;
 804ca2c:	e71e      	b.n	804c86c <sendGSMCommand+0x1e4>
							if(gu8FlagNoTerminate == 1)
 804ca2e:	4b93      	ldr	r3, [pc, #588]	; (804cc7c <sendGSMCommand+0x5f4>)
 804ca30:	f893 33da 	ldrb.w	r3, [r3, #986]	; 0x3da
 804ca34:	2b01      	cmp	r3, #1
 804ca36:	d004      	beq.n	804ca42 <sendGSMCommand+0x3ba>
							gsmInstance.u8IncrementGsmState = TRUE;
 804ca38:	4b8e      	ldr	r3, [pc, #568]	; (804cc74 <sendGSMCommand+0x5ec>)
 804ca3a:	2201      	movs	r2, #1
 804ca3c:	f883 2e1c 	strb.w	r2, [r3, #3612]	; 0xe1c
							break;
 804ca40:	e714      	b.n	804c86c <sendGSMCommand+0x1e4>
								gu8FlagNoTerminate = 0;
 804ca42:	4b8e      	ldr	r3, [pc, #568]	; (804cc7c <sendGSMCommand+0x5f4>)
 804ca44:	2200      	movs	r2, #0
 804ca46:	f883 23da 	strb.w	r2, [r3, #986]	; 0x3da
								gsmInstance.enmGSMCommand++;
 804ca4a:	3401      	adds	r4, #1
 804ca4c:	4b89      	ldr	r3, [pc, #548]	; (804cc74 <sendGSMCommand+0x5ec>)
 804ca4e:	f883 4e3f 	strb.w	r4, [r3, #3647]	; 0xe3f
 804ca52:	e7f1      	b.n	804ca38 <sendGSMCommand+0x3b0>
							gsmInstance.u8IncrementGsmState = TRUE;
 804ca54:	4b87      	ldr	r3, [pc, #540]	; (804cc74 <sendGSMCommand+0x5ec>)
 804ca56:	2201      	movs	r2, #1
 804ca58:	f883 2e1c 	strb.w	r2, [r3, #3612]	; 0xe1c
							break;
 804ca5c:	e706      	b.n	804c86c <sendGSMCommand+0x1e4>
							gsmInstance.u8HTTPInitStatus = TRUE;
 804ca5e:	4b85      	ldr	r3, [pc, #532]	; (804cc74 <sendGSMCommand+0x5ec>)
 804ca60:	2201      	movs	r2, #1
 804ca62:	f883 2e1a 	strb.w	r2, [r3, #3610]	; 0xe1a
							gsmInstance.u8IncrementGsmState = TRUE;
 804ca66:	f883 2e1c 	strb.w	r2, [r3, #3612]	; 0xe1c
							break;
 804ca6a:	e6ff      	b.n	804c86c <sendGSMCommand+0x1e4>
							memcpy(gsmInstance.agsmCommandResponse[gsmInstance.enmGSMCommand],
 804ca6c:	201e      	movs	r0, #30
 804ca6e:	fb00 f004 	mul.w	r0, r0, r4
 804ca72:	30c0      	adds	r0, #192	; 0xc0
 804ca74:	4c7f      	ldr	r4, [pc, #508]	; (804cc74 <sendGSMCommand+0x5ec>)
 804ca76:	4420      	add	r0, r4
 804ca78:	f640 12c4 	movw	r2, #2500	; 0x9c4
 804ca7c:	f204 4152 	addw	r1, r4, #1106	; 0x452
 804ca80:	3003      	adds	r0, #3
 804ca82:	f004 ffbf 	bl	8051a04 <memcpy>
							gsmInstance.u8IncrementGsmState = TRUE;
 804ca86:	2301      	movs	r3, #1
 804ca88:	f884 3e1c 	strb.w	r3, [r4, #3612]	; 0xe1c
							break;
 804ca8c:	e6ee      	b.n	804c86c <sendGSMCommand+0x1e4>
							gsmInstance.u8IncrementGsmState = TRUE;
 804ca8e:	4b79      	ldr	r3, [pc, #484]	; (804cc74 <sendGSMCommand+0x5ec>)
 804ca90:	2201      	movs	r2, #1
 804ca92:	f883 2e1c 	strb.w	r2, [r3, #3612]	; 0xe1c
							break;
 804ca96:	e6e9      	b.n	804c86c <sendGSMCommand+0x1e4>
							char * strLoc = strstr((const char *)gsmInstance.as8GSM_Response_Buff
 804ca98:	4c73      	ldr	r4, [pc, #460]	; (804cc68 <sendGSMCommand+0x5e0>)
 804ca9a:	4979      	ldr	r1, [pc, #484]	; (804cc80 <sendGSMCommand+0x5f8>)
 804ca9c:	4620      	mov	r0, r4
 804ca9e:	f005 f85e 	bl	8051b5e <strstr>
							memcpy(gsmInstance.u32GSMHttpResponseCode, (char *)&strLoc[4], 3);
 804caa2:	4603      	mov	r3, r0
 804caa4:	f833 2f04 	ldrh.w	r2, [r3, #4]!
 804caa8:	789b      	ldrb	r3, [r3, #2]
 804caaa:	f824 2c03 	strh.w	r2, [r4, #-3]
 804caae:	f804 3c01 	strb.w	r3, [r4, #-1]
							switch(atoi(gsmInstance.u32GSMHttpResponseCode))
 804cab2:	1ee0      	subs	r0, r4, #3
 804cab4:	f004 fd04 	bl	80514c0 <atoi>
 804cab8:	28c8      	cmp	r0, #200	; 0xc8
 804caba:	d014      	beq.n	804cae6 <sendGSMCommand+0x45e>
									u8LastHttpResponseCode = atoi(gsmInstance.u32GSMHttpResponseCode);
 804cabc:	4c71      	ldr	r4, [pc, #452]	; (804cc84 <sendGSMCommand+0x5fc>)
 804cabe:	4620      	mov	r0, r4
 804cac0:	f004 fcfe 	bl	80514c0 <atoi>
 804cac4:	4b70      	ldr	r3, [pc, #448]	; (804cc88 <sendGSMCommand+0x600>)
 804cac6:	6218      	str	r0, [r3, #32]
									gsmInstance.u8IllegalHttpResponseCounter++;
 804cac8:	f894 39ce 	ldrb.w	r3, [r4, #2510]	; 0x9ce
 804cacc:	3301      	adds	r3, #1
 804cace:	b2db      	uxtb	r3, r3
 804cad0:	f884 39ce 	strb.w	r3, [r4, #2510]	; 0x9ce
									if(gsmInstance.u8IllegalHttpResponseCounter >= MAX_HTTP_ATTEMPTS)
 804cad4:	2b04      	cmp	r3, #4
 804cad6:	d925      	bls.n	804cb24 <sendGSMCommand+0x49c>
										initGSMSIM868();
 804cad8:	f7ff f972 	bl	804bdc0 <initGSMSIM868>
										gu8CheckSMS = TRUE;
 804cadc:	4b6a      	ldr	r3, [pc, #424]	; (804cc88 <sendGSMCommand+0x600>)
 804cade:	2201      	movs	r2, #1
 804cae0:	f883 2091 	strb.w	r2, [r3, #145]	; 0x91
										break;
 804cae4:	e6c2      	b.n	804c86c <sendGSMCommand+0x1e4>
								dequeue(&gsmPayload);
 804cae6:	4869      	ldr	r0, [pc, #420]	; (804cc8c <sendGSMCommand+0x604>)
 804cae8:	f002 fb86 	bl	804f1f8 <dequeue>
								gsmInstance.u32GSMTimer = TWO_SEC; // Replace with Upload Frequency
 804caec:	f2a4 4052 	subw	r0, r4, #1106	; 0x452
 804caf0:	f44f 63fa 	mov.w	r3, #2000	; 0x7d0
 804caf4:	f8c0 3e20 	str.w	r3, [r0, #3616]	; 0xe20
								gu8HttpPayloadFlag = 0;
 804caf8:	4c63      	ldr	r4, [pc, #396]	; (804cc88 <sendGSMCommand+0x600>)
 804cafa:	2300      	movs	r3, #0
 804cafc:	f884 3090 	strb.w	r3, [r4, #144]	; 0x90
								gsmInstance.enmGSMCommand = enmGSMSTATE_ATHTTPDATACOMMAND;
 804cb00:	2214      	movs	r2, #20
 804cb02:	f880 2e3f 	strb.w	r2, [r0, #3647]	; 0xe3f
								gsmInstance.u8IncrementGsmState = FALSE;
 804cb06:	f880 3e1c 	strb.w	r3, [r0, #3612]	; 0xe1c
								u8LastHttpResponseCode = atoi(gsmInstance.u32GSMHttpResponseCode);
 804cb0a:	f200 404f 	addw	r0, r0, #1103	; 0x44f
 804cb0e:	f004 fcd7 	bl	80514c0 <atoi>
 804cb12:	6220      	str	r0, [r4, #32]
								HAL_GPIO_TogglePin(LED_3_GPIO_Port, LED_3_Pin);
 804cb14:	2120      	movs	r1, #32
 804cb16:	485e      	ldr	r0, [pc, #376]	; (804cc90 <sendGSMCommand+0x608>)
 804cb18:	f7f6 f908 	bl	8042d2c <HAL_GPIO_TogglePin>
								gu32GSMRestartTimer = FIVE_MIN;
 804cb1c:	4b5d      	ldr	r3, [pc, #372]	; (804cc94 <sendGSMCommand+0x60c>)
 804cb1e:	4a5e      	ldr	r2, [pc, #376]	; (804cc98 <sendGSMCommand+0x610>)
 804cb20:	601a      	str	r2, [r3, #0]
								break;
 804cb22:	e6a3      	b.n	804c86c <sendGSMCommand+0x1e4>
									u8LastHttpResponseCode = atoi(gsmInstance.u32GSMHttpResponseCode);
 804cb24:	4c57      	ldr	r4, [pc, #348]	; (804cc84 <sendGSMCommand+0x5fc>)
 804cb26:	4620      	mov	r0, r4
 804cb28:	f004 fcca 	bl	80514c0 <atoi>
 804cb2c:	4b56      	ldr	r3, [pc, #344]	; (804cc88 <sendGSMCommand+0x600>)
 804cb2e:	6218      	str	r0, [r3, #32]
									gsmInstance.enmGSMCommand = enmGSMSTATE_ATHTTPDATACOMMAND;
 804cb30:	2214      	movs	r2, #20
 804cb32:	f884 29f0 	strb.w	r2, [r4, #2544]	; 0x9f0
									gsmInstance.u32GSMResponseTimer = 0;
 804cb36:	2200      	movs	r2, #0
 804cb38:	f8c4 29e5 	str.w	r2, [r4, #2533]	; 0x9e5
									gsmInstance.u8IncrementGsmState = FALSE;
 804cb3c:	f884 29cd 	strb.w	r2, [r4, #2509]	; 0x9cd
								break;
 804cb40:	e694      	b.n	804c86c <sendGSMCommand+0x1e4>
							gsmInstance.u8IncrementGsmState = TRUE;
 804cb42:	4b4c      	ldr	r3, [pc, #304]	; (804cc74 <sendGSMCommand+0x5ec>)
 804cb44:	2201      	movs	r2, #1
 804cb46:	f883 2e1c 	strb.w	r2, [r3, #3612]	; 0xe1c
							break;
 804cb4a:	e68f      	b.n	804c86c <sendGSMCommand+0x1e4>
							char * strLoc = strstr((const char *)gsmInstance.as8GSM_Response_Buff
 804cb4c:	4c46      	ldr	r4, [pc, #280]	; (804cc68 <sendGSMCommand+0x5e0>)
 804cb4e:	4953      	ldr	r1, [pc, #332]	; (804cc9c <sendGSMCommand+0x614>)
 804cb50:	4620      	mov	r0, r4
 804cb52:	f005 f804 	bl	8051b5e <strstr>
 804cb56:	4605      	mov	r5, r0
							memset(gsmInstance.agpsLocationData,0x00, strlen(gsmInstance.agpsLocationData));
 804cb58:	f2a4 4452 	subw	r4, r4, #1106	; 0x452
 804cb5c:	4620      	mov	r0, r4
 804cb5e:	f7f3 fb51 	bl	8040204 <strlen>
 804cb62:	4602      	mov	r2, r0
 804cb64:	2100      	movs	r1, #0
 804cb66:	4620      	mov	r0, r4
 804cb68:	f004 ff5a 	bl	8051a20 <memset>
							memcpy(gsmInstance.agpsLocationData, (char *)&strLoc[11], strlen(strtok(strLoc,"\r")));//strlen(strtok(strLoc,"\r\n")));
 804cb6c:	f105 060b 	add.w	r6, r5, #11
 804cb70:	493f      	ldr	r1, [pc, #252]	; (804cc70 <sendGSMCommand+0x5e8>)
 804cb72:	4628      	mov	r0, r5
 804cb74:	f005 fe3e 	bl	80527f4 <strtok>
 804cb78:	f7f3 fb44 	bl	8040204 <strlen>
 804cb7c:	4602      	mov	r2, r0
 804cb7e:	4631      	mov	r1, r6
 804cb80:	4620      	mov	r0, r4
 804cb82:	f004 ff3f 	bl	8051a04 <memcpy>
							gsmInstance.u8IncrementGsmState = FALSE;
 804cb86:	2300      	movs	r3, #0
 804cb88:	f884 3e1c 	strb.w	r3, [r4, #3612]	; 0xe1c
							if(strlen(gsmInstance.agpsLocationData) < 10)
 804cb8c:	4620      	mov	r0, r4
 804cb8e:	f7f3 fb39 	bl	8040204 <strlen>
 804cb92:	2809      	cmp	r0, #9
 804cb94:	d80e      	bhi.n	804cbb4 <sendGSMCommand+0x52c>
								u32GPSTimeSyncFlag = FALSE;
 804cb96:	4b3c      	ldr	r3, [pc, #240]	; (804cc88 <sendGSMCommand+0x600>)
 804cb98:	2200      	movs	r2, #0
 804cb9a:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
							if(gu32GSMConfigCheckTimer == 0)
 804cb9e:	4b40      	ldr	r3, [pc, #256]	; (804cca0 <sendGSMCommand+0x618>)
 804cba0:	681b      	ldr	r3, [r3, #0]
 804cba2:	b163      	cbz	r3, 804cbbe <sendGSMCommand+0x536>
								gsmInstance.enmcurrentTask = enmGSMTASK_UPLOADDATA;
 804cba4:	4b33      	ldr	r3, [pc, #204]	; (804cc74 <sendGSMCommand+0x5ec>)
 804cba6:	2203      	movs	r2, #3
 804cba8:	f883 2e3e 	strb.w	r2, [r3, #3646]	; 0xe3e
								gsmInstance.enmGSMCommand = enmGSMSTATE_ATHTTPDATACOMMAND;
 804cbac:	2214      	movs	r2, #20
 804cbae:	f883 2e3f 	strb.w	r2, [r3, #3647]	; 0xe3f
 804cbb2:	e65b      	b.n	804c86c <sendGSMCommand+0x1e4>
								u32GPSTimeSyncFlag = TRUE;
 804cbb4:	4b34      	ldr	r3, [pc, #208]	; (804cc88 <sendGSMCommand+0x600>)
 804cbb6:	2201      	movs	r2, #1
 804cbb8:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
 804cbbc:	e7ef      	b.n	804cb9e <sendGSMCommand+0x516>
								gu32GSMConfigCheckTimer = TWENTY_MIN;
 804cbbe:	4b38      	ldr	r3, [pc, #224]	; (804cca0 <sendGSMCommand+0x618>)
 804cbc0:	4a38      	ldr	r2, [pc, #224]	; (804cca4 <sendGSMCommand+0x61c>)
 804cbc2:	601a      	str	r2, [r3, #0]
								initHTTPURLforRemoteConfig();
 804cbc4:	f7ff fbec 	bl	804c3a0 <initHTTPURLforRemoteConfig>
								gsmInstance.enmcurrentTask = enmGSMTASK_DOWNLOADFOTAFILE;
 804cbc8:	4b2a      	ldr	r3, [pc, #168]	; (804cc74 <sendGSMCommand+0x5ec>)
 804cbca:	2208      	movs	r2, #8
 804cbcc:	f883 2e3e 	strb.w	r2, [r3, #3646]	; 0xe3e
								gsmInstance.enmGSMCommand = enmGSMSTATE_HTTPTERMCONFIG;
 804cbd0:	221f      	movs	r2, #31
 804cbd2:	f883 2e3f 	strb.w	r2, [r3, #3647]	; 0xe3f
 804cbd6:	e649      	b.n	804c86c <sendGSMCommand+0x1e4>
							gsmInstance.u8IncrementGsmState = TRUE;
 804cbd8:	4b26      	ldr	r3, [pc, #152]	; (804cc74 <sendGSMCommand+0x5ec>)
 804cbda:	2201      	movs	r2, #1
 804cbdc:	f883 2e1c 	strb.w	r2, [r3, #3612]	; 0xe1c
							break;
 804cbe0:	e644      	b.n	804c86c <sendGSMCommand+0x1e4>
							gsmInstance.u8IncrementGsmState = TRUE;
 804cbe2:	4b24      	ldr	r3, [pc, #144]	; (804cc74 <sendGSMCommand+0x5ec>)
 804cbe4:	2201      	movs	r2, #1
 804cbe6:	f883 2e1c 	strb.w	r2, [r3, #3612]	; 0xe1c
							break;
 804cbea:	e63f      	b.n	804c86c <sendGSMCommand+0x1e4>
							gsmInstance.u32GSMHeartbeatTimer = FIVE_SEC;
 804cbec:	4b21      	ldr	r3, [pc, #132]	; (804cc74 <sendGSMCommand+0x5ec>)
 804cbee:	f241 3288 	movw	r2, #5000	; 0x1388
 804cbf2:	f8c3 2e2c 	str.w	r2, [r3, #3628]	; 0xe2c
							gsmInstance.u32GSMTimer = ONE_SEC;
 804cbf6:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 804cbfa:	f8c3 2e20 	str.w	r2, [r3, #3616]	; 0xe20
							gsmInstance.enmGSMCommand = enmGSMSTATE_ATCSQ;
 804cbfe:	2208      	movs	r2, #8
 804cc00:	f883 2e3f 	strb.w	r2, [r3, #3647]	; 0xe3f
							gsmInstance.enmcurrentTask = enmGSMTASK_ISALIVE;
 804cc04:	2206      	movs	r2, #6
 804cc06:	f883 2e3e 	strb.w	r2, [r3, #3646]	; 0xe3e
							gsmInstance.u8IncrementGsmState = FALSE;
 804cc0a:	2200      	movs	r2, #0
 804cc0c:	f883 2e1c 	strb.w	r2, [r3, #3612]	; 0xe1c
							gu8SendSMS = FALSE;
 804cc10:	4b1d      	ldr	r3, [pc, #116]	; (804cc88 <sendGSMCommand+0x600>)
 804cc12:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
							break;
 804cc16:	e629      	b.n	804c86c <sendGSMCommand+0x1e4>
							gsmInstance.u8IncrementGsmState = TRUE;
 804cc18:	4b16      	ldr	r3, [pc, #88]	; (804cc74 <sendGSMCommand+0x5ec>)
 804cc1a:	2201      	movs	r2, #1
 804cc1c:	f883 2e1c 	strb.w	r2, [r3, #3612]	; 0xe1c
							break;
 804cc20:	e624      	b.n	804c86c <sendGSMCommand+0x1e4>
							sendSystemConfigurationSMS();
 804cc22:	f7ff f9eb 	bl	804bffc <sendSystemConfigurationSMS>
							gsmInstance.enmcurrentTask = enmGSMTASK_SENDSMS;
 804cc26:	4c13      	ldr	r4, [pc, #76]	; (804cc74 <sendGSMCommand+0x5ec>)
 804cc28:	2305      	movs	r3, #5
 804cc2a:	f884 3e3e 	strb.w	r3, [r4, #3646]	; 0xe3e
							gsmInstance.enmGSMCommand = enmGSMSTATE_CMGF;
 804cc2e:	2318      	movs	r3, #24
 804cc30:	f884 3e3f 	strb.w	r3, [r4, #3647]	; 0xe3f
							memset((char *)gsmInstance.as8GSM_Response_Buff, GSM_ARRAY_INIT_CHAR, (GSM_RESPONSE_ARRAY_SIZE));
 804cc34:	f640 12c4 	movw	r2, #2500	; 0x9c4
 804cc38:	2100      	movs	r1, #0
 804cc3a:	f204 4052 	addw	r0, r4, #1106	; 0x452
 804cc3e:	f004 feef 	bl	8051a20 <memset>
							gsmInstance.u8IncrementGsmState = FALSE;
 804cc42:	2300      	movs	r3, #0
 804cc44:	f884 3e1c 	strb.w	r3, [r4, #3612]	; 0xe1c
							break;
 804cc48:	e610      	b.n	804c86c <sendGSMCommand+0x1e4>
							gsmInstance.u8IncrementGsmState = TRUE;
 804cc4a:	4b0a      	ldr	r3, [pc, #40]	; (804cc74 <sendGSMCommand+0x5ec>)
 804cc4c:	2201      	movs	r2, #1
 804cc4e:	f883 2e1c 	strb.w	r2, [r3, #3612]	; 0xe1c
							break;
 804cc52:	e60b      	b.n	804c86c <sendGSMCommand+0x1e4>
							gsmInstance.u8IncrementGsmState = TRUE;
 804cc54:	4b07      	ldr	r3, [pc, #28]	; (804cc74 <sendGSMCommand+0x5ec>)
 804cc56:	2201      	movs	r2, #1
 804cc58:	f883 2e1c 	strb.w	r2, [r3, #3612]	; 0xe1c
							break;
 804cc5c:	e606      	b.n	804c86c <sendGSMCommand+0x1e4>
							gsmInstance.u8IncrementGsmState = TRUE;
 804cc5e:	4b05      	ldr	r3, [pc, #20]	; (804cc74 <sendGSMCommand+0x5ec>)
 804cc60:	2201      	movs	r2, #1
 804cc62:	f883 2e1c 	strb.w	r2, [r3, #3612]	; 0xe1c
							break;
 804cc66:	e601      	b.n	804c86c <sendGSMCommand+0x1e4>
 804cc68:	2000c7ea 	.word	0x2000c7ea
 804cc6c:	0805a950 	.word	0x0805a950
 804cc70:	0805a94c 	.word	0x0805a94c
 804cc74:	2000c398 	.word	0x2000c398
 804cc78:	0805a958 	.word	0x0805a958
 804cc7c:	20000010 	.word	0x20000010
 804cc80:	0805a8c8 	.word	0x0805a8c8
 804cc84:	2000c7e7 	.word	0x2000c7e7
 804cc88:	20004214 	.word	0x20004214
 804cc8c:	2000d508 	.word	0x2000d508
 804cc90:	40020c00 	.word	0x40020c00
 804cc94:	200036c0 	.word	0x200036c0
 804cc98:	000493e0 	.word	0x000493e0
 804cc9c:	0805a964 	.word	0x0805a964
 804cca0:	20005184 	.word	0x20005184
 804cca4:	00124f80 	.word	0x00124f80
								char * strLoc = strstr((const char *)gsmInstance.as8GSM_Response_Buff
 804cca8:	49c4      	ldr	r1, [pc, #784]	; (804cfbc <sendGSMCommand+0x934>)
 804ccaa:	48c5      	ldr	r0, [pc, #788]	; (804cfc0 <sendGSMCommand+0x938>)
 804ccac:	f004 ff57 	bl	8051b5e <strstr>
								if(strLoc != NULL)
 804ccb0:	4605      	mov	r5, r0
 804ccb2:	2800      	cmp	r0, #0
 804ccb4:	d040      	beq.n	804cd38 <sendGSMCommand+0x6b0>
									gu32GSMHangTimer = THREE_MIN;
 804ccb6:	4bc3      	ldr	r3, [pc, #780]	; (804cfc4 <sendGSMCommand+0x93c>)
 804ccb8:	4ac3      	ldr	r2, [pc, #780]	; (804cfc8 <sendGSMCommand+0x940>)
 804ccba:	601a      	str	r2, [r3, #0]
									memset(gau32RemoteConfigSizeinBytes,0x00, strlen(gau32RemoteConfigSizeinBytes));
 804ccbc:	4cc3      	ldr	r4, [pc, #780]	; (804cfcc <sendGSMCommand+0x944>)
 804ccbe:	4620      	mov	r0, r4
 804ccc0:	f7f3 faa0 	bl	8040204 <strlen>
 804ccc4:	4602      	mov	r2, r0
 804ccc6:	2100      	movs	r1, #0
 804ccc8:	4620      	mov	r0, r4
 804ccca:	f004 fea9 	bl	8051a20 <memset>
									memcpy(gau32RemoteConfigSizeinBytes, &strLoc[4], strlen(strtok(&strLoc[4],"\r\n")));
 804ccce:	3504      	adds	r5, #4
 804ccd0:	49bf      	ldr	r1, [pc, #764]	; (804cfd0 <sendGSMCommand+0x948>)
 804ccd2:	4628      	mov	r0, r5
 804ccd4:	f005 fd8e 	bl	80527f4 <strtok>
 804ccd8:	f7f3 fa94 	bl	8040204 <strlen>
 804ccdc:	4602      	mov	r2, r0
 804ccde:	4629      	mov	r1, r5
 804cce0:	4620      	mov	r0, r4
 804cce2:	f004 fe8f 	bl	8051a04 <memcpy>
									gu32RemoteConfigSizeinBytes = strlen(gau32RemoteConfigSizeinBytes);
 804cce6:	4620      	mov	r0, r4
 804cce8:	f7f3 fa8c 	bl	8040204 <strlen>
 804ccec:	4bb9      	ldr	r3, [pc, #740]	; (804cfd4 <sendGSMCommand+0x94c>)
 804ccee:	f8c3 0098 	str.w	r0, [r3, #152]	; 0x98
									gsmInstance.gu32RemoteConfigSizeinBytes = atoi(gau32RemoteConfigSizeinBytes);
 804ccf2:	4620      	mov	r0, r4
 804ccf4:	f004 fbe4 	bl	80514c0 <atoi>
 804ccf8:	4bb7      	ldr	r3, [pc, #732]	; (804cfd8 <sendGSMCommand+0x950>)
 804ccfa:	f8c3 0e30 	str.w	r0, [r3, #3632]	; 0xe30
									if((gsmInstance.gu32RemoteConfigSizeinBytes) <= ((STM32_FLASHSIZE /2) * 1000))//(MAX_RMT_CONFIG_SIZE_BYTES))
 804ccfe:	4bb7      	ldr	r3, [pc, #732]	; (804cfdc <sendGSMCommand+0x954>)
 804cd00:	881b      	ldrh	r3, [r3, #0]
 804cd02:	085a      	lsrs	r2, r3, #1
 804cd04:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 804cd08:	fb03 f302 	mul.w	r3, r3, r2
 804cd0c:	4298      	cmp	r0, r3
 804cd0e:	d807      	bhi.n	804cd20 <sendGSMCommand+0x698>
										gu32AttemptFota = TRUE;
 804cd10:	4bb0      	ldr	r3, [pc, #704]	; (804cfd4 <sendGSMCommand+0x94c>)
 804cd12:	2201      	movs	r2, #1
 804cd14:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c
										if(gsmInstance.gu32RemoteConfigSizeinBytes != 0)
 804cd18:	b148      	cbz	r0, 804cd2e <sendGSMCommand+0x6a6>
											updateHTTPReadLength(gsmInstance.gu32RemoteConfigSizeinBytes);
 804cd1a:	f7ff fc1d 	bl	804c558 <updateHTTPReadLength>
 804cd1e:	e006      	b.n	804cd2e <sendGSMCommand+0x6a6>
										gsmInstance.enmcurrentTask = enmGSMTASK_UPLOADDATA;
 804cd20:	4bad      	ldr	r3, [pc, #692]	; (804cfd8 <sendGSMCommand+0x950>)
 804cd22:	2203      	movs	r2, #3
 804cd24:	f883 2e3e 	strb.w	r2, [r3, #3646]	; 0xe3e
										gsmInstance.enmGSMCommand = enmGSMSTATE_ATHTTPDATACOMMAND;
 804cd28:	2214      	movs	r2, #20
 804cd2a:	f883 2e3f 	strb.w	r2, [r3, #3647]	; 0xe3f
									gsmInstance.u8IncrementGsmState = TRUE;
 804cd2e:	4baa      	ldr	r3, [pc, #680]	; (804cfd8 <sendGSMCommand+0x950>)
 804cd30:	2201      	movs	r2, #1
 804cd32:	f883 2e1c 	strb.w	r2, [r3, #3612]	; 0xe1c
 804cd36:	e599      	b.n	804c86c <sendGSMCommand+0x1e4>
									gsmInstance.u8IncrementGsmState = FALSE;
 804cd38:	4ba7      	ldr	r3, [pc, #668]	; (804cfd8 <sendGSMCommand+0x950>)
 804cd3a:	2200      	movs	r2, #0
 804cd3c:	f883 2e1c 	strb.w	r2, [r3, #3612]	; 0xe1c
									gsmInstance.enmcurrentTask = enmGSMTASK_UPLOADDATA;
 804cd40:	2203      	movs	r2, #3
 804cd42:	f883 2e3e 	strb.w	r2, [r3, #3646]	; 0xe3e
									gsmInstance.enmGSMCommand = enmGSMSTATE_ATHTTPDATACOMMAND;
 804cd46:	2214      	movs	r2, #20
 804cd48:	f883 2e3f 	strb.w	r2, [r3, #3647]	; 0xe3f
 804cd4c:	e58e      	b.n	804c86c <sendGSMCommand+0x1e4>
									if(gu32OTATaskNumber == 0)
 804cd4e:	4ba4      	ldr	r3, [pc, #656]	; (804cfe0 <sendGSMCommand+0x958>)
 804cd50:	f8d3 3418 	ldr.w	r3, [r3, #1048]	; 0x418
 804cd54:	b14b      	cbz	r3, 804cd6a <sendGSMCommand+0x6e2>
									else if(gu32OTATaskNumber == 1)
 804cd56:	2b01      	cmp	r3, #1
 804cd58:	d030      	beq.n	804cdbc <sendGSMCommand+0x734>
										gsmInstance.enmcurrentTask = enmGSMTASK_UPLOADDATA;
 804cd5a:	4b9f      	ldr	r3, [pc, #636]	; (804cfd8 <sendGSMCommand+0x950>)
 804cd5c:	2203      	movs	r2, #3
 804cd5e:	f883 2e3e 	strb.w	r2, [r3, #3646]	; 0xe3e
										gsmInstance.enmGSMCommand = enmGSMSTATE_ATHTTPDATACOMMAND;
 804cd62:	2214      	movs	r2, #20
 804cd64:	f883 2e3f 	strb.w	r2, [r3, #3647]	; 0xe3f
 804cd68:	e580      	b.n	804c86c <sendGSMCommand+0x1e4>
										char *strloc = strstr((const char *)gsmInstance.as8GSM_Response_Buff,(const char *)"(");
 804cd6a:	4c95      	ldr	r4, [pc, #596]	; (804cfc0 <sendGSMCommand+0x938>)
 804cd6c:	2128      	movs	r1, #40	; 0x28
 804cd6e:	4620      	mov	r0, r4
 804cd70:	f004 febb 	bl	8051aea <strchr>
 804cd74:	4605      	mov	r5, r0
										memset(gau8ConfigData,0x00,sizeof(gau8ConfigData));//
 804cd76:	4e9b      	ldr	r6, [pc, #620]	; (804cfe4 <sendGSMCommand+0x95c>)
 804cd78:	f640 12c4 	movw	r2, #2500	; 0x9c4
 804cd7c:	2100      	movs	r1, #0
 804cd7e:	4630      	mov	r0, r6
 804cd80:	f004 fe4e 	bl	8051a20 <memset>
										memcpy(gau8ConfigData, (char *)strloc, gsmInstance.gu32RemoteConfigSizeinBytes);
 804cd84:	f8d4 29de 	ldr.w	r2, [r4, #2526]	; 0x9de
 804cd88:	4629      	mov	r1, r5
 804cd8a:	4630      	mov	r0, r6
 804cd8c:	f004 fe3a 	bl	8051a04 <memcpy>
										restoreHTTPURLforData();
 804cd90:	f7ff fb8c 	bl	804c4ac <restoreHTTPURLforData>
										gsmInstance.enmcurrentTask = enmGSMTASK_UPLOADDATA;
 804cd94:	2303      	movs	r3, #3
 804cd96:	f884 39ec 	strb.w	r3, [r4, #2540]	; 0x9ec
										gsmInstance.enmGSMCommand = enmGSMSTATE_HTTPTERM;
 804cd9a:	2311      	movs	r3, #17
 804cd9c:	f884 39ed 	strb.w	r3, [r4, #2541]	; 0x9ed
										HAL_GPIO_WritePin(LED_1_GPIO_Port, LED_1_Pin, GPIO_PIN_RESET);	// LED ON
 804cda0:	2200      	movs	r2, #0
 804cda2:	f44f 7180 	mov.w	r1, #256	; 0x100
 804cda6:	4890      	ldr	r0, [pc, #576]	; (804cfe8 <sendGSMCommand+0x960>)
 804cda8:	f7f5 ffba 	bl	8042d20 <HAL_GPIO_WritePin>
										gsmInstance.u8IncrementGsmState = FALSE;
 804cdac:	2300      	movs	r3, #0
 804cdae:	f884 39ca 	strb.w	r3, [r4, #2506]	; 0x9ca
										gu32NewConfigAvailable = TRUE;
 804cdb2:	4b88      	ldr	r3, [pc, #544]	; (804cfd4 <sendGSMCommand+0x94c>)
 804cdb4:	2201      	movs	r2, #1
 804cdb6:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
 804cdba:	e557      	b.n	804c86c <sendGSMCommand+0x1e4>
										if(u32ConfigFileReadComplete == 0)//u32FotaFileReadComplete
 804cdbc:	4b85      	ldr	r3, [pc, #532]	; (804cfd4 <sendGSMCommand+0x94c>)
 804cdbe:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 804cdc2:	b163      	cbz	r3, 804cdde <sendGSMCommand+0x756>
										else if(u32ConfigFileReadComplete == 1)
 804cdc4:	2b01      	cmp	r3, #1
 804cdc6:	f000 8089 	beq.w	804cedc <sendGSMCommand+0x854>
											restoreHTTPURLforData();
 804cdca:	f7ff fb6f 	bl	804c4ac <restoreHTTPURLforData>
											gsmInstance.enmcurrentTask = enmGSMTASK_UPLOADDATA;
 804cdce:	4b82      	ldr	r3, [pc, #520]	; (804cfd8 <sendGSMCommand+0x950>)
 804cdd0:	2203      	movs	r2, #3
 804cdd2:	f883 2e3e 	strb.w	r2, [r3, #3646]	; 0xe3e
											gsmInstance.enmGSMCommand = enmGSMSTATE_ATHTTPDATACOMMAND;
 804cdd6:	2214      	movs	r2, #20
 804cdd8:	f883 2e3f 	strb.w	r2, [r3, #3647]	; 0xe3f
 804cddc:	e546      	b.n	804c86c <sendGSMCommand+0x1e4>
											char *ptr = strstr((const char *)&gsmInstance.as8GSM_Response_Buff,"+HTTPREAD:");
 804cdde:	4e78      	ldr	r6, [pc, #480]	; (804cfc0 <sendGSMCommand+0x938>)
 804cde0:	4982      	ldr	r1, [pc, #520]	; (804cfec <sendGSMCommand+0x964>)
 804cde2:	4630      	mov	r0, r6
 804cde4:	f004 febb 	bl	8051b5e <strstr>
											char *ptr2 = strstr(ptr,"\n");
 804cde8:	210a      	movs	r1, #10
 804cdea:	f004 fe7e 	bl	8051aea <strchr>
 804cdee:	4604      	mov	r4, r0
											memset(gau8ConfigData,0x00,sizeof(gau8ConfigData));
 804cdf0:	4d7c      	ldr	r5, [pc, #496]	; (804cfe4 <sendGSMCommand+0x95c>)
 804cdf2:	f640 12c4 	movw	r2, #2500	; 0x9c4
 804cdf6:	2100      	movs	r1, #0
 804cdf8:	4628      	mov	r0, r5
 804cdfa:	f004 fe11 	bl	8051a20 <memset>
											memcpy(gau8ConfigData,(ptr2+1),gsmInstance.gu32RemoteConfigSizeinBytes);
 804cdfe:	f8d6 29de 	ldr.w	r2, [r6, #2526]	; 0x9de
 804ce02:	1c61      	adds	r1, r4, #1
 804ce04:	4628      	mov	r0, r5
 804ce06:	f004 fdfd 	bl	8051a04 <memcpy>
											if(u32MemoryWriteCycle == FALSE)
 804ce0a:	4b72      	ldr	r3, [pc, #456]	; (804cfd4 <sendGSMCommand+0x94c>)
 804ce0c:	f8d3 30a4 	ldr.w	r3, [r3, #164]	; 0xa4
 804ce10:	2b00      	cmp	r3, #0
 804ce12:	d147      	bne.n	804cea4 <sendGSMCommand+0x81c>
												if(u32StartofFotaWrite == 0)
 804ce14:	4b6f      	ldr	r3, [pc, #444]	; (804cfd4 <sendGSMCommand+0x94c>)
 804ce16:	f8d3 30a8 	ldr.w	r3, [r3, #168]	; 0xa8
 804ce1a:	b303      	cbz	r3, 804ce5e <sendGSMCommand+0x7d6>
												u32FlashMemoryWriteStatus = WriteDatatoFlash(u32LastMemoryWriteLocation,(uint8_t *)gau8ConfigData,1024,1);
 804ce1c:	2301      	movs	r3, #1
 804ce1e:	f44f 6280 	mov.w	r2, #1024	; 0x400
 804ce22:	4970      	ldr	r1, [pc, #448]	; (804cfe4 <sendGSMCommand+0x95c>)
 804ce24:	4872      	ldr	r0, [pc, #456]	; (804cff0 <sendGSMCommand+0x968>)
 804ce26:	6800      	ldr	r0, [r0, #0]
 804ce28:	f004 f900 	bl	805102c <WriteDatatoFlash>
 804ce2c:	4a69      	ldr	r2, [pc, #420]	; (804cfd4 <sendGSMCommand+0x94c>)
 804ce2e:	f8c2 00ac 	str.w	r0, [r2, #172]	; 0xac
												if(u32FlashMemoryWriteStatus == SUCCESS)
 804ce32:	bb68      	cbnz	r0, 804ce90 <sendGSMCommand+0x808>
													u32MemoryWriteCycle = TRUE;
 804ce34:	4613      	mov	r3, r2
 804ce36:	2201      	movs	r2, #1
 804ce38:	f8c3 20a4 	str.w	r2, [r3, #164]	; 0xa4
													updateHTTPReadLength(gsmInstance.gu32RemoteConfigSizeinBytes);
 804ce3c:	4c66      	ldr	r4, [pc, #408]	; (804cfd8 <sendGSMCommand+0x950>)
 804ce3e:	f8d4 0e30 	ldr.w	r0, [r4, #3632]	; 0xe30
 804ce42:	f7ff fb89 	bl	804c558 <updateHTTPReadLength>
													memset((char *)gsmInstance.as8GSM_Response_Buff, GSM_ARRAY_INIT_CHAR,(GSM_RESPONSE_ARRAY_SIZE * sizeof(uint8_t)));
 804ce46:	f640 12c4 	movw	r2, #2500	; 0x9c4
 804ce4a:	2100      	movs	r1, #0
 804ce4c:	f204 4052 	addw	r0, r4, #1106	; 0x452
 804ce50:	f004 fde6 	bl	8051a20 <memset>
											gsmInstance.u8IncrementGsmState = FALSE;
 804ce54:	4b60      	ldr	r3, [pc, #384]	; (804cfd8 <sendGSMCommand+0x950>)
 804ce56:	2200      	movs	r2, #0
 804ce58:	f883 2e1c 	strb.w	r2, [r3, #3612]	; 0xe1c
 804ce5c:	e506      	b.n	804c86c <sendGSMCommand+0x1e4>
													FLASH_If_Init();
 804ce5e:	f004 f895 	bl	8050f8c <FLASH_If_Init>
													if(FLASH_If_Erase_User(0,getNewFirmwareStorageLocation()) != FLASHIF_OK)
 804ce62:	f004 f925 	bl	80510b0 <getNewFirmwareStorageLocation>
 804ce66:	4601      	mov	r1, r0
 804ce68:	2000      	movs	r0, #0
 804ce6a:	f004 f8e5 	bl	8051038 <FLASH_If_Erase_User>
 804ce6e:	b920      	cbnz	r0, 804ce7a <sendGSMCommand+0x7f2>
													u32StartofFotaWrite = 1;
 804ce70:	4b58      	ldr	r3, [pc, #352]	; (804cfd4 <sendGSMCommand+0x94c>)
 804ce72:	2201      	movs	r2, #1
 804ce74:	f8c3 20a8 	str.w	r2, [r3, #168]	; 0xa8
 804ce78:	e7d0      	b.n	804ce1c <sendGSMCommand+0x794>
														restoreHTTPURLforData();
 804ce7a:	f7ff fb17 	bl	804c4ac <restoreHTTPURLforData>
														gsmInstance.enmcurrentTask = enmGSMTASK_UPLOADDATA;
 804ce7e:	f2a6 4352 	subw	r3, r6, #1106	; 0x452
 804ce82:	2203      	movs	r2, #3
 804ce84:	f883 2e3e 	strb.w	r2, [r3, #3646]	; 0xe3e
														gsmInstance.enmGSMCommand = enmGSMSTATE_ATHTTPDATACOMMAND;
 804ce88:	2214      	movs	r2, #20
 804ce8a:	f883 2e3f 	strb.w	r2, [r3, #3647]	; 0xe3f
 804ce8e:	e7ef      	b.n	804ce70 <sendGSMCommand+0x7e8>
													restoreHTTPURLforData();
 804ce90:	f7ff fb0c 	bl	804c4ac <restoreHTTPURLforData>
													gsmInstance.enmcurrentTask = enmGSMTASK_UPLOADDATA;
 804ce94:	4b50      	ldr	r3, [pc, #320]	; (804cfd8 <sendGSMCommand+0x950>)
 804ce96:	2203      	movs	r2, #3
 804ce98:	f883 2e3e 	strb.w	r2, [r3, #3646]	; 0xe3e
													gsmInstance.enmGSMCommand = enmGSMSTATE_ATHTTPDATACOMMAND;
 804ce9c:	2214      	movs	r2, #20
 804ce9e:	f883 2e3f 	strb.w	r2, [r3, #3647]	; 0xe3f
 804cea2:	e7d7      	b.n	804ce54 <sendGSMCommand+0x7cc>
												u32FlashMemoryWriteStatus = WriteDatatoFlash(u32LastMemoryWriteLocation,(uint8_t *)gau8ConfigData,1024,1);
 804cea4:	2301      	movs	r3, #1
 804cea6:	f44f 6280 	mov.w	r2, #1024	; 0x400
 804ceaa:	494e      	ldr	r1, [pc, #312]	; (804cfe4 <sendGSMCommand+0x95c>)
 804ceac:	4850      	ldr	r0, [pc, #320]	; (804cff0 <sendGSMCommand+0x968>)
 804ceae:	6800      	ldr	r0, [r0, #0]
 804ceb0:	f004 f8bc 	bl	805102c <WriteDatatoFlash>
 804ceb4:	4a47      	ldr	r2, [pc, #284]	; (804cfd4 <sendGSMCommand+0x94c>)
 804ceb6:	f8c2 00ac 	str.w	r0, [r2, #172]	; 0xac
												if(u32FlashMemoryWriteStatus == SUCCESS)
 804ceba:	b928      	cbnz	r0, 804cec8 <sendGSMCommand+0x840>
													updateHTTPReadLength(gsmInstance.gu32RemoteConfigSizeinBytes);
 804cebc:	4b46      	ldr	r3, [pc, #280]	; (804cfd8 <sendGSMCommand+0x950>)
 804cebe:	f8d3 0e30 	ldr.w	r0, [r3, #3632]	; 0xe30
 804cec2:	f7ff fb49 	bl	804c558 <updateHTTPReadLength>
 804cec6:	e7c5      	b.n	804ce54 <sendGSMCommand+0x7cc>
													restoreHTTPURLforData();
 804cec8:	f7ff faf0 	bl	804c4ac <restoreHTTPURLforData>
													gsmInstance.enmcurrentTask = enmGSMTASK_UPLOADDATA;
 804cecc:	4b42      	ldr	r3, [pc, #264]	; (804cfd8 <sendGSMCommand+0x950>)
 804cece:	2203      	movs	r2, #3
 804ced0:	f883 2e3e 	strb.w	r2, [r3, #3646]	; 0xe3e
													gsmInstance.enmGSMCommand = enmGSMSTATE_ATHTTPDATACOMMAND;
 804ced4:	2214      	movs	r2, #20
 804ced6:	f883 2e3f 	strb.w	r2, [r3, #3647]	; 0xe3f
 804ceda:	e7bb      	b.n	804ce54 <sendGSMCommand+0x7cc>
											char *ptr = strstr((const char *)&gsmInstance.as8GSM_Response_Buff,"+HTTPREAD:");
 804cedc:	4e38      	ldr	r6, [pc, #224]	; (804cfc0 <sendGSMCommand+0x938>)
 804cede:	4943      	ldr	r1, [pc, #268]	; (804cfec <sendGSMCommand+0x964>)
 804cee0:	4630      	mov	r0, r6
 804cee2:	f004 fe3c 	bl	8051b5e <strstr>
											char *ptr2 = strstr(ptr,"\n");
 804cee6:	210a      	movs	r1, #10
 804cee8:	f004 fdff 	bl	8051aea <strchr>
 804ceec:	4604      	mov	r4, r0
											memset(gau8ConfigData,0x00,sizeof(gau8ConfigData));
 804ceee:	4d3d      	ldr	r5, [pc, #244]	; (804cfe4 <sendGSMCommand+0x95c>)
 804cef0:	f640 12c4 	movw	r2, #2500	; 0x9c4
 804cef4:	2100      	movs	r1, #0
 804cef6:	4628      	mov	r0, r5
 804cef8:	f004 fd92 	bl	8051a20 <memset>
											memcpy(gau8ConfigData,(ptr2+1),gsmInstance.gu32RemoteConfigSizeinBytes);
 804cefc:	f8d6 29de 	ldr.w	r2, [r6, #2526]	; 0x9de
 804cf00:	1c61      	adds	r1, r4, #1
 804cf02:	4628      	mov	r0, r5
 804cf04:	f004 fd7e 	bl	8051a04 <memcpy>
											if(u32MemoryWriteCycle == FALSE)
 804cf08:	4b32      	ldr	r3, [pc, #200]	; (804cfd4 <sendGSMCommand+0x94c>)
 804cf0a:	f8d3 30a4 	ldr.w	r3, [r3, #164]	; 0xa4
 804cf0e:	b303      	cbz	r3, 804cf52 <sendGSMCommand+0x8ca>
											u32FlashMemoryWriteStatus = WriteDatatoFlash(u32LastMemoryWriteLocation,(uint8_t *)gau8ConfigData,1024,1);
 804cf10:	2301      	movs	r3, #1
 804cf12:	f44f 6280 	mov.w	r2, #1024	; 0x400
 804cf16:	4933      	ldr	r1, [pc, #204]	; (804cfe4 <sendGSMCommand+0x95c>)
 804cf18:	4835      	ldr	r0, [pc, #212]	; (804cff0 <sendGSMCommand+0x968>)
 804cf1a:	6800      	ldr	r0, [r0, #0]
 804cf1c:	f004 f886 	bl	805102c <WriteDatatoFlash>
 804cf20:	4b2c      	ldr	r3, [pc, #176]	; (804cfd4 <sendGSMCommand+0x94c>)
 804cf22:	f8c3 00ac 	str.w	r0, [r3, #172]	; 0xac
											if(flashWriteBootSection(getNewFirmwareStorageLocation()) == 0)
 804cf26:	f004 f8c3 	bl	80510b0 <getNewFirmwareStorageLocation>
 804cf2a:	f004 f8e9 	bl	8051100 <flashWriteBootSection>
 804cf2e:	bb60      	cbnz	r0, 804cf8a <sendGSMCommand+0x902>
												gu32AttemptFota =  FALSE;
 804cf30:	4b28      	ldr	r3, [pc, #160]	; (804cfd4 <sendGSMCommand+0x94c>)
 804cf32:	2200      	movs	r2, #0
 804cf34:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c
												if(u32MemoryWriteCycle == TRUE)
 804cf38:	f8d3 30a4 	ldr.w	r3, [r3, #164]	; 0xa4
 804cf3c:	2b01      	cmp	r3, #1
 804cf3e:	d020      	beq.n	804cf82 <sendGSMCommand+0x8fa>
												HAL_Delay(50000);
 804cf40:	f24c 3050 	movw	r0, #50000	; 0xc350
 804cf44:	f7f4 f8c2 	bl	80410cc <HAL_Delay>
											u32MemoryWriteCycle = TRUE;
 804cf48:	4b22      	ldr	r3, [pc, #136]	; (804cfd4 <sendGSMCommand+0x94c>)
 804cf4a:	2201      	movs	r2, #1
 804cf4c:	f8c3 20a4 	str.w	r2, [r3, #164]	; 0xa4
 804cf50:	e48c      	b.n	804c86c <sendGSMCommand+0x1e4>
												FLASH_If_Init();
 804cf52:	f004 f81b 	bl	8050f8c <FLASH_If_Init>
												u32MemoryEraseStatus = FLASH_If_Erase_User(0,getNewFirmwareStorageLocation());
 804cf56:	f004 f8ab 	bl	80510b0 <getNewFirmwareStorageLocation>
 804cf5a:	4601      	mov	r1, r0
 804cf5c:	2000      	movs	r0, #0
 804cf5e:	f004 f86b 	bl	8051038 <FLASH_If_Erase_User>
 804cf62:	4a1c      	ldr	r2, [pc, #112]	; (804cfd4 <sendGSMCommand+0x94c>)
 804cf64:	f8c2 00b0 	str.w	r0, [r2, #176]	; 0xb0
												if(u32MemoryEraseStatus != FLASHIF_OK)
 804cf68:	2800      	cmp	r0, #0
 804cf6a:	d0d1      	beq.n	804cf10 <sendGSMCommand+0x888>
													restoreHTTPURLforData();
 804cf6c:	f7ff fa9e 	bl	804c4ac <restoreHTTPURLforData>
													gsmInstance.enmcurrentTask = enmGSMTASK_UPLOADDATA;
 804cf70:	f2a6 4352 	subw	r3, r6, #1106	; 0x452
 804cf74:	2203      	movs	r2, #3
 804cf76:	f883 2e3e 	strb.w	r2, [r3, #3646]	; 0xe3e
													gsmInstance.enmGSMCommand = enmGSMSTATE_ATHTTPDATACOMMAND;
 804cf7a:	2214      	movs	r2, #20
 804cf7c:	f883 2e3f 	strb.w	r2, [r3, #3647]	; 0xe3f
 804cf80:	e7c6      	b.n	804cf10 <sendGSMCommand+0x888>
													u32MemoryWriteCycle = FALSE;
 804cf82:	4b14      	ldr	r3, [pc, #80]	; (804cfd4 <sendGSMCommand+0x94c>)
 804cf84:	f8c3 20a4 	str.w	r2, [r3, #164]	; 0xa4
 804cf88:	e7da      	b.n	804cf40 <sendGSMCommand+0x8b8>
												restoreHTTPURLforData();
 804cf8a:	f7ff fa8f 	bl	804c4ac <restoreHTTPURLforData>
												gsmInstance.enmcurrentTask = enmGSMTASK_UPLOADDATA;
 804cf8e:	4b12      	ldr	r3, [pc, #72]	; (804cfd8 <sendGSMCommand+0x950>)
 804cf90:	2203      	movs	r2, #3
 804cf92:	f883 2e3e 	strb.w	r2, [r3, #3646]	; 0xe3e
												gsmInstance.enmGSMCommand = enmGSMSTATE_ATHTTPDATACOMMAND;
 804cf96:	2214      	movs	r2, #20
 804cf98:	f883 2e3f 	strb.w	r2, [r3, #3647]	; 0xe3f
 804cf9c:	e7d4      	b.n	804cf48 <sendGSMCommand+0x8c0>
							memcpy(gsmInstance.agsmCommandResponse[gsmInstance.enmGSMCommand], (char *)&gsmInstance.as8GSM_Response_Buff, sizeof(gsmInstance.as8GSM_Response_Buff));
 804cf9e:	201e      	movs	r0, #30
 804cfa0:	fb00 f004 	mul.w	r0, r0, r4
 804cfa4:	30c0      	adds	r0, #192	; 0xc0
 804cfa6:	490c      	ldr	r1, [pc, #48]	; (804cfd8 <sendGSMCommand+0x950>)
 804cfa8:	4408      	add	r0, r1
 804cfaa:	f640 12c4 	movw	r2, #2500	; 0x9c4
 804cfae:	f201 4152 	addw	r1, r1, #1106	; 0x452
 804cfb2:	3003      	adds	r0, #3
 804cfb4:	f004 fd26 	bl	8051a04 <memcpy>
							break;
 804cfb8:	e458      	b.n	804c86c <sendGSMCommand+0x1e4>
 804cfba:	bf00      	nop
 804cfbc:	0805a970 	.word	0x0805a970
 804cfc0:	2000c7ea 	.word	0x2000c7ea
 804cfc4:	2000515c 	.word	0x2000515c
 804cfc8:	0002bf20 	.word	0x0002bf20
 804cfcc:	200008d8 	.word	0x200008d8
 804cfd0:	0805a898 	.word	0x0805a898
 804cfd4:	20004214 	.word	0x20004214
 804cfd8:	2000c398 	.word	0x2000c398
 804cfdc:	1fff7a22 	.word	0x1fff7a22
 804cfe0:	20000010 	.word	0x20000010
 804cfe4:	2000b9d4 	.word	0x2000b9d4
 804cfe8:	40020c00 	.word	0x40020c00
 804cfec:	0805a978 	.word	0x0805a978
 804cff0:	20005038 	.word	0x20005038
						memset((char *)gsmInstance.as8GSM_Response_Buff, GSM_ARRAY_INIT_CHAR,(GSM_RESPONSE_ARRAY_SIZE * sizeof(uint8_t))); /* Clear Response Buffer */
 804cff4:	f640 12c4 	movw	r2, #2500	; 0x9c4
 804cff8:	2100      	movs	r1, #0
 804cffa:	f203 4052 	addw	r0, r3, #1106	; 0x452
 804cffe:	f004 fd0f 	bl	8051a20 <memset>
 804d002:	e44a      	b.n	804c89a <sendGSMCommand+0x212>
					gsmInstance.u8GSM_Response_Character_Counter = 0;
 804d004:	4b1b      	ldr	r3, [pc, #108]	; (804d074 <sendGSMCommand+0x9ec>)
 804d006:	2500      	movs	r5, #0
 804d008:	f8c3 5e38 	str.w	r5, [r3, #3640]	; 0xe38
					gsmInstance.enmGSMCommandResponseState = enmGSM_CMDSEND;
 804d00c:	2201      	movs	r2, #1
 804d00e:	f883 2e3c 	strb.w	r2, [r3, #3644]	; 0xe3c
					memcpy(gsmInstance.agsmCommandResponse[gsmInstance.enmGSMCommand], (char *)&gsmInstance.as8GSM_Response_Buff, sizeof(gsmInstance.as8GSM_Response_Buff));
 804d012:	ebc4 1004 	rsb	r0, r4, r4, lsl #4
 804d016:	4090      	lsls	r0, r2
 804d018:	30c0      	adds	r0, #192	; 0xc0
 804d01a:	4418      	add	r0, r3
 804d01c:	f203 4452 	addw	r4, r3, #1106	; 0x452
 804d020:	f640 16c4 	movw	r6, #2500	; 0x9c4
 804d024:	4632      	mov	r2, r6
 804d026:	4621      	mov	r1, r4
 804d028:	3003      	adds	r0, #3
 804d02a:	f004 fceb 	bl	8051a04 <memcpy>
					memset((char *)gsmInstance.as8GSM_Response_Buff, GSM_ARRAY_INIT_CHAR,(GSM_RESPONSE_ARRAY_SIZE * sizeof(uint8_t))); /* Clear Response Buffer */
 804d02e:	4632      	mov	r2, r6
 804d030:	4629      	mov	r1, r5
 804d032:	4620      	mov	r0, r4
 804d034:	f004 fcf4 	bl	8051a20 <memset>
					u8GSMCharRcv = 0;
 804d038:	4b0f      	ldr	r3, [pc, #60]	; (804d078 <sendGSMCommand+0x9f0>)
 804d03a:	601d      	str	r5, [r3, #0]
 804d03c:	f7ff bb2d 	b.w	804c69a <sendGSMCommand+0x12>
						gu8CheckSMS = TRUE;
 804d040:	4b0e      	ldr	r3, [pc, #56]	; (804d07c <sendGSMCommand+0x9f4>)
 804d042:	2201      	movs	r2, #1
 804d044:	f883 2091 	strb.w	r2, [r3, #145]	; 0x91
 804d048:	f7ff bbc7 	b.w	804c7da <sendGSMCommand+0x152>
					gsmInstance.enmGSMCommandState = enmGSM_CMDSEND;
 804d04c:	4c09      	ldr	r4, [pc, #36]	; (804d074 <sendGSMCommand+0x9ec>)
 804d04e:	2301      	movs	r3, #1
 804d050:	f884 3e3d 	strb.w	r3, [r4, #3645]	; 0xe3d
					gsmInstance.enmGSMCommandResponseState = enmGSM_SENDCMD;
 804d054:	2100      	movs	r1, #0
 804d056:	f884 1e3c 	strb.w	r1, [r4, #3644]	; 0xe3c
					memset((char *)gsmInstance.as8GSM_Response_Buff, GSM_ARRAY_INIT_CHAR, (GSM_RESPONSE_ARRAY_SIZE));
 804d05a:	f640 12c4 	movw	r2, #2500	; 0x9c4
 804d05e:	f204 4052 	addw	r0, r4, #1106	; 0x452
 804d062:	f004 fcdd 	bl	8051a20 <memset>
					gsmInstance.u32GSMTimer = ONE_SEC;
 804d066:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 804d06a:	f8c4 3e20 	str.w	r3, [r4, #3616]	; 0xe20
 804d06e:	f7ff bbb6 	b.w	804c7de <sendGSMCommand+0x156>
 804d072:	bf00      	nop
 804d074:	2000c398 	.word	0x2000c398
 804d078:	20004f7c 	.word	0x20004f7c
 804d07c:	20004214 	.word	0x20004214

0804d080 <operateGSMSIM868>:
	if(gsmInstance.u32GSMTimer != 0)
 804d080:	4b96      	ldr	r3, [pc, #600]	; (804d2dc <operateGSMSIM868+0x25c>)
 804d082:	f8d3 3e20 	ldr.w	r3, [r3, #3616]	; 0xe20
 804d086:	2b00      	cmp	r3, #0
 804d088:	f040 8126 	bne.w	804d2d8 <operateGSMSIM868+0x258>
{
 804d08c:	b510      	push	{r4, lr}
 804d08e:	f5ad 5d8b 	sub.w	sp, sp, #4448	; 0x1160
	switch(gsmInstance.enmcurrentTask)
 804d092:	4b92      	ldr	r3, [pc, #584]	; (804d2dc <operateGSMSIM868+0x25c>)
 804d094:	f893 3e3e 	ldrb.w	r3, [r3, #3646]	; 0xe3e
 804d098:	b2db      	uxtb	r3, r3
 804d09a:	2b09      	cmp	r3, #9
 804d09c:	f200 8119 	bhi.w	804d2d2 <operateGSMSIM868+0x252>
 804d0a0:	e8df f013 	tbh	[pc, r3, lsl #1]
 804d0a4:	0030000a 	.word	0x0030000a
 804d0a8:	00c400b2 	.word	0x00c400b2
 804d0ac:	00940076 	.word	0x00940076
 804d0b0:	00ff0064 	.word	0x00ff0064
 804d0b4:	010f0102 	.word	0x010f0102
			if(gsmInstance.enmGSMPwrState == enmGSM_PWRNOTSTARTED)
 804d0b8:	4b88      	ldr	r3, [pc, #544]	; (804d2dc <operateGSMSIM868+0x25c>)
 804d0ba:	f893 3e40 	ldrb.w	r3, [r3, #3648]	; 0xe40
 804d0be:	b19b      	cbz	r3, 804d0e8 <operateGSMSIM868+0x68>
			else if(gsmInstance.enmGSMPwrState == enmGSM_PWRSTARTED)
 804d0c0:	2b01      	cmp	r3, #1
 804d0c2:	f040 80ad 	bne.w	804d220 <operateGSMSIM868+0x1a0>
				HAL_GPIO_WritePin(GSM_PWR_KEY_GPIO_Port,GSM_PWR_KEY_Pin,GPIO_PIN_RESET);
 804d0c6:	2200      	movs	r2, #0
 804d0c8:	2180      	movs	r1, #128	; 0x80
 804d0ca:	4885      	ldr	r0, [pc, #532]	; (804d2e0 <operateGSMSIM868+0x260>)
 804d0cc:	f7f5 fe28 	bl	8042d20 <HAL_GPIO_WritePin>
				gsmInstance.u32GSMTimer = TWO_SEC;
 804d0d0:	4b82      	ldr	r3, [pc, #520]	; (804d2dc <operateGSMSIM868+0x25c>)
 804d0d2:	f44f 62fa 	mov.w	r2, #2000	; 0x7d0
 804d0d6:	f8c3 2e20 	str.w	r2, [r3, #3616]	; 0xe20
				gsmInstance.enmcurrentTask = enmGSMTASK_INITMODULE;
 804d0da:	2201      	movs	r2, #1
 804d0dc:	f883 2e3e 	strb.w	r2, [r3, #3646]	; 0xe3e
				gsmInstance.enmGSMPwrState = enmGSM_PWRCOMPLETED;
 804d0e0:	2202      	movs	r2, #2
 804d0e2:	f883 2e40 	strb.w	r2, [r3, #3648]	; 0xe40
 804d0e6:	e09b      	b.n	804d220 <operateGSMSIM868+0x1a0>
				HAL_GPIO_WritePin(GSM_PWR_KEY_GPIO_Port,GSM_PWR_KEY_Pin,GPIO_PIN_SET);
 804d0e8:	2201      	movs	r2, #1
 804d0ea:	2180      	movs	r1, #128	; 0x80
 804d0ec:	487c      	ldr	r0, [pc, #496]	; (804d2e0 <operateGSMSIM868+0x260>)
 804d0ee:	f7f5 fe17 	bl	8042d20 <HAL_GPIO_WritePin>
				gsmInstance.u32GSMTimer = FIVE_SEC;
 804d0f2:	4b7a      	ldr	r3, [pc, #488]	; (804d2dc <operateGSMSIM868+0x25c>)
 804d0f4:	f241 3288 	movw	r2, #5000	; 0x1388
 804d0f8:	f8c3 2e20 	str.w	r2, [r3, #3616]	; 0xe20
				gsmInstance.enmGSMPwrState = enmGSM_PWRSTARTED;
 804d0fc:	2201      	movs	r2, #1
 804d0fe:	f883 2e40 	strb.w	r2, [r3, #3648]	; 0xe40
 804d102:	e08d      	b.n	804d220 <operateGSMSIM868+0x1a0>
			if(gsmInstance.enmGSMCommandState == enmGSM_CMDTIMEOUT)
 804d104:	4b75      	ldr	r3, [pc, #468]	; (804d2dc <operateGSMSIM868+0x25c>)
 804d106:	f893 3e3d 	ldrb.w	r3, [r3, #3645]	; 0xe3d
 804d10a:	b2db      	uxtb	r3, r3
 804d10c:	2b05      	cmp	r3, #5
 804d10e:	d011      	beq.n	804d134 <operateGSMSIM868+0xb4>
				if(gsmInstance.enmGSMCommand == enmGSMSTATE_ATHTTPDATACOMMAND)
 804d110:	4b72      	ldr	r3, [pc, #456]	; (804d2dc <operateGSMSIM868+0x25c>)
 804d112:	f893 3e3f 	ldrb.w	r3, [r3, #3647]	; 0xe3f
 804d116:	2b14      	cmp	r3, #20
 804d118:	d11b      	bne.n	804d152 <operateGSMSIM868+0xd2>
					if(gu8CheckSMS == TRUE)
 804d11a:	4b72      	ldr	r3, [pc, #456]	; (804d2e4 <operateGSMSIM868+0x264>)
 804d11c:	f893 3091 	ldrb.w	r3, [r3, #145]	; 0x91
 804d120:	2b01      	cmp	r3, #1
 804d122:	d00a      	beq.n	804d13a <operateGSMSIM868+0xba>
						gsmInstance.enmGSMCommand = enmGSMSTATE_GPSINFO;
 804d124:	4b6d      	ldr	r3, [pc, #436]	; (804d2dc <operateGSMSIM868+0x25c>)
 804d126:	2217      	movs	r2, #23
 804d128:	f883 2e3f 	strb.w	r2, [r3, #3647]	; 0xe3f
						gsmInstance.enmcurrentTask = enmGSMTASK_UPDATELOCATION;
 804d12c:	2202      	movs	r2, #2
 804d12e:	f883 2e3e 	strb.w	r2, [r3, #3646]	; 0xe3e
 804d132:	e075      	b.n	804d220 <operateGSMSIM868+0x1a0>
				initGSMSIM868();
 804d134:	f7fe fe44 	bl	804bdc0 <initGSMSIM868>
 804d138:	e072      	b.n	804d220 <operateGSMSIM868+0x1a0>
						gsmInstance.enmcurrentTask = enmGSMTASK_UPLOADDATA;
 804d13a:	4b68      	ldr	r3, [pc, #416]	; (804d2dc <operateGSMSIM868+0x25c>)
 804d13c:	2203      	movs	r2, #3
 804d13e:	f883 2e3e 	strb.w	r2, [r3, #3646]	; 0xe3e
						gsmInstance.enmGSMCommand = enmGSMSTATE_ATHTTPDATACOMMAND;
 804d142:	2214      	movs	r2, #20
 804d144:	f883 2e3f 	strb.w	r2, [r3, #3647]	; 0xe3f
						gu8CheckSMS = FALSE;
 804d148:	4b66      	ldr	r3, [pc, #408]	; (804d2e4 <operateGSMSIM868+0x264>)
 804d14a:	2200      	movs	r2, #0
 804d14c:	f883 2091 	strb.w	r2, [r3, #145]	; 0x91
 804d150:	e066      	b.n	804d220 <operateGSMSIM868+0x1a0>
					sendGSMCommand(gsmInstance);
 804d152:	4c62      	ldr	r4, [pc, #392]	; (804d2dc <operateGSMSIM868+0x25c>)
 804d154:	f44f 528b 	mov.w	r2, #4448	; 0x1160
 804d158:	f104 0110 	add.w	r1, r4, #16
 804d15c:	4668      	mov	r0, sp
 804d15e:	f004 fc51 	bl	8051a04 <memcpy>
 804d162:	e894 000f 	ldmia.w	r4, {r0, r1, r2, r3}
 804d166:	f7ff fa8f 	bl	804c688 <sendGSMCommand>
 804d16a:	e059      	b.n	804d220 <operateGSMSIM868+0x1a0>
			if(gsmInstance.u32GSMHeartbeatTimer == 0)
 804d16c:	4b5b      	ldr	r3, [pc, #364]	; (804d2dc <operateGSMSIM868+0x25c>)
 804d16e:	f8d3 3e2c 	ldr.w	r3, [r3, #3628]	; 0xe2c
 804d172:	2b00      	cmp	r3, #0
 804d174:	d154      	bne.n	804d220 <operateGSMSIM868+0x1a0>
				sendGSMCommand(gsmInstance);
 804d176:	4c59      	ldr	r4, [pc, #356]	; (804d2dc <operateGSMSIM868+0x25c>)
 804d178:	f44f 528b 	mov.w	r2, #4448	; 0x1160
 804d17c:	f104 0110 	add.w	r1, r4, #16
 804d180:	4668      	mov	r0, sp
 804d182:	f004 fc3f 	bl	8051a04 <memcpy>
 804d186:	e894 000f 	ldmia.w	r4, {r0, r1, r2, r3}
 804d18a:	f7ff fa7d 	bl	804c688 <sendGSMCommand>
 804d18e:	e047      	b.n	804d220 <operateGSMSIM868+0x1a0>
			if(gu8ReadSMS == TRUE)
 804d190:	4b54      	ldr	r3, [pc, #336]	; (804d2e4 <operateGSMSIM868+0x264>)
 804d192:	f893 30b4 	ldrb.w	r3, [r3, #180]	; 0xb4
 804d196:	2b01      	cmp	r3, #1
 804d198:	d00b      	beq.n	804d1b2 <operateGSMSIM868+0x132>
				gsmInstance.enmGSMCommand = enmGSMSTATE_GPSINFO;
 804d19a:	4b50      	ldr	r3, [pc, #320]	; (804d2dc <operateGSMSIM868+0x25c>)
 804d19c:	2217      	movs	r2, #23
 804d19e:	f883 2e3f 	strb.w	r2, [r3, #3647]	; 0xe3f
				gsmInstance.enmcurrentTask = enmGSMTASK_UPDATELOCATION;
 804d1a2:	2202      	movs	r2, #2
 804d1a4:	f883 2e3e 	strb.w	r2, [r3, #3646]	; 0xe3e
				gsmInstance.u32GSMTimer = TWO_SEC;
 804d1a8:	f44f 62fa 	mov.w	r2, #2000	; 0x7d0
 804d1ac:	f8c3 2e20 	str.w	r2, [r3, #3616]	; 0xe20
 804d1b0:	e036      	b.n	804d220 <operateGSMSIM868+0x1a0>
				sendGSMCommand(gsmInstance);
 804d1b2:	4c4a      	ldr	r4, [pc, #296]	; (804d2dc <operateGSMSIM868+0x25c>)
 804d1b4:	f44f 528b 	mov.w	r2, #4448	; 0x1160
 804d1b8:	f104 0110 	add.w	r1, r4, #16
 804d1bc:	4668      	mov	r0, sp
 804d1be:	f004 fc21 	bl	8051a04 <memcpy>
 804d1c2:	e894 000f 	ldmia.w	r4, {r0, r1, r2, r3}
 804d1c6:	f7ff fa5f 	bl	804c688 <sendGSMCommand>
 804d1ca:	e029      	b.n	804d220 <operateGSMSIM868+0x1a0>
			if(gu8SendSMS == TRUE)
 804d1cc:	4b45      	ldr	r3, [pc, #276]	; (804d2e4 <operateGSMSIM868+0x264>)
 804d1ce:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 804d1d2:	2b01      	cmp	r3, #1
 804d1d4:	d00b      	beq.n	804d1ee <operateGSMSIM868+0x16e>
				gsmInstance.enmGSMCommand = enmGSMSTATE_GPSINFO;
 804d1d6:	4b41      	ldr	r3, [pc, #260]	; (804d2dc <operateGSMSIM868+0x25c>)
 804d1d8:	2217      	movs	r2, #23
 804d1da:	f883 2e3f 	strb.w	r2, [r3, #3647]	; 0xe3f
				gsmInstance.enmcurrentTask = enmGSMTASK_UPDATELOCATION;
 804d1de:	2202      	movs	r2, #2
 804d1e0:	f883 2e3e 	strb.w	r2, [r3, #3646]	; 0xe3e
				gsmInstance.u32GSMTimer = TWO_SEC;
 804d1e4:	f44f 62fa 	mov.w	r2, #2000	; 0x7d0
 804d1e8:	f8c3 2e20 	str.w	r2, [r3, #3616]	; 0xe20
 804d1ec:	e018      	b.n	804d220 <operateGSMSIM868+0x1a0>
				sendGSMCommand(gsmInstance);
 804d1ee:	4c3b      	ldr	r4, [pc, #236]	; (804d2dc <operateGSMSIM868+0x25c>)
 804d1f0:	f44f 528b 	mov.w	r2, #4448	; 0x1160
 804d1f4:	f104 0110 	add.w	r1, r4, #16
 804d1f8:	4668      	mov	r0, sp
 804d1fa:	f004 fc03 	bl	8051a04 <memcpy>
 804d1fe:	e894 000f 	ldmia.w	r4, {r0, r1, r2, r3}
 804d202:	f7ff fa41 	bl	804c688 <sendGSMCommand>
 804d206:	e00b      	b.n	804d220 <operateGSMSIM868+0x1a0>
			sendGSMCommand(gsmInstance);
 804d208:	4c34      	ldr	r4, [pc, #208]	; (804d2dc <operateGSMSIM868+0x25c>)
 804d20a:	f44f 528b 	mov.w	r2, #4448	; 0x1160
 804d20e:	f104 0110 	add.w	r1, r4, #16
 804d212:	4668      	mov	r0, sp
 804d214:	f004 fbf6 	bl	8051a04 <memcpy>
 804d218:	e894 000f 	ldmia.w	r4, {r0, r1, r2, r3}
 804d21c:	f7ff fa34 	bl	804c688 <sendGSMCommand>
	gu32GSMHangTimer = THREE_MIN;
 804d220:	4b31      	ldr	r3, [pc, #196]	; (804d2e8 <operateGSMSIM868+0x268>)
 804d222:	4a32      	ldr	r2, [pc, #200]	; (804d2ec <operateGSMSIM868+0x26c>)
 804d224:	601a      	str	r2, [r3, #0]
}
 804d226:	f50d 5d8b 	add.w	sp, sp, #4448	; 0x1160
 804d22a:	bd10      	pop	{r4, pc}
			if((isQueueEmpty(&gsmPayload) == FALSE )&& (gsmPayload.data[gsmPayload.tail] != NULL))
 804d22c:	4830      	ldr	r0, [pc, #192]	; (804d2f0 <operateGSMSIM868+0x270>)
 804d22e:	f001 fffd 	bl	804f22c <isQueueEmpty>
 804d232:	bb70      	cbnz	r0, 804d292 <operateGSMSIM868+0x212>
 804d234:	4a2e      	ldr	r2, [pc, #184]	; (804d2f0 <operateGSMSIM868+0x270>)
 804d236:	6853      	ldr	r3, [r2, #4]
 804d238:	3302      	adds	r3, #2
 804d23a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 804d23e:	b343      	cbz	r3, 804d292 <operateGSMSIM868+0x212>
				if((gu8HttpPayloadFlag == 0) && (gsmInstance.enmGSMCommand == enmGSMSTATE_ATHTTPDATACOMMAND))
 804d240:	4b28      	ldr	r3, [pc, #160]	; (804d2e4 <operateGSMSIM868+0x264>)
 804d242:	f893 3090 	ldrb.w	r3, [r3, #144]	; 0x90
 804d246:	b923      	cbnz	r3, 804d252 <operateGSMSIM868+0x1d2>
 804d248:	4a24      	ldr	r2, [pc, #144]	; (804d2dc <operateGSMSIM868+0x25c>)
 804d24a:	f892 2e3f 	ldrb.w	r2, [r2, #3647]	; 0xe3f
 804d24e:	2a14      	cmp	r2, #20
 804d250:	d013      	beq.n	804d27a <operateGSMSIM868+0x1fa>
				else if((gu8HttpPayloadFlag == 1) && (gsmInstance.enmGSMCommand == enmGSMSTATE_SENDDATA))
 804d252:	2b01      	cmp	r3, #1
 804d254:	d104      	bne.n	804d260 <operateGSMSIM868+0x1e0>
 804d256:	4b21      	ldr	r3, [pc, #132]	; (804d2dc <operateGSMSIM868+0x25c>)
 804d258:	f893 3e3f 	ldrb.w	r3, [r3, #3647]	; 0xe3f
 804d25c:	2b15      	cmp	r3, #21
 804d25e:	d013      	beq.n	804d288 <operateGSMSIM868+0x208>
					sendGSMCommand(gsmInstance);
 804d260:	4c1e      	ldr	r4, [pc, #120]	; (804d2dc <operateGSMSIM868+0x25c>)
 804d262:	f44f 528b 	mov.w	r2, #4448	; 0x1160
 804d266:	f104 0110 	add.w	r1, r4, #16
 804d26a:	4668      	mov	r0, sp
 804d26c:	f004 fbca 	bl	8051a04 <memcpy>
 804d270:	e894 000f 	ldmia.w	r4, {r0, r1, r2, r3}
 804d274:	f7ff fa08 	bl	804c688 <sendGSMCommand>
 804d278:	e7d2      	b.n	804d220 <operateGSMSIM868+0x1a0>
					updateHttpDataLength();
 804d27a:	f7fe fe81 	bl	804bf80 <updateHttpDataLength>
					gu8HttpPayloadFlag = 1;
 804d27e:	4b19      	ldr	r3, [pc, #100]	; (804d2e4 <operateGSMSIM868+0x264>)
 804d280:	2201      	movs	r2, #1
 804d282:	f883 2090 	strb.w	r2, [r3, #144]	; 0x90
 804d286:	e7cb      	b.n	804d220 <operateGSMSIM868+0x1a0>
					gu8HttpPayloadFlag = 0;
 804d288:	4b16      	ldr	r3, [pc, #88]	; (804d2e4 <operateGSMSIM868+0x264>)
 804d28a:	2200      	movs	r2, #0
 804d28c:	f883 2090 	strb.w	r2, [r3, #144]	; 0x90
 804d290:	e7c6      	b.n	804d220 <operateGSMSIM868+0x1a0>
				gsmInstance.enmGSMCommand = enmGSMSTATE_GPSINFO;
 804d292:	4b12      	ldr	r3, [pc, #72]	; (804d2dc <operateGSMSIM868+0x25c>)
 804d294:	2217      	movs	r2, #23
 804d296:	f883 2e3f 	strb.w	r2, [r3, #3647]	; 0xe3f
				gsmInstance.enmcurrentTask = enmGSMTASK_UPDATELOCATION;
 804d29a:	2202      	movs	r2, #2
 804d29c:	f883 2e3e 	strb.w	r2, [r3, #3646]	; 0xe3e
 804d2a0:	e7be      	b.n	804d220 <operateGSMSIM868+0x1a0>
			initGSMSIM868();
 804d2a2:	f7fe fd8d 	bl	804bdc0 <initGSMSIM868>
			break;
 804d2a6:	e7bb      	b.n	804d220 <operateGSMSIM868+0x1a0>
				sendGSMCommand(gsmInstance);
 804d2a8:	4c0c      	ldr	r4, [pc, #48]	; (804d2dc <operateGSMSIM868+0x25c>)
 804d2aa:	f44f 528b 	mov.w	r2, #4448	; 0x1160
 804d2ae:	f104 0110 	add.w	r1, r4, #16
 804d2b2:	4668      	mov	r0, sp
 804d2b4:	f004 fba6 	bl	8051a04 <memcpy>
 804d2b8:	e894 000f 	ldmia.w	r4, {r0, r1, r2, r3}
 804d2bc:	f7ff f9e4 	bl	804c688 <sendGSMCommand>
			break;
 804d2c0:	e7ae      	b.n	804d220 <operateGSMSIM868+0x1a0>
			gsmInstance.enmcurrentTask = enmGSMTASK_UPLOADDATA;
 804d2c2:	4b06      	ldr	r3, [pc, #24]	; (804d2dc <operateGSMSIM868+0x25c>)
 804d2c4:	2203      	movs	r2, #3
 804d2c6:	f883 2e3e 	strb.w	r2, [r3, #3646]	; 0xe3e
			gsmInstance.enmGSMCommand = enmGSMSTATE_ATHTTPDATACOMMAND;
 804d2ca:	2214      	movs	r2, #20
 804d2cc:	f883 2e3f 	strb.w	r2, [r3, #3647]	; 0xe3f
			break;
 804d2d0:	e7a6      	b.n	804d220 <operateGSMSIM868+0x1a0>
			initGSMSIM868();
 804d2d2:	f7fe fd75 	bl	804bdc0 <initGSMSIM868>
			break;
 804d2d6:	e7a3      	b.n	804d220 <operateGSMSIM868+0x1a0>
 804d2d8:	4770      	bx	lr
 804d2da:	bf00      	nop
 804d2dc:	2000c398 	.word	0x2000c398
 804d2e0:	40020c00 	.word	0x40020c00
 804d2e4:	20004214 	.word	0x20004214
 804d2e8:	2000515c 	.word	0x2000515c
 804d2ec:	0002bf20 	.word	0x0002bf20
 804d2f0:	2000d508 	.word	0x2000d508

0804d2f4 <MX_I2C1_Init>:

I2C_HandleTypeDef hi2c1;

/* I2C1 init function */
void MX_I2C1_Init(void)
{
 804d2f4:	b508      	push	{r3, lr}

  hi2c1.Instance = I2C1;
 804d2f6:	4813      	ldr	r0, [pc, #76]	; (804d344 <MX_I2C1_Init+0x50>)
 804d2f8:	4b13      	ldr	r3, [pc, #76]	; (804d348 <MX_I2C1_Init+0x54>)
 804d2fa:	6003      	str	r3, [r0, #0]
  hi2c1.Init.ClockSpeed = 100000;
 804d2fc:	4b13      	ldr	r3, [pc, #76]	; (804d34c <MX_I2C1_Init+0x58>)
 804d2fe:	6043      	str	r3, [r0, #4]
  hi2c1.Init.DutyCycle = I2C_DUTYCYCLE_2;
 804d300:	2300      	movs	r3, #0
 804d302:	6083      	str	r3, [r0, #8]
  hi2c1.Init.OwnAddress1 = 0;
 804d304:	60c3      	str	r3, [r0, #12]
  hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
 804d306:	f44f 4280 	mov.w	r2, #16384	; 0x4000
 804d30a:	6102      	str	r2, [r0, #16]
  hi2c1.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
 804d30c:	6143      	str	r3, [r0, #20]
  hi2c1.Init.OwnAddress2 = 0;
 804d30e:	6183      	str	r3, [r0, #24]
  hi2c1.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
 804d310:	61c3      	str	r3, [r0, #28]
  hi2c1.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
 804d312:	6203      	str	r3, [r0, #32]
  if (HAL_I2C_Init(&hi2c1) != HAL_OK)
 804d314:	f7f5 feb4 	bl	8043080 <HAL_I2C_Init>
 804d318:	b950      	cbnz	r0, 804d330 <MX_I2C1_Init+0x3c>
  {
    Error_Handler();
  }
  /** Configure Analogue filter
  */
  if (HAL_I2CEx_ConfigAnalogFilter(&hi2c1, I2C_ANALOGFILTER_ENABLE) != HAL_OK)
 804d31a:	2100      	movs	r1, #0
 804d31c:	4809      	ldr	r0, [pc, #36]	; (804d344 <MX_I2C1_Init+0x50>)
 804d31e:	f7f6 fd0d 	bl	8043d3c <HAL_I2CEx_ConfigAnalogFilter>
 804d322:	b940      	cbnz	r0, 804d336 <MX_I2C1_Init+0x42>
  {
    Error_Handler();
  }
  /** Configure Digital filter
  */
  if (HAL_I2CEx_ConfigDigitalFilter(&hi2c1, 0) != HAL_OK)
 804d324:	2100      	movs	r1, #0
 804d326:	4807      	ldr	r0, [pc, #28]	; (804d344 <MX_I2C1_Init+0x50>)
 804d328:	f7f6 fd2a 	bl	8043d80 <HAL_I2CEx_ConfigDigitalFilter>
 804d32c:	b930      	cbnz	r0, 804d33c <MX_I2C1_Init+0x48>
  {
    Error_Handler();
  }

}
 804d32e:	bd08      	pop	{r3, pc}
    Error_Handler();
 804d330:	f000 fa94 	bl	804d85c <Error_Handler>
 804d334:	e7f1      	b.n	804d31a <MX_I2C1_Init+0x26>
    Error_Handler();
 804d336:	f000 fa91 	bl	804d85c <Error_Handler>
 804d33a:	e7f3      	b.n	804d324 <MX_I2C1_Init+0x30>
    Error_Handler();
 804d33c:	f000 fa8e 	bl	804d85c <Error_Handler>
}
 804d340:	e7f5      	b.n	804d32e <MX_I2C1_Init+0x3a>
 804d342:	bf00      	nop
 804d344:	2000d538 	.word	0x2000d538
 804d348:	40005400 	.word	0x40005400
 804d34c:	000186a0 	.word	0x000186a0

0804d350 <HAL_I2C_MspInit>:

void HAL_I2C_MspInit(I2C_HandleTypeDef* i2cHandle)
{
 804d350:	b530      	push	{r4, r5, lr}
 804d352:	b089      	sub	sp, #36	; 0x24

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 804d354:	2300      	movs	r3, #0
 804d356:	9303      	str	r3, [sp, #12]
 804d358:	9304      	str	r3, [sp, #16]
 804d35a:	9305      	str	r3, [sp, #20]
 804d35c:	9306      	str	r3, [sp, #24]
 804d35e:	9307      	str	r3, [sp, #28]
  if(i2cHandle->Instance==I2C1)
 804d360:	6802      	ldr	r2, [r0, #0]
 804d362:	4b1d      	ldr	r3, [pc, #116]	; (804d3d8 <HAL_I2C_MspInit+0x88>)
 804d364:	429a      	cmp	r2, r3
 804d366:	d001      	beq.n	804d36c <HAL_I2C_MspInit+0x1c>
    HAL_NVIC_EnableIRQ(I2C1_ER_IRQn);
  /* USER CODE BEGIN I2C1_MspInit 1 */

  /* USER CODE END I2C1_MspInit 1 */
  }
}
 804d368:	b009      	add	sp, #36	; 0x24
 804d36a:	bd30      	pop	{r4, r5, pc}
    __HAL_RCC_GPIOB_CLK_ENABLE();
 804d36c:	2400      	movs	r4, #0
 804d36e:	9401      	str	r4, [sp, #4]
 804d370:	4d1a      	ldr	r5, [pc, #104]	; (804d3dc <HAL_I2C_MspInit+0x8c>)
 804d372:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 804d374:	f043 0302 	orr.w	r3, r3, #2
 804d378:	632b      	str	r3, [r5, #48]	; 0x30
 804d37a:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 804d37c:	f003 0302 	and.w	r3, r3, #2
 804d380:	9301      	str	r3, [sp, #4]
 804d382:	9b01      	ldr	r3, [sp, #4]
    GPIO_InitStruct.Pin = GPIO_PIN_6|GPIO_PIN_7;
 804d384:	23c0      	movs	r3, #192	; 0xc0
 804d386:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
 804d388:	2312      	movs	r3, #18
 804d38a:	9304      	str	r3, [sp, #16]
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 804d38c:	2301      	movs	r3, #1
 804d38e:	9305      	str	r3, [sp, #20]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 804d390:	2303      	movs	r3, #3
 804d392:	9306      	str	r3, [sp, #24]
    GPIO_InitStruct.Alternate = GPIO_AF4_I2C1;
 804d394:	2304      	movs	r3, #4
 804d396:	9307      	str	r3, [sp, #28]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 804d398:	a903      	add	r1, sp, #12
 804d39a:	4811      	ldr	r0, [pc, #68]	; (804d3e0 <HAL_I2C_MspInit+0x90>)
 804d39c:	f7f5 fbce 	bl	8042b3c <HAL_GPIO_Init>
    __HAL_RCC_I2C1_CLK_ENABLE();
 804d3a0:	9402      	str	r4, [sp, #8]
 804d3a2:	6c2b      	ldr	r3, [r5, #64]	; 0x40
 804d3a4:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 804d3a8:	642b      	str	r3, [r5, #64]	; 0x40
 804d3aa:	6c2b      	ldr	r3, [r5, #64]	; 0x40
 804d3ac:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 804d3b0:	9302      	str	r3, [sp, #8]
 804d3b2:	9b02      	ldr	r3, [sp, #8]
    HAL_NVIC_SetPriority(I2C1_EV_IRQn, 0, 0);
 804d3b4:	4622      	mov	r2, r4
 804d3b6:	4621      	mov	r1, r4
 804d3b8:	201f      	movs	r0, #31
 804d3ba:	f7f4 fa99 	bl	80418f0 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(I2C1_EV_IRQn);
 804d3be:	201f      	movs	r0, #31
 804d3c0:	f7f4 faca 	bl	8041958 <HAL_NVIC_EnableIRQ>
    HAL_NVIC_SetPriority(I2C1_ER_IRQn, 0, 0);
 804d3c4:	4622      	mov	r2, r4
 804d3c6:	4621      	mov	r1, r4
 804d3c8:	2020      	movs	r0, #32
 804d3ca:	f7f4 fa91 	bl	80418f0 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(I2C1_ER_IRQn);
 804d3ce:	2020      	movs	r0, #32
 804d3d0:	f7f4 fac2 	bl	8041958 <HAL_NVIC_EnableIRQ>
}
 804d3d4:	e7c8      	b.n	804d368 <HAL_I2C_MspInit+0x18>
 804d3d6:	bf00      	nop
 804d3d8:	40005400 	.word	0x40005400
 804d3dc:	40023800 	.word	0x40023800
 804d3e0:	40020400 	.word	0x40020400

0804d3e4 <MX_IWDG_Init>:

IWDG_HandleTypeDef hiwdg;

/* IWDG init function */
void MX_IWDG_Init(void)
{
 804d3e4:	b508      	push	{r3, lr}

  hiwdg.Instance = IWDG;
 804d3e6:	4807      	ldr	r0, [pc, #28]	; (804d404 <MX_IWDG_Init+0x20>)
 804d3e8:	4b07      	ldr	r3, [pc, #28]	; (804d408 <MX_IWDG_Init+0x24>)
 804d3ea:	6003      	str	r3, [r0, #0]
  hiwdg.Init.Prescaler = IWDG_PRESCALER_256;
 804d3ec:	2306      	movs	r3, #6
 804d3ee:	6043      	str	r3, [r0, #4]
  hiwdg.Init.Reload = 4095;
 804d3f0:	f640 73ff 	movw	r3, #4095	; 0xfff
 804d3f4:	6083      	str	r3, [r0, #8]
  if (HAL_IWDG_Init(&hiwdg) != HAL_OK)
 804d3f6:	f7f6 fce4 	bl	8043dc2 <HAL_IWDG_Init>
 804d3fa:	b900      	cbnz	r0, 804d3fe <MX_IWDG_Init+0x1a>
  {
    Error_Handler();
  }

}
 804d3fc:	bd08      	pop	{r3, pc}
    Error_Handler();
 804d3fe:	f000 fa2d 	bl	804d85c <Error_Handler>
}
 804d402:	e7fb      	b.n	804d3fc <MX_IWDG_Init+0x18>
 804d404:	2000d58c 	.word	0x2000d58c
 804d408:	40003000 	.word	0x40003000

0804d40c <MX_LWIP_Init>:

/**
  * LwIP initialization function
  */
void MX_LWIP_Init(void)
{
 804d40c:	b5f0      	push	{r4, r5, r6, r7, lr}
 804d40e:	b085      	sub	sp, #20
  /* IP addresses initialization */
  IP_ADDRESS[0] = 192;
 804d410:	4f3a      	ldr	r7, [pc, #232]	; (804d4fc <MX_LWIP_Init+0xf0>)
 804d412:	21c0      	movs	r1, #192	; 0xc0
 804d414:	7039      	strb	r1, [r7, #0]
  IP_ADDRESS[1] = 168;
 804d416:	22a8      	movs	r2, #168	; 0xa8
 804d418:	707a      	strb	r2, [r7, #1]
  IP_ADDRESS[2] = 0;
 804d41a:	2400      	movs	r4, #0
 804d41c:	70bc      	strb	r4, [r7, #2]
  IP_ADDRESS[3] = 100;
 804d41e:	2364      	movs	r3, #100	; 0x64
 804d420:	70fb      	strb	r3, [r7, #3]
  NETMASK_ADDRESS[0] = 255;
 804d422:	4e37      	ldr	r6, [pc, #220]	; (804d500 <MX_LWIP_Init+0xf4>)
 804d424:	23ff      	movs	r3, #255	; 0xff
 804d426:	7033      	strb	r3, [r6, #0]
  NETMASK_ADDRESS[1] = 255;
 804d428:	7073      	strb	r3, [r6, #1]
  NETMASK_ADDRESS[2] = 255;
 804d42a:	70b3      	strb	r3, [r6, #2]
  NETMASK_ADDRESS[3] = 0;
 804d42c:	70f4      	strb	r4, [r6, #3]
  GATEWAY_ADDRESS[0] = 192;
 804d42e:	4d35      	ldr	r5, [pc, #212]	; (804d504 <MX_LWIP_Init+0xf8>)
 804d430:	7029      	strb	r1, [r5, #0]
  GATEWAY_ADDRESS[1] = 168;
 804d432:	706a      	strb	r2, [r5, #1]
  GATEWAY_ADDRESS[2] = 0;
 804d434:	70ac      	strb	r4, [r5, #2]
  GATEWAY_ADDRESS[3] = 1;
 804d436:	2301      	movs	r3, #1
 804d438:	70eb      	strb	r3, [r5, #3]

  /* Initilialize the LwIP stack without RTOS */
  lwip_init();
 804d43a:	f7f8 f828 	bl	804548e <lwip_init>

  /* IP addresses initialization without DHCP (IPv4) */
  IP4_ADDR(&ipaddr, IP_ADDRESS[0], IP_ADDRESS[1], IP_ADDRESS[2], IP_ADDRESS[3]);
 804d43e:	783a      	ldrb	r2, [r7, #0]
 804d440:	787b      	ldrb	r3, [r7, #1]
 804d442:	041b      	lsls	r3, r3, #16
 804d444:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 804d448:	78ba      	ldrb	r2, [r7, #2]
 804d44a:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 804d44e:	78f9      	ldrb	r1, [r7, #3]
 804d450:	430b      	orrs	r3, r1
 804d452:	021a      	lsls	r2, r3, #8
 804d454:	f402 027f 	and.w	r2, r2, #16711680	; 0xff0000
 804d458:	ea42 6201 	orr.w	r2, r2, r1, lsl #24
 804d45c:	0a19      	lsrs	r1, r3, #8
 804d45e:	f401 417f 	and.w	r1, r1, #65280	; 0xff00
 804d462:	430a      	orrs	r2, r1
 804d464:	ea42 6313 	orr.w	r3, r2, r3, lsr #24
 804d468:	4927      	ldr	r1, [pc, #156]	; (804d508 <MX_LWIP_Init+0xfc>)
 804d46a:	600b      	str	r3, [r1, #0]
  IP4_ADDR(&netmask, NETMASK_ADDRESS[0], NETMASK_ADDRESS[1] , NETMASK_ADDRESS[2], NETMASK_ADDRESS[3]);
 804d46c:	7832      	ldrb	r2, [r6, #0]
 804d46e:	7873      	ldrb	r3, [r6, #1]
 804d470:	041b      	lsls	r3, r3, #16
 804d472:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 804d476:	78b2      	ldrb	r2, [r6, #2]
 804d478:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 804d47c:	78f0      	ldrb	r0, [r6, #3]
 804d47e:	4303      	orrs	r3, r0
 804d480:	021a      	lsls	r2, r3, #8
 804d482:	f402 027f 	and.w	r2, r2, #16711680	; 0xff0000
 804d486:	ea42 6200 	orr.w	r2, r2, r0, lsl #24
 804d48a:	0a18      	lsrs	r0, r3, #8
 804d48c:	f400 407f 	and.w	r0, r0, #65280	; 0xff00
 804d490:	4302      	orrs	r2, r0
 804d492:	ea42 6313 	orr.w	r3, r2, r3, lsr #24
 804d496:	4a1d      	ldr	r2, [pc, #116]	; (804d50c <MX_LWIP_Init+0x100>)
 804d498:	6013      	str	r3, [r2, #0]
  IP4_ADDR(&gw, GATEWAY_ADDRESS[0], GATEWAY_ADDRESS[1], GATEWAY_ADDRESS[2], GATEWAY_ADDRESS[3]);
 804d49a:	7828      	ldrb	r0, [r5, #0]
 804d49c:	786b      	ldrb	r3, [r5, #1]
 804d49e:	041b      	lsls	r3, r3, #16
 804d4a0:	ea43 6300 	orr.w	r3, r3, r0, lsl #24
 804d4a4:	78a8      	ldrb	r0, [r5, #2]
 804d4a6:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
 804d4aa:	78ed      	ldrb	r5, [r5, #3]
 804d4ac:	432b      	orrs	r3, r5
 804d4ae:	0218      	lsls	r0, r3, #8
 804d4b0:	f400 007f 	and.w	r0, r0, #16711680	; 0xff0000
 804d4b4:	ea40 6005 	orr.w	r0, r0, r5, lsl #24
 804d4b8:	0a1d      	lsrs	r5, r3, #8
 804d4ba:	f405 457f 	and.w	r5, r5, #65280	; 0xff00
 804d4be:	4328      	orrs	r0, r5
 804d4c0:	ea40 6013 	orr.w	r0, r0, r3, lsr #24
 804d4c4:	4b12      	ldr	r3, [pc, #72]	; (804d510 <MX_LWIP_Init+0x104>)
 804d4c6:	6018      	str	r0, [r3, #0]

  /* add the network interface (IPv4/IPv6) without RTOS */
  netif_add(&gnetif, &ipaddr, &netmask, &gw, NULL, &ethernetif_init, &ethernet_input);
 804d4c8:	4d12      	ldr	r5, [pc, #72]	; (804d514 <MX_LWIP_Init+0x108>)
 804d4ca:	4813      	ldr	r0, [pc, #76]	; (804d518 <MX_LWIP_Init+0x10c>)
 804d4cc:	9002      	str	r0, [sp, #8]
 804d4ce:	4813      	ldr	r0, [pc, #76]	; (804d51c <MX_LWIP_Init+0x110>)
 804d4d0:	9001      	str	r0, [sp, #4]
 804d4d2:	9400      	str	r4, [sp, #0]
 804d4d4:	4628      	mov	r0, r5
 804d4d6:	f7f8 facd 	bl	8045a74 <netif_add>

  /* Registers the default network interface */
  netif_set_default(&gnetif);
 804d4da:	4628      	mov	r0, r5
 804d4dc:	f7f8 fb0c 	bl	8045af8 <netif_set_default>

  if (netif_is_link_up(&gnetif))
 804d4e0:	f895 302b 	ldrb.w	r3, [r5, #43]	; 0x2b
 804d4e4:	f013 0f04 	tst.w	r3, #4
 804d4e8:	d004      	beq.n	804d4f4 <MX_LWIP_Init+0xe8>
  {
    /* When the netif is fully configured this function must be called */
    netif_set_up(&gnetif);
 804d4ea:	4628      	mov	r0, r5
 804d4ec:	f7f8 fb0a 	bl	8045b04 <netif_set_up>
  }

/* USER CODE BEGIN 3 */

/* USER CODE END 3 */
}
 804d4f0:	b005      	add	sp, #20
 804d4f2:	bdf0      	pop	{r4, r5, r6, r7, pc}
    netif_set_down(&gnetif);
 804d4f4:	4807      	ldr	r0, [pc, #28]	; (804d514 <MX_LWIP_Init+0x108>)
 804d4f6:	f7f8 fb17 	bl	8045b28 <netif_set_down>
}
 804d4fa:	e7f9      	b.n	804d4f0 <MX_LWIP_Init+0xe4>
 804d4fc:	2000d5d4 	.word	0x2000d5d4
 804d500:	2000d5d0 	.word	0x2000d5d0
 804d504:	2000d598 	.word	0x2000d598
 804d508:	2000d5cc 	.word	0x2000d5cc
 804d50c:	2000d5d8 	.word	0x2000d5d8
 804d510:	2000d5dc 	.word	0x2000d5dc
 804d514:	2000d59c 	.word	0x2000d59c
 804d518:	0804b5b1 	.word	0x0804b5b1
 804d51c:	0804bc91 	.word	0x0804bc91

0804d520 <MX_LWIP_Process>:
 * Send it to the lwIP stack for handling
 * Handle timeouts if LWIP_TIMERS is set and without RTOS
 * Handle the llink status if LWIP_NETIF_LINK_CALLBACK is set and without RTOS
 */
void MX_LWIP_Process(void)
{
 804d520:	b508      	push	{r3, lr}
/* USER CODE BEGIN 4_1 */
/* USER CODE END 4_1 */
  ethernetif_input(&gnetif);
 804d522:	4803      	ldr	r0, [pc, #12]	; (804d530 <MX_LWIP_Process+0x10>)
 804d524:	f7fe fba4 	bl	804bc70 <ethernetif_input>

/* USER CODE BEGIN 4_2 */
/* USER CODE END 4_2 */
  /* Handle timeouts */
  sys_check_timeouts();
 804d528:	f7fc fb3e 	bl	8049ba8 <sys_check_timeouts>

/* USER CODE BEGIN 4_3 */
/* USER CODE END 4_3 */
}
 804d52c:	bd08      	pop	{r3, pc}
 804d52e:	bf00      	nop
 804d530:	2000d59c 	.word	0x2000d59c

0804d534 <SystemClock_Config>:
/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
 804d534:	b570      	push	{r4, r5, r6, lr}
 804d536:	b0a0      	sub	sp, #128	; 0x80
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 804d538:	2530      	movs	r5, #48	; 0x30
 804d53a:	462a      	mov	r2, r5
 804d53c:	2100      	movs	r1, #0
 804d53e:	a814      	add	r0, sp, #80	; 0x50
 804d540:	f004 fa6e 	bl	8051a20 <memset>
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 804d544:	2400      	movs	r4, #0
 804d546:	940f      	str	r4, [sp, #60]	; 0x3c
 804d548:	9410      	str	r4, [sp, #64]	; 0x40
 804d54a:	9411      	str	r4, [sp, #68]	; 0x44
 804d54c:	9412      	str	r4, [sp, #72]	; 0x48
 804d54e:	9413      	str	r4, [sp, #76]	; 0x4c
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
 804d550:	462a      	mov	r2, r5
 804d552:	4621      	mov	r1, r4
 804d554:	a803      	add	r0, sp, #12
 804d556:	f004 fa63 	bl	8051a20 <memset>

  /** Configure the main internal regulator output voltage
  */
  __HAL_RCC_PWR_CLK_ENABLE();
 804d55a:	9401      	str	r4, [sp, #4]
 804d55c:	4b22      	ldr	r3, [pc, #136]	; (804d5e8 <SystemClock_Config+0xb4>)
 804d55e:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 804d560:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 804d564:	641a      	str	r2, [r3, #64]	; 0x40
 804d566:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 804d568:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 804d56c:	9301      	str	r3, [sp, #4]
 804d56e:	9b01      	ldr	r3, [sp, #4]
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 804d570:	9402      	str	r4, [sp, #8]
 804d572:	4b1e      	ldr	r3, [pc, #120]	; (804d5ec <SystemClock_Config+0xb8>)
 804d574:	681a      	ldr	r2, [r3, #0]
 804d576:	f442 4240 	orr.w	r2, r2, #49152	; 0xc000
 804d57a:	601a      	str	r2, [r3, #0]
 804d57c:	681b      	ldr	r3, [r3, #0]
 804d57e:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
 804d582:	9302      	str	r3, [sp, #8]
 804d584:	9b02      	ldr	r3, [sp, #8]
  /** Initializes the CPU, AHB and APB busses clocks
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_LSI|RCC_OSCILLATORTYPE_HSE;
 804d586:	2309      	movs	r3, #9
 804d588:	9314      	str	r3, [sp, #80]	; 0x50
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
 804d58a:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 804d58e:	9315      	str	r3, [sp, #84]	; 0x54
  RCC_OscInitStruct.LSIState = RCC_LSI_ON;
 804d590:	2301      	movs	r3, #1
 804d592:	9319      	str	r3, [sp, #100]	; 0x64
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 804d594:	2502      	movs	r5, #2
 804d596:	951a      	str	r5, [sp, #104]	; 0x68
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 804d598:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
 804d59c:	931b      	str	r3, [sp, #108]	; 0x6c
  RCC_OscInitStruct.PLL.PLLM = 15;
 804d59e:	260f      	movs	r6, #15
 804d5a0:	961c      	str	r6, [sp, #112]	; 0x70
  RCC_OscInitStruct.PLL.PLLN = 216;
 804d5a2:	23d8      	movs	r3, #216	; 0xd8
 804d5a4:	931d      	str	r3, [sp, #116]	; 0x74
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
 804d5a6:	951e      	str	r5, [sp, #120]	; 0x78
  RCC_OscInitStruct.PLL.PLLQ = 4;
 804d5a8:	2304      	movs	r3, #4
 804d5aa:	931f      	str	r3, [sp, #124]	; 0x7c
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 804d5ac:	a814      	add	r0, sp, #80	; 0x50
 804d5ae:	f7f6 fc73 	bl	8043e98 <HAL_RCC_OscConfig>
  {
    Error_Handler();
  }
  /** Activate the Over-Drive mode
  */
  if (HAL_PWREx_EnableOverDrive() != HAL_OK)
 804d5b2:	f7f6 fc31 	bl	8043e18 <HAL_PWREx_EnableOverDrive>
  {
    Error_Handler();
  }
  /** Initializes the CPU, AHB and APB busses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 804d5b6:	960f      	str	r6, [sp, #60]	; 0x3c
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 804d5b8:	9510      	str	r5, [sp, #64]	; 0x40
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 804d5ba:	9411      	str	r4, [sp, #68]	; 0x44
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
 804d5bc:	f44f 53a0 	mov.w	r3, #5120	; 0x1400
 804d5c0:	9312      	str	r3, [sp, #72]	; 0x48
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
 804d5c2:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 804d5c6:	9313      	str	r3, [sp, #76]	; 0x4c

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK)
 804d5c8:	2105      	movs	r1, #5
 804d5ca:	a80f      	add	r0, sp, #60	; 0x3c
 804d5cc:	f7f6 fe86 	bl	80442dc <HAL_RCC_ClockConfig>
  {
    Error_Handler();
  }
  PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_RTC;
 804d5d0:	2320      	movs	r3, #32
 804d5d2:	9303      	str	r3, [sp, #12]
  PeriphClkInitStruct.RTCClockSelection = RCC_RTCCLKSOURCE_LSI;
 804d5d4:	f44f 7300 	mov.w	r3, #512	; 0x200
 804d5d8:	930d      	str	r3, [sp, #52]	; 0x34
  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 804d5da:	a803      	add	r0, sp, #12
 804d5dc:	f7f6 ff56 	bl	804448c <HAL_RCCEx_PeriphCLKConfig>
  {
    Error_Handler();
  }
  /** Enables the Clock Security System
  */
  HAL_RCC_EnableCSS();
 804d5e0:	f7f6 fe26 	bl	8044230 <HAL_RCC_EnableCSS>
}
 804d5e4:	b020      	add	sp, #128	; 0x80
 804d5e6:	bd70      	pop	{r4, r5, r6, pc}
 804d5e8:	40023800 	.word	0x40023800
 804d5ec:	40007000 	.word	0x40007000

0804d5f0 <main>:
{
 804d5f0:	b508      	push	{r3, lr}
  HAL_Init();
 804d5f2:	f7f3 fd3f 	bl	8041074 <HAL_Init>
  SystemClock_Config();
 804d5f6:	f7ff ff9d 	bl	804d534 <SystemClock_Config>
  getLastKnownConfiguration();
 804d5fa:	f002 fc3d 	bl	804fe78 <getLastKnownConfiguration>
  MX_GPIO_Init();
 804d5fe:	f7fe fb6f 	bl	804bce0 <MX_GPIO_Init>
  MX_DMA_Init();
 804d602:	f7fe f95f 	bl	804b8c4 <MX_DMA_Init>
  MX_IWDG_Init();
 804d606:	f7ff feed 	bl	804d3e4 <MX_IWDG_Init>
  MX_TIM7_Init();
 804d60a:	f003 f869 	bl	80506e0 <MX_TIM7_Init>
  MX_UART4_Init();
 804d60e:	f003 f8af 	bl	8050770 <MX_UART4_Init>
  MX_RTC_Init();
 804d612:	f002 fdf1 	bl	80501f8 <MX_RTC_Init>
  MX_USART3_UART_Init();
 804d616:	f003 f939 	bl	805088c <MX_USART3_UART_Init>
  MX_ADC1_Init();
 804d61a:	f7fe f855 	bl	804b6c8 <MX_ADC1_Init>
  MX_LWIP_Init();
 804d61e:	f7ff fef5 	bl	804d40c <MX_LWIP_Init>
  MX_I2C1_Init();
 804d622:	f7ff fe67 	bl	804d2f4 <MX_I2C1_Init>
  	updateDeviceSignature();
 804d626:	f7fe f8f3 	bl	804b810 <updateDeviceSignature>
	HAL_GPIO_WritePin(MB_DE_GPIO_Port,MB_DE_Pin,GPIO_PIN_RESET);
 804d62a:	4c74      	ldr	r4, [pc, #464]	; (804d7fc <main+0x20c>)
 804d62c:	2200      	movs	r2, #0
 804d62e:	f44f 6100 	mov.w	r1, #2048	; 0x800
 804d632:	4620      	mov	r0, r4
 804d634:	f7f5 fb74 	bl	8042d20 <HAL_GPIO_WritePin>
	HAL_GPIO_WritePin(MB_RE_GPIO_Port,MB_RE_Pin,GPIO_PIN_SET);
 804d638:	2201      	movs	r2, #1
 804d63a:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 804d63e:	4620      	mov	r0, r4
 804d640:	f7f5 fb6e 	bl	8042d20 <HAL_GPIO_WritePin>
	HAL_GPIO_WritePin(LED_1_GPIO_Port, LED_1_Pin, GPIO_PIN_RESET);
 804d644:	f5a4 6480 	sub.w	r4, r4, #1024	; 0x400
 804d648:	2200      	movs	r2, #0
 804d64a:	f44f 7180 	mov.w	r1, #256	; 0x100
 804d64e:	4620      	mov	r0, r4
 804d650:	f7f5 fb66 	bl	8042d20 <HAL_GPIO_WritePin>
	HAL_GPIO_WritePin(LED_2_GPIO_Port, LED_2_Pin, GPIO_PIN_RESET);
 804d654:	2200      	movs	r2, #0
 804d656:	2140      	movs	r1, #64	; 0x40
 804d658:	4620      	mov	r0, r4
 804d65a:	f7f5 fb61 	bl	8042d20 <HAL_GPIO_WritePin>
	HAL_GPIO_WritePin(LED_3_GPIO_Port, LED_3_Pin, GPIO_PIN_RESET);
 804d65e:	2200      	movs	r2, #0
 804d660:	2120      	movs	r1, #32
 804d662:	4620      	mov	r0, r4
 804d664:	f7f5 fb5c 	bl	8042d20 <HAL_GPIO_WritePin>
	HAL_GPIO_WritePin(GSM_PWR_KEY_GPIO_Port,GSM_PWR_KEY_Pin,GPIO_PIN_RESET);
 804d668:	2200      	movs	r2, #0
 804d66a:	2180      	movs	r1, #128	; 0x80
 804d66c:	4620      	mov	r0, r4
 804d66e:	f7f5 fb57 	bl	8042d20 <HAL_GPIO_WritePin>
	setupModbus();
 804d672:	f000 fd8f 	bl	804e194 <setupModbus>
	setupModbusRTU();
 804d676:	f000 fbf7 	bl	804de68 <setupModbusRTU>
	if(gu32UploadTimeSupply == 0)
 804d67a:	4b61      	ldr	r3, [pc, #388]	; (804d800 <main+0x210>)
 804d67c:	681b      	ldr	r3, [r3, #0]
 804d67e:	b913      	cbnz	r3, 804d686 <main+0x96>
		gu32UploadTimeSupply = TWO_MIN;
 804d680:	4b5f      	ldr	r3, [pc, #380]	; (804d800 <main+0x210>)
 804d682:	4a60      	ldr	r2, [pc, #384]	; (804d804 <main+0x214>)
 804d684:	601a      	str	r2, [r3, #0]
	if(gu32UploadTimeBatt == 0)
 804d686:	4b60      	ldr	r3, [pc, #384]	; (804d808 <main+0x218>)
 804d688:	681b      	ldr	r3, [r3, #0]
 804d68a:	b913      	cbnz	r3, 804d692 <main+0xa2>
		gu32UploadTimeBatt = FIVE_MIN;
 804d68c:	4b5e      	ldr	r3, [pc, #376]	; (804d808 <main+0x218>)
 804d68e:	4a5f      	ldr	r2, [pc, #380]	; (804d80c <main+0x21c>)
 804d690:	601a      	str	r2, [r3, #0]
	enqueue(&gsmPayload,(char *)getSystemConfig());
 804d692:	f001 f879 	bl	804e788 <getSystemConfig>
 804d696:	4601      	mov	r1, r0
 804d698:	485d      	ldr	r0, [pc, #372]	; (804d810 <main+0x220>)
 804d69a:	f001 fd8f 	bl	804f1bc <enqueue>
	HAL_GPIO_WritePin(LED_1_GPIO_Port, LED_1_Pin, GPIO_PIN_SET);	// LED OFF
 804d69e:	2201      	movs	r2, #1
 804d6a0:	f44f 7180 	mov.w	r1, #256	; 0x100
 804d6a4:	485b      	ldr	r0, [pc, #364]	; (804d814 <main+0x224>)
 804d6a6:	f7f5 fb3b 	bl	8042d20 <HAL_GPIO_WritePin>
  SET_BIT(USARTx->CR1, USART_CR1_RXNEIE);
 804d6aa:	4a5b      	ldr	r2, [pc, #364]	; (804d818 <main+0x228>)
 804d6ac:	68d3      	ldr	r3, [r2, #12]
 804d6ae:	f043 0320 	orr.w	r3, r3, #32
 804d6b2:	60d3      	str	r3, [r2, #12]
 804d6b4:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 804d6b8:	68d3      	ldr	r3, [r2, #12]
 804d6ba:	f043 0320 	orr.w	r3, r3, #32
 804d6be:	60d3      	str	r3, [r2, #12]
	if(HAL_TIM_Base_Start_IT(&htim7)!= HAL_OK)
 804d6c0:	4856      	ldr	r0, [pc, #344]	; (804d81c <main+0x22c>)
 804d6c2:	f7f7 fba3 	bl	8044e0c <HAL_TIM_Base_Start_IT>
	updateNetworkAPN();
 804d6c6:	f7fe ff19 	bl	804c4fc <updateNetworkAPN>
	gu32TempPayloadQueueEnqueue = ONE_MIN;
 804d6ca:	4b55      	ldr	r3, [pc, #340]	; (804d820 <main+0x230>)
 804d6cc:	f64e 2260 	movw	r2, #60000	; 0xea60
 804d6d0:	601a      	str	r2, [r3, #0]
	memset(gau8TempMBPayloadString,0x00,sizeof(char) * gu32MBDataByteCounterLimit);
 804d6d2:	4b54      	ldr	r3, [pc, #336]	; (804d824 <main+0x234>)
 804d6d4:	681a      	ldr	r2, [r3, #0]
 804d6d6:	2100      	movs	r1, #0
 804d6d8:	4853      	ldr	r0, [pc, #332]	; (804d828 <main+0x238>)
 804d6da:	f004 f9a1 	bl	8051a20 <memset>
	memset(gau8TempMBRTUPayloadString,0x00,sizeof(char) * gu32MBDataByteCounterLimitRTU);
 804d6de:	4b53      	ldr	r3, [pc, #332]	; (804d82c <main+0x23c>)
 804d6e0:	681a      	ldr	r2, [r3, #0]
 804d6e2:	2100      	movs	r1, #0
 804d6e4:	4852      	ldr	r0, [pc, #328]	; (804d830 <main+0x240>)
 804d6e6:	f004 f99b 	bl	8051a20 <memset>
 804d6ea:	e03e      	b.n	804d76a <main+0x17a>
		mbTCPPoll();
 804d6ec:	f000 fe70 	bl	804e3d0 <mbTCPPoll>
		updateModbusPayload();
 804d6f0:	f000 fd7a 	bl	804e1e8 <updateModbusPayload>
 804d6f4:	e041      	b.n	804d77a <main+0x18a>
		modbusQueryFSM();
 804d6f6:	f000 f907 	bl	804d908 <modbusQueryFSM>
		uploadSlaveData();
 804d6fa:	f000 fb1b 	bl	804dd34 <uploadSlaveData>
 804d6fe:	e040      	b.n	804d782 <main+0x192>
		enqueue(&gsmPayload,(char *)getSystemDataString());
 804d700:	f001 faa8 	bl	804ec54 <getSystemDataString>
 804d704:	4601      	mov	r1, r0
 804d706:	4842      	ldr	r0, [pc, #264]	; (804d810 <main+0x220>)
 804d708:	f001 fd58 	bl	804f1bc <enqueue>
		if(gu32InputSupplySwitchedAlert == TRUE)
 804d70c:	4b49      	ldr	r3, [pc, #292]	; (804d834 <main+0x244>)
 804d70e:	681b      	ldr	r3, [r3, #0]
 804d710:	2b01      	cmp	r3, #1
 804d712:	d00e      	beq.n	804d732 <main+0x142>
			gu32TempPayloadQueueEnqueue = gu32UploadTimeSupply;
 804d714:	4b3a      	ldr	r3, [pc, #232]	; (804d800 <main+0x210>)
 804d716:	681a      	ldr	r2, [r3, #0]
 804d718:	4b41      	ldr	r3, [pc, #260]	; (804d820 <main+0x230>)
 804d71a:	601a      	str	r2, [r3, #0]
		if(gu32TempPayloadQueueEnqueue < THIRTY_SEC)
 804d71c:	4b40      	ldr	r3, [pc, #256]	; (804d820 <main+0x230>)
 804d71e:	681a      	ldr	r2, [r3, #0]
 804d720:	f247 532f 	movw	r3, #29999	; 0x752f
 804d724:	429a      	cmp	r2, r3
 804d726:	d832      	bhi.n	804d78e <main+0x19e>
			gu32TempPayloadQueueEnqueue = THIRTY_SEC;
 804d728:	4b3d      	ldr	r3, [pc, #244]	; (804d820 <main+0x230>)
 804d72a:	f247 5230 	movw	r2, #30000	; 0x7530
 804d72e:	601a      	str	r2, [r3, #0]
 804d730:	e02d      	b.n	804d78e <main+0x19e>
			gu32TempPayloadQueueEnqueue = TEN_SEC;//gu32UploadTimeBatt;
 804d732:	4b3b      	ldr	r3, [pc, #236]	; (804d820 <main+0x230>)
 804d734:	f242 7210 	movw	r2, #10000	; 0x2710
 804d738:	601a      	str	r2, [r3, #0]
 804d73a:	e7ef      	b.n	804d71c <main+0x12c>
		initGSMSIM868();
 804d73c:	f7fe fb40 	bl	804bdc0 <initGSMSIM868>
 804d740:	e034      	b.n	804d7ac <main+0x1bc>
		initGSMSIM868();
 804d742:	f7fe fb3d 	bl	804bdc0 <initGSMSIM868>
 804d746:	e035      	b.n	804d7b4 <main+0x1c4>
	if(gu32LedTimer == 0)
 804d748:	4b3b      	ldr	r3, [pc, #236]	; (804d838 <main+0x248>)
 804d74a:	681b      	ldr	r3, [r3, #0]
 804d74c:	2b00      	cmp	r3, #0
 804d74e:	d03c      	beq.n	804d7ca <main+0x1da>
	if(gu32SystemResetTimer == 0 )
 804d750:	4b3a      	ldr	r3, [pc, #232]	; (804d83c <main+0x24c>)
 804d752:	681b      	ldr	r3, [r3, #0]
 804d754:	2b00      	cmp	r3, #0
 804d756:	d04f      	beq.n	804d7f8 <main+0x208>
	verifyRemoteConfiguration();
 804d758:	f001 ff9e 	bl	804f698 <verifyRemoteConfiguration>
	parseRemoteconfig();
 804d75c:	f002 f816 	bl	804f78c <parseRemoteconfig>
	getRTCCalender();
 804d760:	f003 fcf8 	bl	8051154 <getRTCCalender>
	HAL_IWDG_Refresh(&hiwdg);
 804d764:	4836      	ldr	r0, [pc, #216]	; (804d840 <main+0x250>)
 804d766:	f7f6 fb51 	bl	8043e0c <HAL_IWDG_Refresh>
	MX_LWIP_Process();
 804d76a:	f7ff fed9 	bl	804d520 <MX_LWIP_Process>
	updateEthLinkStatus();
 804d76e:	f003 fb25 	bl	8050dbc <updateEthLinkStatus>
	if(gu32OperateModbusTCP == 1)
 804d772:	4b34      	ldr	r3, [pc, #208]	; (804d844 <main+0x254>)
 804d774:	681b      	ldr	r3, [r3, #0]
 804d776:	2b01      	cmp	r3, #1
 804d778:	d0b8      	beq.n	804d6ec <main+0xfc>
	if(gu32OperateModbus485 == 1)
 804d77a:	4b33      	ldr	r3, [pc, #204]	; (804d848 <main+0x258>)
 804d77c:	681b      	ldr	r3, [r3, #0]
 804d77e:	2b01      	cmp	r3, #1
 804d780:	d0b9      	beq.n	804d6f6 <main+0x106>
	operateadc();
 804d782:	f003 f96f 	bl	8050a64 <operateadc>
	if(gu32TempPayloadQueueEnqueue == 0)
 804d786:	4b26      	ldr	r3, [pc, #152]	; (804d820 <main+0x230>)
 804d788:	681b      	ldr	r3, [r3, #0]
 804d78a:	2b00      	cmp	r3, #0
 804d78c:	d0b8      	beq.n	804d700 <main+0x110>
	if(gsmInstance.u32GSMTimer > FIVE_MIN)
 804d78e:	4b2f      	ldr	r3, [pc, #188]	; (804d84c <main+0x25c>)
 804d790:	f8d3 2e20 	ldr.w	r2, [r3, #3616]	; 0xe20
 804d794:	4b1d      	ldr	r3, [pc, #116]	; (804d80c <main+0x21c>)
 804d796:	429a      	cmp	r2, r3
 804d798:	d904      	bls.n	804d7a4 <main+0x1b4>
		gsmInstance.u32GSMTimer = FOUR_SEC;
 804d79a:	4b2c      	ldr	r3, [pc, #176]	; (804d84c <main+0x25c>)
 804d79c:	f44f 627a 	mov.w	r2, #4000	; 0xfa0
 804d7a0:	f8c3 2e20 	str.w	r2, [r3, #3616]	; 0xe20
	if(gu32GSMHangTimer == 0)
 804d7a4:	4b2a      	ldr	r3, [pc, #168]	; (804d850 <main+0x260>)
 804d7a6:	681b      	ldr	r3, [r3, #0]
 804d7a8:	2b00      	cmp	r3, #0
 804d7aa:	d0c7      	beq.n	804d73c <main+0x14c>
	if(gu32GSMRestartTimer == 0)
 804d7ac:	4b29      	ldr	r3, [pc, #164]	; (804d854 <main+0x264>)
 804d7ae:	681b      	ldr	r3, [r3, #0]
 804d7b0:	2b00      	cmp	r3, #0
 804d7b2:	d0c6      	beq.n	804d742 <main+0x152>
	operateGSMSIM868();
 804d7b4:	f7ff fc64 	bl	804d080 <operateGSMSIM868>
	if(gu32RTCUpdateTimer == 0)
 804d7b8:	4b27      	ldr	r3, [pc, #156]	; (804d858 <main+0x268>)
 804d7ba:	681b      	ldr	r3, [r3, #0]
 804d7bc:	2b00      	cmp	r3, #0
 804d7be:	d1c3      	bne.n	804d748 <main+0x158>
		gu32RTCUpdateTimer = FIVE_SEC;
 804d7c0:	4b25      	ldr	r3, [pc, #148]	; (804d858 <main+0x268>)
 804d7c2:	f241 3288 	movw	r2, #5000	; 0x1388
 804d7c6:	601a      	str	r2, [r3, #0]
 804d7c8:	e7be      	b.n	804d748 <main+0x158>
		HAL_GPIO_TogglePin(LED_2_GPIO_Port, LED_2_Pin);
 804d7ca:	4c12      	ldr	r4, [pc, #72]	; (804d814 <main+0x224>)
 804d7cc:	2140      	movs	r1, #64	; 0x40
 804d7ce:	4620      	mov	r0, r4
 804d7d0:	f7f5 faac 	bl	8042d2c <HAL_GPIO_TogglePin>
		HAL_GPIO_TogglePin(HEARTBEAT_GPIO_Port,HEARTBEAT_Pin);
 804d7d4:	f44f 6100 	mov.w	r1, #2048	; 0x800
 804d7d8:	4620      	mov	r0, r4
 804d7da:	f7f5 faa7 	bl	8042d2c <HAL_GPIO_TogglePin>
		if(gu32InputSupplySwitchedAlert == FALSE)
 804d7de:	4b15      	ldr	r3, [pc, #84]	; (804d834 <main+0x244>)
 804d7e0:	681b      	ldr	r3, [r3, #0]
 804d7e2:	b923      	cbnz	r3, 804d7ee <main+0x1fe>
			gu32LedTimer = ONE_SEC;
 804d7e4:	4b14      	ldr	r3, [pc, #80]	; (804d838 <main+0x248>)
 804d7e6:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 804d7ea:	601a      	str	r2, [r3, #0]
 804d7ec:	e7b0      	b.n	804d750 <main+0x160>
			gu32LedTimer = FIVE_SEC;
 804d7ee:	4b12      	ldr	r3, [pc, #72]	; (804d838 <main+0x248>)
 804d7f0:	f241 3288 	movw	r2, #5000	; 0x1388
 804d7f4:	601a      	str	r2, [r3, #0]
 804d7f6:	e7ab      	b.n	804d750 <main+0x160>
		while(1); /* Forced Reset after 30 Mins or unable to upload data */
 804d7f8:	e7fe      	b.n	804d7f8 <main+0x208>
 804d7fa:	bf00      	nop
 804d7fc:	40021000 	.word	0x40021000
 804d800:	200026c8 	.word	0x200026c8
 804d804:	0001d4c0 	.word	0x0001d4c0
 804d808:	200026cc 	.word	0x200026cc
 804d80c:	000493e0 	.word	0x000493e0
 804d810:	2000d508 	.word	0x2000d508
 804d814:	40020c00 	.word	0x40020c00
 804d818:	40004800 	.word	0x40004800
 804d81c:	2000f370 	.word	0x2000f370
 804d820:	20005168 	.word	0x20005168
 804d824:	20004820 	.word	0x20004820
 804d828:	200020c8 	.word	0x200020c8
 804d82c:	200047e8 	.word	0x200047e8
 804d830:	200014a8 	.word	0x200014a8
 804d834:	20004fa4 	.word	0x20004fa4
 804d838:	20005180 	.word	0x20005180
 804d83c:	200036c8 	.word	0x200036c8
 804d840:	2000d58c 	.word	0x2000d58c
 804d844:	20003670 	.word	0x20003670
 804d848:	20003650 	.word	0x20003650
 804d84c:	2000c398 	.word	0x2000c398
 804d850:	2000515c 	.word	0x2000515c
 804d854:	200036c0 	.word	0x200036c0
 804d858:	20005170 	.word	0x20005170

0804d85c <Error_Handler>:
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */

  /* USER CODE END Error_Handler_Debug */
}
 804d85c:	4770      	bx	lr

0804d85e <modbusCRC16>:
* <hr>
*
*******************************************************************************/

uint16_t modbusCRC16(uint8_t * data , uint8_t length)
{
 804d85e:	b430      	push	{r4, r5}
 804d860:	4605      	mov	r5, r0
	uint16_t crc = 0xFFFF;

	  for (int pos = 0; pos < length; pos++)
 804d862:	2400      	movs	r4, #0
	uint16_t crc = 0xFFFF;
 804d864:	f64f 70ff 	movw	r0, #65535	; 0xffff
	  for (int pos = 0; pos < length; pos++)
 804d868:	e00b      	b.n	804d882 <modbusCRC16+0x24>
	      {
	        crc >>= 1;                    	// Shift right and XOR 0xA001
	        crc ^= 0xA001;
	      }
	      else                            	// Else LSB is not set
	        crc >>= 1;                    	// Just shift right
 804d86a:	0840      	lsrs	r0, r0, #1
	    for (int i = 8; i != 0; i--)  		// Loop over each bit
 804d86c:	3b01      	subs	r3, #1
 804d86e:	b13b      	cbz	r3, 804d880 <modbusCRC16+0x22>
	      if ((crc & 0x0001) != 0) 			// If the LSB is set
 804d870:	f010 0f01 	tst.w	r0, #1
 804d874:	d0f9      	beq.n	804d86a <modbusCRC16+0xc>
	        crc ^= 0xA001;
 804d876:	f24a 0201 	movw	r2, #40961	; 0xa001
 804d87a:	ea82 0050 	eor.w	r0, r2, r0, lsr #1
 804d87e:	e7f5      	b.n	804d86c <modbusCRC16+0xe>
	  for (int pos = 0; pos < length; pos++)
 804d880:	3401      	adds	r4, #1
 804d882:	42a1      	cmp	r1, r4
 804d884:	dd03      	ble.n	804d88e <modbusCRC16+0x30>
	    crc ^= (uint16_t)data[pos];         // XOR byte into least sig. byte of crc
 804d886:	5d2b      	ldrb	r3, [r5, r4]
 804d888:	4058      	eors	r0, r3
	    for (int i = 8; i != 0; i--)  		// Loop over each bit
 804d88a:	2308      	movs	r3, #8
 804d88c:	e7ef      	b.n	804d86e <modbusCRC16+0x10>
	    }
	  }
	  return crc;
}
 804d88e:	bc30      	pop	{r4, r5}
 804d890:	4770      	bx	lr
	...

0804d894 <updateModbusQueryFrameRTU>:
* </table><br><br>
* <hr>
*
*******************************************************************************/
void updateModbusQueryFrameRTU(strctModbusMaster *master)
{
 804d894:	b510      	push	{r4, lr}
 804d896:	4604      	mov	r4, r0
	uint16_t crc ;
	/* Form Query Frame String */
	master->u8QueryFrame[0] = master->u8MBSlave_Address;
 804d898:	7803      	ldrb	r3, [r0, #0]
 804d89a:	7043      	strb	r3, [r0, #1]
	master->u8QueryFrame[1] = gu32MBRTUClientFuncCode[u8MBQueryRegisterAddressCounter];
 804d89c:	4b0f      	ldr	r3, [pc, #60]	; (804d8dc <updateModbusQueryFrameRTU+0x48>)
 804d89e:	781a      	ldrb	r2, [r3, #0]
 804d8a0:	4b0f      	ldr	r3, [pc, #60]	; (804d8e0 <updateModbusQueryFrameRTU+0x4c>)
 804d8a2:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 804d8a6:	7081      	strb	r1, [r0, #2]
	master->u8QueryFrame[2] = ((gu32MBRTUClientAddress[u8MBQueryRegisterAddressCounter] - MB_ADDRESS_DEREF) >> 8);
 804d8a8:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 804d8ac:	f8d3 212c 	ldr.w	r2, [r3, #300]	; 0x12c
 804d8b0:	3a01      	subs	r2, #1
 804d8b2:	0a12      	lsrs	r2, r2, #8
 804d8b4:	70c2      	strb	r2, [r0, #3]
	master->u8QueryFrame[3] = ((gu32MBRTUClientAddress[u8MBQueryRegisterAddressCounter] - MB_ADDRESS_DEREF)& 0xFF);
 804d8b6:	f8d3 212c 	ldr.w	r2, [r3, #300]	; 0x12c
 804d8ba:	3a01      	subs	r2, #1
 804d8bc:	7102      	strb	r2, [r0, #4]
	master->u8QueryFrame[4] = (gu32MBRTUClientNoofPoints[u8MBQueryRegisterAddressCounter] >> 8);
 804d8be:	f8d3 2258 	ldr.w	r2, [r3, #600]	; 0x258
 804d8c2:	0a12      	lsrs	r2, r2, #8
 804d8c4:	7142      	strb	r2, [r0, #5]
	master->u8QueryFrame[5] = (gu32MBRTUClientNoofPoints[u8MBQueryRegisterAddressCounter] & 0xFF);
 804d8c6:	f8d3 3258 	ldr.w	r3, [r3, #600]	; 0x258
 804d8ca:	7183      	strb	r3, [r0, #6]
	crc = modbusCRC16(master->u8QueryFrame , 6);
 804d8cc:	2106      	movs	r1, #6
 804d8ce:	3001      	adds	r0, #1
 804d8d0:	f7ff ffc5 	bl	804d85e <modbusCRC16>
	master->u8QueryFrame[6] = crc;
 804d8d4:	71e0      	strb	r0, [r4, #7]
	master->u8QueryFrame[7] = (crc >> 8);
 804d8d6:	0a00      	lsrs	r0, r0, #8
 804d8d8:	7220      	strb	r0, [r4, #8]
	/* End of Query Frame */
}
 804d8da:	bd10      	pop	{r4, pc}
 804d8dc:	20004320 	.word	0x20004320
 804d8e0:	20000cd8 	.word	0x20000cd8

0804d8e4 <resetModbusPort>:
* </table><br><br>
* <hr>
*
*******************************************************************************/
void resetModbusPort()
{
 804d8e4:	b510      	push	{r4, lr}
	HAL_GPIO_WritePin(MB_DE_GPIO_Port,MB_DE_Pin,GPIO_PIN_RESET);
 804d8e6:	4c07      	ldr	r4, [pc, #28]	; (804d904 <resetModbusPort+0x20>)
 804d8e8:	2200      	movs	r2, #0
 804d8ea:	f44f 6100 	mov.w	r1, #2048	; 0x800
 804d8ee:	4620      	mov	r0, r4
 804d8f0:	f7f5 fa16 	bl	8042d20 <HAL_GPIO_WritePin>
	HAL_GPIO_WritePin(MB_RE_GPIO_Port,MB_RE_Pin,GPIO_PIN_SET);
 804d8f4:	2201      	movs	r2, #1
 804d8f6:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 804d8fa:	4620      	mov	r0, r4
 804d8fc:	f7f5 fa10 	bl	8042d20 <HAL_GPIO_WritePin>
}
 804d900:	bd10      	pop	{r4, pc}
 804d902:	bf00      	nop
 804d904:	40021000 	.word	0x40021000

0804d908 <modbusQueryFSM>:
{
 804d908:	b5f0      	push	{r4, r5, r6, r7, lr}
 804d90a:	b0a1      	sub	sp, #132	; 0x84
	switch(modbusState)
 804d90c:	4bb2      	ldr	r3, [pc, #712]	; (804dbd8 <modbusQueryFSM+0x2d0>)
 804d90e:	785b      	ldrb	r3, [r3, #1]
 804d910:	2b05      	cmp	r3, #5
 804d912:	f200 8201 	bhi.w	804dd18 <modbusQueryFSM+0x410>
 804d916:	e8df f013 	tbh	[pc, r3, lsl #1]
 804d91a:	0006      	.short	0x0006
 804d91c:	004f01fd 	.word	0x004f01fd
 804d920:	01cb0199 	.word	0x01cb0199
 804d924:	0079      	.short	0x0079
			if(master.u32PollDelay == 0)
 804d926:	4bad      	ldr	r3, [pc, #692]	; (804dbdc <modbusQueryFSM+0x2d4>)
 804d928:	f8d3 3e4c 	ldr.w	r3, [r3, #3660]	; 0xe4c
 804d92c:	2b00      	cmp	r3, #0
 804d92e:	f040 81f1 	bne.w	804dd14 <modbusQueryFSM+0x40c>
				if(master.u8MBOperationStatus == 1)
 804d932:	4baa      	ldr	r3, [pc, #680]	; (804dbdc <modbusQueryFSM+0x2d4>)
 804d934:	f893 3521 	ldrb.w	r3, [r3, #1313]	; 0x521
 804d938:	2b01      	cmp	r3, #1
 804d93a:	f040 81eb 	bne.w	804dd14 <modbusQueryFSM+0x40c>
					HAL_GPIO_WritePin(MB_DE_GPIO_Port,MB_DE_Pin,GPIO_PIN_SET); // DE -> High
 804d93e:	4ca8      	ldr	r4, [pc, #672]	; (804dbe0 <modbusQueryFSM+0x2d8>)
 804d940:	2201      	movs	r2, #1
 804d942:	f44f 6100 	mov.w	r1, #2048	; 0x800
 804d946:	4620      	mov	r0, r4
 804d948:	f7f5 f9ea 	bl	8042d20 <HAL_GPIO_WritePin>
					HAL_GPIO_WritePin(MB_RE_GPIO_Port,MB_RE_Pin,GPIO_PIN_SET); // ~RE -> HIGH
 804d94c:	2201      	movs	r2, #1
 804d94e:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 804d952:	4620      	mov	r0, r4
 804d954:	f7f5 f9e4 	bl	8042d20 <HAL_GPIO_WritePin>
					memset(master.u8SlaveResponseArray, 0x00, 260 * sizeof(int32_t));
 804d958:	4ca2      	ldr	r4, [pc, #648]	; (804dbe4 <modbusQueryFSM+0x2dc>)
 804d95a:	f44f 6282 	mov.w	r2, #1040	; 0x410
 804d95e:	2100      	movs	r1, #0
 804d960:	4620      	mov	r0, r4
 804d962:	f004 f85d 	bl	8051a20 <memset>
					master.u8MBResponseCharacterCounter = 0;
 804d966:	2200      	movs	r2, #0
 804d968:	f884 2514 	strb.w	r2, [r4, #1300]	; 0x514
					gu8MBResponseFlag = 0;
 804d96c:	4b9a      	ldr	r3, [pc, #616]	; (804dbd8 <modbusQueryFSM+0x2d0>)
 804d96e:	709a      	strb	r2, [r3, #2]
					if(u8MBQueryRegisterAddressCounter >= (master.u16NoRegisterstoFetch))
 804d970:	781a      	ldrb	r2, [r3, #0]
 804d972:	f8b4 3826 	ldrh.w	r3, [r4, #2086]	; 0x826
 804d976:	429a      	cmp	r2, r3
 804d978:	d304      	bcc.n	804d984 <modbusQueryFSM+0x7c>
						u8MBQueryRegisterAddressCounter = 0;
 804d97a:	4b97      	ldr	r3, [pc, #604]	; (804dbd8 <modbusQueryFSM+0x2d0>)
 804d97c:	2200      	movs	r2, #0
 804d97e:	701a      	strb	r2, [r3, #0]
						gu32MBRTUDataByteCounter = 0;
 804d980:	605a      	str	r2, [r3, #4]
						break;
 804d982:	e1c7      	b.n	804dd14 <modbusQueryFSM+0x40c>
						updateModbusQueryFrameRTU(&master);
 804d984:	4c95      	ldr	r4, [pc, #596]	; (804dbdc <modbusQueryFSM+0x2d4>)
 804d986:	4620      	mov	r0, r4
 804d988:	f7ff ff84 	bl	804d894 <updateModbusQueryFrameRTU>
  SET_BIT(USARTx->CR1, USART_CR1_TXEIE);
 804d98c:	4b96      	ldr	r3, [pc, #600]	; (804dbe8 <modbusQueryFSM+0x2e0>)
 804d98e:	68da      	ldr	r2, [r3, #12]
 804d990:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 804d994:	60da      	str	r2, [r3, #12]
  SET_BIT(USARTx->CR1, USART_CR1_TCIE);
 804d996:	68da      	ldr	r2, [r3, #12]
 804d998:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 804d99c:	60da      	str	r2, [r3, #12]
					u8MBQueryCharacterCounter = 0;
 804d99e:	4a8e      	ldr	r2, [pc, #568]	; (804dbd8 <modbusQueryFSM+0x2d0>)
 804d9a0:	2100      	movs	r1, #0
 804d9a2:	7211      	strb	r1, [r2, #8]
					LL_USART_TransmitData8(USART3,master.u8QueryFrame[u8MBQueryCharacterCounter++]);
 804d9a4:	7a10      	ldrb	r0, [r2, #8]
 804d9a6:	1c41      	adds	r1, r0, #1
 804d9a8:	b2c9      	uxtb	r1, r1
 804d9aa:	7211      	strb	r1, [r2, #8]
 804d9ac:	4404      	add	r4, r0
 804d9ae:	7861      	ldrb	r1, [r4, #1]
  USARTx->DR = Value;
 804d9b0:	6059      	str	r1, [r3, #4]
					modbusState = enmMODBUS_SEND_QUERY;
 804d9b2:	2301      	movs	r3, #1
 804d9b4:	7053      	strb	r3, [r2, #1]
 804d9b6:	e1ad      	b.n	804dd14 <modbusQueryFSM+0x40c>
			if(master.u32PollDelay == 0)
 804d9b8:	4b88      	ldr	r3, [pc, #544]	; (804dbdc <modbusQueryFSM+0x2d4>)
 804d9ba:	f8d3 3e4c 	ldr.w	r3, [r3, #3660]	; 0xe4c
 804d9be:	2b00      	cmp	r3, #0
 804d9c0:	f040 81a8 	bne.w	804dd14 <modbusQueryFSM+0x40c>
				if(gu8MBResponseFlag == 1)
 804d9c4:	4b84      	ldr	r3, [pc, #528]	; (804dbd8 <modbusQueryFSM+0x2d0>)
 804d9c6:	789b      	ldrb	r3, [r3, #2]
 804d9c8:	2b01      	cmp	r3, #1
 804d9ca:	d008      	beq.n	804d9de <modbusQueryFSM+0xd6>
					if(gu32ModbusResponseTimeout == 0)
 804d9cc:	4b82      	ldr	r3, [pc, #520]	; (804dbd8 <modbusQueryFSM+0x2d0>)
 804d9ce:	691b      	ldr	r3, [r3, #16]
 804d9d0:	2b00      	cmp	r3, #0
 804d9d2:	f040 819f 	bne.w	804dd14 <modbusQueryFSM+0x40c>
						modbusState = enmMODBUS_RESPONSE_TIMEOUT;
 804d9d6:	4b80      	ldr	r3, [pc, #512]	; (804dbd8 <modbusQueryFSM+0x2d0>)
 804d9d8:	2204      	movs	r2, #4
 804d9da:	705a      	strb	r2, [r3, #1]
 804d9dc:	e19a      	b.n	804dd14 <modbusQueryFSM+0x40c>
					if((gu32ModbusFrameEndTimer == 0) && (gu32ModbusResponseTimeout != 0))
 804d9de:	4b7e      	ldr	r3, [pc, #504]	; (804dbd8 <modbusQueryFSM+0x2d0>)
 804d9e0:	68db      	ldr	r3, [r3, #12]
 804d9e2:	b943      	cbnz	r3, 804d9f6 <modbusQueryFSM+0xee>
 804d9e4:	4b7c      	ldr	r3, [pc, #496]	; (804dbd8 <modbusQueryFSM+0x2d0>)
 804d9e6:	691b      	ldr	r3, [r3, #16]
 804d9e8:	b12b      	cbz	r3, 804d9f6 <modbusQueryFSM+0xee>
						modbusState = enmMODBUS_PARSE_RESPONSE;
 804d9ea:	4b7b      	ldr	r3, [pc, #492]	; (804dbd8 <modbusQueryFSM+0x2d0>)
 804d9ec:	2205      	movs	r2, #5
 804d9ee:	705a      	strb	r2, [r3, #1]
						gu8MBResponseFlag = 0;
 804d9f0:	2200      	movs	r2, #0
 804d9f2:	709a      	strb	r2, [r3, #2]
 804d9f4:	e18e      	b.n	804dd14 <modbusQueryFSM+0x40c>
					else if(gu32ModbusResponseTimeout == 0)
 804d9f6:	4b78      	ldr	r3, [pc, #480]	; (804dbd8 <modbusQueryFSM+0x2d0>)
 804d9f8:	691b      	ldr	r3, [r3, #16]
 804d9fa:	2b00      	cmp	r3, #0
 804d9fc:	f040 818a 	bne.w	804dd14 <modbusQueryFSM+0x40c>
						modbusState = enmMODBUS_PARSE_RESPONSE;
 804da00:	4b75      	ldr	r3, [pc, #468]	; (804dbd8 <modbusQueryFSM+0x2d0>)
 804da02:	2205      	movs	r2, #5
 804da04:	705a      	strb	r2, [r3, #1]
						gu8MBResponseFlag = 0;
 804da06:	2200      	movs	r2, #0
 804da08:	709a      	strb	r2, [r3, #2]
 804da0a:	e183      	b.n	804dd14 <modbusQueryFSM+0x40c>
			if(master.u8SlaveResponseArray[0] == gu32MBRTUClientFuncCode[u8MBQueryRegisterAddressCounter])
 804da0c:	4b73      	ldr	r3, [pc, #460]	; (804dbdc <modbusQueryFSM+0x2d4>)
 804da0e:	68de      	ldr	r6, [r3, #12]
 804da10:	4b71      	ldr	r3, [pc, #452]	; (804dbd8 <modbusQueryFSM+0x2d0>)
 804da12:	781d      	ldrb	r5, [r3, #0]
 804da14:	462c      	mov	r4, r5
 804da16:	4b75      	ldr	r3, [pc, #468]	; (804dbec <modbusQueryFSM+0x2e4>)
 804da18:	f853 3025 	ldr.w	r3, [r3, r5, lsl #2]
 804da1c:	429e      	cmp	r6, r3
 804da1e:	d007      	beq.n	804da30 <modbusQueryFSM+0x128>
			else if((master.u8SlaveResponseArray[0] & 0x80) == 0x80)
 804da20:	f016 0f80 	tst.w	r6, #128	; 0x80
 804da24:	f040 8110 	bne.w	804dc48 <modbusQueryFSM+0x340>
				modbusState = enmMODBUS_RETRY_QUERY;
 804da28:	4b6b      	ldr	r3, [pc, #428]	; (804dbd8 <modbusQueryFSM+0x2d0>)
 804da2a:	2203      	movs	r2, #3
 804da2c:	705a      	strb	r2, [r3, #1]
 804da2e:	e104      	b.n	804dc3a <modbusQueryFSM+0x332>
				uint8_t u8TempCRCArray[125]= {0};
 804da30:	2400      	movs	r4, #0
 804da32:	9400      	str	r4, [sp, #0]
 804da34:	2279      	movs	r2, #121	; 0x79
 804da36:	4621      	mov	r1, r4
 804da38:	a801      	add	r0, sp, #4
 804da3a:	f003 fff1 	bl	8051a20 <memset>
				uint8_t u8MBNoDataBytesRx = (uint8_t)master.u8SlaveResponseArray[1];
 804da3e:	4b67      	ldr	r3, [pc, #412]	; (804dbdc <modbusQueryFSM+0x2d4>)
 804da40:	691f      	ldr	r7, [r3, #16]
 804da42:	b2f8      	uxtb	r0, r7
				u8TempCRCArray[0]=master.u8MBSlave_Address;       // ID
 804da44:	781b      	ldrb	r3, [r3, #0]
 804da46:	f88d 3000 	strb.w	r3, [sp]
				u8TempCRCArray[1]=master.u8SlaveResponseArray[0]; // FC
 804da4a:	f88d 6001 	strb.w	r6, [sp, #1]
				u8TempCRCArray[2]=master.u8SlaveResponseArray[1]; // No of Bytes
 804da4e:	f88d 0002 	strb.w	r0, [sp, #2]
				for(u8CrcLoopCounter = 0 ; u8CrcLoopCounter < u8MBNoDataBytesRx ;u8CrcLoopCounter ++ )
 804da52:	4621      	mov	r1, r4
 804da54:	e00b      	b.n	804da6e <modbusQueryFSM+0x166>
					u8TempCRCArray[3 + u8CrcLoopCounter] = master.u8SlaveResponseArray[2 + u8CrcLoopCounter];
 804da56:	1d0a      	adds	r2, r1, #4
 804da58:	4b60      	ldr	r3, [pc, #384]	; (804dbdc <modbusQueryFSM+0x2d4>)
 804da5a:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 804da5e:	685a      	ldr	r2, [r3, #4]
 804da60:	1ccb      	adds	r3, r1, #3
 804da62:	ac20      	add	r4, sp, #128	; 0x80
 804da64:	4423      	add	r3, r4
 804da66:	f803 2c80 	strb.w	r2, [r3, #-128]
				for(u8CrcLoopCounter = 0 ; u8CrcLoopCounter < u8MBNoDataBytesRx ;u8CrcLoopCounter ++ )
 804da6a:	3101      	adds	r1, #1
 804da6c:	b2c9      	uxtb	r1, r1
 804da6e:	4281      	cmp	r1, r0
 804da70:	d3f1      	bcc.n	804da56 <modbusQueryFSM+0x14e>
				u16TempCRC = modbusCRC16(u8TempCRCArray,3 + u8CrcLoopCounter);
 804da72:	3103      	adds	r1, #3
 804da74:	b2c9      	uxtb	r1, r1
 804da76:	4668      	mov	r0, sp
 804da78:	f7ff fef1 	bl	804d85e <modbusCRC16>
				uint8_t u8CRCHi = master.u8SlaveResponseArray[u8MBNoDataBytesRx + 2 ];    // CRC High Location
 804da7c:	b2ff      	uxtb	r7, r7
 804da7e:	4a57      	ldr	r2, [pc, #348]	; (804dbdc <modbusQueryFSM+0x2d4>)
 804da80:	1d3b      	adds	r3, r7, #4
 804da82:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 804da86:	791b      	ldrb	r3, [r3, #4]
				uint8_t u8CRCLow = master.u8SlaveResponseArray[u8MBNoDataBytesRx + 3];    // CRC Low Location
 804da88:	1d79      	adds	r1, r7, #5
 804da8a:	eb02 0281 	add.w	r2, r2, r1, lsl #2
 804da8e:	6852      	ldr	r2, [r2, #4]
				uint16_t u16ReceivedCRC =  (u8CRCLow<<8)|u8CRCHi;
 804da90:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 804da94:	b29b      	uxth	r3, r3
				if(u16ReceivedCRC == u16TempCRC)
 804da96:	4298      	cmp	r0, r3
 804da98:	d003      	beq.n	804daa2 <modbusQueryFSM+0x19a>
					modbusState = enmMODBUS_RETRY_QUERY;
 804da9a:	4b4f      	ldr	r3, [pc, #316]	; (804dbd8 <modbusQueryFSM+0x2d0>)
 804da9c:	2203      	movs	r2, #3
 804da9e:	705a      	strb	r2, [r3, #1]
 804daa0:	e0cb      	b.n	804dc3a <modbusQueryFSM+0x332>
					gu32MBRTUClientConnectedFlag = 1; /* Indicates Response Received form client in payload .*/
 804daa2:	4b4d      	ldr	r3, [pc, #308]	; (804dbd8 <modbusQueryFSM+0x2d0>)
 804daa4:	2201      	movs	r2, #1
 804daa6:	615a      	str	r2, [r3, #20]
					if(master.u8SlaveResponseArray[0] == 1)
 804daa8:	4296      	cmp	r6, r2
 804daaa:	d01b      	beq.n	804dae4 <modbusQueryFSM+0x1dc>
						if(u8MBNoDataBytesRx == (2 * gu32MBRTUClientNoofPoints[u8MBQueryRegisterAddressCounter]))
 804daac:	4b4f      	ldr	r3, [pc, #316]	; (804dbec <modbusQueryFSM+0x2e4>)
 804daae:	eb03 0385 	add.w	r3, r3, r5, lsl #2
 804dab2:	f8d3 0258 	ldr.w	r0, [r3, #600]	; 0x258
 804dab6:	ebb7 0f40 	cmp.w	r7, r0, lsl #1
 804daba:	d04d      	beq.n	804db58 <modbusQueryFSM+0x250>
							gu32MBRTUDataByteCounter += gu32MBRTUClientNoofPoints[u8MBQueryRegisterAddressCounter];
 804dabc:	4a46      	ldr	r2, [pc, #280]	; (804dbd8 <modbusQueryFSM+0x2d0>)
 804dabe:	6853      	ldr	r3, [r2, #4]
 804dac0:	4403      	add	r3, r0
 804dac2:	6053      	str	r3, [r2, #4]
					master.u8MBResponseStatus[u8MBQueryRegisterAddressCounter++] = 0;
 804dac4:	4c44      	ldr	r4, [pc, #272]	; (804dbd8 <modbusQueryFSM+0x2d0>)
 804dac6:	1c6b      	adds	r3, r5, #1
 804dac8:	7023      	strb	r3, [r4, #0]
 804daca:	4f44      	ldr	r7, [pc, #272]	; (804dbdc <modbusQueryFSM+0x2d4>)
 804dacc:	443d      	add	r5, r7
 804dace:	2600      	movs	r6, #0
 804dad0:	f885 6523 	strb.w	r6, [r5, #1315]	; 0x523
					resetModbusPort();
 804dad4:	f7ff ff06 	bl	804d8e4 <resetModbusPort>
					master.u32PollDelay = gu32Modbus485PollingTime;//ONE_SEC;
 804dad8:	4b45      	ldr	r3, [pc, #276]	; (804dbf0 <modbusQueryFSM+0x2e8>)
 804dada:	681b      	ldr	r3, [r3, #0]
 804dadc:	f8c7 3e4c 	str.w	r3, [r7, #3660]	; 0xe4c
					modbusState = enmMODBUS_IDLE;
 804dae0:	7066      	strb	r6, [r4, #1]
 804dae2:	e0aa      	b.n	804dc3a <modbusQueryFSM+0x332>
						for(LoopCounter = 0; LoopCounter < u8MBNoDataBytesRx; LoopCounter++)
 804dae4:	2100      	movs	r1, #0
 804dae6:	428f      	cmp	r7, r1
 804dae8:	d913      	bls.n	804db12 <modbusQueryFSM+0x20a>
							master.u32SlaveData[gu32MBRTUDataByteCounter] = master.u8SlaveResponseArray[2 + LoopCounter];
 804daea:	4b3b      	ldr	r3, [pc, #236]	; (804dbd8 <modbusQueryFSM+0x2d0>)
 804daec:	6858      	ldr	r0, [r3, #4]
 804daee:	4a3b      	ldr	r2, [pc, #236]	; (804dbdc <modbusQueryFSM+0x2d4>)
 804daf0:	1d0c      	adds	r4, r1, #4
 804daf2:	eb02 0484 	add.w	r4, r2, r4, lsl #2
 804daf6:	6864      	ldr	r4, [r4, #4]
 804daf8:	f200 268e 	addw	r6, r0, #654	; 0x28e
 804dafc:	eb02 0286 	add.w	r2, r2, r6, lsl #2
 804db00:	6054      	str	r4, [r2, #4]
							gu32MBRTUDataStatus[gu32MBRTUDataByteCounter++] = 2;
 804db02:	1c42      	adds	r2, r0, #1
 804db04:	605a      	str	r2, [r3, #4]
 804db06:	eb03 0380 	add.w	r3, r3, r0, lsl #2
 804db0a:	2202      	movs	r2, #2
 804db0c:	619a      	str	r2, [r3, #24]
						for(LoopCounter = 0; LoopCounter < u8MBNoDataBytesRx; LoopCounter++)
 804db0e:	3101      	adds	r1, #1
 804db10:	e7e9      	b.n	804dae6 <modbusQueryFSM+0x1de>
						if(u8MBNoDataBytesRx != gu32MBRTUClientNoofPoints[u8MBQueryRegisterAddressCounter])
 804db12:	4a36      	ldr	r2, [pc, #216]	; (804dbec <modbusQueryFSM+0x2e4>)
 804db14:	eb02 0285 	add.w	r2, r2, r5, lsl #2
 804db18:	f8d2 2258 	ldr.w	r2, [r2, #600]	; 0x258
 804db1c:	4297      	cmp	r7, r2
 804db1e:	d0d1      	beq.n	804dac4 <modbusQueryFSM+0x1bc>
							gu32MBRTUDataByteCounter += (gu32MBRTUClientNoofPoints[u8MBQueryRegisterAddressCounter] - u8MBNoDataBytesRx);
 804db20:	1bd3      	subs	r3, r2, r7
 804db22:	492d      	ldr	r1, [pc, #180]	; (804dbd8 <modbusQueryFSM+0x2d0>)
 804db24:	684a      	ldr	r2, [r1, #4]
 804db26:	4413      	add	r3, r2
 804db28:	604b      	str	r3, [r1, #4]
 804db2a:	e7cb      	b.n	804dac4 <modbusQueryFSM+0x1bc>
									master.u32SlaveData[gu32MBRTUDataByteCounter] = ((int16_t)master.u8SlaveResponseArray[2 + (2* u32LoopCounter)] << 8)
 804db2c:	492b      	ldr	r1, [pc, #172]	; (804dbdc <modbusQueryFSM+0x2d4>)
 804db2e:	eb01 0484 	add.w	r4, r1, r4, lsl #2
 804db32:	f9b4 4004 	ldrsh.w	r4, [r4, #4]
																					 + (int16_t)master.u8SlaveResponseArray[2 + (2 * u32LoopCounter) + 1] +256 ;
 804db36:	3303      	adds	r3, #3
 804db38:	eb01 0383 	add.w	r3, r1, r3, lsl #2
 804db3c:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 804db40:	eb03 2304 	add.w	r3, r3, r4, lsl #8
									master.u32SlaveData[gu32MBRTUDataByteCounter] = ((int16_t)master.u8SlaveResponseArray[2 + (2* u32LoopCounter)] << 8)
 804db44:	4c24      	ldr	r4, [pc, #144]	; (804dbd8 <modbusQueryFSM+0x2d0>)
 804db46:	6864      	ldr	r4, [r4, #4]
																					 + (int16_t)master.u8SlaveResponseArray[2 + (2 * u32LoopCounter) + 1] +256 ;
 804db48:	f503 7380 	add.w	r3, r3, #256	; 0x100
									master.u32SlaveData[gu32MBRTUDataByteCounter] = ((int16_t)master.u8SlaveResponseArray[2 + (2* u32LoopCounter)] << 8)
 804db4c:	f204 248e 	addw	r4, r4, #654	; 0x28e
 804db50:	eb01 0184 	add.w	r1, r1, r4, lsl #2
 804db54:	604b      	str	r3, [r1, #4]
 804db56:	e01f      	b.n	804db98 <modbusQueryFSM+0x290>
							for(u32LoopCounter = 0; u32LoopCounter < gu32MBRTUClientNoofPoints[u8MBQueryRegisterAddressCounter];u32LoopCounter++)
 804db58:	2200      	movs	r2, #0
 804db5a:	4290      	cmp	r0, r2
 804db5c:	d9b2      	bls.n	804dac4 <modbusQueryFSM+0x1bc>
								if((int32_t)master.u8SlaveResponseArray[2 + (2 * u32LoopCounter)] < 0)
 804db5e:	3201      	adds	r2, #1
 804db60:	0053      	lsls	r3, r2, #1
 804db62:	1c9c      	adds	r4, r3, #2
 804db64:	491d      	ldr	r1, [pc, #116]	; (804dbdc <modbusQueryFSM+0x2d4>)
 804db66:	eb01 0184 	add.w	r1, r1, r4, lsl #2
 804db6a:	6849      	ldr	r1, [r1, #4]
 804db6c:	2900      	cmp	r1, #0
 804db6e:	dbdd      	blt.n	804db2c <modbusQueryFSM+0x224>
									master.u32SlaveData[gu32MBRTUDataByteCounter] = ((int16_t)master.u8SlaveResponseArray[2 + (2* u32LoopCounter)] << 8)
 804db70:	491a      	ldr	r1, [pc, #104]	; (804dbdc <modbusQueryFSM+0x2d4>)
 804db72:	1c9c      	adds	r4, r3, #2
 804db74:	eb01 0484 	add.w	r4, r1, r4, lsl #2
 804db78:	f9b4 6004 	ldrsh.w	r6, [r4, #4]
																					 + (int16_t)master.u8SlaveResponseArray[2 + (2 * u32LoopCounter) + 1] ;
 804db7c:	3303      	adds	r3, #3
 804db7e:	eb01 0383 	add.w	r3, r1, r3, lsl #2
 804db82:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
									master.u32SlaveData[gu32MBRTUDataByteCounter] = ((int16_t)master.u8SlaveResponseArray[2 + (2* u32LoopCounter)] << 8)
 804db86:	4c14      	ldr	r4, [pc, #80]	; (804dbd8 <modbusQueryFSM+0x2d0>)
 804db88:	6864      	ldr	r4, [r4, #4]
																					 + (int16_t)master.u8SlaveResponseArray[2 + (2 * u32LoopCounter) + 1] ;
 804db8a:	eb03 2306 	add.w	r3, r3, r6, lsl #8
									master.u32SlaveData[gu32MBRTUDataByteCounter] = ((int16_t)master.u8SlaveResponseArray[2 + (2* u32LoopCounter)] << 8)
 804db8e:	f204 248e 	addw	r4, r4, #654	; 0x28e
 804db92:	eb01 0184 	add.w	r1, r1, r4, lsl #2
 804db96:	604b      	str	r3, [r1, #4]
								if(master.u32SlaveData[gu32MBRTUDataByteCounter] > 32768)
 804db98:	4b0f      	ldr	r3, [pc, #60]	; (804dbd8 <modbusQueryFSM+0x2d0>)
 804db9a:	685b      	ldr	r3, [r3, #4]
 804db9c:	f203 248e 	addw	r4, r3, #654	; 0x28e
 804dba0:	490e      	ldr	r1, [pc, #56]	; (804dbdc <modbusQueryFSM+0x2d4>)
 804dba2:	eb01 0184 	add.w	r1, r1, r4, lsl #2
 804dba6:	6849      	ldr	r1, [r1, #4]
 804dba8:	f5b1 4f00 	cmp.w	r1, #32768	; 0x8000
 804dbac:	d905      	bls.n	804dbba <modbusQueryFSM+0x2b2>
									master.u32SlaveData[gu32MBRTUDataByteCounter] = master.u32SlaveData[gu32MBRTUDataByteCounter] - 65536;
 804dbae:	f5a1 3180 	sub.w	r1, r1, #65536	; 0x10000
 804dbb2:	4e0a      	ldr	r6, [pc, #40]	; (804dbdc <modbusQueryFSM+0x2d4>)
 804dbb4:	eb06 0484 	add.w	r4, r6, r4, lsl #2
 804dbb8:	6061      	str	r1, [r4, #4]
								gu32MBRTUDataStatus[gu32MBRTUDataByteCounter] = 0;
 804dbba:	4907      	ldr	r1, [pc, #28]	; (804dbd8 <modbusQueryFSM+0x2d0>)
 804dbbc:	eb01 0483 	add.w	r4, r1, r3, lsl #2
 804dbc0:	2600      	movs	r6, #0
 804dbc2:	61a6      	str	r6, [r4, #24]
								gu32MBRTUDataByteCounter++;
 804dbc4:	3301      	adds	r3, #1
 804dbc6:	604b      	str	r3, [r1, #4]
								if(gu32MBRTUDataByteCounter >= gu32MBDataByteCounterLimitRTU)
 804dbc8:	f8d1 14c8 	ldr.w	r1, [r1, #1224]	; 0x4c8
 804dbcc:	428b      	cmp	r3, r1
 804dbce:	d3c4      	bcc.n	804db5a <modbusQueryFSM+0x252>
									gu32MBRTUDataByteCounter = 0;
 804dbd0:	4b01      	ldr	r3, [pc, #4]	; (804dbd8 <modbusQueryFSM+0x2d0>)
 804dbd2:	605e      	str	r6, [r3, #4]
 804dbd4:	e7c1      	b.n	804db5a <modbusQueryFSM+0x252>
 804dbd6:	bf00      	nop
 804dbd8:	20004320 	.word	0x20004320
 804dbdc:	2000d5e0 	.word	0x2000d5e0
 804dbe0:	40021000 	.word	0x40021000
 804dbe4:	2000d5ec 	.word	0x2000d5ec
 804dbe8:	40004800 	.word	0x40004800
 804dbec:	20000cd8 	.word	0x20000cd8
 804dbf0:	200026d8 	.word	0x200026d8
					master.u32SlaveData[gu32MBRTUDataByteCounter] = master.u8SlaveResponseArray[1] ;
 804dbf4:	4b4a      	ldr	r3, [pc, #296]	; (804dd20 <modbusQueryFSM+0x418>)
 804dbf6:	6859      	ldr	r1, [r3, #4]
 804dbf8:	4a4a      	ldr	r2, [pc, #296]	; (804dd24 <modbusQueryFSM+0x41c>)
 804dbfa:	6916      	ldr	r6, [r2, #16]
 804dbfc:	f201 278e 	addw	r7, r1, #654	; 0x28e
 804dc00:	eb02 0287 	add.w	r2, r2, r7, lsl #2
 804dc04:	6056      	str	r6, [r2, #4]
					gu32MBRTUDataStatus[gu32MBRTUDataByteCounter++] = 1;
 804dc06:	1c4a      	adds	r2, r1, #1
 804dc08:	605a      	str	r2, [r3, #4]
 804dc0a:	eb03 0381 	add.w	r3, r3, r1, lsl #2
 804dc0e:	2201      	movs	r2, #1
 804dc10:	619a      	str	r2, [r3, #24]
				for(u32TempLoopCounter = 0; u32TempLoopCounter < gu32MBRTUClientNoofPoints[u8MBQueryRegisterAddressCounter];u32TempLoopCounter++)
 804dc12:	4410      	add	r0, r2
 804dc14:	4b44      	ldr	r3, [pc, #272]	; (804dd28 <modbusQueryFSM+0x420>)
 804dc16:	eb03 0384 	add.w	r3, r3, r4, lsl #2
 804dc1a:	f8d3 3258 	ldr.w	r3, [r3, #600]	; 0x258
 804dc1e:	4283      	cmp	r3, r0
 804dc20:	d8e8      	bhi.n	804dbf4 <modbusQueryFSM+0x2ec>
				u8MBQueryRegisterAddressCounter++;
 804dc22:	4c3f      	ldr	r4, [pc, #252]	; (804dd20 <modbusQueryFSM+0x418>)
 804dc24:	3501      	adds	r5, #1
 804dc26:	7025      	strb	r5, [r4, #0]
				resetModbusPort();
 804dc28:	f7ff fe5c 	bl	804d8e4 <resetModbusPort>
				master.u32PollDelay = gu32Modbus485PollingTime;//ONE_SEC;
 804dc2c:	4b3f      	ldr	r3, [pc, #252]	; (804dd2c <modbusQueryFSM+0x424>)
 804dc2e:	681a      	ldr	r2, [r3, #0]
 804dc30:	4b3c      	ldr	r3, [pc, #240]	; (804dd24 <modbusQueryFSM+0x41c>)
 804dc32:	f8c3 2e4c 	str.w	r2, [r3, #3660]	; 0xe4c
				modbusState = enmMODBUS_IDLE;
 804dc36:	2300      	movs	r3, #0
 804dc38:	7063      	strb	r3, [r4, #1]
			memset(master.u8SlaveResponseArray,0x00,sizeof(master.u8SlaveResponseArray));
 804dc3a:	f44f 6282 	mov.w	r2, #1040	; 0x410
 804dc3e:	2100      	movs	r1, #0
 804dc40:	483b      	ldr	r0, [pc, #236]	; (804dd30 <modbusQueryFSM+0x428>)
 804dc42:	f003 feed 	bl	8051a20 <memset>
			break;
 804dc46:	e065      	b.n	804dd14 <modbusQueryFSM+0x40c>
				for(u32TempLoopCounter = 0; u32TempLoopCounter < gu32MBRTUClientNoofPoints[u8MBQueryRegisterAddressCounter];u32TempLoopCounter++)
 804dc48:	2000      	movs	r0, #0
 804dc4a:	e7e3      	b.n	804dc14 <modbusQueryFSM+0x30c>
			if(master.u8MBNoQueryAttempts > MB_485_QUERY_RETRY_ATTEMPTS)
 804dc4c:	4b35      	ldr	r3, [pc, #212]	; (804dd24 <modbusQueryFSM+0x41c>)
 804dc4e:	f893 3522 	ldrb.w	r3, [r3, #1314]	; 0x522
 804dc52:	2b03      	cmp	r3, #3
 804dc54:	d927      	bls.n	804dca6 <modbusQueryFSM+0x39e>
				gu32MBRTUDataByteCounter += gu32MBRTUClientNoofPoints[u8MBQueryRegisterAddressCounter];
 804dc56:	4b32      	ldr	r3, [pc, #200]	; (804dd20 <modbusQueryFSM+0x418>)
 804dc58:	781a      	ldrb	r2, [r3, #0]
 804dc5a:	4933      	ldr	r1, [pc, #204]	; (804dd28 <modbusQueryFSM+0x420>)
 804dc5c:	eb01 0182 	add.w	r1, r1, r2, lsl #2
 804dc60:	f8d1 0258 	ldr.w	r0, [r1, #600]	; 0x258
 804dc64:	6859      	ldr	r1, [r3, #4]
 804dc66:	4401      	add	r1, r0
 804dc68:	6059      	str	r1, [r3, #4]
				u8MBQueryRegisterAddressCounter++;
 804dc6a:	3201      	adds	r2, #1
 804dc6c:	701a      	strb	r2, [r3, #0]
			if(u8MBQueryRegisterAddressCounter > master.u16NoRegisterstoFetch)
 804dc6e:	4b2c      	ldr	r3, [pc, #176]	; (804dd20 <modbusQueryFSM+0x418>)
 804dc70:	781a      	ldrb	r2, [r3, #0]
 804dc72:	4b2c      	ldr	r3, [pc, #176]	; (804dd24 <modbusQueryFSM+0x41c>)
 804dc74:	f8b3 3832 	ldrh.w	r3, [r3, #2098]	; 0x832
 804dc78:	429a      	cmp	r2, r3
 804dc7a:	d904      	bls.n	804dc86 <modbusQueryFSM+0x37e>
				gu32MBRTUDataByteCounter = 0;
 804dc7c:	4b28      	ldr	r3, [pc, #160]	; (804dd20 <modbusQueryFSM+0x418>)
 804dc7e:	2200      	movs	r2, #0
 804dc80:	605a      	str	r2, [r3, #4]
				u8MBQueryRegisterAddressCounter = 0;
 804dc82:	701a      	strb	r2, [r3, #0]
				gu32MBRTUClientConnectedFlag = 0;
 804dc84:	615a      	str	r2, [r3, #20]
			resetModbusPort();
 804dc86:	f7ff fe2d 	bl	804d8e4 <resetModbusPort>
			master.u32PollDelay = gu32Modbus485PollingTime;//ONE_SEC;
 804dc8a:	4826      	ldr	r0, [pc, #152]	; (804dd24 <modbusQueryFSM+0x41c>)
 804dc8c:	4b27      	ldr	r3, [pc, #156]	; (804dd2c <modbusQueryFSM+0x424>)
 804dc8e:	681b      	ldr	r3, [r3, #0]
 804dc90:	f8c0 3e4c 	str.w	r3, [r0, #3660]	; 0xe4c
			modbusState = enmMODBUS_IDLE;
 804dc94:	2100      	movs	r1, #0
 804dc96:	4b22      	ldr	r3, [pc, #136]	; (804dd20 <modbusQueryFSM+0x418>)
 804dc98:	7059      	strb	r1, [r3, #1]
			memset(master.u8SlaveResponseArray,0x00,sizeof(master.u8SlaveResponseArray));
 804dc9a:	f44f 6282 	mov.w	r2, #1040	; 0x410
 804dc9e:	300c      	adds	r0, #12
 804dca0:	f003 febe 	bl	8051a20 <memset>
			break;
 804dca4:	e036      	b.n	804dd14 <modbusQueryFSM+0x40c>
				master.u8MBNoQueryAttempts++;
 804dca6:	3301      	adds	r3, #1
 804dca8:	4a1e      	ldr	r2, [pc, #120]	; (804dd24 <modbusQueryFSM+0x41c>)
 804dcaa:	f882 3522 	strb.w	r3, [r2, #1314]	; 0x522
 804dcae:	e7de      	b.n	804dc6e <modbusQueryFSM+0x366>
			uint32_t temploopcountrt = gu32MBRTUDataByteCounter;
 804dcb0:	4a1b      	ldr	r2, [pc, #108]	; (804dd20 <modbusQueryFSM+0x418>)
 804dcb2:	6853      	ldr	r3, [r2, #4]
			gu32MBRTUDataByteCounter += gu32MBRTUClientNoofPoints[u8MBQueryRegisterAddressCounter++];
 804dcb4:	7810      	ldrb	r0, [r2, #0]
 804dcb6:	1c44      	adds	r4, r0, #1
 804dcb8:	b2e4      	uxtb	r4, r4
 804dcba:	7014      	strb	r4, [r2, #0]
 804dcbc:	491a      	ldr	r1, [pc, #104]	; (804dd28 <modbusQueryFSM+0x420>)
 804dcbe:	eb01 0180 	add.w	r1, r1, r0, lsl #2
 804dcc2:	f8d1 0258 	ldr.w	r0, [r1, #600]	; 0x258
 804dcc6:	4418      	add	r0, r3
 804dcc8:	6050      	str	r0, [r2, #4]
			for(iteratorrt = temploopcountrt ; iteratorrt < gu32MBRTUDataByteCounter ; iteratorrt++)
 804dcca:	e007      	b.n	804dcdc <modbusQueryFSM+0x3d4>
				master.u32SlaveData[iteratorrt] = 0;
 804dccc:	f203 218e 	addw	r1, r3, #654	; 0x28e
 804dcd0:	4a14      	ldr	r2, [pc, #80]	; (804dd24 <modbusQueryFSM+0x41c>)
 804dcd2:	eb02 0281 	add.w	r2, r2, r1, lsl #2
 804dcd6:	2100      	movs	r1, #0
 804dcd8:	6051      	str	r1, [r2, #4]
			for(iteratorrt = temploopcountrt ; iteratorrt < gu32MBRTUDataByteCounter ; iteratorrt++)
 804dcda:	3301      	adds	r3, #1
 804dcdc:	4298      	cmp	r0, r3
 804dcde:	d8f5      	bhi.n	804dccc <modbusQueryFSM+0x3c4>
			if(u8MBQueryRegisterAddressCounter >= (master.u16NoRegisterstoFetch))
 804dce0:	b2a4      	uxth	r4, r4
 804dce2:	4b10      	ldr	r3, [pc, #64]	; (804dd24 <modbusQueryFSM+0x41c>)
 804dce4:	f8b3 3832 	ldrh.w	r3, [r3, #2098]	; 0x832
 804dce8:	429c      	cmp	r4, r3
 804dcea:	d304      	bcc.n	804dcf6 <modbusQueryFSM+0x3ee>
				u8MBQueryRegisterAddressCounter = 0;
 804dcec:	4b0c      	ldr	r3, [pc, #48]	; (804dd20 <modbusQueryFSM+0x418>)
 804dcee:	2200      	movs	r2, #0
 804dcf0:	701a      	strb	r2, [r3, #0]
				gu32MBRTUClientConnectedFlag = 0;
 804dcf2:	615a      	str	r2, [r3, #20]
				gu32MBRTUDataByteCounter = 0;
 804dcf4:	605a      	str	r2, [r3, #4]
			resetModbusPort();
 804dcf6:	f7ff fdf5 	bl	804d8e4 <resetModbusPort>
			master.u32PollDelay = gu32Modbus485PollingTime;//ONE_SEC;
 804dcfa:	480a      	ldr	r0, [pc, #40]	; (804dd24 <modbusQueryFSM+0x41c>)
 804dcfc:	4b0b      	ldr	r3, [pc, #44]	; (804dd2c <modbusQueryFSM+0x424>)
 804dcfe:	681b      	ldr	r3, [r3, #0]
 804dd00:	f8c0 3e4c 	str.w	r3, [r0, #3660]	; 0xe4c
			modbusState = enmMODBUS_IDLE;
 804dd04:	2100      	movs	r1, #0
 804dd06:	4b06      	ldr	r3, [pc, #24]	; (804dd20 <modbusQueryFSM+0x418>)
 804dd08:	7059      	strb	r1, [r3, #1]
			memset(master.u8SlaveResponseArray,0x00,sizeof(master.u8SlaveResponseArray));
 804dd0a:	f44f 6282 	mov.w	r2, #1040	; 0x410
 804dd0e:	300c      	adds	r0, #12
 804dd10:	f003 fe86 	bl	8051a20 <memset>
}
 804dd14:	b021      	add	sp, #132	; 0x84
 804dd16:	bdf0      	pop	{r4, r5, r6, r7, pc}
			modbusState = enmMODBUS_IDLE;
 804dd18:	4b01      	ldr	r3, [pc, #4]	; (804dd20 <modbusQueryFSM+0x418>)
 804dd1a:	2200      	movs	r2, #0
 804dd1c:	705a      	strb	r2, [r3, #1]
}
 804dd1e:	e7f9      	b.n	804dd14 <modbusQueryFSM+0x40c>
 804dd20:	20004320 	.word	0x20004320
 804dd24:	2000d5e0 	.word	0x2000d5e0
 804dd28:	20000cd8 	.word	0x20000cd8
 804dd2c:	200026d8 	.word	0x200026d8
 804dd30:	2000d5ec 	.word	0x2000d5ec

0804dd34 <uploadSlaveData>:
* </table><br><br>
* <hr>
*
*******************************************************************************/
void uploadSlaveData(void)
{
 804dd34:	b530      	push	{r4, r5, lr}
 804dd36:	b083      	sub	sp, #12
	static int32_t value;
	char buffer[6];

//	if(master.u8MBOperationStatus == 2)
//	{
		value = master.u32SlaveData[Loopcounter];    // Signed Integer
 804dd38:	4a45      	ldr	r2, [pc, #276]	; (804de50 <uploadSlaveData+0x11c>)
 804dd3a:	f8d2 44cc 	ldr.w	r4, [r2, #1228]	; 0x4cc
 804dd3e:	f204 218e 	addw	r1, r4, #654	; 0x28e
 804dd42:	4b44      	ldr	r3, [pc, #272]	; (804de54 <uploadSlaveData+0x120>)
 804dd44:	eb03 0381 	add.w	r3, r3, r1, lsl #2
 804dd48:	685d      	ldr	r5, [r3, #4]
 804dd4a:	f8c2 54d0 	str.w	r5, [r2, #1232]	; 0x4d0
		if(Loopcounter == 0)
 804dd4e:	b364      	cbz	r4, 804ddaa <uploadSlaveData+0x76>
		{
			memset(gau8MBPayloadStringRT, 0x00, (1100 * sizeof(char)));
		}
		if(Loopcounter < gu32MBDataByteCounterLimitRTU)
 804dd50:	4b3f      	ldr	r3, [pc, #252]	; (804de50 <uploadSlaveData+0x11c>)
 804dd52:	f8d3 34c8 	ldr.w	r3, [r3, #1224]	; 0x4c8
 804dd56:	429c      	cmp	r4, r3
 804dd58:	d264      	bcs.n	804de24 <uploadSlaveData+0xf0>
		{
			/* Append Data to GSM Payload */
			if(gu32MBRTUDataStatus[Loopcounter] == 1)
 804dd5a:	4b3d      	ldr	r3, [pc, #244]	; (804de50 <uploadSlaveData+0x11c>)
 804dd5c:	eb03 0484 	add.w	r4, r3, r4, lsl #2
 804dd60:	69a3      	ldr	r3, [r4, #24]
 804dd62:	2b01      	cmp	r3, #1
 804dd64:	d028      	beq.n	804ddb8 <uploadSlaveData+0x84>
				memset(buffer, 0x00, (6 * sizeof(char)));
				itoa(value,buffer,MB_PAYLOAD_RADIX);	   	   				  // Decimal String
				strcat(gau8MBPayloadStringRT,buffer);
				strcat(gau8MBPayloadStringRT,PAYLOAD_SEPARATOR);
			}
			else if(gu32MBRTUDataStatus[Loopcounter] == 2)
 804dd66:	2b02      	cmp	r3, #2
 804dd68:	d147      	bne.n	804ddfa <uploadSlaveData+0xc6>
			{
				/* Coil Data .Represent in binary .
				 * */
				if(value < 0)
 804dd6a:	2d00      	cmp	r5, #0
 804dd6c:	db3f      	blt.n	804ddee <uploadSlaveData+0xba>
					value += 256;

				memset(buffer, 0x00, (6 * sizeof(char)));
 804dd6e:	2300      	movs	r3, #0
 804dd70:	9300      	str	r3, [sp, #0]
 804dd72:	f8ad 3004 	strh.w	r3, [sp, #4]
				itoa(value,buffer,10);
 804dd76:	220a      	movs	r2, #10
 804dd78:	4669      	mov	r1, sp
 804dd7a:	4b35      	ldr	r3, [pc, #212]	; (804de50 <uploadSlaveData+0x11c>)
 804dd7c:	f8d3 04d0 	ldr.w	r0, [r3, #1232]	; 0x4d0
 804dd80:	f003 fbde 	bl	8051540 <itoa>
				strcat(gau8MBPayloadStringRT,buffer);
 804dd84:	4c34      	ldr	r4, [pc, #208]	; (804de58 <uploadSlaveData+0x124>)
 804dd86:	4669      	mov	r1, sp
 804dd88:	4620      	mov	r0, r4
 804dd8a:	f003 fe9f 	bl	8051acc <strcat>
				strcat(gau8MBPayloadStringRT,PAYLOAD_SEPARATOR);
 804dd8e:	4620      	mov	r0, r4
 804dd90:	f7f2 fa38 	bl	8040204 <strlen>
 804dd94:	4b31      	ldr	r3, [pc, #196]	; (804de5c <uploadSlaveData+0x128>)
 804dd96:	881b      	ldrh	r3, [r3, #0]
 804dd98:	5223      	strh	r3, [r4, r0]
				strcat(gau8MBPayloadStringRT,PAYLOAD_SEPARATOR);
			}
			//master.u32SlaveData[Loopcounter] = 0;
			/*Added on 20-1-2020 */
			//gu32MBRTUDataStatus[Loopcounter] = 0;
			Loopcounter++;
 804dd9a:	4a2d      	ldr	r2, [pc, #180]	; (804de50 <uploadSlaveData+0x11c>)
 804dd9c:	f8d2 34cc 	ldr.w	r3, [r2, #1228]	; 0x4cc
 804dda0:	3301      	adds	r3, #1
 804dda2:	f8c2 34cc 	str.w	r3, [r2, #1228]	; 0x4cc
			memset(gau8MBPayloadStringRT,0x00,1100 * sizeof(char));
			Loopcounter = 0;
			//gu32MBRTUDataByteCounter = 0;
		}
	//}
}
 804dda6:	b003      	add	sp, #12
 804dda8:	bd30      	pop	{r4, r5, pc}
			memset(gau8MBPayloadStringRT, 0x00, (1100 * sizeof(char)));
 804ddaa:	f240 424c 	movw	r2, #1100	; 0x44c
 804ddae:	2100      	movs	r1, #0
 804ddb0:	4829      	ldr	r0, [pc, #164]	; (804de58 <uploadSlaveData+0x124>)
 804ddb2:	f003 fe35 	bl	8051a20 <memset>
 804ddb6:	e7cb      	b.n	804dd50 <uploadSlaveData+0x1c>
				strcat(gau8MBPayloadStringRT,"E");
 804ddb8:	4c27      	ldr	r4, [pc, #156]	; (804de58 <uploadSlaveData+0x124>)
 804ddba:	4620      	mov	r0, r4
 804ddbc:	f7f2 fa22 	bl	8040204 <strlen>
 804ddc0:	4b27      	ldr	r3, [pc, #156]	; (804de60 <uploadSlaveData+0x12c>)
 804ddc2:	881b      	ldrh	r3, [r3, #0]
 804ddc4:	5223      	strh	r3, [r4, r0]
				memset(buffer, 0x00, (6 * sizeof(char)));
 804ddc6:	2300      	movs	r3, #0
 804ddc8:	9300      	str	r3, [sp, #0]
 804ddca:	f8ad 3004 	strh.w	r3, [sp, #4]
				itoa(value,buffer,MB_PAYLOAD_RADIX);	   	   				  // Decimal String
 804ddce:	220a      	movs	r2, #10
 804ddd0:	4669      	mov	r1, sp
 804ddd2:	4628      	mov	r0, r5
 804ddd4:	f003 fbb4 	bl	8051540 <itoa>
				strcat(gau8MBPayloadStringRT,buffer);
 804ddd8:	4669      	mov	r1, sp
 804ddda:	4620      	mov	r0, r4
 804dddc:	f003 fe76 	bl	8051acc <strcat>
				strcat(gau8MBPayloadStringRT,PAYLOAD_SEPARATOR);
 804dde0:	4620      	mov	r0, r4
 804dde2:	f7f2 fa0f 	bl	8040204 <strlen>
 804dde6:	4b1d      	ldr	r3, [pc, #116]	; (804de5c <uploadSlaveData+0x128>)
 804dde8:	881b      	ldrh	r3, [r3, #0]
 804ddea:	5223      	strh	r3, [r4, r0]
 804ddec:	e7d5      	b.n	804dd9a <uploadSlaveData+0x66>
					value += 256;
 804ddee:	f505 7580 	add.w	r5, r5, #256	; 0x100
 804ddf2:	4b17      	ldr	r3, [pc, #92]	; (804de50 <uploadSlaveData+0x11c>)
 804ddf4:	f8c3 54d0 	str.w	r5, [r3, #1232]	; 0x4d0
 804ddf8:	e7b9      	b.n	804dd6e <uploadSlaveData+0x3a>
				memset(buffer, 0x00, (6 * sizeof(char)));
 804ddfa:	2300      	movs	r3, #0
 804ddfc:	9300      	str	r3, [sp, #0]
 804ddfe:	f8ad 3004 	strh.w	r3, [sp, #4]
				itoa(value,buffer,MB_PAYLOAD_RADIX);
 804de02:	220a      	movs	r2, #10
 804de04:	4669      	mov	r1, sp
 804de06:	4628      	mov	r0, r5
 804de08:	f003 fb9a 	bl	8051540 <itoa>
				strcat(gau8MBPayloadStringRT,buffer);
 804de0c:	4c12      	ldr	r4, [pc, #72]	; (804de58 <uploadSlaveData+0x124>)
 804de0e:	4669      	mov	r1, sp
 804de10:	4620      	mov	r0, r4
 804de12:	f003 fe5b 	bl	8051acc <strcat>
				strcat(gau8MBPayloadStringRT,PAYLOAD_SEPARATOR);
 804de16:	4620      	mov	r0, r4
 804de18:	f7f2 f9f4 	bl	8040204 <strlen>
 804de1c:	4b0f      	ldr	r3, [pc, #60]	; (804de5c <uploadSlaveData+0x128>)
 804de1e:	881b      	ldrh	r3, [r3, #0]
 804de20:	5223      	strh	r3, [r4, r0]
 804de22:	e7ba      	b.n	804dd9a <uploadSlaveData+0x66>
			memcpy(gau8TempMBRTUPayloadString,gau8MBPayloadStringRT,sizeof(gau8MBPayloadStringRT));
 804de24:	480f      	ldr	r0, [pc, #60]	; (804de64 <uploadSlaveData+0x130>)
 804de26:	f500 7461 	add.w	r4, r0, #900	; 0x384
 804de2a:	f240 454c 	movw	r5, #1100	; 0x44c
 804de2e:	462a      	mov	r2, r5
 804de30:	4621      	mov	r1, r4
 804de32:	f500 60fa 	add.w	r0, r0, #2000	; 0x7d0
 804de36:	f003 fde5 	bl	8051a04 <memcpy>
			memset(gau8MBPayloadStringRT,0x00,1100 * sizeof(char));
 804de3a:	462a      	mov	r2, r5
 804de3c:	2100      	movs	r1, #0
 804de3e:	4620      	mov	r0, r4
 804de40:	f003 fdee 	bl	8051a20 <memset>
			Loopcounter = 0;
 804de44:	4b02      	ldr	r3, [pc, #8]	; (804de50 <uploadSlaveData+0x11c>)
 804de46:	2200      	movs	r2, #0
 804de48:	f8c3 24cc 	str.w	r2, [r3, #1228]	; 0x4cc
}
 804de4c:	e7ab      	b.n	804dda6 <uploadSlaveData+0x72>
 804de4e:	bf00      	nop
 804de50:	20004320 	.word	0x20004320
 804de54:	2000d5e0 	.word	0x2000d5e0
 804de58:	2000105c 	.word	0x2000105c
 804de5c:	0805a920 	.word	0x0805a920
 804de60:	0805a9d8 	.word	0x0805a9d8
 804de64:	20000cd8 	.word	0x20000cd8

0804de68 <setupModbusRTU>:
* </table><br><br>
* <hr>
*
*******************************************************************************/
void setupModbusRTU(void)
{
 804de68:	b410      	push	{r4}
	uint32_t temp = 0;
	master.u16NoRegisterstoFetch = gu32Modbus485RegisterFetch;;
 804de6a:	4b13      	ldr	r3, [pc, #76]	; (804deb8 <setupModbusRTU+0x50>)
 804de6c:	881c      	ldrh	r4, [r3, #0]
 804de6e:	4b13      	ldr	r3, [pc, #76]	; (804debc <setupModbusRTU+0x54>)
 804de70:	f8a3 4832 	strh.w	r4, [r3, #2098]	; 0x832
	master.u8MBSlave_Address = gu32Modbus485SlaveID;
 804de74:	4a12      	ldr	r2, [pc, #72]	; (804dec0 <setupModbusRTU+0x58>)
 804de76:	6812      	ldr	r2, [r2, #0]
 804de78:	701a      	strb	r2, [r3, #0]
	master.u8MBOperationStatus = 1;
 804de7a:	2201      	movs	r2, #1
 804de7c:	f883 2521 	strb.w	r2, [r3, #1313]	; 0x521
	master.u32PollDelay = gu32Modbus485PollingTime;
 804de80:	4a10      	ldr	r2, [pc, #64]	; (804dec4 <setupModbusRTU+0x5c>)
 804de82:	6812      	ldr	r2, [r2, #0]
 804de84:	f8c3 2e4c 	str.w	r2, [r3, #3660]	; 0xe4c

	for(temp = 0; temp < master.u16NoRegisterstoFetch ;temp++)
 804de88:	2300      	movs	r3, #0
 804de8a:	429c      	cmp	r4, r3
 804de8c:	d90c      	bls.n	804dea8 <setupModbusRTU+0x40>
	{
		/*Calculates how many data values will be there in payload */
		gu32MBDataByteCounterLimitRTU += gu32MBRTUClientNoofPoints[temp];
 804de8e:	4a0e      	ldr	r2, [pc, #56]	; (804dec8 <setupModbusRTU+0x60>)
 804de90:	eb02 0283 	add.w	r2, r2, r3, lsl #2
 804de94:	f8d2 0258 	ldr.w	r0, [r2, #600]	; 0x258
 804de98:	490c      	ldr	r1, [pc, #48]	; (804decc <setupModbusRTU+0x64>)
 804de9a:	f8d1 24c8 	ldr.w	r2, [r1, #1224]	; 0x4c8
 804de9e:	4402      	add	r2, r0
 804dea0:	f8c1 24c8 	str.w	r2, [r1, #1224]	; 0x4c8
	for(temp = 0; temp < master.u16NoRegisterstoFetch ;temp++)
 804dea4:	3301      	adds	r3, #1
 804dea6:	e7f0      	b.n	804de8a <setupModbusRTU+0x22>
	}
	master.u8MBNoQueryAttempts = 0;
 804dea8:	4b04      	ldr	r3, [pc, #16]	; (804debc <setupModbusRTU+0x54>)
 804deaa:	2200      	movs	r2, #0
 804deac:	f883 2522 	strb.w	r2, [r3, #1314]	; 0x522
}
 804deb0:	f85d 4b04 	ldr.w	r4, [sp], #4
 804deb4:	4770      	bx	lr
 804deb6:	bf00      	nop
 804deb8:	20003658 	.word	0x20003658
 804debc:	2000d5e0 	.word	0x2000d5e0
 804dec0:	20003654 	.word	0x20003654
 804dec4:	200026d8 	.word	0x200026d8
 804dec8:	20000cd8 	.word	0x20000cd8
 804decc:	20004320 	.word	0x20004320

0804ded0 <tcp_client_handle>:
	//uint16_t inPort = tpcb->remote_port;

	/* Extract the IP */
	//char *remIP = ipaddr_ntoa(&inIP);

	esTx = es;
 804ded0:	4b01      	ldr	r3, [pc, #4]	; (804ded8 <tcp_client_handle+0x8>)
 804ded2:	6019      	str	r1, [r3, #0]
	pcbTx = tpcb;
 804ded4:	6058      	str	r0, [r3, #4]

}
 804ded6:	4770      	bx	lr
 804ded8:	20004800 	.word	0x20004800

0804dedc <tcp_modbusclient_send>:
{
 804dedc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 804dede:	4606      	mov	r6, r0
 804dee0:	460f      	mov	r7, r1
  err_t wr_err = ERR_OK;
 804dee2:	2500      	movs	r5, #0
  while ((wr_err == ERR_OK) &&
 804dee4:	e002      	b.n	804deec <tcp_modbusclient_send+0x10>
      pbuf_free(ptr);
 804dee6:	4620      	mov	r0, r4
 804dee8:	f7f7 fef8 	bl	8045cdc <pbuf_free>
  while ((wr_err == ERR_OK) &&
 804deec:	b9cd      	cbnz	r5, 804df22 <tcp_modbusclient_send+0x46>
         (es->p_tx != NULL) &&
 804deee:	68bc      	ldr	r4, [r7, #8]
  while ((wr_err == ERR_OK) &&
 804def0:	b1bc      	cbz	r4, 804df22 <tcp_modbusclient_send+0x46>
         (es->p_tx->len <= tcp_sndbuf(tpcb)))
 804def2:	8962      	ldrh	r2, [r4, #10]
 804def4:	f8b6 3060 	ldrh.w	r3, [r6, #96]	; 0x60
         (es->p_tx != NULL) &&
 804def8:	429a      	cmp	r2, r3
 804defa:	d812      	bhi.n	804df22 <tcp_modbusclient_send+0x46>
    wr_err = tcp_write(tpcb, ptr->payload, ptr->len, 1);
 804defc:	2301      	movs	r3, #1
 804defe:	6861      	ldr	r1, [r4, #4]
 804df00:	4630      	mov	r0, r6
 804df02:	f7fa ff41 	bl	8048d88 <tcp_write>
    if (wr_err == ERR_OK) {
 804df06:	4605      	mov	r5, r0
 804df08:	b930      	cbnz	r0, 804df18 <tcp_modbusclient_send+0x3c>
      es->p_tx = ptr->next;
 804df0a:	6820      	ldr	r0, [r4, #0]
 804df0c:	60b8      	str	r0, [r7, #8]
      if (es->p_tx != NULL) {
 804df0e:	2800      	cmp	r0, #0
 804df10:	d0e9      	beq.n	804dee6 <tcp_modbusclient_send+0xa>
        pbuf_ref(es->p_tx);
 804df12:	f7f8 f8b7 	bl	8046084 <pbuf_ref>
 804df16:	e7e6      	b.n	804dee6 <tcp_modbusclient_send+0xa>
   } else if(wr_err == ERR_MEM) {
 804df18:	f1b0 3fff 	cmp.w	r0, #4294967295
 804df1c:	d1e6      	bne.n	804deec <tcp_modbusclient_send+0x10>
     es->p_tx = ptr;
 804df1e:	60bc      	str	r4, [r7, #8]
 804df20:	e7e4      	b.n	804deec <tcp_modbusclient_send+0x10>
}
 804df22:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0804df24 <tcp_modbusclient_sent>:
{
 804df24:	b508      	push	{r3, lr}
 804df26:	4603      	mov	r3, r0
  if(es->p_tx != NULL)
 804df28:	6882      	ldr	r2, [r0, #8]
 804df2a:	b11a      	cbz	r2, 804df34 <tcp_modbusclient_sent+0x10>
 804df2c:	4608      	mov	r0, r1
    tcp_modbusclient_send(tpcb, es);
 804df2e:	4619      	mov	r1, r3
 804df30:	f7ff ffd4 	bl	804dedc <tcp_modbusclient_send>
}
 804df34:	2000      	movs	r0, #0
 804df36:	bd08      	pop	{r3, pc}

0804df38 <tcp_modbusclient_connection_close>:
{
 804df38:	b538      	push	{r3, r4, r5, lr}
 804df3a:	4604      	mov	r4, r0
 804df3c:	460d      	mov	r5, r1
  tcp_recv(tpcb, NULL);
 804df3e:	2100      	movs	r1, #0
 804df40:	f7f8 fbde 	bl	8046700 <tcp_recv>
  tcp_sent(tpcb, NULL);
 804df44:	2100      	movs	r1, #0
 804df46:	4620      	mov	r0, r4
 804df48:	f7f8 fbf4 	bl	8046734 <tcp_sent>
  tcp_poll(tpcb, NULL,0);
 804df4c:	2200      	movs	r2, #0
 804df4e:	4611      	mov	r1, r2
 804df50:	4620      	mov	r0, r4
 804df52:	f7f8 fc21 	bl	8046798 <tcp_poll>
  if (es != NULL) {
 804df56:	b115      	cbz	r5, 804df5e <tcp_modbusclient_connection_close+0x26>
    mem_free(es);
 804df58:	4628      	mov	r0, r5
 804df5a:	f7f7 fb2f 	bl	80455bc <mem_free>
  tcp_close(tpcb);
 804df5e:	4620      	mov	r0, r4
 804df60:	f7f8 ff56 	bl	8046e10 <tcp_close>
}
 804df64:	bd38      	pop	{r3, r4, r5, pc}

0804df66 <tcp_modbusclient_poll>:
{
 804df66:	b508      	push	{r3, lr}
 804df68:	460b      	mov	r3, r1
  if (es != NULL) {
 804df6a:	b188      	cbz	r0, 804df90 <tcp_modbusclient_poll+0x2a>
 804df6c:	4601      	mov	r1, r0
    if (es->p_tx != NULL) {
 804df6e:	6882      	ldr	r2, [r0, #8]
 804df70:	b122      	cbz	r2, 804df7c <tcp_modbusclient_poll+0x16>
      tcp_modbusclient_send(tpcb, es);
 804df72:	4618      	mov	r0, r3
 804df74:	f7ff ffb2 	bl	804dedc <tcp_modbusclient_send>
    ret_err = ERR_OK;
 804df78:	2000      	movs	r0, #0
}
 804df7a:	bd08      	pop	{r3, pc}
      if (es->state == ES_CLOSING) {
 804df7c:	7802      	ldrb	r2, [r0, #0]
 804df7e:	2a03      	cmp	r2, #3
 804df80:	d001      	beq.n	804df86 <tcp_modbusclient_poll+0x20>
    ret_err = ERR_OK;
 804df82:	2000      	movs	r0, #0
 804df84:	e7f9      	b.n	804df7a <tcp_modbusclient_poll+0x14>
        tcp_modbusclient_connection_close(tpcb, es);
 804df86:	4618      	mov	r0, r3
 804df88:	f7ff ffd6 	bl	804df38 <tcp_modbusclient_connection_close>
    ret_err = ERR_OK;
 804df8c:	2000      	movs	r0, #0
 804df8e:	e7f4      	b.n	804df7a <tcp_modbusclient_poll+0x14>
    tcp_abort(tpcb);
 804df90:	4608      	mov	r0, r1
 804df92:	f7f9 f85f 	bl	8047054 <tcp_abort>
    ret_err = ERR_ABRT;
 804df96:	f06f 000c 	mvn.w	r0, #12
 804df9a:	e7ee      	b.n	804df7a <tcp_modbusclient_poll+0x14>

0804df9c <tcp_modbusclient_recv>:
{
 804df9c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 804df9e:	460f      	mov	r7, r1
 804dfa0:	4615      	mov	r5, r2
 804dfa2:	461c      	mov	r4, r3
  LWIP_ASSERT("arg != NULL",arg != NULL);
 804dfa4:	4606      	mov	r6, r0
 804dfa6:	b188      	cbz	r0, 804dfcc <tcp_modbusclient_recv+0x30>
  if (p == NULL) {
 804dfa8:	b1c5      	cbz	r5, 804dfdc <tcp_modbusclient_recv+0x40>
  else if (err != ERR_OK) {
 804dfaa:	bb3c      	cbnz	r4, 804dffc <tcp_modbusclient_recv+0x60>
  } else if(es->state == ES_CONNECTED) {
 804dfac:	7833      	ldrb	r3, [r6, #0]
 804dfae:	2b01      	cmp	r3, #1
 804dfb0:	d13a      	bne.n	804e028 <tcp_modbusclient_recv+0x8c>
	  if(gu32MBClientConnectedFlag == 1)
 804dfb2:	4b22      	ldr	r3, [pc, #136]	; (804e03c <tcp_modbusclient_recv+0xa0>)
 804dfb4:	689b      	ldr	r3, [r3, #8]
 804dfb6:	2b01      	cmp	r3, #1
 804dfb8:	d025      	beq.n	804e006 <tcp_modbusclient_recv+0x6a>
	  tcp_recved(tpcb, p->tot_len);
 804dfba:	8929      	ldrh	r1, [r5, #8]
 804dfbc:	4638      	mov	r0, r7
 804dfbe:	f7f8 fb2f 	bl	8046620 <tcp_recved>
	  pbuf_free(p);
 804dfc2:	4628      	mov	r0, r5
 804dfc4:	f7f7 fe8a 	bl	8045cdc <pbuf_free>
	  ret_err = ERR_OK;
 804dfc8:	4620      	mov	r0, r4
}
 804dfca:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  LWIP_ASSERT("arg != NULL",arg != NULL);
 804dfcc:	4b1c      	ldr	r3, [pc, #112]	; (804e040 <tcp_modbusclient_recv+0xa4>)
 804dfce:	f44f 725f 	mov.w	r2, #892	; 0x37c
 804dfd2:	491c      	ldr	r1, [pc, #112]	; (804e044 <tcp_modbusclient_recv+0xa8>)
 804dfd4:	481c      	ldr	r0, [pc, #112]	; (804e048 <tcp_modbusclient_recv+0xac>)
 804dfd6:	f003 fd37 	bl	8051a48 <printf>
 804dfda:	e7e5      	b.n	804dfa8 <tcp_modbusclient_recv+0xc>
    es->state = ES_CLOSING;
 804dfdc:	2303      	movs	r3, #3
 804dfde:	7033      	strb	r3, [r6, #0]
    if (es->p_tx == NULL) {
 804dfe0:	68b3      	ldr	r3, [r6, #8]
 804dfe2:	b12b      	cbz	r3, 804dff0 <tcp_modbusclient_recv+0x54>
      tcp_modbusclient_send(tpcb, es);
 804dfe4:	4631      	mov	r1, r6
 804dfe6:	4638      	mov	r0, r7
 804dfe8:	f7ff ff78 	bl	804dedc <tcp_modbusclient_send>
    ret_err = ERR_OK;
 804dfec:	2000      	movs	r0, #0
 804dfee:	e7ec      	b.n	804dfca <tcp_modbusclient_recv+0x2e>
       tcp_modbusclient_connection_close(tpcb, es);
 804dff0:	4631      	mov	r1, r6
 804dff2:	4638      	mov	r0, r7
 804dff4:	f7ff ffa0 	bl	804df38 <tcp_modbusclient_connection_close>
    ret_err = ERR_OK;
 804dff8:	2000      	movs	r0, #0
 804dffa:	e7e6      	b.n	804dfca <tcp_modbusclient_recv+0x2e>
      pbuf_free(p);
 804dffc:	4628      	mov	r0, r5
 804dffe:	f7f7 fe6d 	bl	8045cdc <pbuf_free>
    ret_err = err;
 804e002:	4620      	mov	r0, r4
 804e004:	e7e1      	b.n	804dfca <tcp_modbusclient_recv+0x2e>
		  memcpy(strMbClient.s8SlaveResponseArray,p->payload,p->tot_len);
 804e006:	892a      	ldrh	r2, [r5, #8]
 804e008:	6869      	ldr	r1, [r5, #4]
 804e00a:	4810      	ldr	r0, [pc, #64]	; (804e04c <tcp_modbusclient_recv+0xb0>)
 804e00c:	f003 fcfa 	bl	8051a04 <memcpy>
		  enmMBCurrentState = enmMB_RESPONSERECEIVED;
 804e010:	4b0f      	ldr	r3, [pc, #60]	; (804e050 <tcp_modbusclient_recv+0xb4>)
 804e012:	2204      	movs	r2, #4
 804e014:	701a      	strb	r2, [r3, #0]
		  gu32MBConnected = 1;
 804e016:	4b09      	ldr	r3, [pc, #36]	; (804e03c <tcp_modbusclient_recv+0xa0>)
 804e018:	2201      	movs	r2, #1
 804e01a:	60da      	str	r2, [r3, #12]
		  gu32MBOperateFlag = 1;
 804e01c:	611a      	str	r2, [r3, #16]
		  tcp_client_handle(tpcb, es);
 804e01e:	4631      	mov	r1, r6
 804e020:	4638      	mov	r0, r7
 804e022:	f7ff ff55 	bl	804ded0 <tcp_client_handle>
 804e026:	e7c8      	b.n	804dfba <tcp_modbusclient_recv+0x1e>
    tcp_recved(tpcb, p->tot_len);
 804e028:	8929      	ldrh	r1, [r5, #8]
 804e02a:	4638      	mov	r0, r7
 804e02c:	f7f8 faf8 	bl	8046620 <tcp_recved>
    pbuf_free(p);
 804e030:	4628      	mov	r0, r5
 804e032:	f7f7 fe53 	bl	8045cdc <pbuf_free>
    ret_err = ERR_OK;
 804e036:	4620      	mov	r0, r4
 804e038:	e7c7      	b.n	804dfca <tcp_modbusclient_recv+0x2e>
 804e03a:	bf00      	nop
 804e03c:	20004800 	.word	0x20004800
 804e040:	0805a9dc 	.word	0x0805a9dc
 804e044:	0805a9f0 	.word	0x0805a9f0
 804e048:	08058ecc 	.word	0x08058ecc
 804e04c:	2000e5bc 	.word	0x2000e5bc
 804e050:	200018f4 	.word	0x200018f4

0804e054 <updateModbusQueryFrame>:
	strMbClient.u32QueryFrame[0] = (MB_TCP_TID >> 8);
 804e054:	4b1f      	ldr	r3, [pc, #124]	; (804e0d4 <updateModbusQueryFrame+0x80>)
 804e056:	2200      	movs	r2, #0
 804e058:	f883 2020 	strb.w	r2, [r3, #32]
	strMbClient.u32QueryFrame[1] = (MB_TCP_TID & 0xFF);
 804e05c:	2103      	movs	r1, #3
 804e05e:	f883 1021 	strb.w	r1, [r3, #33]	; 0x21
	strMbClient.u32QueryFrame[2] = (MB_TCP_PID >> 8);
 804e062:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
	strMbClient.u32QueryFrame[3] = (MB_TCP_PID & 0xFF);
 804e066:	f883 2023 	strb.w	r2, [r3, #35]	; 0x23
	strMbClient.u32QueryFrame[4] = (6 >> 8);
 804e06a:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
	strMbClient.u32QueryFrame[5] = (6 & 0xFF);
 804e06e:	2206      	movs	r2, #6
 804e070:	f883 2025 	strb.w	r2, [r3, #37]	; 0x25
	strMbClient.u32QueryFrame[6] = (strMbClient.u32UnitId);
 804e074:	7b1a      	ldrb	r2, [r3, #12]
 804e076:	f883 2026 	strb.w	r2, [r3, #38]	; 0x26
	strMbClient.u32QueryFrame[7] = gu32MBTCPClientFuncCode[message_count];
 804e07a:	4a17      	ldr	r2, [pc, #92]	; (804e0d8 <updateModbusQueryFrame+0x84>)
 804e07c:	6950      	ldr	r0, [r2, #20]
 804e07e:	4917      	ldr	r1, [pc, #92]	; (804e0dc <updateModbusQueryFrame+0x88>)
 804e080:	eb01 0080 	add.w	r0, r1, r0, lsl #2
 804e084:	7900      	ldrb	r0, [r0, #4]
 804e086:	f883 0027 	strb.w	r0, [r3, #39]	; 0x27
	strMbClient.u32QueryFrame[8] = ((gu32MBTCPClientAddress[message_count]- MB_ADDRESS_DEREF) >> 8);
 804e08a:	6950      	ldr	r0, [r2, #20]
 804e08c:	eb01 0080 	add.w	r0, r1, r0, lsl #2
 804e090:	f8d0 0130 	ldr.w	r0, [r0, #304]	; 0x130
 804e094:	3801      	subs	r0, #1
 804e096:	f3c0 2007 	ubfx	r0, r0, #8, #8
 804e09a:	f883 0028 	strb.w	r0, [r3, #40]	; 0x28
	strMbClient.u32QueryFrame[9] = ((gu32MBTCPClientAddress[message_count]- MB_ADDRESS_DEREF)& 0xFF);
 804e09e:	6950      	ldr	r0, [r2, #20]
 804e0a0:	eb01 0080 	add.w	r0, r1, r0, lsl #2
 804e0a4:	f8d0 0130 	ldr.w	r0, [r0, #304]	; 0x130
 804e0a8:	3801      	subs	r0, #1
 804e0aa:	b2c0      	uxtb	r0, r0
 804e0ac:	f883 0029 	strb.w	r0, [r3, #41]	; 0x29
	strMbClient.u32QueryFrame[10] = ((gu32MBTCPClientNoofPoints[message_count]) >> 8);
 804e0b0:	6950      	ldr	r0, [r2, #20]
 804e0b2:	eb01 0080 	add.w	r0, r1, r0, lsl #2
 804e0b6:	f890 025d 	ldrb.w	r0, [r0, #605]	; 0x25d
 804e0ba:	f883 002a 	strb.w	r0, [r3, #42]	; 0x2a
	strMbClient.u32QueryFrame[11] = ((gu32MBTCPClientNoofPoints[message_count])& 0xFF);
 804e0be:	6950      	ldr	r0, [r2, #20]
 804e0c0:	eb01 0180 	add.w	r1, r1, r0, lsl #2
 804e0c4:	f891 125c 	ldrb.w	r1, [r1, #604]	; 0x25c
 804e0c8:	f883 102b 	strb.w	r1, [r3, #43]	; 0x2b
	temp++;
 804e0cc:	6993      	ldr	r3, [r2, #24]
 804e0ce:	3301      	adds	r3, #1
 804e0d0:	6193      	str	r3, [r2, #24]
}
 804e0d2:	4770      	bx	lr
 804e0d4:	2000e4c8 	.word	0x2000e4c8
 804e0d8:	20004800 	.word	0x20004800
 804e0dc:	200018f4 	.word	0x200018f4

0804e0e0 <tcp_modbusclient_connected>:
{
 804e0e0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 804e0e2:	460c      	mov	r4, r1
  if (err == ERR_OK) {
 804e0e4:	4616      	mov	r6, r2
 804e0e6:	2a00      	cmp	r2, #0
 804e0e8:	d141      	bne.n	804e16e <tcp_modbusclient_connected+0x8e>
    es = (struct mbclient *)mem_malloc(sizeof(struct mbclient));
 804e0ea:	200c      	movs	r0, #12
 804e0ec:	f7f7 fb3e 	bl	804576c <mem_malloc>
    if (es != NULL) {
 804e0f0:	4605      	mov	r5, r0
 804e0f2:	2800      	cmp	r0, #0
 804e0f4:	d034      	beq.n	804e160 <tcp_modbusclient_connected+0x80>
      es->state = ES_CONNECTED;
 804e0f6:	2701      	movs	r7, #1
 804e0f8:	7007      	strb	r7, [r0, #0]
      es->pcb = tpcb;
 804e0fa:	6044      	str	r4, [r0, #4]
      updateModbusQueryFrame();
 804e0fc:	f7ff ffaa 	bl	804e054 <updateModbusQueryFrame>
      gu32MBClientConnectedFlag = 1;
 804e100:	4b1e      	ldr	r3, [pc, #120]	; (804e17c <tcp_modbusclient_connected+0x9c>)
 804e102:	609f      	str	r7, [r3, #8]
      es->p_tx = pbuf_alloc(PBUF_TRANSPORT, 12 , PBUF_POOL);
 804e104:	2203      	movs	r2, #3
 804e106:	210c      	movs	r1, #12
 804e108:	2000      	movs	r0, #0
 804e10a:	f7f7 fe4b 	bl	8045da4 <pbuf_alloc>
 804e10e:	60a8      	str	r0, [r5, #8]
      if (es->p_tx) {
 804e110:	b388      	cbz	r0, 804e176 <tcp_modbusclient_connected+0x96>
        pbuf_take(es->p_tx, (uint8_t *)strMbClient.u32QueryFrame, 12);
 804e112:	220c      	movs	r2, #12
 804e114:	491a      	ldr	r1, [pc, #104]	; (804e180 <tcp_modbusclient_connected+0xa0>)
 804e116:	f7f8 f8e9 	bl	80462ec <pbuf_take>
        tcp_arg(tpcb, es);
 804e11a:	4629      	mov	r1, r5
 804e11c:	4620      	mov	r0, r4
 804e11e:	f7f8 faec 	bl	80466fa <tcp_arg>
        tcp_recv(tpcb, tcp_modbusclient_recv);
 804e122:	4918      	ldr	r1, [pc, #96]	; (804e184 <tcp_modbusclient_connected+0xa4>)
 804e124:	4620      	mov	r0, r4
 804e126:	f7f8 faeb 	bl	8046700 <tcp_recv>
        tcp_sent(tpcb, tcp_modbusclient_sent);
 804e12a:	4917      	ldr	r1, [pc, #92]	; (804e188 <tcp_modbusclient_connected+0xa8>)
 804e12c:	4620      	mov	r0, r4
 804e12e:	f7f8 fb01 	bl	8046734 <tcp_sent>
        tcp_poll(tpcb, tcp_modbusclient_poll, 1); // changed from 1 21/1/2021
 804e132:	463a      	mov	r2, r7
 804e134:	4915      	ldr	r1, [pc, #84]	; (804e18c <tcp_modbusclient_connected+0xac>)
 804e136:	4620      	mov	r0, r4
 804e138:	f7f8 fb2e 	bl	8046798 <tcp_poll>
        tcp_client_handle(tpcb, es);
 804e13c:	4629      	mov	r1, r5
 804e13e:	4620      	mov	r0, r4
 804e140:	f7ff fec6 	bl	804ded0 <tcp_client_handle>
        gu32MBOperateFlag = 1;
 804e144:	4f0d      	ldr	r7, [pc, #52]	; (804e17c <tcp_modbusclient_connected+0x9c>)
 804e146:	2301      	movs	r3, #1
 804e148:	613b      	str	r3, [r7, #16]
        enmMBCurrentState = enmMB_CONNECTED;
 804e14a:	4b11      	ldr	r3, [pc, #68]	; (804e190 <tcp_modbusclient_connected+0xb0>)
 804e14c:	2202      	movs	r2, #2
 804e14e:	701a      	strb	r2, [r3, #0]
        tcp_modbusclient_send(tpcb,es);
 804e150:	4629      	mov	r1, r5
 804e152:	4620      	mov	r0, r4
 804e154:	f7ff fec2 	bl	804dedc <tcp_modbusclient_send>
        gu32MBTCPTimer = FIVE_SEC;
 804e158:	f241 3388 	movw	r3, #5000	; 0x1388
 804e15c:	61fb      	str	r3, [r7, #28]
        return ERR_OK;
 804e15e:	e00a      	b.n	804e176 <tcp_modbusclient_connected+0x96>
      tcp_modbusclient_connection_close(tpcb, es);
 804e160:	4601      	mov	r1, r0
 804e162:	4620      	mov	r0, r4
 804e164:	f7ff fee8 	bl	804df38 <tcp_modbusclient_connection_close>
      return ERR_MEM;
 804e168:	f04f 36ff 	mov.w	r6, #4294967295
 804e16c:	e003      	b.n	804e176 <tcp_modbusclient_connected+0x96>
    tcp_modbusclient_connection_close(tpcb, es);
 804e16e:	2100      	movs	r1, #0
 804e170:	4620      	mov	r0, r4
 804e172:	f7ff fee1 	bl	804df38 <tcp_modbusclient_connection_close>
}
 804e176:	4630      	mov	r0, r6
 804e178:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 804e17a:	bf00      	nop
 804e17c:	20004800 	.word	0x20004800
 804e180:	2000e4e8 	.word	0x2000e4e8
 804e184:	0804df9d 	.word	0x0804df9d
 804e188:	0804df25 	.word	0x0804df25
 804e18c:	0804df67 	.word	0x0804df67
 804e190:	200018f4 	.word	0x200018f4

0804e194 <setupModbus>:
{
 804e194:	b410      	push	{r4}
	strMbClient.u32MBQueryCounter = 0;
 804e196:	4a10      	ldr	r2, [pc, #64]	; (804e1d8 <setupModbus+0x44>)
 804e198:	2300      	movs	r3, #0
 804e19a:	6113      	str	r3, [r2, #16]
	strMbClient.u32NoofRegConfigured = gu32Modbus485RegisterFetch;//44;
 804e19c:	490f      	ldr	r1, [pc, #60]	; (804e1dc <setupModbus+0x48>)
 804e19e:	680c      	ldr	r4, [r1, #0]
 804e1a0:	f8c2 4668 	str.w	r4, [r2, #1640]	; 0x668
	for(temp = 0; temp < strMbClient.u32NoofRegConfigured ;temp++)
 804e1a4:	4a0e      	ldr	r2, [pc, #56]	; (804e1e0 <setupModbus+0x4c>)
 804e1a6:	6193      	str	r3, [r2, #24]
 804e1a8:	4b0d      	ldr	r3, [pc, #52]	; (804e1e0 <setupModbus+0x4c>)
 804e1aa:	699b      	ldr	r3, [r3, #24]
 804e1ac:	429c      	cmp	r4, r3
 804e1ae:	d90b      	bls.n	804e1c8 <setupModbus+0x34>
		gu32MBDataByteCounterLimit += gu32MBTCPClientNoofPoints[temp];
 804e1b0:	4a0c      	ldr	r2, [pc, #48]	; (804e1e4 <setupModbus+0x50>)
 804e1b2:	eb02 0283 	add.w	r2, r2, r3, lsl #2
 804e1b6:	f8d2 025c 	ldr.w	r0, [r2, #604]	; 0x25c
 804e1ba:	4a09      	ldr	r2, [pc, #36]	; (804e1e0 <setupModbus+0x4c>)
 804e1bc:	6a11      	ldr	r1, [r2, #32]
 804e1be:	4401      	add	r1, r0
 804e1c0:	6211      	str	r1, [r2, #32]
	for(temp = 0; temp < strMbClient.u32NoofRegConfigured ;temp++)
 804e1c2:	3301      	adds	r3, #1
 804e1c4:	6193      	str	r3, [r2, #24]
 804e1c6:	e7ef      	b.n	804e1a8 <setupModbus+0x14>
	strMbClient.u32MBNoQueryAttempts = 0;
 804e1c8:	4b03      	ldr	r3, [pc, #12]	; (804e1d8 <setupModbus+0x44>)
 804e1ca:	2200      	movs	r2, #0
 804e1cc:	609a      	str	r2, [r3, #8]
	strMbClient.u32UnitId = 1;
 804e1ce:	2201      	movs	r2, #1
 804e1d0:	60da      	str	r2, [r3, #12]
}
 804e1d2:	f85d 4b04 	ldr.w	r4, [sp], #4
 804e1d6:	4770      	bx	lr
 804e1d8:	2000e4c8 	.word	0x2000e4c8
 804e1dc:	20003658 	.word	0x20003658
 804e1e0:	20004800 	.word	0x20004800
 804e1e4:	200018f4 	.word	0x200018f4

0804e1e8 <updateModbusPayload>:
{
 804e1e8:	b570      	push	{r4, r5, r6, lr}
		value = strMbClient.u32SlaveData[RegisterCounter];    // Signed Integer
 804e1ea:	4a4a      	ldr	r2, [pc, #296]	; (804e314 <updateModbusPayload+0x12c>)
 804e1ec:	6a54      	ldr	r4, [r2, #36]	; 0x24
 804e1ee:	f104 0194 	add.w	r1, r4, #148	; 0x94
 804e1f2:	4b49      	ldr	r3, [pc, #292]	; (804e318 <updateModbusPayload+0x130>)
 804e1f4:	eb03 0381 	add.w	r3, r3, r1, lsl #2
 804e1f8:	685d      	ldr	r5, [r3, #4]
 804e1fa:	6295      	str	r5, [r2, #40]	; 0x28
		if(RegisterCounter == 0)
 804e1fc:	b354      	cbz	r4, 804e254 <updateModbusPayload+0x6c>
		if(RegisterCounter < (gu32MBDataByteCounterLimit))
 804e1fe:	4b45      	ldr	r3, [pc, #276]	; (804e314 <updateModbusPayload+0x12c>)
 804e200:	6a1b      	ldr	r3, [r3, #32]
 804e202:	429c      	cmp	r4, r3
 804e204:	d26a      	bcs.n	804e2dc <updateModbusPayload+0xf4>
			if(gu32MBTCPDataStatus[RegisterCounter] == 1)
 804e206:	4b43      	ldr	r3, [pc, #268]	; (804e314 <updateModbusPayload+0x12c>)
 804e208:	eb03 0484 	add.w	r4, r3, r4, lsl #2
 804e20c:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 804e20e:	2b01      	cmp	r3, #1
 804e210:	d027      	beq.n	804e262 <updateModbusPayload+0x7a>
			else if(gu32MBTCPDataStatus[RegisterCounter] == 2)
 804e212:	2b02      	cmp	r3, #2
 804e214:	d149      	bne.n	804e2aa <updateModbusPayload+0xc2>
				if(value < 0)
 804e216:	2d00      	cmp	r5, #0
 804e218:	db42      	blt.n	804e2a0 <updateModbusPayload+0xb8>
				memset(buffer, 0x00, (6 * sizeof(char)));
 804e21a:	4b3e      	ldr	r3, [pc, #248]	; (804e314 <updateModbusPayload+0x12c>)
 804e21c:	f203 45dc 	addw	r5, r3, #1244	; 0x4dc
 804e220:	2200      	movs	r2, #0
 804e222:	f8c3 24dc 	str.w	r2, [r3, #1244]	; 0x4dc
 804e226:	f8a3 24e0 	strh.w	r2, [r3, #1248]	; 0x4e0
				itoa(value,buffer,10);	   	   				  // decimal String
 804e22a:	220a      	movs	r2, #10
 804e22c:	4629      	mov	r1, r5
 804e22e:	6a98      	ldr	r0, [r3, #40]	; 0x28
 804e230:	f003 f986 	bl	8051540 <itoa>
				strcat(gau8MBPayloadString,buffer);
 804e234:	4c39      	ldr	r4, [pc, #228]	; (804e31c <updateModbusPayload+0x134>)
 804e236:	4629      	mov	r1, r5
 804e238:	4620      	mov	r0, r4
 804e23a:	f003 fc47 	bl	8051acc <strcat>
				strcat(gau8MBPayloadString,PAYLOAD_SEPARATOR);
 804e23e:	4620      	mov	r0, r4
 804e240:	f7f1 ffe0 	bl	8040204 <strlen>
 804e244:	4b36      	ldr	r3, [pc, #216]	; (804e320 <updateModbusPayload+0x138>)
 804e246:	881b      	ldrh	r3, [r3, #0]
 804e248:	5223      	strh	r3, [r4, r0]
			RegisterCounter++;
 804e24a:	4a32      	ldr	r2, [pc, #200]	; (804e314 <updateModbusPayload+0x12c>)
 804e24c:	6a53      	ldr	r3, [r2, #36]	; 0x24
 804e24e:	3301      	adds	r3, #1
 804e250:	6253      	str	r3, [r2, #36]	; 0x24
}
 804e252:	bd70      	pop	{r4, r5, r6, pc}
			memset(gau8MBPayloadString, 0x00, (1100 * sizeof(char)));
 804e254:	f240 424c 	movw	r2, #1100	; 0x44c
 804e258:	2100      	movs	r1, #0
 804e25a:	4830      	ldr	r0, [pc, #192]	; (804e31c <updateModbusPayload+0x134>)
 804e25c:	f003 fbe0 	bl	8051a20 <memset>
 804e260:	e7cd      	b.n	804e1fe <updateModbusPayload+0x16>
				strcat(gau8MBPayloadString,"E");
 804e262:	4c2e      	ldr	r4, [pc, #184]	; (804e31c <updateModbusPayload+0x134>)
 804e264:	4620      	mov	r0, r4
 804e266:	f7f1 ffcd 	bl	8040204 <strlen>
 804e26a:	4b2e      	ldr	r3, [pc, #184]	; (804e324 <updateModbusPayload+0x13c>)
 804e26c:	881b      	ldrh	r3, [r3, #0]
 804e26e:	5223      	strh	r3, [r4, r0]
				memset(buffer, 0x00, (6 * sizeof(char)));
 804e270:	4a28      	ldr	r2, [pc, #160]	; (804e314 <updateModbusPayload+0x12c>)
 804e272:	f202 46dc 	addw	r6, r2, #1244	; 0x4dc
 804e276:	2300      	movs	r3, #0
 804e278:	f8c2 34dc 	str.w	r3, [r2, #1244]	; 0x4dc
 804e27c:	f8a2 34e0 	strh.w	r3, [r2, #1248]	; 0x4e0
				itoa(value,buffer,MB_PAYLOAD_RADIX);	   	   				  // Decimal String
 804e280:	220a      	movs	r2, #10
 804e282:	4631      	mov	r1, r6
 804e284:	4628      	mov	r0, r5
 804e286:	f003 f95b 	bl	8051540 <itoa>
				strcat(gau8MBPayloadString,buffer);
 804e28a:	4631      	mov	r1, r6
 804e28c:	4620      	mov	r0, r4
 804e28e:	f003 fc1d 	bl	8051acc <strcat>
				strcat(gau8MBPayloadString,PAYLOAD_SEPARATOR);
 804e292:	4620      	mov	r0, r4
 804e294:	f7f1 ffb6 	bl	8040204 <strlen>
 804e298:	4b21      	ldr	r3, [pc, #132]	; (804e320 <updateModbusPayload+0x138>)
 804e29a:	881b      	ldrh	r3, [r3, #0]
 804e29c:	5223      	strh	r3, [r4, r0]
 804e29e:	e7d4      	b.n	804e24a <updateModbusPayload+0x62>
					value += 256;
 804e2a0:	f505 7580 	add.w	r5, r5, #256	; 0x100
 804e2a4:	4b1b      	ldr	r3, [pc, #108]	; (804e314 <updateModbusPayload+0x12c>)
 804e2a6:	629d      	str	r5, [r3, #40]	; 0x28
 804e2a8:	e7b7      	b.n	804e21a <updateModbusPayload+0x32>
				memset(buffer, 0x00, (6 * sizeof(char)));
 804e2aa:	4a1a      	ldr	r2, [pc, #104]	; (804e314 <updateModbusPayload+0x12c>)
 804e2ac:	f202 46dc 	addw	r6, r2, #1244	; 0x4dc
 804e2b0:	2300      	movs	r3, #0
 804e2b2:	f8c2 34dc 	str.w	r3, [r2, #1244]	; 0x4dc
 804e2b6:	f8a2 34e0 	strh.w	r3, [r2, #1248]	; 0x4e0
				itoa(value,buffer,MB_PAYLOAD_RADIX);	   	   			// Decimal String
 804e2ba:	220a      	movs	r2, #10
 804e2bc:	4631      	mov	r1, r6
 804e2be:	4628      	mov	r0, r5
 804e2c0:	f003 f93e 	bl	8051540 <itoa>
				strcat(gau8MBPayloadString,buffer);
 804e2c4:	4c15      	ldr	r4, [pc, #84]	; (804e31c <updateModbusPayload+0x134>)
 804e2c6:	4631      	mov	r1, r6
 804e2c8:	4620      	mov	r0, r4
 804e2ca:	f003 fbff 	bl	8051acc <strcat>
				strcat(gau8MBPayloadString,PAYLOAD_SEPARATOR);
 804e2ce:	4620      	mov	r0, r4
 804e2d0:	f7f1 ff98 	bl	8040204 <strlen>
 804e2d4:	4b12      	ldr	r3, [pc, #72]	; (804e320 <updateModbusPayload+0x138>)
 804e2d6:	881b      	ldrh	r3, [r3, #0]
 804e2d8:	5223      	strh	r3, [r4, r0]
 804e2da:	e7b6      	b.n	804e24a <updateModbusPayload+0x62>
			memcpy(gau8TempMBPayloadString,gau8MBPayloadString,sizeof(gau8MBPayloadString));
 804e2dc:	4812      	ldr	r0, [pc, #72]	; (804e328 <updateModbusPayload+0x140>)
 804e2de:	f500 7462 	add.w	r4, r0, #904	; 0x388
 804e2e2:	f240 454c 	movw	r5, #1100	; 0x44c
 804e2e6:	462a      	mov	r2, r5
 804e2e8:	4621      	mov	r1, r4
 804e2ea:	f200 70d4 	addw	r0, r0, #2004	; 0x7d4
 804e2ee:	f003 fb89 	bl	8051a04 <memcpy>
			memset(gau8MBPayloadString,0x00,1100 * sizeof(char));
 804e2f2:	462a      	mov	r2, r5
 804e2f4:	2100      	movs	r1, #0
 804e2f6:	4620      	mov	r0, r4
 804e2f8:	f003 fb92 	bl	8051a20 <memset>
			if(gu32MBProcessPayloadFlag)
 804e2fc:	4b05      	ldr	r3, [pc, #20]	; (804e314 <updateModbusPayload+0x12c>)
 804e2fe:	f8d3 34e4 	ldr.w	r3, [r3, #1252]	; 0x4e4
 804e302:	b11b      	cbz	r3, 804e30c <updateModbusPayload+0x124>
				gu32MBProcessPayloadFlag = 0;
 804e304:	4b03      	ldr	r3, [pc, #12]	; (804e314 <updateModbusPayload+0x12c>)
 804e306:	2200      	movs	r2, #0
 804e308:	f8c3 24e4 	str.w	r2, [r3, #1252]	; 0x4e4
			RegisterCounter = 0;
 804e30c:	4b01      	ldr	r3, [pc, #4]	; (804e314 <updateModbusPayload+0x12c>)
 804e30e:	2200      	movs	r2, #0
 804e310:	625a      	str	r2, [r3, #36]	; 0x24
}
 804e312:	e79e      	b.n	804e252 <updateModbusPayload+0x6a>
 804e314:	20004800 	.word	0x20004800
 804e318:	2000e4c8 	.word	0x2000e4c8
 804e31c:	20001c7c 	.word	0x20001c7c
 804e320:	0805a920 	.word	0x0805a920
 804e324:	0805a9d8 	.word	0x0805a9d8
 804e328:	200018f4 	.word	0x200018f4

0804e32c <tcp_modbusclient_connect>:
	if(gu32MBOperateFlag)
 804e32c:	4b22      	ldr	r3, [pc, #136]	; (804e3b8 <tcp_modbusclient_connect+0x8c>)
 804e32e:	691b      	ldr	r3, [r3, #16]
 804e330:	b103      	cbz	r3, 804e334 <tcp_modbusclient_connect+0x8>
 804e332:	4770      	bx	lr
{
 804e334:	b510      	push	{r4, lr}
 804e336:	b082      	sub	sp, #8
	  mbclient_pcb = tcp_new();
 804e338:	f7f8 ff72 	bl	8047220 <tcp_new>
 804e33c:	4b1e      	ldr	r3, [pc, #120]	; (804e3b8 <tcp_modbusclient_connect+0x8c>)
 804e33e:	f8c3 04e8 	str.w	r0, [r3, #1256]	; 0x4e8
	if (mbclient_pcb != NULL)
 804e342:	2800      	cmp	r0, #0
 804e344:	d032      	beq.n	804e3ac <tcp_modbusclient_connect+0x80>
	IP4_ADDR( &DestIPaddr, IP_ADDRESS_DESTI[0], IP_ADDRESS_DESTI[1], IP_ADDRESS_DESTI[2], IP_ADDRESS_DESTI[3]);
 804e346:	4a1d      	ldr	r2, [pc, #116]	; (804e3bc <tcp_modbusclient_connect+0x90>)
 804e348:	7811      	ldrb	r1, [r2, #0]
 804e34a:	7853      	ldrb	r3, [r2, #1]
 804e34c:	041b      	lsls	r3, r3, #16
 804e34e:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
 804e352:	7891      	ldrb	r1, [r2, #2]
 804e354:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 804e358:	78d1      	ldrb	r1, [r2, #3]
 804e35a:	430b      	orrs	r3, r1
 804e35c:	021a      	lsls	r2, r3, #8
 804e35e:	f402 027f 	and.w	r2, r2, #16711680	; 0xff0000
 804e362:	ea42 6201 	orr.w	r2, r2, r1, lsl #24
 804e366:	0a19      	lsrs	r1, r3, #8
 804e368:	f401 417f 	and.w	r1, r1, #65280	; 0xff00
 804e36c:	430a      	orrs	r2, r1
 804e36e:	ea42 6313 	orr.w	r3, r2, r3, lsr #24
 804e372:	9301      	str	r3, [sp, #4]
	  tcp_err(mbclient_pcb, tcp_modbusclient_error);
 804e374:	4912      	ldr	r1, [pc, #72]	; (804e3c0 <tcp_modbusclient_connect+0x94>)
 804e376:	f7f8 f9f5 	bl	8046764 <tcp_err>
	  tcp_bind(mbclient_pcb, IP_ADDR_ANY,8009);
 804e37a:	4c0f      	ldr	r4, [pc, #60]	; (804e3b8 <tcp_modbusclient_connect+0x8c>)
 804e37c:	f641 7249 	movw	r2, #8009	; 0x1f49
 804e380:	4910      	ldr	r1, [pc, #64]	; (804e3c4 <tcp_modbusclient_connect+0x98>)
 804e382:	f8d4 04e8 	ldr.w	r0, [r4, #1256]	; 0x4e8
 804e386:	f7f8 f8bf 	bl	8046508 <tcp_bind>
	  gu32MBClientConnectedFlag = 0;
 804e38a:	2300      	movs	r3, #0
 804e38c:	60a3      	str	r3, [r4, #8]
	  err = tcp_connect(mbclient_pcb,&DestIPaddr,gu32ModbusTCPPort,tcp_modbusclient_connected); //502
 804e38e:	4b0e      	ldr	r3, [pc, #56]	; (804e3c8 <tcp_modbusclient_connect+0x9c>)
 804e390:	4a0e      	ldr	r2, [pc, #56]	; (804e3cc <tcp_modbusclient_connect+0xa0>)
 804e392:	8812      	ldrh	r2, [r2, #0]
 804e394:	a901      	add	r1, sp, #4
 804e396:	f8d4 04e8 	ldr.w	r0, [r4, #1256]	; 0x4e8
 804e39a:	f7f8 ff63 	bl	8047264 <tcp_connect>
 804e39e:	f884 04ec 	strb.w	r0, [r4, #1260]	; 0x4ec
	  if(err != ERR_OK)
 804e3a2:	b928      	cbnz	r0, 804e3b0 <tcp_modbusclient_connect+0x84>
		gu32MBTCPTimer = THREE_SEC;
 804e3a4:	4b04      	ldr	r3, [pc, #16]	; (804e3b8 <tcp_modbusclient_connect+0x8c>)
 804e3a6:	f640 32b8 	movw	r2, #3000	; 0xbb8
 804e3aa:	61da      	str	r2, [r3, #28]
}
 804e3ac:	b002      	add	sp, #8
 804e3ae:	bd10      	pop	{r4, pc}
		Error_Handler();
 804e3b0:	f7ff fa54 	bl	804d85c <Error_Handler>
 804e3b4:	e7fa      	b.n	804e3ac <tcp_modbusclient_connect+0x80>
 804e3b6:	bf00      	nop
 804e3b8:	20004800 	.word	0x20004800
 804e3bc:	20003660 	.word	0x20003660
 804e3c0:	0804e761 	.word	0x0804e761
 804e3c4:	08058e58 	.word	0x08058e58
 804e3c8:	0804e0e1 	.word	0x0804e0e1
 804e3cc:	20003664 	.word	0x20003664

0804e3d0 <mbTCPPoll>:
	if( (gu32MBPOLLTimer != 0 ))//gu32EthLinkAlert == 1 gu32MBProcessPayloadFlag  ||
 804e3d0:	4bad      	ldr	r3, [pc, #692]	; (804e688 <mbTCPPoll+0x2b8>)
 804e3d2:	f8d3 34f0 	ldr.w	r3, [r3, #1264]	; 0x4f0
 804e3d6:	2b00      	cmp	r3, #0
 804e3d8:	f040 81b7 	bne.w	804e74a <mbTCPPoll+0x37a>
{
 804e3dc:	b570      	push	{r4, r5, r6, lr}
	switch(enmMBCurrentState)
 804e3de:	4aab      	ldr	r2, [pc, #684]	; (804e68c <mbTCPPoll+0x2bc>)
 804e3e0:	7812      	ldrb	r2, [r2, #0]
 804e3e2:	2a06      	cmp	r2, #6
 804e3e4:	f200 81ad 	bhi.w	804e742 <mbTCPPoll+0x372>
 804e3e8:	e8df f012 	tbh	[pc, r2, lsl #1]
 804e3ec:	000b0007 	.word	0x000b0007
 804e3f0:	00380030 	.word	0x00380030
 804e3f4:	015a0040 	.word	0x015a0040
 804e3f8:	019b      	.short	0x019b
			enmMBCurrentState = enmMB_CONNECTING;
 804e3fa:	4ba4      	ldr	r3, [pc, #656]	; (804e68c <mbTCPPoll+0x2bc>)
 804e3fc:	2201      	movs	r2, #1
 804e3fe:	701a      	strb	r2, [r3, #0]
}
 804e400:	bd70      	pop	{r4, r5, r6, pc}
			if(gu32MBConnected == 0)
 804e402:	4ba1      	ldr	r3, [pc, #644]	; (804e688 <mbTCPPoll+0x2b8>)
 804e404:	68db      	ldr	r3, [r3, #12]
 804e406:	b92b      	cbnz	r3, 804e414 <mbTCPPoll+0x44>
				tcp_modbusclient_connect();
 804e408:	f7ff ff90 	bl	804e32c <tcp_modbusclient_connect>
			enmMBCurrentState = enmMB_CONNECTED;
 804e40c:	4b9f      	ldr	r3, [pc, #636]	; (804e68c <mbTCPPoll+0x2bc>)
 804e40e:	2202      	movs	r2, #2
 804e410:	701a      	strb	r2, [r3, #0]
		break;
 804e412:	e7f5      	b.n	804e400 <mbTCPPoll+0x30>
				updateModbusQueryFrame();
 804e414:	f7ff fe1e 	bl	804e054 <updateModbusQueryFrame>
				esTx->p_tx = pbuf_alloc(PBUF_TRANSPORT, 12 , PBUF_POOL);
 804e418:	4c9b      	ldr	r4, [pc, #620]	; (804e688 <mbTCPPoll+0x2b8>)
 804e41a:	6825      	ldr	r5, [r4, #0]
 804e41c:	2203      	movs	r2, #3
 804e41e:	210c      	movs	r1, #12
 804e420:	2000      	movs	r0, #0
 804e422:	f7f7 fcbf 	bl	8045da4 <pbuf_alloc>
 804e426:	60a8      	str	r0, [r5, #8]
				pbuf_take(esTx->p_tx, (char*)strMbClient.u32QueryFrame, 12);
 804e428:	6823      	ldr	r3, [r4, #0]
 804e42a:	220c      	movs	r2, #12
 804e42c:	4998      	ldr	r1, [pc, #608]	; (804e690 <mbTCPPoll+0x2c0>)
 804e42e:	6898      	ldr	r0, [r3, #8]
 804e430:	f7f7 ff5c 	bl	80462ec <pbuf_take>
				tcp_modbusclient_send(pcbTx, esTx);
 804e434:	6821      	ldr	r1, [r4, #0]
 804e436:	6860      	ldr	r0, [r4, #4]
 804e438:	f7ff fd50 	bl	804dedc <tcp_modbusclient_send>
				pbuf_free(esTx->p_tx);
 804e43c:	6823      	ldr	r3, [r4, #0]
 804e43e:	6898      	ldr	r0, [r3, #8]
 804e440:	f7f7 fc4c 	bl	8045cdc <pbuf_free>
				gu32MBTCPTimer = THREE_SEC;
 804e444:	f640 33b8 	movw	r3, #3000	; 0xbb8
 804e448:	61e3      	str	r3, [r4, #28]
 804e44a:	e7df      	b.n	804e40c <mbTCPPoll+0x3c>
			if(gu32MBTCPTimer == 0)
 804e44c:	4b8e      	ldr	r3, [pc, #568]	; (804e688 <mbTCPPoll+0x2b8>)
 804e44e:	69db      	ldr	r3, [r3, #28]
 804e450:	2b00      	cmp	r3, #0
 804e452:	d1d5      	bne.n	804e400 <mbTCPPoll+0x30>
				enmMBCurrentState = enmMB_RESPONSETIMEOUT;
 804e454:	4b8d      	ldr	r3, [pc, #564]	; (804e68c <mbTCPPoll+0x2bc>)
 804e456:	2205      	movs	r2, #5
 804e458:	701a      	strb	r2, [r3, #0]
 804e45a:	e7d1      	b.n	804e400 <mbTCPPoll+0x30>
			 if(gu32MBTCPTimer == 0)
 804e45c:	4b8a      	ldr	r3, [pc, #552]	; (804e688 <mbTCPPoll+0x2b8>)
 804e45e:	69db      	ldr	r3, [r3, #28]
 804e460:	2b00      	cmp	r3, #0
 804e462:	d1cd      	bne.n	804e400 <mbTCPPoll+0x30>
				enmMBCurrentState = enmMB_RESPONSETIMEOUT;
 804e464:	4b89      	ldr	r3, [pc, #548]	; (804e68c <mbTCPPoll+0x2bc>)
 804e466:	2205      	movs	r2, #5
 804e468:	701a      	strb	r2, [r3, #0]
 804e46a:	e7c9      	b.n	804e400 <mbTCPPoll+0x30>
			if(gu32MBOperateFlag)
 804e46c:	4a86      	ldr	r2, [pc, #536]	; (804e688 <mbTCPPoll+0x2b8>)
 804e46e:	6912      	ldr	r2, [r2, #16]
 804e470:	2a00      	cmp	r2, #0
 804e472:	d0c5      	beq.n	804e400 <mbTCPPoll+0x30>
				if((((uint16_t)strMbClient.s8SlaveResponseArray[0] << 8) + strMbClient.s8SlaveResponseArray[1])
 804e474:	4887      	ldr	r0, [pc, #540]	; (804e694 <mbTCPPoll+0x2c4>)
 804e476:	f990 20f4 	ldrsb.w	r2, [r0, #244]	; 0xf4
 804e47a:	b291      	uxth	r1, r2
 804e47c:	f990 20f5 	ldrsb.w	r2, [r0, #245]	; 0xf5
 804e480:	eb02 2201 	add.w	r2, r2, r1, lsl #8
 804e484:	2a03      	cmp	r2, #3
 804e486:	d021      	beq.n	804e4cc <mbTCPPoll+0xfc>
				gu32MBOperateFlag = 0;
 804e488:	4b7f      	ldr	r3, [pc, #508]	; (804e688 <mbTCPPoll+0x2b8>)
 804e48a:	2200      	movs	r2, #0
 804e48c:	611a      	str	r2, [r3, #16]
				enmMBCurrentState = enmMB_CONNECTING;
 804e48e:	4a7f      	ldr	r2, [pc, #508]	; (804e68c <mbTCPPoll+0x2bc>)
 804e490:	2101      	movs	r1, #1
 804e492:	7011      	strb	r1, [r2, #0]
				message_count++;
 804e494:	695a      	ldr	r2, [r3, #20]
 804e496:	440a      	add	r2, r1
 804e498:	615a      	str	r2, [r3, #20]
				if(message_count >= strMbClient.u32NoofRegConfigured)
 804e49a:	4a7e      	ldr	r2, [pc, #504]	; (804e694 <mbTCPPoll+0x2c4>)
 804e49c:	f8d2 2668 	ldr.w	r2, [r2, #1640]	; 0x668
 804e4a0:	695b      	ldr	r3, [r3, #20]
 804e4a2:	429a      	cmp	r2, r3
 804e4a4:	d806      	bhi.n	804e4b4 <mbTCPPoll+0xe4>
					message_count = 0;
 804e4a6:	4b78      	ldr	r3, [pc, #480]	; (804e688 <mbTCPPoll+0x2b8>)
 804e4a8:	2200      	movs	r2, #0
 804e4aa:	615a      	str	r2, [r3, #20]
					gu32MBProcessPayloadFlag = 1;
 804e4ac:	f8c3 14e4 	str.w	r1, [r3, #1252]	; 0x4e4
					gu32MBDataByteCounter = 0;
 804e4b0:	f8c3 24fc 	str.w	r2, [r3, #1276]	; 0x4fc
				gu32MBPOLLTimer = gu32ModbusTCPPollingTime;
 804e4b4:	4b78      	ldr	r3, [pc, #480]	; (804e698 <mbTCPPoll+0x2c8>)
 804e4b6:	681a      	ldr	r2, [r3, #0]
 804e4b8:	4b73      	ldr	r3, [pc, #460]	; (804e688 <mbTCPPoll+0x2b8>)
 804e4ba:	f8c3 24f0 	str.w	r2, [r3, #1264]	; 0x4f0
				memset(strMbClient.s8SlaveResponseArray,0x00,sizeof(strMbClient.s8SlaveResponseArray));
 804e4be:	f44f 72af 	mov.w	r2, #350	; 0x15e
 804e4c2:	2100      	movs	r1, #0
 804e4c4:	4875      	ldr	r0, [pc, #468]	; (804e69c <mbTCPPoll+0x2cc>)
 804e4c6:	f003 faab 	bl	8051a20 <memset>
 804e4ca:	e799      	b.n	804e400 <mbTCPPoll+0x30>
					if((((uint16_t)strMbClient.s8SlaveResponseArray[2] << 8) + strMbClient.s8SlaveResponseArray[3])
 804e4cc:	f990 20f6 	ldrsb.w	r2, [r0, #246]	; 0xf6
 804e4d0:	b291      	uxth	r1, r2
 804e4d2:	f990 20f7 	ldrsb.w	r2, [r0, #247]	; 0xf7
 804e4d6:	eb02 2201 	add.w	r2, r2, r1, lsl #8
 804e4da:	2a00      	cmp	r2, #0
 804e4dc:	d1d4      	bne.n	804e488 <mbTCPPoll+0xb8>
						gu32PayloadLength = ((uint32_t)strMbClient.s8SlaveResponseArray[4] << 8)
 804e4de:	4602      	mov	r2, r0
 804e4e0:	f990 00f8 	ldrsb.w	r0, [r0, #248]	; 0xf8
								+ strMbClient.s8SlaveResponseArray[5];
 804e4e4:	f992 10f9 	ldrsb.w	r1, [r2, #249]	; 0xf9
 804e4e8:	eb01 2100 	add.w	r1, r1, r0, lsl #8
						gu32PayloadLength = ((uint32_t)strMbClient.s8SlaveResponseArray[4] << 8)
 804e4ec:	4866      	ldr	r0, [pc, #408]	; (804e688 <mbTCPPoll+0x2b8>)
 804e4ee:	f8c0 14f4 	str.w	r1, [r0, #1268]	; 0x4f4
						if(strMbClient.s8SlaveResponseArray[6] == strMbClient.u32UnitId)
 804e4f2:	f992 10fa 	ldrsb.w	r1, [r2, #250]	; 0xfa
 804e4f6:	68d2      	ldr	r2, [r2, #12]
 804e4f8:	4291      	cmp	r1, r2
 804e4fa:	d1c5      	bne.n	804e488 <mbTCPPoll+0xb8>
							if(strMbClient.s8SlaveResponseArray[7] == gu32MBTCPClientFuncCode[message_count])
 804e4fc:	4a65      	ldr	r2, [pc, #404]	; (804e694 <mbTCPPoll+0x2c4>)
 804e4fe:	f992 10fb 	ldrsb.w	r1, [r2, #251]	; 0xfb
 804e502:	6940      	ldr	r0, [r0, #20]
 804e504:	4a61      	ldr	r2, [pc, #388]	; (804e68c <mbTCPPoll+0x2bc>)
 804e506:	eb02 0280 	add.w	r2, r2, r0, lsl #2
 804e50a:	6852      	ldr	r2, [r2, #4]
 804e50c:	4291      	cmp	r1, r2
 804e50e:	d002      	beq.n	804e516 <mbTCPPoll+0x146>
							else if((strMbClient.s8SlaveResponseArray[7] & 0x80 ) == 0x80)
 804e510:	2900      	cmp	r1, #0
 804e512:	dab9      	bge.n	804e488 <mbTCPPoll+0xb8>
 804e514:	e0ad      	b.n	804e672 <mbTCPPoll+0x2a2>
								gu32MBDataLengthBytes = ((uint8_t)strMbClient.s8SlaveResponseArray[8]);
 804e516:	4a5f      	ldr	r2, [pc, #380]	; (804e694 <mbTCPPoll+0x2c4>)
 804e518:	f892 50fc 	ldrb.w	r5, [r2, #252]	; 0xfc
 804e51c:	4a5a      	ldr	r2, [pc, #360]	; (804e688 <mbTCPPoll+0x2b8>)
 804e51e:	f8c2 54f8 	str.w	r5, [r2, #1272]	; 0x4f8
								if(strMbClient.s8SlaveResponseArray[7] == 1)
 804e522:	2901      	cmp	r1, #1
 804e524:	d02c      	beq.n	804e580 <mbTCPPoll+0x1b0>
									if(gu32MBDataLengthBytes == (2 * gu32MBTCPClientNoofPoints[message_count]))
 804e526:	4a58      	ldr	r2, [pc, #352]	; (804e688 <mbTCPPoll+0x2b8>)
 804e528:	6951      	ldr	r1, [r2, #20]
 804e52a:	4a58      	ldr	r2, [pc, #352]	; (804e68c <mbTCPPoll+0x2bc>)
 804e52c:	eb02 0281 	add.w	r2, r2, r1, lsl #2
 804e530:	f8d2 225c 	ldr.w	r2, [r2, #604]	; 0x25c
 804e534:	ebb5 0f42 	cmp.w	r5, r2, lsl #1
 804e538:	d052      	beq.n	804e5e0 <mbTCPPoll+0x210>
										gu32MBDataByteCounter += gu32MBTCPClientNoofPoints[message_count];
 804e53a:	4b53      	ldr	r3, [pc, #332]	; (804e688 <mbTCPPoll+0x2b8>)
 804e53c:	6959      	ldr	r1, [r3, #20]
 804e53e:	4a53      	ldr	r2, [pc, #332]	; (804e68c <mbTCPPoll+0x2bc>)
 804e540:	eb02 0281 	add.w	r2, r2, r1, lsl #2
 804e544:	f8d2 125c 	ldr.w	r1, [r2, #604]	; 0x25c
 804e548:	f8d3 24fc 	ldr.w	r2, [r3, #1276]	; 0x4fc
 804e54c:	440a      	add	r2, r1
 804e54e:	f8c3 24fc 	str.w	r2, [r3, #1276]	; 0x4fc
 804e552:	e799      	b.n	804e488 <mbTCPPoll+0xb8>
										strMbClient.u32SlaveData[gu32MBDataByteCounter] = strMbClient.s8SlaveResponseArray[9 + LoopCounter];
 804e554:	f103 0409 	add.w	r4, r3, #9
 804e558:	4a4b      	ldr	r2, [pc, #300]	; (804e688 <mbTCPPoll+0x2b8>)
 804e55a:	f8d2 04fc 	ldr.w	r0, [r2, #1276]	; 0x4fc
 804e55e:	494d      	ldr	r1, [pc, #308]	; (804e694 <mbTCPPoll+0x2c4>)
 804e560:	440c      	add	r4, r1
 804e562:	f994 40f4 	ldrsb.w	r4, [r4, #244]	; 0xf4
 804e566:	f100 0694 	add.w	r6, r0, #148	; 0x94
 804e56a:	eb01 0186 	add.w	r1, r1, r6, lsl #2
 804e56e:	604c      	str	r4, [r1, #4]
										gu32MBTCPDataStatus[gu32MBDataByteCounter++] = 2;
 804e570:	1c41      	adds	r1, r0, #1
 804e572:	f8c2 14fc 	str.w	r1, [r2, #1276]	; 0x4fc
 804e576:	eb02 0280 	add.w	r2, r2, r0, lsl #2
 804e57a:	2102      	movs	r1, #2
 804e57c:	62d1      	str	r1, [r2, #44]	; 0x2c
									for(LoopCounter = 0; LoopCounter < gu32MBDataLengthBytes; LoopCounter++)
 804e57e:	3301      	adds	r3, #1
 804e580:	429d      	cmp	r5, r3
 804e582:	d8e7      	bhi.n	804e554 <mbTCPPoll+0x184>
									if(gu32MBDataLengthBytes != gu32MBTCPClientNoofPoints[message_count])
 804e584:	4b40      	ldr	r3, [pc, #256]	; (804e688 <mbTCPPoll+0x2b8>)
 804e586:	695a      	ldr	r2, [r3, #20]
 804e588:	4b40      	ldr	r3, [pc, #256]	; (804e68c <mbTCPPoll+0x2bc>)
 804e58a:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 804e58e:	f8d3 325c 	ldr.w	r3, [r3, #604]	; 0x25c
 804e592:	429d      	cmp	r5, r3
 804e594:	f43f af78 	beq.w	804e488 <mbTCPPoll+0xb8>
										gu32MBDataByteCounter += (gu32MBTCPClientNoofPoints[message_count] - gu32MBDataLengthBytes);
 804e598:	4b3b      	ldr	r3, [pc, #236]	; (804e688 <mbTCPPoll+0x2b8>)
 804e59a:	6959      	ldr	r1, [r3, #20]
 804e59c:	4a3b      	ldr	r2, [pc, #236]	; (804e68c <mbTCPPoll+0x2bc>)
 804e59e:	eb02 0281 	add.w	r2, r2, r1, lsl #2
 804e5a2:	f8d2 225c 	ldr.w	r2, [r2, #604]	; 0x25c
 804e5a6:	1b55      	subs	r5, r2, r5
 804e5a8:	f8d3 24fc 	ldr.w	r2, [r3, #1276]	; 0x4fc
 804e5ac:	442a      	add	r2, r5
 804e5ae:	f8c3 24fc 	str.w	r2, [r3, #1276]	; 0x4fc
 804e5b2:	e769      	b.n	804e488 <mbTCPPoll+0xb8>
												strMbClient.u32SlaveData[gu32MBDataByteCounter] = ((int16_t)strMbClient.s8SlaveResponseArray[9 + (2* u32LoopCounter)] << 8)
 804e5b4:	0058      	lsls	r0, r3, #1
 804e5b6:	3009      	adds	r0, #9
 804e5b8:	4936      	ldr	r1, [pc, #216]	; (804e694 <mbTCPPoll+0x2c4>)
 804e5ba:	4408      	add	r0, r1
 804e5bc:	f990 00f4 	ldrsb.w	r0, [r0, #244]	; 0xf4
																								 + (int16_t)strMbClient.s8SlaveResponseArray[9 + (2 * u32LoopCounter) + 1] + 256 ;
 804e5c0:	440a      	add	r2, r1
 804e5c2:	f992 20f4 	ldrsb.w	r2, [r2, #244]	; 0xf4
 804e5c6:	eb02 2200 	add.w	r2, r2, r0, lsl #8
												strMbClient.u32SlaveData[gu32MBDataByteCounter] = ((int16_t)strMbClient.s8SlaveResponseArray[9 + (2* u32LoopCounter)] << 8)
 804e5ca:	482f      	ldr	r0, [pc, #188]	; (804e688 <mbTCPPoll+0x2b8>)
 804e5cc:	f8d0 04fc 	ldr.w	r0, [r0, #1276]	; 0x4fc
																								 + (int16_t)strMbClient.s8SlaveResponseArray[9 + (2 * u32LoopCounter) + 1] + 256 ;
 804e5d0:	f502 7280 	add.w	r2, r2, #256	; 0x100
												strMbClient.u32SlaveData[gu32MBDataByteCounter] = ((int16_t)strMbClient.s8SlaveResponseArray[9 + (2* u32LoopCounter)] << 8)
 804e5d4:	3094      	adds	r0, #148	; 0x94
 804e5d6:	eb01 0180 	add.w	r1, r1, r0, lsl #2
 804e5da:	604a      	str	r2, [r1, #4]
 804e5dc:	e025      	b.n	804e62a <mbTCPPoll+0x25a>
										for(u32LoopCounter = 0; u32LoopCounter < gu32MBTCPClientNoofPoints[message_count];u32LoopCounter++)
 804e5de:	3301      	adds	r3, #1
 804e5e0:	4a29      	ldr	r2, [pc, #164]	; (804e688 <mbTCPPoll+0x2b8>)
 804e5e2:	6951      	ldr	r1, [r2, #20]
 804e5e4:	4a29      	ldr	r2, [pc, #164]	; (804e68c <mbTCPPoll+0x2bc>)
 804e5e6:	eb02 0281 	add.w	r2, r2, r1, lsl #2
 804e5ea:	f8d2 225c 	ldr.w	r2, [r2, #604]	; 0x25c
 804e5ee:	429a      	cmp	r2, r3
 804e5f0:	f67f af4a 	bls.w	804e488 <mbTCPPoll+0xb8>
											if((int32_t)strMbClient.s8SlaveResponseArray[9 + (2 * u32LoopCounter) + 1] < 0)
 804e5f4:	1d58      	adds	r0, r3, #5
 804e5f6:	0042      	lsls	r2, r0, #1
 804e5f8:	4926      	ldr	r1, [pc, #152]	; (804e694 <mbTCPPoll+0x2c4>)
 804e5fa:	eb01 0140 	add.w	r1, r1, r0, lsl #1
 804e5fe:	f991 10f4 	ldrsb.w	r1, [r1, #244]	; 0xf4
 804e602:	2900      	cmp	r1, #0
 804e604:	dbd6      	blt.n	804e5b4 <mbTCPPoll+0x1e4>
												strMbClient.u32SlaveData[gu32MBDataByteCounter] = ((int16_t)strMbClient.s8SlaveResponseArray[9 + (2* u32LoopCounter)] << 8)
 804e606:	0058      	lsls	r0, r3, #1
 804e608:	3009      	adds	r0, #9
 804e60a:	4922      	ldr	r1, [pc, #136]	; (804e694 <mbTCPPoll+0x2c4>)
 804e60c:	4408      	add	r0, r1
 804e60e:	f990 40f4 	ldrsb.w	r4, [r0, #244]	; 0xf4
																								 + (int16_t)strMbClient.s8SlaveResponseArray[9 + (2 * u32LoopCounter) + 1] ;
 804e612:	440a      	add	r2, r1
 804e614:	f992 20f4 	ldrsb.w	r2, [r2, #244]	; 0xf4
												strMbClient.u32SlaveData[gu32MBDataByteCounter] = ((int16_t)strMbClient.s8SlaveResponseArray[9 + (2* u32LoopCounter)] << 8)
 804e618:	481b      	ldr	r0, [pc, #108]	; (804e688 <mbTCPPoll+0x2b8>)
 804e61a:	f8d0 04fc 	ldr.w	r0, [r0, #1276]	; 0x4fc
																								 + (int16_t)strMbClient.s8SlaveResponseArray[9 + (2 * u32LoopCounter) + 1] ;
 804e61e:	eb02 2204 	add.w	r2, r2, r4, lsl #8
												strMbClient.u32SlaveData[gu32MBDataByteCounter] = ((int16_t)strMbClient.s8SlaveResponseArray[9 + (2* u32LoopCounter)] << 8)
 804e622:	3094      	adds	r0, #148	; 0x94
 804e624:	eb01 0180 	add.w	r1, r1, r0, lsl #2
 804e628:	604a      	str	r2, [r1, #4]
											gu32MBTCPDataStatus[gu32MBDataByteCounter] = 0;
 804e62a:	4917      	ldr	r1, [pc, #92]	; (804e688 <mbTCPPoll+0x2b8>)
 804e62c:	f8d1 24fc 	ldr.w	r2, [r1, #1276]	; 0x4fc
 804e630:	eb01 0082 	add.w	r0, r1, r2, lsl #2
 804e634:	2400      	movs	r4, #0
 804e636:	62c4      	str	r4, [r0, #44]	; 0x2c
											gu32MBDataByteCounter++;
 804e638:	3201      	adds	r2, #1
 804e63a:	f8c1 24fc 	str.w	r2, [r1, #1276]	; 0x4fc
											if(gu32MBDataByteCounter >= gu32MBDataByteCounterLimit)
 804e63e:	6a09      	ldr	r1, [r1, #32]
 804e640:	428a      	cmp	r2, r1
 804e642:	d3cc      	bcc.n	804e5de <mbTCPPoll+0x20e>
												gu32MBDataByteCounter = 0;
 804e644:	4a10      	ldr	r2, [pc, #64]	; (804e688 <mbTCPPoll+0x2b8>)
 804e646:	f8c2 44fc 	str.w	r4, [r2, #1276]	; 0x4fc
 804e64a:	e7c8      	b.n	804e5de <mbTCPPoll+0x20e>
									strMbClient.u32SlaveData[gu32MBDataByteCounter] = strMbClient.s8SlaveResponseArray[8] ;
 804e64c:	4a0e      	ldr	r2, [pc, #56]	; (804e688 <mbTCPPoll+0x2b8>)
 804e64e:	f8d2 04fc 	ldr.w	r0, [r2, #1276]	; 0x4fc
 804e652:	4910      	ldr	r1, [pc, #64]	; (804e694 <mbTCPPoll+0x2c4>)
 804e654:	f991 40fc 	ldrsb.w	r4, [r1, #252]	; 0xfc
 804e658:	f100 0594 	add.w	r5, r0, #148	; 0x94
 804e65c:	eb01 0185 	add.w	r1, r1, r5, lsl #2
 804e660:	604c      	str	r4, [r1, #4]
									gu32MBTCPDataStatus[gu32MBDataByteCounter++] = 1;
 804e662:	1c41      	adds	r1, r0, #1
 804e664:	f8c2 14fc 	str.w	r1, [r2, #1276]	; 0x4fc
 804e668:	eb02 0280 	add.w	r2, r2, r0, lsl #2
 804e66c:	2101      	movs	r1, #1
 804e66e:	62d1      	str	r1, [r2, #44]	; 0x2c
								for(u32TempLoopCounter = 0; u32TempLoopCounter < gu32MBTCPClientNoofPoints[message_count];u32TempLoopCounter++)
 804e670:	440b      	add	r3, r1
 804e672:	4a05      	ldr	r2, [pc, #20]	; (804e688 <mbTCPPoll+0x2b8>)
 804e674:	6951      	ldr	r1, [r2, #20]
 804e676:	4a05      	ldr	r2, [pc, #20]	; (804e68c <mbTCPPoll+0x2bc>)
 804e678:	eb02 0281 	add.w	r2, r2, r1, lsl #2
 804e67c:	f8d2 225c 	ldr.w	r2, [r2, #604]	; 0x25c
 804e680:	429a      	cmp	r2, r3
 804e682:	d8e3      	bhi.n	804e64c <mbTCPPoll+0x27c>
 804e684:	e700      	b.n	804e488 <mbTCPPoll+0xb8>
 804e686:	bf00      	nop
 804e688:	20004800 	.word	0x20004800
 804e68c:	200018f4 	.word	0x200018f4
 804e690:	2000e4e8 	.word	0x2000e4e8
 804e694:	2000e4c8 	.word	0x2000e4c8
 804e698:	20002a60 	.word	0x20002a60
 804e69c:	2000e5bc 	.word	0x2000e5bc
			strMbClient.u32MBNoQueryAttempts++;
 804e6a0:	4a2a      	ldr	r2, [pc, #168]	; (804e74c <mbTCPPoll+0x37c>)
 804e6a2:	6893      	ldr	r3, [r2, #8]
 804e6a4:	3301      	adds	r3, #1
 804e6a6:	6093      	str	r3, [r2, #8]
			if(strMbClient.u32MBNoQueryAttempts > 3)
 804e6a8:	2b03      	cmp	r3, #3
 804e6aa:	d930      	bls.n	804e70e <mbTCPPoll+0x33e>
				uint32_t temploopcounttcp = gu32MBDataByteCounter;
 804e6ac:	4a28      	ldr	r2, [pc, #160]	; (804e750 <mbTCPPoll+0x380>)
 804e6ae:	f8d2 34fc 	ldr.w	r3, [r2, #1276]	; 0x4fc
				gu32MBDataByteCounter += gu32MBTCPClientNoofPoints[message_count];
 804e6b2:	6950      	ldr	r0, [r2, #20]
 804e6b4:	4927      	ldr	r1, [pc, #156]	; (804e754 <mbTCPPoll+0x384>)
 804e6b6:	eb01 0180 	add.w	r1, r1, r0, lsl #2
 804e6ba:	f8d1 025c 	ldr.w	r0, [r1, #604]	; 0x25c
 804e6be:	4418      	add	r0, r3
 804e6c0:	f8c2 04fc 	str.w	r0, [r2, #1276]	; 0x4fc
				for(iteratortcp = temploopcounttcp ; iteratortcp < gu32MBDataByteCounter ; iteratortcp++)
 804e6c4:	4298      	cmp	r0, r3
 804e6c6:	d908      	bls.n	804e6da <mbTCPPoll+0x30a>
					strMbClient.u32SlaveData[iteratortcp] = 0;
 804e6c8:	f103 0194 	add.w	r1, r3, #148	; 0x94
 804e6cc:	4a1f      	ldr	r2, [pc, #124]	; (804e74c <mbTCPPoll+0x37c>)
 804e6ce:	eb02 0281 	add.w	r2, r2, r1, lsl #2
 804e6d2:	2100      	movs	r1, #0
 804e6d4:	6051      	str	r1, [r2, #4]
				for(iteratortcp = temploopcounttcp ; iteratortcp < gu32MBDataByteCounter ; iteratortcp++)
 804e6d6:	3301      	adds	r3, #1
 804e6d8:	e7f4      	b.n	804e6c4 <mbTCPPoll+0x2f4>
				strMbClient.u32MBNoQueryAttempts = 0;
 804e6da:	491c      	ldr	r1, [pc, #112]	; (804e74c <mbTCPPoll+0x37c>)
 804e6dc:	2300      	movs	r3, #0
 804e6de:	608b      	str	r3, [r1, #8]
				message_count++;
 804e6e0:	4b1b      	ldr	r3, [pc, #108]	; (804e750 <mbTCPPoll+0x380>)
 804e6e2:	695a      	ldr	r2, [r3, #20]
 804e6e4:	3201      	adds	r2, #1
 804e6e6:	615a      	str	r2, [r3, #20]
				if(message_count >= strMbClient.u32NoofRegConfigured)
 804e6e8:	f8d1 2668 	ldr.w	r2, [r1, #1640]	; 0x668
 804e6ec:	695b      	ldr	r3, [r3, #20]
 804e6ee:	429a      	cmp	r2, r3
 804e6f0:	d80d      	bhi.n	804e70e <mbTCPPoll+0x33e>
					message_count = 0;
 804e6f2:	4b17      	ldr	r3, [pc, #92]	; (804e750 <mbTCPPoll+0x380>)
 804e6f4:	2200      	movs	r2, #0
 804e6f6:	615a      	str	r2, [r3, #20]
					gu32MBProcessPayloadFlag = 1;
 804e6f8:	2101      	movs	r1, #1
 804e6fa:	f8c3 14e4 	str.w	r1, [r3, #1252]	; 0x4e4
					gu32MBNotResponding++;
 804e6fe:	f8d3 1500 	ldr.w	r1, [r3, #1280]	; 0x500
 804e702:	3101      	adds	r1, #1
 804e704:	f8c3 1500 	str.w	r1, [r3, #1280]	; 0x500
					gu32MBDataByteCounter = 0;
 804e708:	f8c3 24fc 	str.w	r2, [r3, #1276]	; 0x4fc
					gu32MBClientConnectedFlag = 0;
 804e70c:	609a      	str	r2, [r3, #8]
			enmMBCurrentState = enmMB_CLOSECLIENT;
 804e70e:	4b11      	ldr	r3, [pc, #68]	; (804e754 <mbTCPPoll+0x384>)
 804e710:	2206      	movs	r2, #6
 804e712:	701a      	strb	r2, [r3, #0]
			memset(strMbClient.s8SlaveResponseArray,0x00,sizeof(strMbClient.s8SlaveResponseArray));
 804e714:	f44f 72af 	mov.w	r2, #350	; 0x15e
 804e718:	2100      	movs	r1, #0
 804e71a:	480f      	ldr	r0, [pc, #60]	; (804e758 <mbTCPPoll+0x388>)
 804e71c:	f003 f980 	bl	8051a20 <memset>
			break;
 804e720:	e66e      	b.n	804e400 <mbTCPPoll+0x30>
			gu32MBConnected = 0;
 804e722:	4c0b      	ldr	r4, [pc, #44]	; (804e750 <mbTCPPoll+0x380>)
 804e724:	2500      	movs	r5, #0
 804e726:	60e5      	str	r5, [r4, #12]
			tcp_modbusclient_connection_close(pcbTx, esTx);
 804e728:	6821      	ldr	r1, [r4, #0]
 804e72a:	6860      	ldr	r0, [r4, #4]
 804e72c:	f7ff fc04 	bl	804df38 <tcp_modbusclient_connection_close>
			enmMBCurrentState = enmMB_CONNECTING;
 804e730:	4b08      	ldr	r3, [pc, #32]	; (804e754 <mbTCPPoll+0x384>)
 804e732:	2201      	movs	r2, #1
 804e734:	701a      	strb	r2, [r3, #0]
			gu32MBOperateFlag = 0;
 804e736:	6125      	str	r5, [r4, #16]
			gu32MBPOLLTimer = gu32ModbusTCPPollingTime;
 804e738:	4b08      	ldr	r3, [pc, #32]	; (804e75c <mbTCPPoll+0x38c>)
 804e73a:	681b      	ldr	r3, [r3, #0]
 804e73c:	f8c4 34f0 	str.w	r3, [r4, #1264]	; 0x4f0
			break;
 804e740:	e65e      	b.n	804e400 <mbTCPPoll+0x30>
			enmMBCurrentState = enmMB_CONNECTING;
 804e742:	4b04      	ldr	r3, [pc, #16]	; (804e754 <mbTCPPoll+0x384>)
 804e744:	2201      	movs	r2, #1
 804e746:	701a      	strb	r2, [r3, #0]
		break;
 804e748:	e65a      	b.n	804e400 <mbTCPPoll+0x30>
 804e74a:	4770      	bx	lr
 804e74c:	2000e4c8 	.word	0x2000e4c8
 804e750:	20004800 	.word	0x20004800
 804e754:	200018f4 	.word	0x200018f4
 804e758:	2000e5bc 	.word	0x2000e5bc
 804e75c:	20002a60 	.word	0x20002a60

0804e760 <tcp_modbusclient_error>:
{
 804e760:	b510      	push	{r4, lr}
	if(mbclient_pcb != NULL)
 804e762:	4b08      	ldr	r3, [pc, #32]	; (804e784 <tcp_modbusclient_error+0x24>)
 804e764:	f8d3 04e8 	ldr.w	r0, [r3, #1256]	; 0x4e8
 804e768:	b108      	cbz	r0, 804e76e <tcp_modbusclient_error+0xe>
		mem_free(mbclient_pcb);
 804e76a:	f7f6 ff27 	bl	80455bc <mem_free>
	tcp_close(mbclient_pcb);
 804e76e:	4c05      	ldr	r4, [pc, #20]	; (804e784 <tcp_modbusclient_error+0x24>)
 804e770:	f8d4 04e8 	ldr.w	r0, [r4, #1256]	; 0x4e8
 804e774:	f7f8 fb4c 	bl	8046e10 <tcp_close>
	tcp_modbusclient_connect();
 804e778:	f7ff fdd8 	bl	804e32c <tcp_modbusclient_connect>
	gu32MBClientConnectedFlag = 0;
 804e77c:	2300      	movs	r3, #0
 804e77e:	60a3      	str	r3, [r4, #8]
}
 804e780:	bd10      	pop	{r4, pc}
 804e782:	bf00      	nop
 804e784:	20004800 	.word	0x20004800

0804e788 <getSystemConfig>:
* </table><br><br>
* <hr>
*
*******************************************************************************/
char * getSystemConfig(void)
{
 804e788:	b5f0      	push	{r4, r5, r6, r7, lr}
 804e78a:	b08f      	sub	sp, #60	; 0x3c
	char * systemConfig = malloc(sizeof(char) * 2000);
 804e78c:	f44f 60fa 	mov.w	r0, #2000	; 0x7d0
 804e790:	f002 fed8 	bl	8051544 <malloc>
	if(systemConfig != NULL)
 804e794:	4604      	mov	r4, r0
 804e796:	2800      	cmp	r0, #0
 804e798:	f000 80f0 	beq.w	804e97c <getSystemConfig+0x1f4>
	{
		memset(systemConfig,0x00,sizeof(char) * GSM_PAYLOAD_MAX_SIZE);
 804e79c:	f44f 62fa 	mov.w	r2, #2000	; 0x7d0
 804e7a0:	2100      	movs	r1, #0
 804e7a2:	f003 f93d 	bl	8051a20 <memset>
		char temp_array[50];

		/* Start of Frame */
		strcpy((char *)systemConfig,(char * )START_OF_FRAME);
 804e7a6:	4b77      	ldr	r3, [pc, #476]	; (804e984 <getSystemConfig+0x1fc>)
 804e7a8:	881b      	ldrh	r3, [r3, #0]
 804e7aa:	8023      	strh	r3, [r4, #0]
		strcat((char *)systemConfig,(char * )PAYLOAD_SEPARATOR);
 804e7ac:	4620      	mov	r0, r4
 804e7ae:	f7f1 fd29 	bl	8040204 <strlen>
 804e7b2:	4b75      	ldr	r3, [pc, #468]	; (804e988 <getSystemConfig+0x200>)
 804e7b4:	881d      	ldrh	r5, [r3, #0]
 804e7b6:	5225      	strh	r5, [r4, r0]

		/* Device UUID */
		strcat((char *)systemConfig,(char * )dinfo);
 804e7b8:	4974      	ldr	r1, [pc, #464]	; (804e98c <getSystemConfig+0x204>)
 804e7ba:	4620      	mov	r0, r4
 804e7bc:	f003 f986 	bl	8051acc <strcat>
		strcat((char *)systemConfig,(char * )"_Conf");
 804e7c0:	4620      	mov	r0, r4
 804e7c2:	f7f1 fd1f 	bl	8040204 <strlen>
 804e7c6:	4603      	mov	r3, r0
 804e7c8:	1821      	adds	r1, r4, r0
 804e7ca:	4a71      	ldr	r2, [pc, #452]	; (804e990 <getSystemConfig+0x208>)
 804e7cc:	6810      	ldr	r0, [r2, #0]
 804e7ce:	50e0      	str	r0, [r4, r3]
 804e7d0:	8893      	ldrh	r3, [r2, #4]
 804e7d2:	808b      	strh	r3, [r1, #4]
		strcat((char *)systemConfig,(char * )PAYLOAD_SEPARATOR);
 804e7d4:	4620      	mov	r0, r4
 804e7d6:	f7f1 fd15 	bl	8040204 <strlen>
 804e7da:	5225      	strh	r5, [r4, r0]

		/* Model Number */
		strcat((char *)systemConfig,(char * )MODEL_NUMBER);
 804e7dc:	4620      	mov	r0, r4
 804e7de:	f7f1 fd11 	bl	8040204 <strlen>
 804e7e2:	4603      	mov	r3, r0
 804e7e4:	1826      	adds	r6, r4, r0
 804e7e6:	4a6b      	ldr	r2, [pc, #428]	; (804e994 <getSystemConfig+0x20c>)
 804e7e8:	ca03      	ldmia	r2!, {r0, r1}
 804e7ea:	50e0      	str	r0, [r4, r3]
 804e7ec:	6071      	str	r1, [r6, #4]
		strcat((char *)systemConfig,(char * )PAYLOAD_SEPARATOR);
 804e7ee:	4620      	mov	r0, r4
 804e7f0:	f7f1 fd08 	bl	8040204 <strlen>
 804e7f4:	5225      	strh	r5, [r4, r0]

		/* Local Time Stamp */
		strcat((char *)systemConfig,(char * )gau8Date);
 804e7f6:	4968      	ldr	r1, [pc, #416]	; (804e998 <getSystemConfig+0x210>)
 804e7f8:	4620      	mov	r0, r4
 804e7fa:	f003 f967 	bl	8051acc <strcat>
		strcat((char *)systemConfig,(char * )RTC_DATESEPARATOR);
 804e7fe:	4620      	mov	r0, r4
 804e800:	f7f1 fd00 	bl	8040204 <strlen>
 804e804:	4b65      	ldr	r3, [pc, #404]	; (804e99c <getSystemConfig+0x214>)
 804e806:	881e      	ldrh	r6, [r3, #0]
 804e808:	5226      	strh	r6, [r4, r0]
		strcat((char *)systemConfig,(char * )gau8Month);
 804e80a:	4965      	ldr	r1, [pc, #404]	; (804e9a0 <getSystemConfig+0x218>)
 804e80c:	4620      	mov	r0, r4
 804e80e:	f003 f95d 	bl	8051acc <strcat>
		strcat((char *)systemConfig,(char * )RTC_DATESEPARATOR);
 804e812:	4620      	mov	r0, r4
 804e814:	f7f1 fcf6 	bl	8040204 <strlen>
 804e818:	5226      	strh	r6, [r4, r0]
		strcat((char *)systemConfig,(char * )gau8Year);
 804e81a:	4962      	ldr	r1, [pc, #392]	; (804e9a4 <getSystemConfig+0x21c>)
 804e81c:	4620      	mov	r0, r4
 804e81e:	f003 f955 	bl	8051acc <strcat>
		strcat((char *)systemConfig,(char * )RTC_PARAM_SEPARATOR);
 804e822:	4620      	mov	r0, r4
 804e824:	f7f1 fcee 	bl	8040204 <strlen>
 804e828:	4b5f      	ldr	r3, [pc, #380]	; (804e9a8 <getSystemConfig+0x220>)
 804e82a:	881b      	ldrh	r3, [r3, #0]
 804e82c:	5223      	strh	r3, [r4, r0]
		strcat((char *)systemConfig,(char * )gau8Hour);
 804e82e:	495f      	ldr	r1, [pc, #380]	; (804e9ac <getSystemConfig+0x224>)
 804e830:	4620      	mov	r0, r4
 804e832:	f003 f94b 	bl	8051acc <strcat>
		strcat((char *)systemConfig,(char * )RTC_TIMESEPARATOR);
 804e836:	4620      	mov	r0, r4
 804e838:	f7f1 fce4 	bl	8040204 <strlen>
 804e83c:	4b5c      	ldr	r3, [pc, #368]	; (804e9b0 <getSystemConfig+0x228>)
 804e83e:	881e      	ldrh	r6, [r3, #0]
 804e840:	5226      	strh	r6, [r4, r0]
		strcat((char *)systemConfig,(char * )gau8Minutes);
 804e842:	495c      	ldr	r1, [pc, #368]	; (804e9b4 <getSystemConfig+0x22c>)
 804e844:	4620      	mov	r0, r4
 804e846:	f003 f941 	bl	8051acc <strcat>
		strcat((char *)systemConfig,(char * )RTC_TIMESEPARATOR);
 804e84a:	4620      	mov	r0, r4
 804e84c:	f7f1 fcda 	bl	8040204 <strlen>
 804e850:	5226      	strh	r6, [r4, r0]
		strcat((char *)systemConfig,(char * )gau8Seconds);
 804e852:	4959      	ldr	r1, [pc, #356]	; (804e9b8 <getSystemConfig+0x230>)
 804e854:	4620      	mov	r0, r4
 804e856:	f003 f939 	bl	8051acc <strcat>
		strcat((char *)systemConfig,(char * )PAYLOAD_SEPARATOR);
 804e85a:	4620      	mov	r0, r4
 804e85c:	f7f1 fcd2 	bl	8040204 <strlen>
 804e860:	5225      	strh	r5, [r4, r0]

		/* Firmware Version*/
		strcat((char *)systemConfig,(char * )FIRMWARE_VER);
 804e862:	4620      	mov	r0, r4
 804e864:	f7f1 fcce 	bl	8040204 <strlen>
 804e868:	4607      	mov	r7, r0
 804e86a:	1826      	adds	r6, r4, r0
 804e86c:	4b53      	ldr	r3, [pc, #332]	; (804e9bc <getSystemConfig+0x234>)
 804e86e:	cb07      	ldmia	r3!, {r0, r1, r2}
 804e870:	51e0      	str	r0, [r4, r7]
 804e872:	6071      	str	r1, [r6, #4]
 804e874:	60b2      	str	r2, [r6, #8]
 804e876:	881a      	ldrh	r2, [r3, #0]
 804e878:	789b      	ldrb	r3, [r3, #2]
 804e87a:	81b2      	strh	r2, [r6, #12]
 804e87c:	73b3      	strb	r3, [r6, #14]
		strcat((char *)systemConfig,(char * )PAYLOAD_SEPARATOR);
 804e87e:	4620      	mov	r0, r4
 804e880:	f7f1 fcc0 	bl	8040204 <strlen>
 804e884:	5225      	strh	r5, [r4, r0]

		strcat((char *)systemConfig,(char * )"SystemConfig :");
 804e886:	4620      	mov	r0, r4
 804e888:	f7f1 fcbc 	bl	8040204 <strlen>
 804e88c:	4607      	mov	r7, r0
 804e88e:	1826      	adds	r6, r4, r0
 804e890:	4b4b      	ldr	r3, [pc, #300]	; (804e9c0 <getSystemConfig+0x238>)
 804e892:	cb07      	ldmia	r3!, {r0, r1, r2}
 804e894:	51e0      	str	r0, [r4, r7]
 804e896:	6071      	str	r1, [r6, #4]
 804e898:	60b2      	str	r2, [r6, #8]
 804e89a:	881a      	ldrh	r2, [r3, #0]
 804e89c:	789b      	ldrb	r3, [r3, #2]
 804e89e:	81b2      	strh	r2, [r6, #12]
 804e8a0:	73b3      	strb	r3, [r6, #14]
		strcat((char *)systemConfig,(char * )PAYLOAD_SEPARATOR);
 804e8a2:	4620      	mov	r0, r4
 804e8a4:	f7f1 fcae 	bl	8040204 <strlen>
 804e8a8:	5225      	strh	r5, [r4, r0]
		strcat((char *)systemConfig,(char * )gau8LastKnownConfiguration);
 804e8aa:	4946      	ldr	r1, [pc, #280]	; (804e9c4 <getSystemConfig+0x23c>)
 804e8ac:	4620      	mov	r0, r4
 804e8ae:	f003 f90d 	bl	8051acc <strcat>
		strcat((char *)systemConfig,(char * )PAYLOAD_SEPARATOR);
 804e8b2:	4620      	mov	r0, r4
 804e8b4:	f7f1 fca6 	bl	8040204 <strlen>
 804e8b8:	5225      	strh	r5, [r4, r0]

		/* Config Error */
		memset(temp_array, 0, sizeof(temp_array));
 804e8ba:	2732      	movs	r7, #50	; 0x32
 804e8bc:	463a      	mov	r2, r7
 804e8be:	2100      	movs	r1, #0
 804e8c0:	a801      	add	r0, sp, #4
 804e8c2:	f003 f8ad 	bl	8051a20 <memset>
		itoa(gu32ConfigNetworkErrorDatabase, temp_array, 10);
 804e8c6:	220a      	movs	r2, #10
 804e8c8:	a901      	add	r1, sp, #4
 804e8ca:	4b3f      	ldr	r3, [pc, #252]	; (804e9c8 <getSystemConfig+0x240>)
 804e8cc:	6818      	ldr	r0, [r3, #0]
 804e8ce:	f002 fe37 	bl	8051540 <itoa>
		strcat((char *)systemConfig,(char * )"NetworkErr ");
 804e8d2:	4620      	mov	r0, r4
 804e8d4:	f7f1 fc96 	bl	8040204 <strlen>
 804e8d8:	4606      	mov	r6, r0
 804e8da:	eb04 0c00 	add.w	ip, r4, r0
 804e8de:	4b3b      	ldr	r3, [pc, #236]	; (804e9cc <getSystemConfig+0x244>)
 804e8e0:	cb07      	ldmia	r3!, {r0, r1, r2}
 804e8e2:	51a0      	str	r0, [r4, r6]
 804e8e4:	f8cc 1004 	str.w	r1, [ip, #4]
 804e8e8:	f8cc 2008 	str.w	r2, [ip, #8]
		strcat((char *)systemConfig,(char * )temp_array);
 804e8ec:	a901      	add	r1, sp, #4
 804e8ee:	4620      	mov	r0, r4
 804e8f0:	f003 f8ec 	bl	8051acc <strcat>
		strcat((char *)systemConfig,(char * )PAYLOAD_SEPARATOR);
 804e8f4:	4620      	mov	r0, r4
 804e8f6:	f7f1 fc85 	bl	8040204 <strlen>
 804e8fa:	5225      	strh	r5, [r4, r0]

		memset(temp_array, 0, sizeof(temp_array));
 804e8fc:	463a      	mov	r2, r7
 804e8fe:	2100      	movs	r1, #0
 804e900:	a801      	add	r0, sp, #4
 804e902:	f003 f88d 	bl	8051a20 <memset>
		itoa(gu32ConfigModbus485ErrorDatabase, temp_array, 10);
 804e906:	220a      	movs	r2, #10
 804e908:	a901      	add	r1, sp, #4
 804e90a:	4b31      	ldr	r3, [pc, #196]	; (804e9d0 <getSystemConfig+0x248>)
 804e90c:	6818      	ldr	r0, [r3, #0]
 804e90e:	f002 fe17 	bl	8051540 <itoa>
		strcat((char *)systemConfig,(char * )"485Err ");
 804e912:	4620      	mov	r0, r4
 804e914:	f7f1 fc76 	bl	8040204 <strlen>
 804e918:	4603      	mov	r3, r0
 804e91a:	1826      	adds	r6, r4, r0
 804e91c:	4a2d      	ldr	r2, [pc, #180]	; (804e9d4 <getSystemConfig+0x24c>)
 804e91e:	ca03      	ldmia	r2!, {r0, r1}
 804e920:	50e0      	str	r0, [r4, r3]
 804e922:	6071      	str	r1, [r6, #4]
		strcat((char *)systemConfig,(char * )temp_array);
 804e924:	a901      	add	r1, sp, #4
 804e926:	4620      	mov	r0, r4
 804e928:	f003 f8d0 	bl	8051acc <strcat>
		strcat((char *)systemConfig,(char * )PAYLOAD_SEPARATOR);
 804e92c:	4620      	mov	r0, r4
 804e92e:	f7f1 fc69 	bl	8040204 <strlen>
 804e932:	5225      	strh	r5, [r4, r0]

		memset(temp_array, 0, sizeof(temp_array));
 804e934:	463a      	mov	r2, r7
 804e936:	2100      	movs	r1, #0
 804e938:	a801      	add	r0, sp, #4
 804e93a:	f003 f871 	bl	8051a20 <memset>
		itoa(gu32ConfigModbusTCPErrorDatabase, temp_array, 10);
 804e93e:	220a      	movs	r2, #10
 804e940:	a901      	add	r1, sp, #4
 804e942:	4b25      	ldr	r3, [pc, #148]	; (804e9d8 <getSystemConfig+0x250>)
 804e944:	6818      	ldr	r0, [r3, #0]
 804e946:	f002 fdfb 	bl	8051540 <itoa>
		strcat((char *)systemConfig,(char * )"MBTCPErr ");
 804e94a:	4620      	mov	r0, r4
 804e94c:	f7f1 fc5a 	bl	8040204 <strlen>
 804e950:	4602      	mov	r2, r0
 804e952:	1826      	adds	r6, r4, r0
 804e954:	4b21      	ldr	r3, [pc, #132]	; (804e9dc <getSystemConfig+0x254>)
 804e956:	cb03      	ldmia	r3!, {r0, r1}
 804e958:	50a0      	str	r0, [r4, r2]
 804e95a:	6071      	str	r1, [r6, #4]
 804e95c:	881b      	ldrh	r3, [r3, #0]
 804e95e:	8133      	strh	r3, [r6, #8]
		strcat((char *)systemConfig,(char * )temp_array);
 804e960:	a901      	add	r1, sp, #4
 804e962:	4620      	mov	r0, r4
 804e964:	f003 f8b2 	bl	8051acc <strcat>
		strcat((char *)systemConfig,(char * )PAYLOAD_SEPARATOR);
 804e968:	4620      	mov	r0, r4
 804e96a:	f7f1 fc4b 	bl	8040204 <strlen>
 804e96e:	5225      	strh	r5, [r4, r0]

		strcat((char *)systemConfig,(char * )END_OF_FRAME);
 804e970:	4620      	mov	r0, r4
 804e972:	f7f1 fc47 	bl	8040204 <strlen>
 804e976:	4b1a      	ldr	r3, [pc, #104]	; (804e9e0 <getSystemConfig+0x258>)
 804e978:	881b      	ldrh	r3, [r3, #0]
 804e97a:	5223      	strh	r3, [r4, r0]

		return systemConfig;
	}
	else
		return NULL;
}
 804e97c:	4620      	mov	r0, r4
 804e97e:	b00f      	add	sp, #60	; 0x3c
 804e980:	bdf0      	pop	{r4, r5, r6, r7, pc}
 804e982:	bf00      	nop
 804e984:	0805a9fc 	.word	0x0805a9fc
 804e988:	0805a920 	.word	0x0805a920
 804e98c:	200087e4 	.word	0x200087e4
 804e990:	0805aa00 	.word	0x0805aa00
 804e994:	0805a8b4 	.word	0x0805a8b4
 804e998:	2000369c 	.word	0x2000369c
 804e99c:	0805aa08 	.word	0x0805aa08
 804e9a0:	20003694 	.word	0x20003694
 804e9a4:	2000368c 	.word	0x2000368c
 804e9a8:	0805a900 	.word	0x0805a900
 804e9ac:	200036a4 	.word	0x200036a4
 804e9b0:	0805a9a0 	.word	0x0805a9a0
 804e9b4:	200036ac 	.word	0x200036ac
 804e9b8:	200036b4 	.word	0x200036b4
 804e9bc:	0805aa0c 	.word	0x0805aa0c
 804e9c0:	0805aa1c 	.word	0x0805aa1c
 804e9c4:	2000eb60 	.word	0x2000eb60
 804e9c8:	20004d30 	.word	0x20004d30
 804e9cc:	0805aa2c 	.word	0x0805aa2c
 804e9d0:	20004e98 	.word	0x20004e98
 804e9d4:	0805aa38 	.word	0x0805aa38
 804e9d8:	20004ec4 	.word	0x20004ec4
 804e9dc:	0805aa40 	.word	0x0805aa40
 804e9e0:	0805aa4c 	.word	0x0805aa4c

0804e9e4 <updateInputVoltage>:
* </table><br><br>
* <hr>
*
*******************************************************************************/
void updateInputVoltage(void)
{
 804e9e4:	b510      	push	{r4, lr}
	sprintf(gcSystemSupplyVoltage,"%.2f",gfInputSupplyVoltage);
 804e9e6:	4b0b      	ldr	r3, [pc, #44]	; (804ea14 <updateInputVoltage+0x30>)
 804e9e8:	6818      	ldr	r0, [r3, #0]
 804e9ea:	f7f1 fdcd 	bl	8040588 <__aeabi_f2d>
 804e9ee:	4602      	mov	r2, r0
 804e9f0:	460b      	mov	r3, r1
 804e9f2:	4c09      	ldr	r4, [pc, #36]	; (804ea18 <updateInputVoltage+0x34>)
 804e9f4:	4621      	mov	r1, r4
 804e9f6:	4809      	ldr	r0, [pc, #36]	; (804ea1c <updateInputVoltage+0x38>)
 804e9f8:	f003 f848 	bl	8051a8c <sprintf>
	sprintf(gcBatterySupplyVoltage,"%.2f",gfBatteryVoltage);
 804e9fc:	4b08      	ldr	r3, [pc, #32]	; (804ea20 <updateInputVoltage+0x3c>)
 804e9fe:	6818      	ldr	r0, [r3, #0]
 804ea00:	f7f1 fdc2 	bl	8040588 <__aeabi_f2d>
 804ea04:	4602      	mov	r2, r0
 804ea06:	460b      	mov	r3, r1
 804ea08:	4621      	mov	r1, r4
 804ea0a:	4806      	ldr	r0, [pc, #24]	; (804ea24 <updateInputVoltage+0x40>)
 804ea0c:	f003 f83e 	bl	8051a8c <sprintf>
}
 804ea10:	bd10      	pop	{r4, pc}
 804ea12:	bf00      	nop
 804ea14:	20004fa0 	.word	0x20004fa0
 804ea18:	0805aa50 	.word	0x0805aa50
 804ea1c:	2000eb4c 	.word	0x2000eb4c
 804ea20:	20004f9c 	.word	0x20004f9c
 804ea24:	2000eb3c 	.word	0x2000eb3c

0804ea28 <formatGPSSring>:
* </table><br><br>
* <hr>
*
*******************************************************************************/
void formatGPSSring(void)
{
 804ea28:	b570      	push	{r4, r5, r6, lr}
	/*Formulate Lat and Lon in standard format
		 * 1830.101 = 18 + (30.101094/60) = 18.5016849
		 * 7348.878 = 73 + (48.877697 /60) = 73.8146 */

	char *configptr = strtok(agpsLastLocationData, ",");
 804ea2a:	4984      	ldr	r1, [pc, #528]	; (804ec3c <formatGPSSring+0x214>)
 804ea2c:	4884      	ldr	r0, [pc, #528]	; (804ec40 <formatGPSSring+0x218>)
 804ea2e:	f003 fee1 	bl	80527f4 <strtok>
 804ea32:	4604      	mov	r4, r0
	gu32ExtractGPSParamCounter = 0;
 804ea34:	4b83      	ldr	r3, [pc, #524]	; (804ec44 <formatGPSSring+0x21c>)
 804ea36:	2200      	movs	r2, #0
 804ea38:	601a      	str	r2, [r3, #0]

	while(gu32ExtractGPSParamCounter != 9) //reference : while(configptr != NULL)
 804ea3a:	e045      	b.n	804eac8 <formatGPSSring+0xa0>
	{
		switch(gu32ExtractGPSParamCounter)
		{
			case 0:
				/* Lat  */
				strcpy(gu32GPSLat,configptr);
 804ea3c:	4d80      	ldr	r5, [pc, #512]	; (804ec40 <formatGPSSring+0x218>)
 804ea3e:	4621      	mov	r1, r4
 804ea40:	f105 0098 	add.w	r0, r5, #152	; 0x98
 804ea44:	f003 f85e 	bl	8051b04 <strcpy>
				templat = atof(&gu32GPSLat[2]);
 804ea48:	f105 009a 	add.w	r0, r5, #154	; 0x9a
 804ea4c:	f002 fd35 	bl	80514ba <atof>
 804ea50:	ec51 0b10 	vmov	r0, r1, d0
 804ea54:	f7f2 f8e8 	bl	8040c28 <__aeabi_d2f>
 804ea58:	ee06 0a90 	vmov	s13, r0
				templat /= 60;
 804ea5c:	eddf 7a7a 	vldr	s15, [pc, #488]	; 804ec48 <formatGPSSring+0x220>
 804ea60:	ee86 7aa7 	vdiv.f32	s14, s13, s15
				templat += (((gu32GPSLat[0]-'0') * 10) + (gu32GPSLat[1]-'0'));
 804ea64:	f895 3098 	ldrb.w	r3, [r5, #152]	; 0x98
 804ea68:	3b30      	subs	r3, #48	; 0x30
 804ea6a:	eb03 0283 	add.w	r2, r3, r3, lsl #2
 804ea6e:	f895 3099 	ldrb.w	r3, [r5, #153]	; 0x99
 804ea72:	3b30      	subs	r3, #48	; 0x30
 804ea74:	eb03 0342 	add.w	r3, r3, r2, lsl #1
 804ea78:	ee07 3a90 	vmov	s15, r3
 804ea7c:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 804ea80:	ee77 7a87 	vadd.f32	s15, s15, s14
 804ea84:	4b6f      	ldr	r3, [pc, #444]	; (804ec44 <formatGPSSring+0x21c>)
 804ea86:	edc3 7a01 	vstr	s15, [r3, #4]
				sprintf(gu32GPSLatformatted,"%.7f",templat);
 804ea8a:	ee17 0a90 	vmov	r0, s15
 804ea8e:	f7f1 fd7b 	bl	8040588 <__aeabi_f2d>
 804ea92:	4602      	mov	r2, r0
 804ea94:	460b      	mov	r3, r1
 804ea96:	f105 06a8 	add.w	r6, r5, #168	; 0xa8
 804ea9a:	496c      	ldr	r1, [pc, #432]	; (804ec4c <formatGPSSring+0x224>)
 804ea9c:	4630      	mov	r0, r6
 804ea9e:	f002 fff5 	bl	8051a8c <sprintf>
				memset(agpsLastLocationDataFormatted,0x00,150);
 804eaa2:	35b8      	adds	r5, #184	; 0xb8
 804eaa4:	2296      	movs	r2, #150	; 0x96
 804eaa6:	2100      	movs	r1, #0
 804eaa8:	4628      	mov	r0, r5
 804eaaa:	f002 ffb9 	bl	8051a20 <memset>
				strcpy(agpsLastLocationDataFormatted,gu32GPSLatformatted);
 804eaae:	4631      	mov	r1, r6
 804eab0:	4628      	mov	r0, r5
 804eab2:	f003 f827 	bl	8051b04 <strcpy>

			default:

				break;
		}
		if(gu32ExtractGPSParamCounter != 9)
 804eab6:	4b63      	ldr	r3, [pc, #396]	; (804ec44 <formatGPSSring+0x21c>)
 804eab8:	681b      	ldr	r3, [r3, #0]
 804eaba:	2b09      	cmp	r3, #9
 804eabc:	f040 80b7 	bne.w	804ec2e <formatGPSSring+0x206>
			configptr = strtok(NULL, ",");

		gu32ExtractGPSParamCounter++;
 804eac0:	4a60      	ldr	r2, [pc, #384]	; (804ec44 <formatGPSSring+0x21c>)
 804eac2:	6813      	ldr	r3, [r2, #0]
 804eac4:	3301      	adds	r3, #1
 804eac6:	6013      	str	r3, [r2, #0]
	while(gu32ExtractGPSParamCounter != 9) //reference : while(configptr != NULL)
 804eac8:	4b5e      	ldr	r3, [pc, #376]	; (804ec44 <formatGPSSring+0x21c>)
 804eaca:	681b      	ldr	r3, [r3, #0]
 804eacc:	2b09      	cmp	r3, #9
 804eace:	f000 80b4 	beq.w	804ec3a <formatGPSSring+0x212>
		switch(gu32ExtractGPSParamCounter)
 804ead2:	2b08      	cmp	r3, #8
 804ead4:	d8ef      	bhi.n	804eab6 <formatGPSSring+0x8e>
 804ead6:	a201      	add	r2, pc, #4	; (adr r2, 804eadc <formatGPSSring+0xb4>)
 804ead8:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 804eadc:	0804ea3d 	.word	0x0804ea3d
 804eae0:	0804eb01 	.word	0x0804eb01
 804eae4:	0804eb21 	.word	0x0804eb21
 804eae8:	0804eb9f 	.word	0x0804eb9f
 804eaec:	0804ebb7 	.word	0x0804ebb7
 804eaf0:	0804ebcf 	.word	0x0804ebcf
 804eaf4:	0804ebe7 	.word	0x0804ebe7
 804eaf8:	0804ebff 	.word	0x0804ebff
 804eafc:	0804ec17 	.word	0x0804ec17
				strcat(agpsLastLocationDataFormatted,",");
 804eb00:	4d53      	ldr	r5, [pc, #332]	; (804ec50 <formatGPSSring+0x228>)
 804eb02:	4628      	mov	r0, r5
 804eb04:	f7f1 fb7e 	bl	8040204 <strlen>
 804eb08:	4b4c      	ldr	r3, [pc, #304]	; (804ec3c <formatGPSSring+0x214>)
 804eb0a:	881e      	ldrh	r6, [r3, #0]
 804eb0c:	522e      	strh	r6, [r5, r0]
				strcat(agpsLastLocationDataFormatted,configptr);
 804eb0e:	4621      	mov	r1, r4
 804eb10:	4628      	mov	r0, r5
 804eb12:	f002 ffdb 	bl	8051acc <strcat>
				strcat(agpsLastLocationDataFormatted,",");
 804eb16:	4628      	mov	r0, r5
 804eb18:	f7f1 fb74 	bl	8040204 <strlen>
 804eb1c:	522e      	strh	r6, [r5, r0]
				break;
 804eb1e:	e7ca      	b.n	804eab6 <formatGPSSring+0x8e>
				strcpy(gu32GPSLon,configptr);
 804eb20:	4d47      	ldr	r5, [pc, #284]	; (804ec40 <formatGPSSring+0x218>)
 804eb22:	4621      	mov	r1, r4
 804eb24:	f505 70a8 	add.w	r0, r5, #336	; 0x150
 804eb28:	f002 ffec 	bl	8051b04 <strcpy>
				templon = atof(&gu32GPSLon[3]);
 804eb2c:	f205 1053 	addw	r0, r5, #339	; 0x153
 804eb30:	f002 fcc3 	bl	80514ba <atof>
 804eb34:	ec51 0b10 	vmov	r0, r1, d0
 804eb38:	f7f2 f876 	bl	8040c28 <__aeabi_d2f>
 804eb3c:	ee06 0a90 	vmov	s13, r0
				templon /= 60;
 804eb40:	eddf 7a41 	vldr	s15, [pc, #260]	; 804ec48 <formatGPSSring+0x220>
 804eb44:	ee86 7aa7 	vdiv.f32	s14, s13, s15
				templon += (((gu32GPSLon[0]- '0') * 100 )+ ((gu32GPSLon[1]-'0') * 10) +(gu32GPSLon[2]-'0'));
 804eb48:	f895 3150 	ldrb.w	r3, [r5, #336]	; 0x150
 804eb4c:	3b30      	subs	r3, #48	; 0x30
 804eb4e:	f895 2151 	ldrb.w	r2, [r5, #337]	; 0x151
 804eb52:	3a30      	subs	r2, #48	; 0x30
 804eb54:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 804eb58:	0052      	lsls	r2, r2, #1
 804eb5a:	2164      	movs	r1, #100	; 0x64
 804eb5c:	fb01 2303 	mla	r3, r1, r3, r2
 804eb60:	f895 2152 	ldrb.w	r2, [r5, #338]	; 0x152
 804eb64:	3a30      	subs	r2, #48	; 0x30
 804eb66:	4413      	add	r3, r2
 804eb68:	ee07 3a90 	vmov	s15, r3
 804eb6c:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 804eb70:	ee77 7a87 	vadd.f32	s15, s15, s14
 804eb74:	4b33      	ldr	r3, [pc, #204]	; (804ec44 <formatGPSSring+0x21c>)
 804eb76:	edc3 7a02 	vstr	s15, [r3, #8]
				sprintf(gu32GPSLonformatted,"%.7f",templon);
 804eb7a:	ee17 0a90 	vmov	r0, s15
 804eb7e:	f7f1 fd03 	bl	8040588 <__aeabi_f2d>
 804eb82:	4602      	mov	r2, r0
 804eb84:	460b      	mov	r3, r1
 804eb86:	f505 76b0 	add.w	r6, r5, #352	; 0x160
 804eb8a:	4930      	ldr	r1, [pc, #192]	; (804ec4c <formatGPSSring+0x224>)
 804eb8c:	4630      	mov	r0, r6
 804eb8e:	f002 ff7d 	bl	8051a8c <sprintf>
				strcat(agpsLastLocationDataFormatted,gu32GPSLonformatted);
 804eb92:	4631      	mov	r1, r6
 804eb94:	f105 00b8 	add.w	r0, r5, #184	; 0xb8
 804eb98:	f002 ff98 	bl	8051acc <strcat>
				break;
 804eb9c:	e78b      	b.n	804eab6 <formatGPSSring+0x8e>
				strcat(agpsLastLocationDataFormatted,",");
 804eb9e:	4d2c      	ldr	r5, [pc, #176]	; (804ec50 <formatGPSSring+0x228>)
 804eba0:	4628      	mov	r0, r5
 804eba2:	f7f1 fb2f 	bl	8040204 <strlen>
 804eba6:	4b25      	ldr	r3, [pc, #148]	; (804ec3c <formatGPSSring+0x214>)
 804eba8:	881b      	ldrh	r3, [r3, #0]
 804ebaa:	522b      	strh	r3, [r5, r0]
				strcat(agpsLastLocationDataFormatted,configptr);
 804ebac:	4621      	mov	r1, r4
 804ebae:	4628      	mov	r0, r5
 804ebb0:	f002 ff8c 	bl	8051acc <strcat>
				break;
 804ebb4:	e77f      	b.n	804eab6 <formatGPSSring+0x8e>
				strcat(agpsLastLocationDataFormatted,",");
 804ebb6:	4d26      	ldr	r5, [pc, #152]	; (804ec50 <formatGPSSring+0x228>)
 804ebb8:	4628      	mov	r0, r5
 804ebba:	f7f1 fb23 	bl	8040204 <strlen>
 804ebbe:	4b1f      	ldr	r3, [pc, #124]	; (804ec3c <formatGPSSring+0x214>)
 804ebc0:	881b      	ldrh	r3, [r3, #0]
 804ebc2:	522b      	strh	r3, [r5, r0]
				strcat(agpsLastLocationDataFormatted,configptr);
 804ebc4:	4621      	mov	r1, r4
 804ebc6:	4628      	mov	r0, r5
 804ebc8:	f002 ff80 	bl	8051acc <strcat>
				break;
 804ebcc:	e773      	b.n	804eab6 <formatGPSSring+0x8e>
				strcat(agpsLastLocationDataFormatted,",");
 804ebce:	4d20      	ldr	r5, [pc, #128]	; (804ec50 <formatGPSSring+0x228>)
 804ebd0:	4628      	mov	r0, r5
 804ebd2:	f7f1 fb17 	bl	8040204 <strlen>
 804ebd6:	4b19      	ldr	r3, [pc, #100]	; (804ec3c <formatGPSSring+0x214>)
 804ebd8:	881b      	ldrh	r3, [r3, #0]
 804ebda:	522b      	strh	r3, [r5, r0]
				strcat(agpsLastLocationDataFormatted,configptr);
 804ebdc:	4621      	mov	r1, r4
 804ebde:	4628      	mov	r0, r5
 804ebe0:	f002 ff74 	bl	8051acc <strcat>
				break;
 804ebe4:	e767      	b.n	804eab6 <formatGPSSring+0x8e>
				strcat(agpsLastLocationDataFormatted,",");
 804ebe6:	4d1a      	ldr	r5, [pc, #104]	; (804ec50 <formatGPSSring+0x228>)
 804ebe8:	4628      	mov	r0, r5
 804ebea:	f7f1 fb0b 	bl	8040204 <strlen>
 804ebee:	4b13      	ldr	r3, [pc, #76]	; (804ec3c <formatGPSSring+0x214>)
 804ebf0:	881b      	ldrh	r3, [r3, #0]
 804ebf2:	522b      	strh	r3, [r5, r0]
				strcat(agpsLastLocationDataFormatted,configptr);
 804ebf4:	4621      	mov	r1, r4
 804ebf6:	4628      	mov	r0, r5
 804ebf8:	f002 ff68 	bl	8051acc <strcat>
				break;
 804ebfc:	e75b      	b.n	804eab6 <formatGPSSring+0x8e>
				strcat(agpsLastLocationDataFormatted,",");
 804ebfe:	4d14      	ldr	r5, [pc, #80]	; (804ec50 <formatGPSSring+0x228>)
 804ec00:	4628      	mov	r0, r5
 804ec02:	f7f1 faff 	bl	8040204 <strlen>
 804ec06:	4b0d      	ldr	r3, [pc, #52]	; (804ec3c <formatGPSSring+0x214>)
 804ec08:	881b      	ldrh	r3, [r3, #0]
 804ec0a:	522b      	strh	r3, [r5, r0]
				strcat(agpsLastLocationDataFormatted,configptr);
 804ec0c:	4621      	mov	r1, r4
 804ec0e:	4628      	mov	r0, r5
 804ec10:	f002 ff5c 	bl	8051acc <strcat>
				break;
 804ec14:	e74f      	b.n	804eab6 <formatGPSSring+0x8e>
				strcat(agpsLastLocationDataFormatted,",");
 804ec16:	4d0e      	ldr	r5, [pc, #56]	; (804ec50 <formatGPSSring+0x228>)
 804ec18:	4628      	mov	r0, r5
 804ec1a:	f7f1 faf3 	bl	8040204 <strlen>
 804ec1e:	4b07      	ldr	r3, [pc, #28]	; (804ec3c <formatGPSSring+0x214>)
 804ec20:	881b      	ldrh	r3, [r3, #0]
 804ec22:	522b      	strh	r3, [r5, r0]
				strcat(agpsLastLocationDataFormatted,configptr);
 804ec24:	4621      	mov	r1, r4
 804ec26:	4628      	mov	r0, r5
 804ec28:	f002 ff50 	bl	8051acc <strcat>
				break;
 804ec2c:	e743      	b.n	804eab6 <formatGPSSring+0x8e>
			configptr = strtok(NULL, ",");
 804ec2e:	4903      	ldr	r1, [pc, #12]	; (804ec3c <formatGPSSring+0x214>)
 804ec30:	2000      	movs	r0, #0
 804ec32:	f003 fddf 	bl	80527f4 <strtok>
 804ec36:	4604      	mov	r4, r0
 804ec38:	e742      	b.n	804eac0 <formatGPSSring+0x98>

	}
}
 804ec3a:	bd70      	pop	{r4, r5, r6, pc}
 804ec3c:	0805a920 	.word	0x0805a920
 804ec40:	20002514 	.word	0x20002514
 804ec44:	20004d14 	.word	0x20004d14
 804ec48:	42700000 	.word	0x42700000
 804ec4c:	0805aa58 	.word	0x0805aa58
 804ec50:	200025cc 	.word	0x200025cc

0804ec54 <getSystemDataString>:
{
 804ec54:	b5f0      	push	{r4, r5, r6, r7, lr}
 804ec56:	b08f      	sub	sp, #60	; 0x3c
	char * systemPayload = malloc(sizeof(char) * GSM_PAYLOAD_MAX_SIZE);
 804ec58:	f44f 60fa 	mov.w	r0, #2000	; 0x7d0
 804ec5c:	f002 fc72 	bl	8051544 <malloc>
 804ec60:	4604      	mov	r4, r0
	getrtcStamp();
 804ec62:	f002 fae9 	bl	8051238 <getrtcStamp>
	updateInputVoltage();
 804ec66:	f7ff febd 	bl	804e9e4 <updateInputVoltage>
	itoa(gu32EthLinkAlert,gacEthernetLinkStatus,10);
 804ec6a:	220a      	movs	r2, #10
 804ec6c:	498c      	ldr	r1, [pc, #560]	; (804eea0 <getSystemDataString+0x24c>)
 804ec6e:	4b8d      	ldr	r3, [pc, #564]	; (804eea4 <getSystemDataString+0x250>)
 804ec70:	6818      	ldr	r0, [r3, #0]
 804ec72:	f002 fc65 	bl	8051540 <itoa>
	itoa(gu32MBDataByteCounterLimit,gacMBDataPoints,10);
 804ec76:	220a      	movs	r2, #10
 804ec78:	498b      	ldr	r1, [pc, #556]	; (804eea8 <getSystemDataString+0x254>)
 804ec7a:	4b8c      	ldr	r3, [pc, #560]	; (804eeac <getSystemDataString+0x258>)
 804ec7c:	6818      	ldr	r0, [r3, #0]
 804ec7e:	f002 fc5f 	bl	8051540 <itoa>
	itoa(gu32MBDataByteCounterLimitRTU,gacMBDataPointsRTU,10);
 804ec82:	220a      	movs	r2, #10
 804ec84:	498a      	ldr	r1, [pc, #552]	; (804eeb0 <getSystemDataString+0x25c>)
 804ec86:	4b8b      	ldr	r3, [pc, #556]	; (804eeb4 <getSystemDataString+0x260>)
 804ec88:	6818      	ldr	r0, [r3, #0]
 804ec8a:	f002 fc59 	bl	8051540 <itoa>
	itoa(gu32MBClientConnectedFlag,gacModbusStatus,10);
 804ec8e:	4b8a      	ldr	r3, [pc, #552]	; (804eeb8 <getSystemDataString+0x264>)
 804ec90:	6818      	ldr	r0, [r3, #0]
 804ec92:	4d8a      	ldr	r5, [pc, #552]	; (804eebc <getSystemDataString+0x268>)
 804ec94:	220a      	movs	r2, #10
 804ec96:	f105 010c 	add.w	r1, r5, #12
 804ec9a:	f002 fc51 	bl	8051540 <itoa>
	itoa(gu32MBRTUClientConnectedFlag,gacModbusStatusRTU,10);
 804ec9e:	4b88      	ldr	r3, [pc, #544]	; (804eec0 <getSystemDataString+0x26c>)
 804eca0:	6818      	ldr	r0, [r3, #0]
 804eca2:	220a      	movs	r2, #10
 804eca4:	f105 0110 	add.w	r1, r5, #16
 804eca8:	f002 fc4a 	bl	8051540 <itoa>
	if(strlen(gsmInstance.agpsLocationData) > 10)
 804ecac:	4885      	ldr	r0, [pc, #532]	; (804eec4 <getSystemDataString+0x270>)
 804ecae:	f7f1 faa9 	bl	8040204 <strlen>
 804ecb2:	280a      	cmp	r0, #10
 804ecb4:	d812      	bhi.n	804ecdc <getSystemDataString+0x88>
	if(systemPayload != NULL)
 804ecb6:	b174      	cbz	r4, 804ecd6 <getSystemDataString+0x82>
		memset(systemPayload,0x00,sizeof(char) * GSM_PAYLOAD_MAX_SIZE);
 804ecb8:	f44f 62fa 	mov.w	r2, #2000	; 0x7d0
 804ecbc:	2100      	movs	r1, #0
 804ecbe:	4620      	mov	r0, r4
 804ecc0:	f002 feae 	bl	8051a20 <memset>
		if(gu32OperateModbusTCP == 1)
 804ecc4:	4b80      	ldr	r3, [pc, #512]	; (804eec8 <getSystemDataString+0x274>)
 804ecc6:	681b      	ldr	r3, [r3, #0]
 804ecc8:	2b01      	cmp	r3, #1
 804ecca:	d00f      	beq.n	804ecec <getSystemDataString+0x98>
		if(gu32OperateModbus485 == 1)
 804eccc:	4b7f      	ldr	r3, [pc, #508]	; (804eecc <getSystemDataString+0x278>)
 804ecce:	681b      	ldr	r3, [r3, #0]
 804ecd0:	2b01      	cmp	r3, #1
 804ecd2:	f000 8127 	beq.w	804ef24 <getSystemDataString+0x2d0>
}
 804ecd6:	4620      	mov	r0, r4
 804ecd8:	b00f      	add	sp, #60	; 0x3c
 804ecda:	bdf0      	pop	{r4, r5, r6, r7, pc}
		memcpy(agpsLastLocationData,gsmInstance.agpsLocationData,strlen(gsmInstance.agpsLocationData));
 804ecdc:	4602      	mov	r2, r0
 804ecde:	4979      	ldr	r1, [pc, #484]	; (804eec4 <getSystemDataString+0x270>)
 804ece0:	487b      	ldr	r0, [pc, #492]	; (804eed0 <getSystemDataString+0x27c>)
 804ece2:	f002 fe8f 	bl	8051a04 <memcpy>
		formatGPSSring();
 804ece6:	f7ff fe9f 	bl	804ea28 <formatGPSSring>
 804ecea:	e7e4      	b.n	804ecb6 <getSystemDataString+0x62>
			strcpy((char *)systemPayload,(char * )START_OF_FRAME);
 804ecec:	4b79      	ldr	r3, [pc, #484]	; (804eed4 <getSystemDataString+0x280>)
 804ecee:	881b      	ldrh	r3, [r3, #0]
 804ecf0:	8023      	strh	r3, [r4, #0]
			strcat((char *)systemPayload,(char * )PAYLOAD_SEPARATOR);
 804ecf2:	4620      	mov	r0, r4
 804ecf4:	f7f1 fa86 	bl	8040204 <strlen>
 804ecf8:	4b77      	ldr	r3, [pc, #476]	; (804eed8 <getSystemDataString+0x284>)
 804ecfa:	881d      	ldrh	r5, [r3, #0]
 804ecfc:	5225      	strh	r5, [r4, r0]
			strcat((char *)systemPayload,(char * )dinfo);
 804ecfe:	4977      	ldr	r1, [pc, #476]	; (804eedc <getSystemDataString+0x288>)
 804ed00:	4620      	mov	r0, r4
 804ed02:	f002 fee3 	bl	8051acc <strcat>
			strcat((char *)systemPayload,(char * )PAYLOAD_SEPARATOR);
 804ed06:	4620      	mov	r0, r4
 804ed08:	f7f1 fa7c 	bl	8040204 <strlen>
 804ed0c:	5225      	strh	r5, [r4, r0]
			strcat((char *)systemPayload,(char * )MODEL_NUMBER);
 804ed0e:	4620      	mov	r0, r4
 804ed10:	f7f1 fa78 	bl	8040204 <strlen>
 804ed14:	4603      	mov	r3, r0
 804ed16:	1826      	adds	r6, r4, r0
 804ed18:	4a71      	ldr	r2, [pc, #452]	; (804eee0 <getSystemDataString+0x28c>)
 804ed1a:	ca03      	ldmia	r2!, {r0, r1}
 804ed1c:	50e0      	str	r0, [r4, r3]
 804ed1e:	6071      	str	r1, [r6, #4]
			strcat((char *)systemPayload,(char * )PAYLOAD_SEPARATOR);
 804ed20:	4620      	mov	r0, r4
 804ed22:	f7f1 fa6f 	bl	8040204 <strlen>
 804ed26:	5225      	strh	r5, [r4, r0]
			strcat((char *)systemPayload,(char * )aShowDateStamp);
 804ed28:	496e      	ldr	r1, [pc, #440]	; (804eee4 <getSystemDataString+0x290>)
 804ed2a:	4620      	mov	r0, r4
 804ed2c:	f002 fece 	bl	8051acc <strcat>
			strcat((char *)systemPayload,(char * )" ");
 804ed30:	4620      	mov	r0, r4
 804ed32:	f7f1 fa67 	bl	8040204 <strlen>
 804ed36:	4b6c      	ldr	r3, [pc, #432]	; (804eee8 <getSystemDataString+0x294>)
 804ed38:	881b      	ldrh	r3, [r3, #0]
 804ed3a:	5223      	strh	r3, [r4, r0]
			strcat((char *)systemPayload,(char * )aShowTimeStamp);
 804ed3c:	496b      	ldr	r1, [pc, #428]	; (804eeec <getSystemDataString+0x298>)
 804ed3e:	4620      	mov	r0, r4
 804ed40:	f002 fec4 	bl	8051acc <strcat>
			strcat((char *)systemPayload,(char * )PAYLOAD_SEPARATOR);
 804ed44:	4620      	mov	r0, r4
 804ed46:	f7f1 fa5d 	bl	8040204 <strlen>
 804ed4a:	5225      	strh	r5, [r4, r0]
			strcat((char *)systemPayload,(char * )FIRMWARE_VER);
 804ed4c:	4620      	mov	r0, r4
 804ed4e:	f7f1 fa59 	bl	8040204 <strlen>
 804ed52:	4607      	mov	r7, r0
 804ed54:	1826      	adds	r6, r4, r0
 804ed56:	4b66      	ldr	r3, [pc, #408]	; (804eef0 <getSystemDataString+0x29c>)
 804ed58:	cb07      	ldmia	r3!, {r0, r1, r2}
 804ed5a:	51e0      	str	r0, [r4, r7]
 804ed5c:	6071      	str	r1, [r6, #4]
 804ed5e:	60b2      	str	r2, [r6, #8]
 804ed60:	881a      	ldrh	r2, [r3, #0]
 804ed62:	789b      	ldrb	r3, [r3, #2]
 804ed64:	81b2      	strh	r2, [r6, #12]
 804ed66:	73b3      	strb	r3, [r6, #14]
			strcat((char *)systemPayload,(char * )PAYLOAD_SEPARATOR);
 804ed68:	4620      	mov	r0, r4
 804ed6a:	f7f1 fa4b 	bl	8040204 <strlen>
 804ed6e:	5225      	strh	r5, [r4, r0]
			strcat((char *)systemPayload,(char * )gacEthernetLinkStatus);
 804ed70:	494b      	ldr	r1, [pc, #300]	; (804eea0 <getSystemDataString+0x24c>)
 804ed72:	4620      	mov	r0, r4
 804ed74:	f002 feaa 	bl	8051acc <strcat>
			strcat((char *)systemPayload,(char * )PAYLOAD_SEPARATOR);
 804ed78:	4620      	mov	r0, r4
 804ed7a:	f7f1 fa43 	bl	8040204 <strlen>
 804ed7e:	5225      	strh	r5, [r4, r0]
			strcat((char *)systemPayload,(char * )gacMBDataPoints);
 804ed80:	4949      	ldr	r1, [pc, #292]	; (804eea8 <getSystemDataString+0x254>)
 804ed82:	4620      	mov	r0, r4
 804ed84:	f002 fea2 	bl	8051acc <strcat>
			strcat((char *)systemPayload,(char * )PAYLOAD_SEPARATOR);
 804ed88:	4620      	mov	r0, r4
 804ed8a:	f7f1 fa3b 	bl	8040204 <strlen>
 804ed8e:	5225      	strh	r5, [r4, r0]
			if((float)gfInputSupplyVoltage < 9.00f)
 804ed90:	4b58      	ldr	r3, [pc, #352]	; (804eef4 <getSystemDataString+0x2a0>)
 804ed92:	ed93 7a00 	vldr	s14, [r3]
 804ed96:	eef2 7a02 	vmov.f32	s15, #34	; 0x41100000  9.0
 804ed9a:	eeb4 7ae7 	vcmpe.f32	s14, s15
 804ed9e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 804eda2:	d56a      	bpl.n	804ee7a <getSystemDataString+0x226>
				strcat((char *)systemPayload,(char * )gcBatterySupplyVoltage);
 804eda4:	4954      	ldr	r1, [pc, #336]	; (804eef8 <getSystemDataString+0x2a4>)
 804eda6:	4620      	mov	r0, r4
 804eda8:	f002 fe90 	bl	8051acc <strcat>
				strcat((char *)systemPayload,(char * )PAYLOAD_SEPARATOR);
 804edac:	4620      	mov	r0, r4
 804edae:	f7f1 fa29 	bl	8040204 <strlen>
 804edb2:	4b49      	ldr	r3, [pc, #292]	; (804eed8 <getSystemDataString+0x284>)
 804edb4:	881b      	ldrh	r3, [r3, #0]
 804edb6:	5223      	strh	r3, [r4, r0]
			strcat((char *)systemPayload,(char * )gacModbusStatus);
 804edb8:	4950      	ldr	r1, [pc, #320]	; (804eefc <getSystemDataString+0x2a8>)
 804edba:	4620      	mov	r0, r4
 804edbc:	f002 fe86 	bl	8051acc <strcat>
			strcat((char *)systemPayload,(char * )PAYLOAD_SEPARATOR);
 804edc0:	4620      	mov	r0, r4
 804edc2:	f7f1 fa1f 	bl	8040204 <strlen>
 804edc6:	4b44      	ldr	r3, [pc, #272]	; (804eed8 <getSystemDataString+0x284>)
 804edc8:	881d      	ldrh	r5, [r3, #0]
 804edca:	5225      	strh	r5, [r4, r0]
			strcat((char *)systemPayload,"IP,");
 804edcc:	4620      	mov	r0, r4
 804edce:	f7f1 fa19 	bl	8040204 <strlen>
 804edd2:	4603      	mov	r3, r0
 804edd4:	4a4a      	ldr	r2, [pc, #296]	; (804ef00 <getSystemDataString+0x2ac>)
 804edd6:	6810      	ldr	r0, [r2, #0]
 804edd8:	50e0      	str	r0, [r4, r3]
			strcat((char *)systemPayload,(char * )PAYLOAD_SEPARATOR);
 804edda:	4620      	mov	r0, r4
 804eddc:	f7f1 fa12 	bl	8040204 <strlen>
 804ede0:	5225      	strh	r5, [r4, r0]
			strcat((char *)systemPayload,(char * )agpsLastLocationDataFormatted);
 804ede2:	4948      	ldr	r1, [pc, #288]	; (804ef04 <getSystemDataString+0x2b0>)
 804ede4:	4620      	mov	r0, r4
 804ede6:	f002 fe71 	bl	8051acc <strcat>
			strcat((char *)systemPayload,(char * )PAYLOAD_SEPARATOR);
 804edea:	4620      	mov	r0, r4
 804edec:	f7f1 fa0a 	bl	8040204 <strlen>
 804edf0:	5225      	strh	r5, [r4, r0]
			if(strlen(gsmInstance.agsmSignalStrength ) > 0)
 804edf2:	4b34      	ldr	r3, [pc, #208]	; (804eec4 <getSystemDataString+0x270>)
 804edf4:	f893 3096 	ldrb.w	r3, [r3, #150]	; 0x96
 804edf8:	2b00      	cmp	r3, #0
 804edfa:	d049      	beq.n	804ee90 <getSystemDataString+0x23c>
				strcat((char *)systemPayload,(char * )gsmInstance.agsmSignalStrength);
 804edfc:	4942      	ldr	r1, [pc, #264]	; (804ef08 <getSystemDataString+0x2b4>)
 804edfe:	4620      	mov	r0, r4
 804ee00:	f002 fe64 	bl	8051acc <strcat>
			u32TempVar = gu32GSMConfigCheckTimer / 1000;
 804ee04:	4b41      	ldr	r3, [pc, #260]	; (804ef0c <getSystemDataString+0x2b8>)
 804ee06:	681d      	ldr	r5, [r3, #0]
 804ee08:	4b41      	ldr	r3, [pc, #260]	; (804ef10 <getSystemDataString+0x2bc>)
 804ee0a:	fba3 3505 	umull	r3, r5, r3, r5
 804ee0e:	09ad      	lsrs	r5, r5, #6
			memset(temp_array, 0, sizeof(temp_array));
 804ee10:	2232      	movs	r2, #50	; 0x32
 804ee12:	2100      	movs	r1, #0
 804ee14:	a801      	add	r0, sp, #4
 804ee16:	f002 fe03 	bl	8051a20 <memset>
			itoa(u32TempVar, temp_array, 10);
 804ee1a:	220a      	movs	r2, #10
 804ee1c:	a901      	add	r1, sp, #4
 804ee1e:	4628      	mov	r0, r5
 804ee20:	f002 fb8e 	bl	8051540 <itoa>
			strcat((char *)systemPayload,(char * )",ConfigCheckTime:  ");
 804ee24:	4620      	mov	r0, r4
 804ee26:	f7f1 f9ed 	bl	8040204 <strlen>
 804ee2a:	4607      	mov	r7, r0
 804ee2c:	1826      	adds	r6, r4, r0
 804ee2e:	4d39      	ldr	r5, [pc, #228]	; (804ef14 <getSystemDataString+0x2c0>)
 804ee30:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 804ee32:	51e0      	str	r0, [r4, r7]
 804ee34:	6071      	str	r1, [r6, #4]
 804ee36:	60b2      	str	r2, [r6, #8]
 804ee38:	60f3      	str	r3, [r6, #12]
 804ee3a:	6828      	ldr	r0, [r5, #0]
 804ee3c:	6130      	str	r0, [r6, #16]
			strcat((char *)systemPayload,(char * )temp_array);
 804ee3e:	a901      	add	r1, sp, #4
 804ee40:	4620      	mov	r0, r4
 804ee42:	f002 fe43 	bl	8051acc <strcat>
			strcat((char *)systemPayload,(char * )PAYLOAD_SEPARATOR);
 804ee46:	4620      	mov	r0, r4
 804ee48:	f7f1 f9dc 	bl	8040204 <strlen>
 804ee4c:	4b22      	ldr	r3, [pc, #136]	; (804eed8 <getSystemDataString+0x284>)
 804ee4e:	881b      	ldrh	r3, [r3, #0]
 804ee50:	5223      	strh	r3, [r4, r0]
			strcat((char *)systemPayload,gau8TempMBPayloadString);
 804ee52:	4d31      	ldr	r5, [pc, #196]	; (804ef18 <getSystemDataString+0x2c4>)
 804ee54:	4629      	mov	r1, r5
 804ee56:	4620      	mov	r0, r4
 804ee58:	f002 fe38 	bl	8051acc <strcat>
			strcat((char *)systemPayload,(char * )END_OF_FRAME);
 804ee5c:	4620      	mov	r0, r4
 804ee5e:	f7f1 f9d1 	bl	8040204 <strlen>
 804ee62:	4b2e      	ldr	r3, [pc, #184]	; (804ef1c <getSystemDataString+0x2c8>)
 804ee64:	881b      	ldrh	r3, [r3, #0]
 804ee66:	5223      	strh	r3, [r4, r0]
			gu32TempLoopCounter = 0;
 804ee68:	2100      	movs	r1, #0
 804ee6a:	4b14      	ldr	r3, [pc, #80]	; (804eebc <getSystemDataString+0x268>)
 804ee6c:	6159      	str	r1, [r3, #20]
			memset(gau8TempMBPayloadString,0x00,sizeof(char) * gu32MBDataByteCounterLimit);
 804ee6e:	4b0f      	ldr	r3, [pc, #60]	; (804eeac <getSystemDataString+0x258>)
 804ee70:	681a      	ldr	r2, [r3, #0]
 804ee72:	4628      	mov	r0, r5
 804ee74:	f002 fdd4 	bl	8051a20 <memset>
 804ee78:	e728      	b.n	804eccc <getSystemDataString+0x78>
				strcat((char *)systemPayload,(char * )gcSystemSupplyVoltage);
 804ee7a:	4929      	ldr	r1, [pc, #164]	; (804ef20 <getSystemDataString+0x2cc>)
 804ee7c:	4620      	mov	r0, r4
 804ee7e:	f002 fe25 	bl	8051acc <strcat>
				strcat((char *)systemPayload,(char * )PAYLOAD_SEPARATOR);
 804ee82:	4620      	mov	r0, r4
 804ee84:	f7f1 f9be 	bl	8040204 <strlen>
 804ee88:	4b13      	ldr	r3, [pc, #76]	; (804eed8 <getSystemDataString+0x284>)
 804ee8a:	881b      	ldrh	r3, [r3, #0]
 804ee8c:	5223      	strh	r3, [r4, r0]
 804ee8e:	e793      	b.n	804edb8 <getSystemDataString+0x164>
				strcat((char *)systemPayload,gpu8Norssi);
 804ee90:	4b0f      	ldr	r3, [pc, #60]	; (804eed0 <getSystemDataString+0x27c>)
 804ee92:	f8d3 1170 	ldr.w	r1, [r3, #368]	; 0x170
 804ee96:	4620      	mov	r0, r4
 804ee98:	f002 fe18 	bl	8051acc <strcat>
 804ee9c:	e7b2      	b.n	804ee04 <getSystemDataString+0x1b0>
 804ee9e:	bf00      	nop
 804eea0:	2000eb5c 	.word	0x2000eb5c
 804eea4:	20003688 	.word	0x20003688
 804eea8:	2000eb54 	.word	0x2000eb54
 804eeac:	20004820 	.word	0x20004820
 804eeb0:	2000eb44 	.word	0x2000eb44
 804eeb4:	200047e8 	.word	0x200047e8
 804eeb8:	20004808 	.word	0x20004808
 804eebc:	20004d14 	.word	0x20004d14
 804eec0:	20004334 	.word	0x20004334
 804eec4:	2000c398 	.word	0x2000c398
 804eec8:	20003670 	.word	0x20003670
 804eecc:	20003650 	.word	0x20003650
 804eed0:	20002514 	.word	0x20002514
 804eed4:	0805a9fc 	.word	0x0805a9fc
 804eed8:	0805a920 	.word	0x0805a920
 804eedc:	200087e4 	.word	0x200087e4
 804eee0:	0805a8b4 	.word	0x0805a8b4
 804eee4:	20005084 	.word	0x20005084
 804eee8:	0805a900 	.word	0x0805a900
 804eeec:	20005050 	.word	0x20005050
 804eef0:	0805aa0c 	.word	0x0805aa0c
 804eef4:	20004fa0 	.word	0x20004fa0
 804eef8:	2000eb3c 	.word	0x2000eb3c
 804eefc:	20004d20 	.word	0x20004d20
 804ef00:	0805aa60 	.word	0x0805aa60
 804ef04:	200025cc 	.word	0x200025cc
 804ef08:	2000c42e 	.word	0x2000c42e
 804ef0c:	20005184 	.word	0x20005184
 804ef10:	10624dd3 	.word	0x10624dd3
 804ef14:	0805aa64 	.word	0x0805aa64
 804ef18:	200020c8 	.word	0x200020c8
 804ef1c:	0805aa4c 	.word	0x0805aa4c
 804ef20:	2000eb4c 	.word	0x2000eb4c
			strcat((char *)systemPayload,(char * )START_OF_FRAME);
 804ef24:	4620      	mov	r0, r4
 804ef26:	f7f1 f96d 	bl	8040204 <strlen>
 804ef2a:	4b83      	ldr	r3, [pc, #524]	; (804f138 <getSystemDataString+0x4e4>)
 804ef2c:	881b      	ldrh	r3, [r3, #0]
 804ef2e:	5223      	strh	r3, [r4, r0]
			strcat((char *)systemPayload,(char * )PAYLOAD_SEPARATOR);
 804ef30:	4620      	mov	r0, r4
 804ef32:	f7f1 f967 	bl	8040204 <strlen>
 804ef36:	4b81      	ldr	r3, [pc, #516]	; (804f13c <getSystemDataString+0x4e8>)
 804ef38:	881d      	ldrh	r5, [r3, #0]
 804ef3a:	5225      	strh	r5, [r4, r0]
			strcat((char *)systemPayload,(char * )dinfo);
 804ef3c:	4980      	ldr	r1, [pc, #512]	; (804f140 <getSystemDataString+0x4ec>)
 804ef3e:	4620      	mov	r0, r4
 804ef40:	f002 fdc4 	bl	8051acc <strcat>
			strcat((char *)systemPayload,(char * )"_RTU");
 804ef44:	4620      	mov	r0, r4
 804ef46:	f7f1 f95d 	bl	8040204 <strlen>
 804ef4a:	4603      	mov	r3, r0
 804ef4c:	1821      	adds	r1, r4, r0
 804ef4e:	4a7d      	ldr	r2, [pc, #500]	; (804f144 <getSystemDataString+0x4f0>)
 804ef50:	6810      	ldr	r0, [r2, #0]
 804ef52:	50e0      	str	r0, [r4, r3]
 804ef54:	7913      	ldrb	r3, [r2, #4]
 804ef56:	710b      	strb	r3, [r1, #4]
			strcat((char *)systemPayload,(char * )PAYLOAD_SEPARATOR);
 804ef58:	4620      	mov	r0, r4
 804ef5a:	f7f1 f953 	bl	8040204 <strlen>
 804ef5e:	5225      	strh	r5, [r4, r0]
			strcat((char *)systemPayload,(char * )MODEL_NUMBER);
 804ef60:	4620      	mov	r0, r4
 804ef62:	f7f1 f94f 	bl	8040204 <strlen>
 804ef66:	4603      	mov	r3, r0
 804ef68:	1826      	adds	r6, r4, r0
 804ef6a:	4a77      	ldr	r2, [pc, #476]	; (804f148 <getSystemDataString+0x4f4>)
 804ef6c:	ca03      	ldmia	r2!, {r0, r1}
 804ef6e:	50e0      	str	r0, [r4, r3]
 804ef70:	6071      	str	r1, [r6, #4]
			strcat((char *)systemPayload,(char * )PAYLOAD_SEPARATOR);
 804ef72:	4620      	mov	r0, r4
 804ef74:	f7f1 f946 	bl	8040204 <strlen>
 804ef78:	5225      	strh	r5, [r4, r0]
			strcat((char *)systemPayload,(char * )gau8Date);
 804ef7a:	4974      	ldr	r1, [pc, #464]	; (804f14c <getSystemDataString+0x4f8>)
 804ef7c:	4620      	mov	r0, r4
 804ef7e:	f002 fda5 	bl	8051acc <strcat>
			strcat((char *)systemPayload,(char * )RTC_DATESEPARATOR);
 804ef82:	4620      	mov	r0, r4
 804ef84:	f7f1 f93e 	bl	8040204 <strlen>
 804ef88:	4b71      	ldr	r3, [pc, #452]	; (804f150 <getSystemDataString+0x4fc>)
 804ef8a:	881e      	ldrh	r6, [r3, #0]
 804ef8c:	5226      	strh	r6, [r4, r0]
			strcat((char *)systemPayload,(char * )gau8Month);
 804ef8e:	4971      	ldr	r1, [pc, #452]	; (804f154 <getSystemDataString+0x500>)
 804ef90:	4620      	mov	r0, r4
 804ef92:	f002 fd9b 	bl	8051acc <strcat>
			strcat((char *)systemPayload,(char * )RTC_DATESEPARATOR);
 804ef96:	4620      	mov	r0, r4
 804ef98:	f7f1 f934 	bl	8040204 <strlen>
 804ef9c:	5226      	strh	r6, [r4, r0]
			strcat((char *)systemPayload,(char * )gau8Year);
 804ef9e:	496e      	ldr	r1, [pc, #440]	; (804f158 <getSystemDataString+0x504>)
 804efa0:	4620      	mov	r0, r4
 804efa2:	f002 fd93 	bl	8051acc <strcat>
			strcat((char *)systemPayload,(char * )RTC_PARAM_SEPARATOR);
 804efa6:	4620      	mov	r0, r4
 804efa8:	f7f1 f92c 	bl	8040204 <strlen>
 804efac:	4b6b      	ldr	r3, [pc, #428]	; (804f15c <getSystemDataString+0x508>)
 804efae:	881b      	ldrh	r3, [r3, #0]
 804efb0:	5223      	strh	r3, [r4, r0]
			strcat((char *)systemPayload,(char * )gau8Hour);
 804efb2:	496b      	ldr	r1, [pc, #428]	; (804f160 <getSystemDataString+0x50c>)
 804efb4:	4620      	mov	r0, r4
 804efb6:	f002 fd89 	bl	8051acc <strcat>
			strcat((char *)systemPayload,(char * )RTC_TIMESEPARATOR);
 804efba:	4620      	mov	r0, r4
 804efbc:	f7f1 f922 	bl	8040204 <strlen>
 804efc0:	4b68      	ldr	r3, [pc, #416]	; (804f164 <getSystemDataString+0x510>)
 804efc2:	881e      	ldrh	r6, [r3, #0]
 804efc4:	5226      	strh	r6, [r4, r0]
			strcat((char *)systemPayload,(char * )gau8Minutes);
 804efc6:	4968      	ldr	r1, [pc, #416]	; (804f168 <getSystemDataString+0x514>)
 804efc8:	4620      	mov	r0, r4
 804efca:	f002 fd7f 	bl	8051acc <strcat>
			strcat((char *)systemPayload,(char * )RTC_TIMESEPARATOR);
 804efce:	4620      	mov	r0, r4
 804efd0:	f7f1 f918 	bl	8040204 <strlen>
 804efd4:	5226      	strh	r6, [r4, r0]
			strcat((char *)systemPayload,(char * )gau8Seconds);
 804efd6:	4965      	ldr	r1, [pc, #404]	; (804f16c <getSystemDataString+0x518>)
 804efd8:	4620      	mov	r0, r4
 804efda:	f002 fd77 	bl	8051acc <strcat>
			strcat((char *)systemPayload,(char * )PAYLOAD_SEPARATOR);
 804efde:	4620      	mov	r0, r4
 804efe0:	f7f1 f910 	bl	8040204 <strlen>
 804efe4:	5225      	strh	r5, [r4, r0]
			strcat((char *)systemPayload,(char * )FIRMWARE_VER);
 804efe6:	4620      	mov	r0, r4
 804efe8:	f7f1 f90c 	bl	8040204 <strlen>
 804efec:	4607      	mov	r7, r0
 804efee:	1826      	adds	r6, r4, r0
 804eff0:	4b5f      	ldr	r3, [pc, #380]	; (804f170 <getSystemDataString+0x51c>)
 804eff2:	cb07      	ldmia	r3!, {r0, r1, r2}
 804eff4:	51e0      	str	r0, [r4, r7]
 804eff6:	6071      	str	r1, [r6, #4]
 804eff8:	60b2      	str	r2, [r6, #8]
 804effa:	881a      	ldrh	r2, [r3, #0]
 804effc:	789b      	ldrb	r3, [r3, #2]
 804effe:	81b2      	strh	r2, [r6, #12]
 804f000:	73b3      	strb	r3, [r6, #14]
			strcat((char *)systemPayload,(char * )PAYLOAD_SEPARATOR);
 804f002:	4620      	mov	r0, r4
 804f004:	f7f1 f8fe 	bl	8040204 <strlen>
 804f008:	5225      	strh	r5, [r4, r0]
			strcat((char *)systemPayload,(char * )gacEthernetLinkStatus);
 804f00a:	495a      	ldr	r1, [pc, #360]	; (804f174 <getSystemDataString+0x520>)
 804f00c:	4620      	mov	r0, r4
 804f00e:	f002 fd5d 	bl	8051acc <strcat>
			strcat((char *)systemPayload,(char * )PAYLOAD_SEPARATOR);
 804f012:	4620      	mov	r0, r4
 804f014:	f7f1 f8f6 	bl	8040204 <strlen>
 804f018:	5225      	strh	r5, [r4, r0]
			strcat((char *)systemPayload,(char * )gacMBDataPointsRTU);
 804f01a:	4957      	ldr	r1, [pc, #348]	; (804f178 <getSystemDataString+0x524>)
 804f01c:	4620      	mov	r0, r4
 804f01e:	f002 fd55 	bl	8051acc <strcat>
			strcat((char *)systemPayload,(char * )PAYLOAD_SEPARATOR);
 804f022:	4620      	mov	r0, r4
 804f024:	f7f1 f8ee 	bl	8040204 <strlen>
 804f028:	5225      	strh	r5, [r4, r0]
			if((float)gfInputSupplyVoltage < 9.00f)
 804f02a:	4b54      	ldr	r3, [pc, #336]	; (804f17c <getSystemDataString+0x528>)
 804f02c:	ed93 7a00 	vldr	s14, [r3]
 804f030:	eef2 7a02 	vmov.f32	s15, #34	; 0x41100000  9.0
 804f034:	eeb4 7ae7 	vcmpe.f32	s14, s15
 804f038:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 804f03c:	d56a      	bpl.n	804f114 <getSystemDataString+0x4c0>
				strcat((char *)systemPayload,(char * )gcBatterySupplyVoltage);
 804f03e:	4950      	ldr	r1, [pc, #320]	; (804f180 <getSystemDataString+0x52c>)
 804f040:	4620      	mov	r0, r4
 804f042:	f002 fd43 	bl	8051acc <strcat>
				strcat((char *)systemPayload,(char * )PAYLOAD_SEPARATOR);
 804f046:	4620      	mov	r0, r4
 804f048:	f7f1 f8dc 	bl	8040204 <strlen>
 804f04c:	4b3b      	ldr	r3, [pc, #236]	; (804f13c <getSystemDataString+0x4e8>)
 804f04e:	881b      	ldrh	r3, [r3, #0]
 804f050:	5223      	strh	r3, [r4, r0]
			strcat((char *)systemPayload,(char * )gacModbusStatusRTU);
 804f052:	494c      	ldr	r1, [pc, #304]	; (804f184 <getSystemDataString+0x530>)
 804f054:	4620      	mov	r0, r4
 804f056:	f002 fd39 	bl	8051acc <strcat>
			strcat((char *)systemPayload,(char * )PAYLOAD_SEPARATOR);
 804f05a:	4620      	mov	r0, r4
 804f05c:	f7f1 f8d2 	bl	8040204 <strlen>
 804f060:	4b36      	ldr	r3, [pc, #216]	; (804f13c <getSystemDataString+0x4e8>)
 804f062:	881d      	ldrh	r5, [r3, #0]
 804f064:	5225      	strh	r5, [r4, r0]
			strcat((char *)systemPayload,"RT,");
 804f066:	4620      	mov	r0, r4
 804f068:	f7f1 f8cc 	bl	8040204 <strlen>
 804f06c:	4603      	mov	r3, r0
 804f06e:	4a46      	ldr	r2, [pc, #280]	; (804f188 <getSystemDataString+0x534>)
 804f070:	6810      	ldr	r0, [r2, #0]
 804f072:	50e0      	str	r0, [r4, r3]
			strcat((char *)systemPayload,(char * )PAYLOAD_SEPARATOR);
 804f074:	4620      	mov	r0, r4
 804f076:	f7f1 f8c5 	bl	8040204 <strlen>
 804f07a:	5225      	strh	r5, [r4, r0]
			strcat((char *)systemPayload,(char * )agpsLastLocationDataFormatted);
 804f07c:	4943      	ldr	r1, [pc, #268]	; (804f18c <getSystemDataString+0x538>)
 804f07e:	4620      	mov	r0, r4
 804f080:	f002 fd24 	bl	8051acc <strcat>
			strcat((char *)systemPayload,(char * )PAYLOAD_SEPARATOR);
 804f084:	4620      	mov	r0, r4
 804f086:	f7f1 f8bd 	bl	8040204 <strlen>
 804f08a:	5225      	strh	r5, [r4, r0]
			if(strlen(gsmInstance.agsmSignalStrength ) > 0)
 804f08c:	4b40      	ldr	r3, [pc, #256]	; (804f190 <getSystemDataString+0x53c>)
 804f08e:	f893 3096 	ldrb.w	r3, [r3, #150]	; 0x96
 804f092:	2b00      	cmp	r3, #0
 804f094:	d049      	beq.n	804f12a <getSystemDataString+0x4d6>
				strcat((char *)systemPayload,(char * )gsmInstance.agsmSignalStrength);
 804f096:	493f      	ldr	r1, [pc, #252]	; (804f194 <getSystemDataString+0x540>)
 804f098:	4620      	mov	r0, r4
 804f09a:	f002 fd17 	bl	8051acc <strcat>
			u32TempVar = gu32GSMConfigCheckTimer / 1000;
 804f09e:	4b3e      	ldr	r3, [pc, #248]	; (804f198 <getSystemDataString+0x544>)
 804f0a0:	681d      	ldr	r5, [r3, #0]
 804f0a2:	4b3e      	ldr	r3, [pc, #248]	; (804f19c <getSystemDataString+0x548>)
 804f0a4:	fba3 3505 	umull	r3, r5, r3, r5
 804f0a8:	09ad      	lsrs	r5, r5, #6
			memset(temp_array, 0, sizeof(temp_array));
 804f0aa:	2232      	movs	r2, #50	; 0x32
 804f0ac:	2100      	movs	r1, #0
 804f0ae:	a801      	add	r0, sp, #4
 804f0b0:	f002 fcb6 	bl	8051a20 <memset>
			itoa(u32TempVar, temp_array, 10);
 804f0b4:	220a      	movs	r2, #10
 804f0b6:	a901      	add	r1, sp, #4
 804f0b8:	4628      	mov	r0, r5
 804f0ba:	f002 fa41 	bl	8051540 <itoa>
			strcat((char *)systemPayload,(char * )",ConfigCheckTime ");
 804f0be:	4620      	mov	r0, r4
 804f0c0:	f7f1 f8a0 	bl	8040204 <strlen>
 804f0c4:	4607      	mov	r7, r0
 804f0c6:	1826      	adds	r6, r4, r0
 804f0c8:	4d35      	ldr	r5, [pc, #212]	; (804f1a0 <getSystemDataString+0x54c>)
 804f0ca:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 804f0cc:	51e0      	str	r0, [r4, r7]
 804f0ce:	6071      	str	r1, [r6, #4]
 804f0d0:	60b2      	str	r2, [r6, #8]
 804f0d2:	60f3      	str	r3, [r6, #12]
 804f0d4:	882b      	ldrh	r3, [r5, #0]
 804f0d6:	8233      	strh	r3, [r6, #16]
			strcat((char *)systemPayload,(char * )temp_array);
 804f0d8:	a901      	add	r1, sp, #4
 804f0da:	4620      	mov	r0, r4
 804f0dc:	f002 fcf6 	bl	8051acc <strcat>
			strcat((char *)systemPayload,(char * )PAYLOAD_SEPARATOR);
 804f0e0:	4620      	mov	r0, r4
 804f0e2:	f7f1 f88f 	bl	8040204 <strlen>
 804f0e6:	4b15      	ldr	r3, [pc, #84]	; (804f13c <getSystemDataString+0x4e8>)
 804f0e8:	881b      	ldrh	r3, [r3, #0]
 804f0ea:	5223      	strh	r3, [r4, r0]
			strcat((char *)systemPayload,gau8TempMBRTUPayloadString);
 804f0ec:	4d2d      	ldr	r5, [pc, #180]	; (804f1a4 <getSystemDataString+0x550>)
 804f0ee:	4629      	mov	r1, r5
 804f0f0:	4620      	mov	r0, r4
 804f0f2:	f002 fceb 	bl	8051acc <strcat>
			strcat((char *)systemPayload,(char * )END_OF_FRAME);
 804f0f6:	4620      	mov	r0, r4
 804f0f8:	f7f1 f884 	bl	8040204 <strlen>
 804f0fc:	4b2a      	ldr	r3, [pc, #168]	; (804f1a8 <getSystemDataString+0x554>)
 804f0fe:	881b      	ldrh	r3, [r3, #0]
 804f100:	5223      	strh	r3, [r4, r0]
			gu32TempLoopCounter = 0;
 804f102:	2100      	movs	r1, #0
 804f104:	4b29      	ldr	r3, [pc, #164]	; (804f1ac <getSystemDataString+0x558>)
 804f106:	6159      	str	r1, [r3, #20]
			memset(gau8TempMBRTUPayloadString,0x00,sizeof(char) * gu32MBDataByteCounterLimitRTU);
 804f108:	4b29      	ldr	r3, [pc, #164]	; (804f1b0 <getSystemDataString+0x55c>)
 804f10a:	681a      	ldr	r2, [r3, #0]
 804f10c:	4628      	mov	r0, r5
 804f10e:	f002 fc87 	bl	8051a20 <memset>
		return systemPayload;
 804f112:	e5e0      	b.n	804ecd6 <getSystemDataString+0x82>
				strcat((char *)systemPayload,(char * )gcSystemSupplyVoltage);
 804f114:	4927      	ldr	r1, [pc, #156]	; (804f1b4 <getSystemDataString+0x560>)
 804f116:	4620      	mov	r0, r4
 804f118:	f002 fcd8 	bl	8051acc <strcat>
				strcat((char *)systemPayload,(char * )PAYLOAD_SEPARATOR);
 804f11c:	4620      	mov	r0, r4
 804f11e:	f7f1 f871 	bl	8040204 <strlen>
 804f122:	4b06      	ldr	r3, [pc, #24]	; (804f13c <getSystemDataString+0x4e8>)
 804f124:	881b      	ldrh	r3, [r3, #0]
 804f126:	5223      	strh	r3, [r4, r0]
 804f128:	e793      	b.n	804f052 <getSystemDataString+0x3fe>
				strcat((char *)systemPayload,gpu8Norssi);
 804f12a:	4b23      	ldr	r3, [pc, #140]	; (804f1b8 <getSystemDataString+0x564>)
 804f12c:	f8d3 1170 	ldr.w	r1, [r3, #368]	; 0x170
 804f130:	4620      	mov	r0, r4
 804f132:	f002 fccb 	bl	8051acc <strcat>
 804f136:	e7b2      	b.n	804f09e <getSystemDataString+0x44a>
 804f138:	0805a9fc 	.word	0x0805a9fc
 804f13c:	0805a920 	.word	0x0805a920
 804f140:	200087e4 	.word	0x200087e4
 804f144:	0805aa78 	.word	0x0805aa78
 804f148:	0805a8b4 	.word	0x0805a8b4
 804f14c:	2000369c 	.word	0x2000369c
 804f150:	0805aa08 	.word	0x0805aa08
 804f154:	20003694 	.word	0x20003694
 804f158:	2000368c 	.word	0x2000368c
 804f15c:	0805a900 	.word	0x0805a900
 804f160:	200036a4 	.word	0x200036a4
 804f164:	0805a9a0 	.word	0x0805a9a0
 804f168:	200036ac 	.word	0x200036ac
 804f16c:	200036b4 	.word	0x200036b4
 804f170:	0805aa0c 	.word	0x0805aa0c
 804f174:	2000eb5c 	.word	0x2000eb5c
 804f178:	2000eb44 	.word	0x2000eb44
 804f17c:	20004fa0 	.word	0x20004fa0
 804f180:	2000eb3c 	.word	0x2000eb3c
 804f184:	20004d24 	.word	0x20004d24
 804f188:	0805aa80 	.word	0x0805aa80
 804f18c:	200025cc 	.word	0x200025cc
 804f190:	2000c398 	.word	0x2000c398
 804f194:	2000c42e 	.word	0x2000c42e
 804f198:	20005184 	.word	0x20005184
 804f19c:	10624dd3 	.word	0x10624dd3
 804f1a0:	0805aa84 	.word	0x0805aa84
 804f1a4:	200014a8 	.word	0x200014a8
 804f1a8:	0805aa4c 	.word	0x0805aa4c
 804f1ac:	20004d14 	.word	0x20004d14
 804f1b0:	200047e8 	.word	0x200047e8
 804f1b4:	2000eb4c 	.word	0x2000eb4c
 804f1b8:	20002514 	.word	0x20002514

0804f1bc <enqueue>:
* <hr>
*
*******************************************************************************/
void enqueue(strctQUEUE * queue,char * data)
{
	if(data != NULL)
 804f1bc:	b1d9      	cbz	r1, 804f1f6 <enqueue+0x3a>
{
 804f1be:	b538      	push	{r3, r4, r5, lr}
 804f1c0:	4604      	mov	r4, r0
 804f1c2:	460d      	mov	r5, r1
	{
		if(queue->head == (MAX_QUEUE_SIZE))
 804f1c4:	6803      	ldr	r3, [r0, #0]
 804f1c6:	2b0a      	cmp	r3, #10
 804f1c8:	d012      	beq.n	804f1f0 <enqueue+0x34>
		{
			/*Queue Overflow */
			queue->head = 0;
		}
		/* If queue has data overwrite it */
		if(queue->data[queue->head] != NULL)
 804f1ca:	6823      	ldr	r3, [r4, #0]
 804f1cc:	3302      	adds	r3, #2
 804f1ce:	f854 0023 	ldr.w	r0, [r4, r3, lsl #2]
 804f1d2:	b130      	cbz	r0, 804f1e2 <enqueue+0x26>
		{
			free(queue->data[queue->head]);
 804f1d4:	f002 f9be 	bl	8051554 <free>
			queue->data[queue->head] = NULL;
 804f1d8:	6823      	ldr	r3, [r4, #0]
 804f1da:	3302      	adds	r3, #2
 804f1dc:	2200      	movs	r2, #0
 804f1de:	f844 2023 	str.w	r2, [r4, r3, lsl #2]
		}
		queue->data[queue->head]= data;
 804f1e2:	6823      	ldr	r3, [r4, #0]
 804f1e4:	1c9a      	adds	r2, r3, #2
 804f1e6:	f844 5022 	str.w	r5, [r4, r2, lsl #2]
		queue->head++;
 804f1ea:	3301      	adds	r3, #1
 804f1ec:	6023      	str	r3, [r4, #0]
	else
	{
		/* Log Error */
		//Error_Callback(enmERROR_ENQUEUE);
	}
}
 804f1ee:	bd38      	pop	{r3, r4, r5, pc}
			queue->head = 0;
 804f1f0:	2300      	movs	r3, #0
 804f1f2:	6003      	str	r3, [r0, #0]
 804f1f4:	e7e9      	b.n	804f1ca <enqueue+0xe>
 804f1f6:	4770      	bx	lr

0804f1f8 <dequeue>:
* </table><br><br>
* <hr>
*
*******************************************************************************/
void dequeue(strctQUEUE * queue)
{
 804f1f8:	b510      	push	{r4, lr}
 804f1fa:	4604      	mov	r4, r0
	/* After data is uploaded free the pointer in queue->data */
    if(((queue->tail == 0) && (queue->head == 0)) || (queue->tail == queue->head))
 804f1fc:	6843      	ldr	r3, [r0, #4]
 804f1fe:	b90b      	cbnz	r3, 804f204 <dequeue+0xc>
 804f200:	6802      	ldr	r2, [r0, #0]
 804f202:	b112      	cbz	r2, 804f20a <dequeue+0x12>
 804f204:	6822      	ldr	r2, [r4, #0]
 804f206:	4293      	cmp	r3, r2
 804f208:	d100      	bne.n	804f20c <dequeue+0x14>
        free(queue->data[queue->tail]);
        queue->data[queue->tail] = NULL;
        queue->tail++;
        if(queue->tail > (MAX_QUEUE_SIZE-1)) queue->tail=0;
    }
}
 804f20a:	bd10      	pop	{r4, pc}
        free(queue->data[queue->tail]);
 804f20c:	3302      	adds	r3, #2
 804f20e:	f854 0023 	ldr.w	r0, [r4, r3, lsl #2]
 804f212:	f002 f99f 	bl	8051554 <free>
        queue->data[queue->tail] = NULL;
 804f216:	6863      	ldr	r3, [r4, #4]
 804f218:	1c9a      	adds	r2, r3, #2
 804f21a:	2100      	movs	r1, #0
 804f21c:	f844 1022 	str.w	r1, [r4, r2, lsl #2]
        queue->tail++;
 804f220:	3301      	adds	r3, #1
 804f222:	6063      	str	r3, [r4, #4]
        if(queue->tail > (MAX_QUEUE_SIZE-1)) queue->tail=0;
 804f224:	2b09      	cmp	r3, #9
 804f226:	ddf0      	ble.n	804f20a <dequeue+0x12>
 804f228:	6061      	str	r1, [r4, #4]
}
 804f22a:	e7ee      	b.n	804f20a <dequeue+0x12>

0804f22c <isQueueEmpty>:
* <hr>
*
*******************************************************************************/
uint32_t isQueueEmpty(strctQUEUE * queue)
{
	return((queue->head) == (queue->tail));
 804f22c:	6802      	ldr	r2, [r0, #0]
 804f22e:	6840      	ldr	r0, [r0, #4]
}
 804f230:	4282      	cmp	r2, r0
 804f232:	bf14      	ite	ne
 804f234:	2000      	movne	r0, #0
 804f236:	2001      	moveq	r0, #1
 804f238:	4770      	bx	lr
	...

0804f23c <verifyNetworkConfigData>:
* </table><br><br>
* <hr>
*
*******************************************************************************/
static void verifyNetworkConfigData(void)
{
 804f23c:	b510      	push	{r4, lr}
	/*Log Errors Related to */
	if(atoi(gau8ConfigNewtorkIsEnabled) > 2)
 804f23e:	4858      	ldr	r0, [pc, #352]	; (804f3a0 <verifyNetworkConfigData+0x164>)
 804f240:	f002 f93e 	bl	80514c0 <atoi>
 804f244:	2802      	cmp	r0, #2
 804f246:	dd62      	ble.n	804f30e <verifyNetworkConfigData+0xd2>
		gu32ConfigNetworkErrorDatabase |= (1 << enmCONFIG_NWISENABLED);
 804f248:	4a55      	ldr	r2, [pc, #340]	; (804f3a0 <verifyNetworkConfigData+0x164>)
 804f24a:	6853      	ldr	r3, [r2, #4]
 804f24c:	f043 0302 	orr.w	r3, r3, #2
 804f250:	6053      	str	r3, [r2, #4]
	else
		gu32ConfigNetworkErrorDatabase &= ~(1 << enmCONFIG_NWISENABLED);

	if(strlen(gau8ConfigNewtorkServerURL) > 150)
 804f252:	4854      	ldr	r0, [pc, #336]	; (804f3a4 <verifyNetworkConfigData+0x168>)
 804f254:	f7f0 ffd6 	bl	8040204 <strlen>
 804f258:	2896      	cmp	r0, #150	; 0x96
 804f25a:	d95e      	bls.n	804f31a <verifyNetworkConfigData+0xde>
		gu32ConfigNetworkErrorDatabase |= (1 << enmCONFIG_NWSERURLLEN);
 804f25c:	4a50      	ldr	r2, [pc, #320]	; (804f3a0 <verifyNetworkConfigData+0x164>)
 804f25e:	6853      	ldr	r3, [r2, #4]
 804f260:	f043 0304 	orr.w	r3, r3, #4
 804f264:	6053      	str	r3, [r2, #4]
	else
		gu32ConfigNetworkErrorDatabase &= ~(1 << enmCONFIG_NWSERURLLEN);

	if(strlen(gau8ConfigNewtorkConfigURL) > 150)
 804f266:	4850      	ldr	r0, [pc, #320]	; (804f3a8 <verifyNetworkConfigData+0x16c>)
 804f268:	f7f0 ffcc 	bl	8040204 <strlen>
 804f26c:	2896      	cmp	r0, #150	; 0x96
 804f26e:	d95a      	bls.n	804f326 <verifyNetworkConfigData+0xea>
		gu32ConfigNetworkErrorDatabase |= (1 << enmCONFIG_NWCONFURLLEN);
 804f270:	4a4b      	ldr	r2, [pc, #300]	; (804f3a0 <verifyNetworkConfigData+0x164>)
 804f272:	6853      	ldr	r3, [r2, #4]
 804f274:	f043 0308 	orr.w	r3, r3, #8
 804f278:	6053      	str	r3, [r2, #4]
	else
		gu32ConfigNetworkErrorDatabase &= ~(1 << enmCONFIG_NWCONFURLLEN);

	if(strlen(gau8ConfigNewtorkAPN) > 50)
 804f27a:	484c      	ldr	r0, [pc, #304]	; (804f3ac <verifyNetworkConfigData+0x170>)
 804f27c:	f7f0 ffc2 	bl	8040204 <strlen>
 804f280:	2832      	cmp	r0, #50	; 0x32
 804f282:	d956      	bls.n	804f332 <verifyNetworkConfigData+0xf6>
		gu32ConfigNetworkErrorDatabase |= (1 << enmCONFIG_NWAPN);
 804f284:	4a46      	ldr	r2, [pc, #280]	; (804f3a0 <verifyNetworkConfigData+0x164>)
 804f286:	6853      	ldr	r3, [r2, #4]
 804f288:	f043 0310 	orr.w	r3, r3, #16
 804f28c:	6053      	str	r3, [r2, #4]
	else
		gu32ConfigNetworkErrorDatabase &= ~(1 << enmCONFIG_NWAPN);

	if(atoi(gau8ConfigNewtorkUpFreqSupply) > 10000000)
 804f28e:	4848      	ldr	r0, [pc, #288]	; (804f3b0 <verifyNetworkConfigData+0x174>)
 804f290:	f002 f916 	bl	80514c0 <atoi>
 804f294:	4b47      	ldr	r3, [pc, #284]	; (804f3b4 <verifyNetworkConfigData+0x178>)
 804f296:	4298      	cmp	r0, r3
 804f298:	dd51      	ble.n	804f33e <verifyNetworkConfigData+0x102>
		gu32ConfigNetworkErrorDatabase |= (1 << enmCONFIG_NWUPFREQSUPPLY);
 804f29a:	4a41      	ldr	r2, [pc, #260]	; (804f3a0 <verifyNetworkConfigData+0x164>)
 804f29c:	6853      	ldr	r3, [r2, #4]
 804f29e:	f043 0320 	orr.w	r3, r3, #32
 804f2a2:	6053      	str	r3, [r2, #4]
	{
		gu32UploadTimeSupply = atoi(gau8ConfigNewtorkUpFreqSupply);
		gu32ConfigNetworkErrorDatabase &= ~(1 << enmCONFIG_NWUPFREQSUPPLY);
	}

	if(atoi(gau8ConfigNewtorkUpFreqBatt) > 10000000)
 804f2a4:	4844      	ldr	r0, [pc, #272]	; (804f3b8 <verifyNetworkConfigData+0x17c>)
 804f2a6:	f002 f90b 	bl	80514c0 <atoi>
 804f2aa:	4b42      	ldr	r3, [pc, #264]	; (804f3b4 <verifyNetworkConfigData+0x178>)
 804f2ac:	4298      	cmp	r0, r3
 804f2ae:	dd52      	ble.n	804f356 <verifyNetworkConfigData+0x11a>
		gu32ConfigNetworkErrorDatabase |= (1 << enmCONFIG_NWUPFREQBATT);
 804f2b0:	4a3b      	ldr	r2, [pc, #236]	; (804f3a0 <verifyNetworkConfigData+0x164>)
 804f2b2:	6853      	ldr	r3, [r2, #4]
 804f2b4:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 804f2b8:	6053      	str	r3, [r2, #4]
	else
	{
		gu32UploadTimeBatt = atoi(gau8ConfigNewtorkUpFreqBatt);
		gu32ConfigNetworkErrorDatabase &= ~(1 << enmCONFIG_NWUPFREQBATT);
	}
	if(atoi(gau8ConfigNewtorkType) > 2)
 804f2ba:	4840      	ldr	r0, [pc, #256]	; (804f3bc <verifyNetworkConfigData+0x180>)
 804f2bc:	f002 f900 	bl	80514c0 <atoi>
 804f2c0:	2802      	cmp	r0, #2
 804f2c2:	dd54      	ble.n	804f36e <verifyNetworkConfigData+0x132>
		gu32ConfigNetworkErrorDatabase |= (1 << enmCONFIG_NWTYPE);
 804f2c4:	4a36      	ldr	r2, [pc, #216]	; (804f3a0 <verifyNetworkConfigData+0x164>)
 804f2c6:	6853      	ldr	r3, [r2, #4]
 804f2c8:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 804f2cc:	6053      	str	r3, [r2, #4]
	else
		gu32ConfigNetworkErrorDatabase &= ~(1 << enmCONFIG_NWTYPE);

	if(atoi(gau8ConfigNewtorkGPSEnable) > 1)
 804f2ce:	483c      	ldr	r0, [pc, #240]	; (804f3c0 <verifyNetworkConfigData+0x184>)
 804f2d0:	f002 f8f6 	bl	80514c0 <atoi>
 804f2d4:	2801      	cmp	r0, #1
 804f2d6:	dd50      	ble.n	804f37a <verifyNetworkConfigData+0x13e>
		gu32ConfigNetworkErrorDatabase |= (1 << enmCONFIG_NWGPSEN);
 804f2d8:	4a31      	ldr	r2, [pc, #196]	; (804f3a0 <verifyNetworkConfigData+0x164>)
 804f2da:	6853      	ldr	r3, [r2, #4]
 804f2dc:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 804f2e0:	6053      	str	r3, [r2, #4]
	else
		gu32ConfigNetworkErrorDatabase &= ~(1 << enmCONFIG_NWGPSEN);

	if(atoi(gau8ConfigNewtorkSendData) > 1)
 804f2e2:	4838      	ldr	r0, [pc, #224]	; (804f3c4 <verifyNetworkConfigData+0x188>)
 804f2e4:	f002 f8ec 	bl	80514c0 <atoi>
 804f2e8:	2801      	cmp	r0, #1
 804f2ea:	dd4c      	ble.n	804f386 <verifyNetworkConfigData+0x14a>
		gu32ConfigNetworkErrorDatabase |= (1 << enmCONFIG_NWSENDDATAEN);
 804f2ec:	4a2c      	ldr	r2, [pc, #176]	; (804f3a0 <verifyNetworkConfigData+0x164>)
 804f2ee:	6853      	ldr	r3, [r2, #4]
 804f2f0:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 804f2f4:	6053      	str	r3, [r2, #4]
	else
		gu32ConfigNetworkErrorDatabase &= ~(1 << enmCONFIG_NWSENDDATAEN);

	if(atoi(gau8ConfigNewtorkSendDataDisableTime) > 10000000)
 804f2f6:	4834      	ldr	r0, [pc, #208]	; (804f3c8 <verifyNetworkConfigData+0x18c>)
 804f2f8:	f002 f8e2 	bl	80514c0 <atoi>
 804f2fc:	4b2d      	ldr	r3, [pc, #180]	; (804f3b4 <verifyNetworkConfigData+0x178>)
 804f2fe:	4298      	cmp	r0, r3
 804f300:	dd47      	ble.n	804f392 <verifyNetworkConfigData+0x156>
		gu32ConfigNetworkErrorDatabase |= (1 << enmCONFIG_NWSENDDATADISABLE);
 804f302:	4a27      	ldr	r2, [pc, #156]	; (804f3a0 <verifyNetworkConfigData+0x164>)
 804f304:	6853      	ldr	r3, [r2, #4]
 804f306:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 804f30a:	6053      	str	r3, [r2, #4]
	else
		gu32ConfigNetworkErrorDatabase &= ~(1 << enmCONFIG_NWSENDDATADISABLE);

}
 804f30c:	bd10      	pop	{r4, pc}
		gu32ConfigNetworkErrorDatabase &= ~(1 << enmCONFIG_NWISENABLED);
 804f30e:	4a24      	ldr	r2, [pc, #144]	; (804f3a0 <verifyNetworkConfigData+0x164>)
 804f310:	6853      	ldr	r3, [r2, #4]
 804f312:	f023 0302 	bic.w	r3, r3, #2
 804f316:	6053      	str	r3, [r2, #4]
 804f318:	e79b      	b.n	804f252 <verifyNetworkConfigData+0x16>
		gu32ConfigNetworkErrorDatabase &= ~(1 << enmCONFIG_NWSERURLLEN);
 804f31a:	4a21      	ldr	r2, [pc, #132]	; (804f3a0 <verifyNetworkConfigData+0x164>)
 804f31c:	6853      	ldr	r3, [r2, #4]
 804f31e:	f023 0304 	bic.w	r3, r3, #4
 804f322:	6053      	str	r3, [r2, #4]
 804f324:	e79f      	b.n	804f266 <verifyNetworkConfigData+0x2a>
		gu32ConfigNetworkErrorDatabase &= ~(1 << enmCONFIG_NWCONFURLLEN);
 804f326:	4a1e      	ldr	r2, [pc, #120]	; (804f3a0 <verifyNetworkConfigData+0x164>)
 804f328:	6853      	ldr	r3, [r2, #4]
 804f32a:	f023 0308 	bic.w	r3, r3, #8
 804f32e:	6053      	str	r3, [r2, #4]
 804f330:	e7a3      	b.n	804f27a <verifyNetworkConfigData+0x3e>
		gu32ConfigNetworkErrorDatabase &= ~(1 << enmCONFIG_NWAPN);
 804f332:	4a1b      	ldr	r2, [pc, #108]	; (804f3a0 <verifyNetworkConfigData+0x164>)
 804f334:	6853      	ldr	r3, [r2, #4]
 804f336:	f023 0310 	bic.w	r3, r3, #16
 804f33a:	6053      	str	r3, [r2, #4]
 804f33c:	e7a7      	b.n	804f28e <verifyNetworkConfigData+0x52>
		gu32UploadTimeSupply = atoi(gau8ConfigNewtorkUpFreqSupply);
 804f33e:	4c18      	ldr	r4, [pc, #96]	; (804f3a0 <verifyNetworkConfigData+0x164>)
 804f340:	f504 709c 	add.w	r0, r4, #312	; 0x138
 804f344:	f002 f8bc 	bl	80514c0 <atoi>
 804f348:	4b18      	ldr	r3, [pc, #96]	; (804f3ac <verifyNetworkConfigData+0x170>)
 804f34a:	6358      	str	r0, [r3, #52]	; 0x34
		gu32ConfigNetworkErrorDatabase &= ~(1 << enmCONFIG_NWUPFREQSUPPLY);
 804f34c:	6863      	ldr	r3, [r4, #4]
 804f34e:	f023 0320 	bic.w	r3, r3, #32
 804f352:	6063      	str	r3, [r4, #4]
 804f354:	e7a6      	b.n	804f2a4 <verifyNetworkConfigData+0x68>
		gu32UploadTimeBatt = atoi(gau8ConfigNewtorkUpFreqBatt);
 804f356:	4c12      	ldr	r4, [pc, #72]	; (804f3a0 <verifyNetworkConfigData+0x164>)
 804f358:	f504 70a2 	add.w	r0, r4, #324	; 0x144
 804f35c:	f002 f8b0 	bl	80514c0 <atoi>
 804f360:	4b12      	ldr	r3, [pc, #72]	; (804f3ac <verifyNetworkConfigData+0x170>)
 804f362:	6398      	str	r0, [r3, #56]	; 0x38
		gu32ConfigNetworkErrorDatabase &= ~(1 << enmCONFIG_NWUPFREQBATT);
 804f364:	6863      	ldr	r3, [r4, #4]
 804f366:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 804f36a:	6063      	str	r3, [r4, #4]
 804f36c:	e7a5      	b.n	804f2ba <verifyNetworkConfigData+0x7e>
		gu32ConfigNetworkErrorDatabase &= ~(1 << enmCONFIG_NWTYPE);
 804f36e:	4a0c      	ldr	r2, [pc, #48]	; (804f3a0 <verifyNetworkConfigData+0x164>)
 804f370:	6853      	ldr	r3, [r2, #4]
 804f372:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 804f376:	6053      	str	r3, [r2, #4]
 804f378:	e7a9      	b.n	804f2ce <verifyNetworkConfigData+0x92>
		gu32ConfigNetworkErrorDatabase &= ~(1 << enmCONFIG_NWGPSEN);
 804f37a:	4a09      	ldr	r2, [pc, #36]	; (804f3a0 <verifyNetworkConfigData+0x164>)
 804f37c:	6853      	ldr	r3, [r2, #4]
 804f37e:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 804f382:	6053      	str	r3, [r2, #4]
 804f384:	e7ad      	b.n	804f2e2 <verifyNetworkConfigData+0xa6>
		gu32ConfigNetworkErrorDatabase &= ~(1 << enmCONFIG_NWSENDDATAEN);
 804f386:	4a06      	ldr	r2, [pc, #24]	; (804f3a0 <verifyNetworkConfigData+0x164>)
 804f388:	6853      	ldr	r3, [r2, #4]
 804f38a:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 804f38e:	6053      	str	r3, [r2, #4]
 804f390:	e7b1      	b.n	804f2f6 <verifyNetworkConfigData+0xba>
		gu32ConfigNetworkErrorDatabase &= ~(1 << enmCONFIG_NWSENDDATADISABLE);
 804f392:	4a03      	ldr	r2, [pc, #12]	; (804f3a0 <verifyNetworkConfigData+0x164>)
 804f394:	6853      	ldr	r3, [r2, #4]
 804f396:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 804f39a:	6053      	str	r3, [r2, #4]
}
 804f39c:	e7b6      	b.n	804f30c <verifyNetworkConfigData+0xd0>
 804f39e:	bf00      	nop
 804f3a0:	20004d2c 	.word	0x20004d2c
 804f3a4:	20004d34 	.word	0x20004d34
 804f3a8:	20004dcc 	.word	0x20004dcc
 804f3ac:	20002694 	.word	0x20002694
 804f3b0:	20004e64 	.word	0x20004e64
 804f3b4:	00989680 	.word	0x00989680
 804f3b8:	20004e70 	.word	0x20004e70
 804f3bc:	20004e7c 	.word	0x20004e7c
 804f3c0:	20004e80 	.word	0x20004e80
 804f3c4:	20004e84 	.word	0x20004e84
 804f3c8:	20004e88 	.word	0x20004e88

0804f3cc <verifyModbus485ConfigData>:
* </table><br><br>
* <hr>
*
*******************************************************************************/
static void verifyModbus485ConfigData(void)
{
 804f3cc:	b538      	push	{r3, r4, r5, lr}
   /* Log Errors Related to Modbus485 Configuration */
	uint32_t u32LoopCounter = 0;

	if(atoi(gau8ConfigModbus485IsEnabled) > 2)
 804f3ce:	48a5      	ldr	r0, [pc, #660]	; (804f664 <verifyModbus485ConfigData+0x298>)
 804f3d0:	f002 f876 	bl	80514c0 <atoi>
 804f3d4:	2802      	cmp	r0, #2
 804f3d6:	f340 8090 	ble.w	804f4fa <verifyModbus485ConfigData+0x12e>
		gu32ConfigModbus485ErrorDatabase |= (1 << enmCONFIG_MB485ISENABLED);
 804f3da:	4aa3      	ldr	r2, [pc, #652]	; (804f668 <verifyModbus485ConfigData+0x29c>)
 804f3dc:	f8d2 316c 	ldr.w	r3, [r2, #364]	; 0x16c
 804f3e0:	f043 0302 	orr.w	r3, r3, #2
 804f3e4:	f8c2 316c 	str.w	r3, [r2, #364]	; 0x16c
	else
		gu32ConfigModbus485ErrorDatabase &= ~(1 << enmCONFIG_MB485ISENABLED);

	if((atoi(gau8ConfigModbus485SlaveID) <= 0) | (atoi(gau8ConfigModbus485SlaveID) > 255)) // 1 to 255
 804f3e8:	4da0      	ldr	r5, [pc, #640]	; (804f66c <verifyModbus485ConfigData+0x2a0>)
 804f3ea:	4628      	mov	r0, r5
 804f3ec:	f002 f868 	bl	80514c0 <atoi>
 804f3f0:	4604      	mov	r4, r0
 804f3f2:	4628      	mov	r0, r5
 804f3f4:	f002 f864 	bl	80514c0 <atoi>
 804f3f8:	28ff      	cmp	r0, #255	; 0xff
 804f3fa:	bfd4      	ite	le
 804f3fc:	2300      	movle	r3, #0
 804f3fe:	2301      	movgt	r3, #1
 804f400:	2c00      	cmp	r4, #0
 804f402:	bfd8      	it	le
 804f404:	f043 0301 	orrle.w	r3, r3, #1
 804f408:	2b00      	cmp	r3, #0
 804f40a:	d07e      	beq.n	804f50a <verifyModbus485ConfigData+0x13e>
		gu32ConfigModbus485ErrorDatabase |= (1 << enmCONFIG_MB485SLAVEID);
 804f40c:	f5a5 72b8 	sub.w	r2, r5, #368	; 0x170
 804f410:	f8d2 316c 	ldr.w	r3, [r2, #364]	; 0x16c
 804f414:	f043 0304 	orr.w	r3, r3, #4
 804f418:	f8c2 316c 	str.w	r3, [r2, #364]	; 0x16c
	else
		gu32ConfigModbus485ErrorDatabase &= ~(1 << enmCONFIG_MB485SLAVEID);

	if(atoi(gau8ConfigModbus485Termination) > 1)
 804f41c:	4894      	ldr	r0, [pc, #592]	; (804f670 <verifyModbus485ConfigData+0x2a4>)
 804f41e:	f002 f84f 	bl	80514c0 <atoi>
 804f422:	2801      	cmp	r0, #1
 804f424:	dd79      	ble.n	804f51a <verifyModbus485ConfigData+0x14e>
		gu32ConfigModbus485ErrorDatabase |= (1 << enmCONFIG_MB485TERMINATE);
 804f426:	4a90      	ldr	r2, [pc, #576]	; (804f668 <verifyModbus485ConfigData+0x29c>)
 804f428:	f8d2 316c 	ldr.w	r3, [r2, #364]	; 0x16c
 804f42c:	f043 0308 	orr.w	r3, r3, #8
 804f430:	f8c2 316c 	str.w	r3, [r2, #364]	; 0x16c
	else
		gu32ConfigModbus485ErrorDatabase &= ~(1 << enmCONFIG_MB485TERMINATE);

	if(atoi(gau8ConfigModbus485DataPoints) > CONFIG_MB485_MAXPARAMS)
 804f434:	488f      	ldr	r0, [pc, #572]	; (804f674 <verifyModbus485ConfigData+0x2a8>)
 804f436:	f002 f843 	bl	80514c0 <atoi>
 804f43a:	284b      	cmp	r0, #75	; 0x4b
 804f43c:	dd75      	ble.n	804f52a <verifyModbus485ConfigData+0x15e>
		gu32ConfigModbus485ErrorDatabase |= (1 << enmCONFIG_MB485DATAPOINTS);
 804f43e:	4a8a      	ldr	r2, [pc, #552]	; (804f668 <verifyModbus485ConfigData+0x29c>)
 804f440:	f8d2 316c 	ldr.w	r3, [r2, #364]	; 0x16c
 804f444:	f043 0310 	orr.w	r3, r3, #16
 804f448:	f8c2 316c 	str.w	r3, [r2, #364]	; 0x16c
	else
		gu32ConfigModbus485ErrorDatabase &= ~(1 << enmCONFIG_MB485DATAPOINTS);

	if(atoi(gau8ConfigModbus485UARTBR) > 115200)
 804f44c:	488a      	ldr	r0, [pc, #552]	; (804f678 <verifyModbus485ConfigData+0x2ac>)
 804f44e:	f002 f837 	bl	80514c0 <atoi>
 804f452:	f5b0 3fe1 	cmp.w	r0, #115200	; 0x1c200
 804f456:	dd70      	ble.n	804f53a <verifyModbus485ConfigData+0x16e>
		gu32ConfigModbus485ErrorDatabase |= (1 << enmCONFIG_MB485UARTBR);
 804f458:	4a83      	ldr	r2, [pc, #524]	; (804f668 <verifyModbus485ConfigData+0x29c>)
 804f45a:	f8d2 316c 	ldr.w	r3, [r2, #364]	; 0x16c
 804f45e:	f043 0320 	orr.w	r3, r3, #32
 804f462:	f8c2 316c 	str.w	r3, [r2, #364]	; 0x16c
	else
		gu32ConfigModbus485ErrorDatabase &= ~(1 << enmCONFIG_MB485UARTBR);

	if(atoi(gau8ConfigModbus485UARTStartBit) > 3)
 804f466:	4885      	ldr	r0, [pc, #532]	; (804f67c <verifyModbus485ConfigData+0x2b0>)
 804f468:	f002 f82a 	bl	80514c0 <atoi>
 804f46c:	2803      	cmp	r0, #3
 804f46e:	dd6c      	ble.n	804f54a <verifyModbus485ConfigData+0x17e>
		gu32ConfigModbus485ErrorDatabase |= (1 << enmCONFIG_MB485UARTSTARTBIT);
 804f470:	4a7d      	ldr	r2, [pc, #500]	; (804f668 <verifyModbus485ConfigData+0x29c>)
 804f472:	f8d2 316c 	ldr.w	r3, [r2, #364]	; 0x16c
 804f476:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 804f47a:	f8c2 316c 	str.w	r3, [r2, #364]	; 0x16c
	else
		gu32ConfigModbus485ErrorDatabase &= ~(1 << enmCONFIG_MB485UARTSTARTBIT);

	if(atoi(gau8ConfigModbus485UARTStopBit) > 3)
 804f47e:	4880      	ldr	r0, [pc, #512]	; (804f680 <verifyModbus485ConfigData+0x2b4>)
 804f480:	f002 f81e 	bl	80514c0 <atoi>
 804f484:	2803      	cmp	r0, #3
 804f486:	dd68      	ble.n	804f55a <verifyModbus485ConfigData+0x18e>
		gu32ConfigModbus485ErrorDatabase |= (1 << enmCONFIG_MB485UARTSTOPBIT);
 804f488:	4a77      	ldr	r2, [pc, #476]	; (804f668 <verifyModbus485ConfigData+0x29c>)
 804f48a:	f8d2 316c 	ldr.w	r3, [r2, #364]	; 0x16c
 804f48e:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 804f492:	f8c2 316c 	str.w	r3, [r2, #364]	; 0x16c
	else
		gu32ConfigModbus485ErrorDatabase &= ~(1 << enmCONFIG_MB485UARTSTOPBIT);

	if(atoi(gau8ConfigModbus485PollingTime) > 1000000)
 804f496:	487b      	ldr	r0, [pc, #492]	; (804f684 <verifyModbus485ConfigData+0x2b8>)
 804f498:	f002 f812 	bl	80514c0 <atoi>
 804f49c:	4b7a      	ldr	r3, [pc, #488]	; (804f688 <verifyModbus485ConfigData+0x2bc>)
 804f49e:	4298      	cmp	r0, r3
 804f4a0:	dd63      	ble.n	804f56a <verifyModbus485ConfigData+0x19e>
		gu32ConfigModbus485ErrorDatabase |= (1 << enmCONFIG_MB485POLLTIME);
 804f4a2:	4a71      	ldr	r2, [pc, #452]	; (804f668 <verifyModbus485ConfigData+0x29c>)
 804f4a4:	f8d2 316c 	ldr.w	r3, [r2, #364]	; 0x16c
 804f4a8:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 804f4ac:	f8c2 316c 	str.w	r3, [r2, #364]	; 0x16c
	{
		gu32Modbus485PollingTime = atoi(gau8ConfigModbus485PollingTime);
		gu32ConfigModbus485ErrorDatabase &= ~(1 << enmCONFIG_MB485POLLTIME);
	}

	if(atoi(gau8ConfigModbus485ResponseTime) > 1000000)
 804f4b0:	4876      	ldr	r0, [pc, #472]	; (804f68c <verifyModbus485ConfigData+0x2c0>)
 804f4b2:	f002 f805 	bl	80514c0 <atoi>
 804f4b6:	4b74      	ldr	r3, [pc, #464]	; (804f688 <verifyModbus485ConfigData+0x2bc>)
 804f4b8:	4298      	cmp	r0, r3
 804f4ba:	dd64      	ble.n	804f586 <verifyModbus485ConfigData+0x1ba>
		gu32ConfigModbus485ErrorDatabase |= (1 << enmCONFIG_MB485RESPTIME);
 804f4bc:	4a6a      	ldr	r2, [pc, #424]	; (804f668 <verifyModbus485ConfigData+0x29c>)
 804f4be:	f8d2 316c 	ldr.w	r3, [r2, #364]	; 0x16c
 804f4c2:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 804f4c6:	f8c2 316c 	str.w	r3, [r2, #364]	; 0x16c
{
 804f4ca:	2400      	movs	r4, #0
	else
	{	gu32ModbusResponseTimeout = atoi(gau8ConfigModbus485ResponseTime);
		gu32ConfigModbus485ErrorDatabase &= ~(1 << enmCONFIG_MB485RESPTIME);
	}
	for(u32LoopCounter = 0 ; u32LoopCounter < atoi(gau8ConfigModbus485DataPoints) ; u32LoopCounter++ )
 804f4cc:	4869      	ldr	r0, [pc, #420]	; (804f674 <verifyModbus485ConfigData+0x2a8>)
 804f4ce:	f001 fff7 	bl	80514c0 <atoi>
 804f4d2:	42a0      	cmp	r0, r4
 804f4d4:	d96c      	bls.n	804f5b0 <verifyModbus485ConfigData+0x1e4>
	{
		if((gau32ConfigModbus485Address[u32LoopCounter] == 0) || (gau32ConfigModbus485Address[u32LoopCounter] > 65535))
 804f4d6:	4b6e      	ldr	r3, [pc, #440]	; (804f690 <verifyModbus485ConfigData+0x2c4>)
 804f4d8:	eb03 0384 	add.w	r3, r3, r4, lsl #2
 804f4dc:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 804f4de:	3b01      	subs	r3, #1
 804f4e0:	f64f 72fe 	movw	r2, #65534	; 0xfffe
 804f4e4:	4293      	cmp	r3, r2
 804f4e6:	d85c      	bhi.n	804f5a2 <verifyModbus485ConfigData+0x1d6>
			 * Log Error*/
			gu32ConfigModbus485ErrorDatabase |= (1 << enmCONFIG_MB485ADDRESS);
			break;
		}
		else
			gu32ConfigModbus485ErrorDatabase &= ~(1 << enmCONFIG_MB485ADDRESS);
 804f4e8:	4a5f      	ldr	r2, [pc, #380]	; (804f668 <verifyModbus485ConfigData+0x29c>)
 804f4ea:	f8d2 316c 	ldr.w	r3, [r2, #364]	; 0x16c
 804f4ee:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 804f4f2:	f8c2 316c 	str.w	r3, [r2, #364]	; 0x16c
	for(u32LoopCounter = 0 ; u32LoopCounter < atoi(gau8ConfigModbus485DataPoints) ; u32LoopCounter++ )
 804f4f6:	3401      	adds	r4, #1
 804f4f8:	e7e8      	b.n	804f4cc <verifyModbus485ConfigData+0x100>
		gu32ConfigModbus485ErrorDatabase &= ~(1 << enmCONFIG_MB485ISENABLED);
 804f4fa:	4a5b      	ldr	r2, [pc, #364]	; (804f668 <verifyModbus485ConfigData+0x29c>)
 804f4fc:	f8d2 316c 	ldr.w	r3, [r2, #364]	; 0x16c
 804f500:	f023 0302 	bic.w	r3, r3, #2
 804f504:	f8c2 316c 	str.w	r3, [r2, #364]	; 0x16c
 804f508:	e76e      	b.n	804f3e8 <verifyModbus485ConfigData+0x1c>
		gu32ConfigModbus485ErrorDatabase &= ~(1 << enmCONFIG_MB485SLAVEID);
 804f50a:	4a57      	ldr	r2, [pc, #348]	; (804f668 <verifyModbus485ConfigData+0x29c>)
 804f50c:	f8d2 316c 	ldr.w	r3, [r2, #364]	; 0x16c
 804f510:	f023 0304 	bic.w	r3, r3, #4
 804f514:	f8c2 316c 	str.w	r3, [r2, #364]	; 0x16c
 804f518:	e780      	b.n	804f41c <verifyModbus485ConfigData+0x50>
		gu32ConfigModbus485ErrorDatabase &= ~(1 << enmCONFIG_MB485TERMINATE);
 804f51a:	4a53      	ldr	r2, [pc, #332]	; (804f668 <verifyModbus485ConfigData+0x29c>)
 804f51c:	f8d2 316c 	ldr.w	r3, [r2, #364]	; 0x16c
 804f520:	f023 0308 	bic.w	r3, r3, #8
 804f524:	f8c2 316c 	str.w	r3, [r2, #364]	; 0x16c
 804f528:	e784      	b.n	804f434 <verifyModbus485ConfigData+0x68>
		gu32ConfigModbus485ErrorDatabase &= ~(1 << enmCONFIG_MB485DATAPOINTS);
 804f52a:	4a4f      	ldr	r2, [pc, #316]	; (804f668 <verifyModbus485ConfigData+0x29c>)
 804f52c:	f8d2 316c 	ldr.w	r3, [r2, #364]	; 0x16c
 804f530:	f023 0310 	bic.w	r3, r3, #16
 804f534:	f8c2 316c 	str.w	r3, [r2, #364]	; 0x16c
 804f538:	e788      	b.n	804f44c <verifyModbus485ConfigData+0x80>
		gu32ConfigModbus485ErrorDatabase &= ~(1 << enmCONFIG_MB485UARTBR);
 804f53a:	4a4b      	ldr	r2, [pc, #300]	; (804f668 <verifyModbus485ConfigData+0x29c>)
 804f53c:	f8d2 316c 	ldr.w	r3, [r2, #364]	; 0x16c
 804f540:	f023 0320 	bic.w	r3, r3, #32
 804f544:	f8c2 316c 	str.w	r3, [r2, #364]	; 0x16c
 804f548:	e78d      	b.n	804f466 <verifyModbus485ConfigData+0x9a>
		gu32ConfigModbus485ErrorDatabase &= ~(1 << enmCONFIG_MB485UARTSTARTBIT);
 804f54a:	4a47      	ldr	r2, [pc, #284]	; (804f668 <verifyModbus485ConfigData+0x29c>)
 804f54c:	f8d2 316c 	ldr.w	r3, [r2, #364]	; 0x16c
 804f550:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 804f554:	f8c2 316c 	str.w	r3, [r2, #364]	; 0x16c
 804f558:	e791      	b.n	804f47e <verifyModbus485ConfigData+0xb2>
		gu32ConfigModbus485ErrorDatabase &= ~(1 << enmCONFIG_MB485UARTSTOPBIT);
 804f55a:	4a43      	ldr	r2, [pc, #268]	; (804f668 <verifyModbus485ConfigData+0x29c>)
 804f55c:	f8d2 316c 	ldr.w	r3, [r2, #364]	; 0x16c
 804f560:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 804f564:	f8c2 316c 	str.w	r3, [r2, #364]	; 0x16c
 804f568:	e795      	b.n	804f496 <verifyModbus485ConfigData+0xca>
		gu32Modbus485PollingTime = atoi(gau8ConfigModbus485PollingTime);
 804f56a:	4c3f      	ldr	r4, [pc, #252]	; (804f668 <verifyModbus485ConfigData+0x29c>)
 804f56c:	f504 70c4 	add.w	r0, r4, #392	; 0x188
 804f570:	f001 ffa6 	bl	80514c0 <atoi>
 804f574:	4b46      	ldr	r3, [pc, #280]	; (804f690 <verifyModbus485ConfigData+0x2c4>)
 804f576:	6458      	str	r0, [r3, #68]	; 0x44
		gu32ConfigModbus485ErrorDatabase &= ~(1 << enmCONFIG_MB485POLLTIME);
 804f578:	f8d4 316c 	ldr.w	r3, [r4, #364]	; 0x16c
 804f57c:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 804f580:	f8c4 316c 	str.w	r3, [r4, #364]	; 0x16c
 804f584:	e794      	b.n	804f4b0 <verifyModbus485ConfigData+0xe4>
	{	gu32ModbusResponseTimeout = atoi(gau8ConfigModbus485ResponseTime);
 804f586:	4c38      	ldr	r4, [pc, #224]	; (804f668 <verifyModbus485ConfigData+0x29c>)
 804f588:	f504 70c8 	add.w	r0, r4, #400	; 0x190
 804f58c:	f001 ff98 	bl	80514c0 <atoi>
 804f590:	4b40      	ldr	r3, [pc, #256]	; (804f694 <verifyModbus485ConfigData+0x2c8>)
 804f592:	6018      	str	r0, [r3, #0]
		gu32ConfigModbus485ErrorDatabase &= ~(1 << enmCONFIG_MB485RESPTIME);
 804f594:	f8d4 316c 	ldr.w	r3, [r4, #364]	; 0x16c
 804f598:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 804f59c:	f8c4 316c 	str.w	r3, [r4, #364]	; 0x16c
 804f5a0:	e793      	b.n	804f4ca <verifyModbus485ConfigData+0xfe>
			gu32ConfigModbus485ErrorDatabase |= (1 << enmCONFIG_MB485ADDRESS);
 804f5a2:	4a31      	ldr	r2, [pc, #196]	; (804f668 <verifyModbus485ConfigData+0x29c>)
 804f5a4:	f8d2 316c 	ldr.w	r3, [r2, #364]	; 0x16c
 804f5a8:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 804f5ac:	f8c2 316c 	str.w	r3, [r2, #364]	; 0x16c
{
 804f5b0:	2400      	movs	r4, #0
	}

	u32LoopCounter = 0;
	for(u32LoopCounter = 0 ; u32LoopCounter < atoi(gau8ConfigModbus485DataPoints) ; u32LoopCounter++ )
 804f5b2:	4830      	ldr	r0, [pc, #192]	; (804f674 <verifyModbus485ConfigData+0x2a8>)
 804f5b4:	f001 ff84 	bl	80514c0 <atoi>
 804f5b8:	42a0      	cmp	r0, r4
 804f5ba:	d917      	bls.n	804f5ec <verifyModbus485ConfigData+0x220>
	{
		if((gau32ConfigModbus485DFunctionCode[u32LoopCounter] == 0) || (gau32ConfigModbus485DFunctionCode[u32LoopCounter] > 5))
 804f5bc:	4b34      	ldr	r3, [pc, #208]	; (804f690 <verifyModbus485ConfigData+0x2c4>)
 804f5be:	eb03 0384 	add.w	r3, r3, r4, lsl #2
 804f5c2:	f8d3 3174 	ldr.w	r3, [r3, #372]	; 0x174
 804f5c6:	3b01      	subs	r3, #1
 804f5c8:	2b04      	cmp	r3, #4
 804f5ca:	d808      	bhi.n	804f5de <verifyModbus485ConfigData+0x212>
			 * Log Error*/
			gu32ConfigModbus485ErrorDatabase |= (1 << enmCONFIG_MB485FUCNTIONCODE);
			break;
		}
		else
			gu32ConfigModbus485ErrorDatabase &= ~(1 << enmCONFIG_MB485FUCNTIONCODE);
 804f5cc:	4a26      	ldr	r2, [pc, #152]	; (804f668 <verifyModbus485ConfigData+0x29c>)
 804f5ce:	f8d2 316c 	ldr.w	r3, [r2, #364]	; 0x16c
 804f5d2:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 804f5d6:	f8c2 316c 	str.w	r3, [r2, #364]	; 0x16c
	for(u32LoopCounter = 0 ; u32LoopCounter < atoi(gau8ConfigModbus485DataPoints) ; u32LoopCounter++ )
 804f5da:	3401      	adds	r4, #1
 804f5dc:	e7e9      	b.n	804f5b2 <verifyModbus485ConfigData+0x1e6>
			gu32ConfigModbus485ErrorDatabase |= (1 << enmCONFIG_MB485FUCNTIONCODE);
 804f5de:	4a22      	ldr	r2, [pc, #136]	; (804f668 <verifyModbus485ConfigData+0x29c>)
 804f5e0:	f8d2 316c 	ldr.w	r3, [r2, #364]	; 0x16c
 804f5e4:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 804f5e8:	f8c2 316c 	str.w	r3, [r2, #364]	; 0x16c
{
 804f5ec:	2400      	movs	r4, #0
	}
	u32LoopCounter = 0;
	for(u32LoopCounter = 0 ; u32LoopCounter < atoi(gau8ConfigModbus485DataPoints) ; u32LoopCounter++ )
 804f5ee:	4821      	ldr	r0, [pc, #132]	; (804f674 <verifyModbus485ConfigData+0x2a8>)
 804f5f0:	f001 ff66 	bl	80514c0 <atoi>
 804f5f4:	42a0      	cmp	r0, r4
 804f5f6:	d917      	bls.n	804f628 <verifyModbus485ConfigData+0x25c>
	{
		if((gau32ConfigModbus485NoPoints[u32LoopCounter] == 0) || (gau32ConfigModbus485NoPoints[u32LoopCounter] > 255))
 804f5f8:	4b25      	ldr	r3, [pc, #148]	; (804f690 <verifyModbus485ConfigData+0x2c4>)
 804f5fa:	eb03 0384 	add.w	r3, r3, r4, lsl #2
 804f5fe:	f8d3 32a0 	ldr.w	r3, [r3, #672]	; 0x2a0
 804f602:	3b01      	subs	r3, #1
 804f604:	2bfe      	cmp	r3, #254	; 0xfe
 804f606:	d808      	bhi.n	804f61a <verifyModbus485ConfigData+0x24e>
			 * Log Error*/
			gu32ConfigModbus485ErrorDatabase |= (1 << enmCONFIG_MB485DATAPOINTS);
			break;
		}
		else
			gu32ConfigModbus485ErrorDatabase &= ~(1 << enmCONFIG_MB485DATAPOINTS);
 804f608:	4a17      	ldr	r2, [pc, #92]	; (804f668 <verifyModbus485ConfigData+0x29c>)
 804f60a:	f8d2 316c 	ldr.w	r3, [r2, #364]	; 0x16c
 804f60e:	f023 0310 	bic.w	r3, r3, #16
 804f612:	f8c2 316c 	str.w	r3, [r2, #364]	; 0x16c
	for(u32LoopCounter = 0 ; u32LoopCounter < atoi(gau8ConfigModbus485DataPoints) ; u32LoopCounter++ )
 804f616:	3401      	adds	r4, #1
 804f618:	e7e9      	b.n	804f5ee <verifyModbus485ConfigData+0x222>
			gu32ConfigModbus485ErrorDatabase |= (1 << enmCONFIG_MB485DATAPOINTS);
 804f61a:	4a13      	ldr	r2, [pc, #76]	; (804f668 <verifyModbus485ConfigData+0x29c>)
 804f61c:	f8d2 316c 	ldr.w	r3, [r2, #364]	; 0x16c
 804f620:	f043 0310 	orr.w	r3, r3, #16
 804f624:	f8c2 316c 	str.w	r3, [r2, #364]	; 0x16c
	}

	if(IP_IS_TYPE_V4(gau8ConfigModbusTCPIPDEVICE) != 1)
		gu32ConfigModbusTCPErrorDatabase |= (1 << enmCONFIG_MBTCPIPDEVICE);
	else
		gu32ConfigModbusTCPErrorDatabase &= ~(1 << enmCONFIG_MBTCPIPDEVICE);
 804f628:	480f      	ldr	r0, [pc, #60]	; (804f668 <verifyModbus485ConfigData+0x29c>)
 804f62a:	f8d0 3198 	ldr.w	r3, [r0, #408]	; 0x198
		gu32ConfigModbusTCPErrorDatabase &= ~(1 << enmCONFIG_MB485UARTSTOPBIT);

	if(IP_IS_TYPE_V4(gau8ConfigModbusTCPIPGATEWAY) != 1)
		gu32ConfigModbusTCPErrorDatabase |= (1 << enmCONFIG_MB485POLLTIME);
	else
		gu32ConfigModbusTCPErrorDatabase &= ~(1 << enmCONFIG_MB485POLLTIME);
 804f62e:	f423 43a1 	bic.w	r3, r3, #20608	; 0x5080
 804f632:	f8c0 3198 	str.w	r3, [r0, #408]	; 0x198

	if(atoi(gau8ConfigModbusTCPPORT) > 65535)
 804f636:	f500 70ce 	add.w	r0, r0, #412	; 0x19c
 804f63a:	f001 ff41 	bl	80514c0 <atoi>
 804f63e:	f5b0 3f80 	cmp.w	r0, #65536	; 0x10000
 804f642:	db07      	blt.n	804f654 <verifyModbus485ConfigData+0x288>
		gu32ConfigModbusTCPErrorDatabase |= (1 << enmCONFIG_MBTCPIPPORT);
 804f644:	4a08      	ldr	r2, [pc, #32]	; (804f668 <verifyModbus485ConfigData+0x29c>)
 804f646:	f8d2 3198 	ldr.w	r3, [r2, #408]	; 0x198
 804f64a:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 804f64e:	f8c2 3198 	str.w	r3, [r2, #408]	; 0x198
	else
		gu32ConfigModbusTCPErrorDatabase &= ~(1 << enmCONFIG_MBTCPIPPORT);

}
 804f652:	bd38      	pop	{r3, r4, r5, pc}
		gu32ConfigModbusTCPErrorDatabase &= ~(1 << enmCONFIG_MBTCPIPPORT);
 804f654:	4a04      	ldr	r2, [pc, #16]	; (804f668 <verifyModbus485ConfigData+0x29c>)
 804f656:	f8d2 3198 	ldr.w	r3, [r2, #408]	; 0x198
 804f65a:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 804f65e:	f8c2 3198 	str.w	r3, [r2, #408]	; 0x198
}
 804f662:	e7f6      	b.n	804f652 <verifyModbus485ConfigData+0x286>
 804f664:	20004e94 	.word	0x20004e94
 804f668:	20004d2c 	.word	0x20004d2c
 804f66c:	20004e9c 	.word	0x20004e9c
 804f670:	20004ea4 	.word	0x20004ea4
 804f674:	20004ea8 	.word	0x20004ea8
 804f678:	200026d0 	.word	0x200026d0
 804f67c:	20004eac 	.word	0x20004eac
 804f680:	20004eb0 	.word	0x20004eb0
 804f684:	20004eb4 	.word	0x20004eb4
 804f688:	000f4240 	.word	0x000f4240
 804f68c:	20004ebc 	.word	0x20004ebc
 804f690:	20002694 	.word	0x20002694
 804f694:	20004330 	.word	0x20004330

0804f698 <verifyRemoteConfiguration>:
{
 804f698:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if(gu32NewConfigAvailable == TRUE)
 804f69a:	4b30      	ldr	r3, [pc, #192]	; (804f75c <verifyRemoteConfiguration+0xc4>)
 804f69c:	681b      	ldr	r3, [r3, #0]
 804f69e:	2b01      	cmp	r3, #1
 804f6a0:	d003      	beq.n	804f6aa <verifyRemoteConfiguration+0x12>
	gu32NewConfigAvailable = FALSE;
 804f6a2:	4b2e      	ldr	r3, [pc, #184]	; (804f75c <verifyRemoteConfiguration+0xc4>)
 804f6a4:	2200      	movs	r2, #0
 804f6a6:	601a      	str	r2, [r3, #0]
}
 804f6a8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		sof = strstr(gau8ConfigData,"(,");
 804f6aa:	4d2d      	ldr	r5, [pc, #180]	; (804f760 <verifyRemoteConfiguration+0xc8>)
 804f6ac:	492d      	ldr	r1, [pc, #180]	; (804f764 <verifyRemoteConfiguration+0xcc>)
 804f6ae:	4628      	mov	r0, r5
 804f6b0:	f002 fa55 	bl	8051b5e <strstr>
 804f6b4:	4606      	mov	r6, r0
 804f6b6:	4c2c      	ldr	r4, [pc, #176]	; (804f768 <verifyRemoteConfiguration+0xd0>)
 804f6b8:	f8c4 0754 	str.w	r0, [r4, #1876]	; 0x754
		eof = strstr(gau8ConfigData,",)");
 804f6bc:	492b      	ldr	r1, [pc, #172]	; (804f76c <verifyRemoteConfiguration+0xd4>)
 804f6be:	4628      	mov	r0, r5
 804f6c0:	f002 fa4d 	bl	8051b5e <strstr>
 804f6c4:	4607      	mov	r7, r0
 804f6c6:	f8c4 0758 	str.w	r0, [r4, #1880]	; 0x758
		nwsof = strstr(gau8ConfigData,"NS,");
 804f6ca:	4929      	ldr	r1, [pc, #164]	; (804f770 <verifyRemoteConfiguration+0xd8>)
 804f6cc:	4628      	mov	r0, r5
 804f6ce:	f002 fa46 	bl	8051b5e <strstr>
 804f6d2:	f8c4 075c 	str.w	r0, [r4, #1884]	; 0x75c
		nweof = strstr(gau8ConfigData,",NE");
 804f6d6:	4927      	ldr	r1, [pc, #156]	; (804f774 <verifyRemoteConfiguration+0xdc>)
 804f6d8:	4628      	mov	r0, r5
 804f6da:	f002 fa40 	bl	8051b5e <strstr>
 804f6de:	f8c4 0760 	str.w	r0, [r4, #1888]	; 0x760
		mb485sof = strstr(gau8ConfigData,"MS,");
 804f6e2:	4925      	ldr	r1, [pc, #148]	; (804f778 <verifyRemoteConfiguration+0xe0>)
 804f6e4:	4628      	mov	r0, r5
 804f6e6:	f002 fa3a 	bl	8051b5e <strstr>
 804f6ea:	f8c4 0764 	str.w	r0, [r4, #1892]	; 0x764
		mb485eof = strstr(gau8ConfigData,",ME");
 804f6ee:	4923      	ldr	r1, [pc, #140]	; (804f77c <verifyRemoteConfiguration+0xe4>)
 804f6f0:	4628      	mov	r0, r5
 804f6f2:	f002 fa34 	bl	8051b5e <strstr>
 804f6f6:	f8c4 0768 	str.w	r0, [r4, #1896]	; 0x768
		devReset = strstr(gau8ConfigData,"!");
 804f6fa:	2121      	movs	r1, #33	; 0x21
 804f6fc:	4628      	mov	r0, r5
 804f6fe:	f002 f9f4 	bl	8051aea <strchr>
 804f702:	f8c4 076c 	str.w	r0, [r4, #1900]	; 0x76c
		useDefaultConfig = strstr(gau8ConfigData,"^");
 804f706:	215e      	movs	r1, #94	; 0x5e
 804f708:	4628      	mov	r0, r5
 804f70a:	f002 f9ee 	bl	8051aea <strchr>
 804f70e:	f8c4 0770 	str.w	r0, [r4, #1904]	; 0x770
		getConfig = strstr(gau8ConfigData,"%");
 804f712:	2125      	movs	r1, #37	; 0x25
 804f714:	4628      	mov	r0, r5
 804f716:	f002 f9e8 	bl	8051aea <strchr>
 804f71a:	f8c4 0774 	str.w	r0, [r4, #1908]	; 0x774
		if(sof != NULL)
 804f71e:	2e00      	cmp	r6, #0
 804f720:	d0bf      	beq.n	804f6a2 <verifyRemoteConfiguration+0xa>
			if(eof != NULL)
 804f722:	2f00      	cmp	r7, #0
 804f724:	d0bd      	beq.n	804f6a2 <verifyRemoteConfiguration+0xa>
				gu32ConfigLen = eof - sof ;	// Total Config Bytes
 804f726:	1bbf      	subs	r7, r7, r6
 804f728:	4c15      	ldr	r4, [pc, #84]	; (804f780 <verifyRemoteConfiguration+0xe8>)
 804f72a:	f8c4 71bc 	str.w	r7, [r4, #444]	; 0x1bc
				memset(gau8RemoteDeviceID, 0, sizeof(gau8RemoteDeviceID));
 804f72e:	4d15      	ldr	r5, [pc, #84]	; (804f784 <verifyRemoteConfiguration+0xec>)
 804f730:	2228      	movs	r2, #40	; 0x28
 804f732:	2100      	movs	r1, #0
 804f734:	4628      	mov	r0, r5
 804f736:	f002 f973 	bl	8051a20 <memset>
				memcpy(gau8RemoteDeviceID, sof+4, strlen(strtok(sof+4,",")));
 804f73a:	3604      	adds	r6, #4
 804f73c:	4912      	ldr	r1, [pc, #72]	; (804f788 <verifyRemoteConfiguration+0xf0>)
 804f73e:	4630      	mov	r0, r6
 804f740:	f003 f858 	bl	80527f4 <strtok>
 804f744:	f7f0 fd5e 	bl	8040204 <strlen>
 804f748:	4602      	mov	r2, r0
 804f74a:	4631      	mov	r1, r6
 804f74c:	4628      	mov	r0, r5
 804f74e:	f002 f959 	bl	8051a04 <memcpy>
				gu32ParseConfigAvailable = TRUE;
 804f752:	2301      	movs	r3, #1
 804f754:	f8c4 31c0 	str.w	r3, [r4, #448]	; 0x1c0
 804f758:	e7a3      	b.n	804f6a2 <verifyRemoteConfiguration+0xa>
 804f75a:	bf00      	nop
 804f75c:	200042b4 	.word	0x200042b4
 804f760:	2000b9d4 	.word	0x2000b9d4
 804f764:	0805aac4 	.word	0x0805aac4
 804f768:	20002694 	.word	0x20002694
 804f76c:	0805aac8 	.word	0x0805aac8
 804f770:	0805aacc 	.word	0x0805aacc
 804f774:	0805aad0 	.word	0x0805aad0
 804f778:	0805aad4 	.word	0x0805aad4
 804f77c:	0805aad8 	.word	0x0805aad8
 804f780:	20004d2c 	.word	0x20004d2c
 804f784:	20002e0c 	.word	0x20002e0c
 804f788:	0805a920 	.word	0x0805a920

0804f78c <parseRemoteconfig>:
	if(gu32ParseConfigAvailable == TRUE)
 804f78c:	4bae      	ldr	r3, [pc, #696]	; (804fa48 <parseRemoteconfig+0x2bc>)
 804f78e:	f8d3 31c0 	ldr.w	r3, [r3, #448]	; 0x1c0
 804f792:	2b01      	cmp	r3, #1
 804f794:	d000      	beq.n	804f798 <parseRemoteconfig+0xc>
 804f796:	4770      	bx	lr
{
 804f798:	b570      	push	{r4, r5, r6, lr}
		if(strcmp(dinfo,gau8RemoteDeviceID) == 0)
 804f79a:	49ac      	ldr	r1, [pc, #688]	; (804fa4c <parseRemoteconfig+0x2c0>)
 804f79c:	48ac      	ldr	r0, [pc, #688]	; (804fa50 <parseRemoteconfig+0x2c4>)
 804f79e:	f7f0 fd27 	bl	80401f0 <strcmp>
 804f7a2:	b100      	cbz	r0, 804f7a6 <parseRemoteconfig+0x1a>
}
 804f7a4:	bd70      	pop	{r4, r5, r6, pc}
			HAL_GPIO_WritePin(LED_1_GPIO_Port, LED_1_Pin, GPIO_PIN_RESET);	// LED ON
 804f7a6:	2200      	movs	r2, #0
 804f7a8:	f44f 7180 	mov.w	r1, #256	; 0x100
 804f7ac:	48a9      	ldr	r0, [pc, #676]	; (804fa54 <parseRemoteconfig+0x2c8>)
 804f7ae:	f7f3 fab7 	bl	8042d20 <HAL_GPIO_WritePin>
			if(devReset != NULL)
 804f7b2:	4ba9      	ldr	r3, [pc, #676]	; (804fa58 <parseRemoteconfig+0x2cc>)
 804f7b4:	f8d3 376c 	ldr.w	r3, [r3, #1900]	; 0x76c
 804f7b8:	b133      	cbz	r3, 804f7c8 <parseRemoteconfig+0x3c>
				HAL_Delay(1000);
 804f7ba:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 804f7be:	f7f1 fc85 	bl	80410cc <HAL_Delay>
				HAL_NVIC_SystemReset();
 804f7c2:	f7f2 f8d7 	bl	8041974 <HAL_NVIC_SystemReset>
 804f7c6:	e7ed      	b.n	804f7a4 <parseRemoteconfig+0x18>
			else if(useDefaultConfig != NULL)
 804f7c8:	4ba3      	ldr	r3, [pc, #652]	; (804fa58 <parseRemoteconfig+0x2cc>)
 804f7ca:	f8d3 3770 	ldr.w	r3, [r3, #1904]	; 0x770
 804f7ce:	b13b      	cbz	r3, 804f7e0 <parseRemoteconfig+0x54>
				if(FLASH_If_Erase(ADDR_FLASH_SECTOR_22) != FLASHIF_OK)
 804f7d0:	48a2      	ldr	r0, [pc, #648]	; (804fa5c <parseRemoteconfig+0x2d0>)
 804f7d2:	f001 fbe5 	bl	8050fa0 <FLASH_If_Erase>
 804f7d6:	2800      	cmp	r0, #0
 804f7d8:	d1e4      	bne.n	804f7a4 <parseRemoteconfig+0x18>
					HAL_NVIC_SystemReset();
 804f7da:	f7f2 f8cb 	bl	8041974 <HAL_NVIC_SystemReset>
 804f7de:	e7e1      	b.n	804f7a4 <parseRemoteconfig+0x18>
			else if(getConfig != NULL)
 804f7e0:	4b9d      	ldr	r3, [pc, #628]	; (804fa58 <parseRemoteconfig+0x2cc>)
 804f7e2:	f8d3 3774 	ldr.w	r3, [r3, #1908]	; 0x774
 804f7e6:	b133      	cbz	r3, 804f7f6 <parseRemoteconfig+0x6a>
				enqueue(&gsmPayload,(char *)getSystemConfig());
 804f7e8:	f7fe ffce 	bl	804e788 <getSystemConfig>
 804f7ec:	4601      	mov	r1, r0
 804f7ee:	489c      	ldr	r0, [pc, #624]	; (804fa60 <parseRemoteconfig+0x2d4>)
 804f7f0:	f7ff fce4 	bl	804f1bc <enqueue>
 804f7f4:	e7d6      	b.n	804f7a4 <parseRemoteconfig+0x18>
				switch(enmDeviceConfigState)
 804f7f6:	4b94      	ldr	r3, [pc, #592]	; (804fa48 <parseRemoteconfig+0x2bc>)
 804f7f8:	f893 31c4 	ldrb.w	r3, [r3, #452]	; 0x1c4
 804f7fc:	2b0d      	cmp	r3, #13
 804f7fe:	f200 819e 	bhi.w	804fb3e <parseRemoteconfig+0x3b2>
 804f802:	e8df f013 	tbh	[pc, r3, lsl #1]
 804f806:	000e      	.short	0x000e
 804f808:	003c0032 	.word	0x003c0032
 804f80c:	00500046 	.word	0x00500046
 804f810:	00aa005b 	.word	0x00aa005b
 804f814:	013300e5 	.word	0x013300e5
 804f818:	0149013e 	.word	0x0149013e
 804f81c:	015f0154 	.word	0x015f0154
 804f820:	016a      	.short	0x016a
						memcpy(gau8RemoteDeviceType, sof+2, strlen(strtok(sof+2,",")));
 804f822:	4d8d      	ldr	r5, [pc, #564]	; (804fa58 <parseRemoteconfig+0x2cc>)
 804f824:	f8d5 4754 	ldr.w	r4, [r5, #1876]	; 0x754
 804f828:	3402      	adds	r4, #2
 804f82a:	498e      	ldr	r1, [pc, #568]	; (804fa64 <parseRemoteconfig+0x2d8>)
 804f82c:	4620      	mov	r0, r4
 804f82e:	f002 ffe1 	bl	80527f4 <strtok>
 804f832:	f7f0 fce7 	bl	8040204 <strlen>
 804f836:	4602      	mov	r2, r0
 804f838:	4e8b      	ldr	r6, [pc, #556]	; (804fa68 <parseRemoteconfig+0x2dc>)
 804f83a:	4621      	mov	r1, r4
 804f83c:	4630      	mov	r0, r6
 804f83e:	f002 f8e1 	bl	8051a04 <memcpy>
						if(atoi(gau8RemoteDeviceType) == enmMyDeviceType)
 804f842:	4630      	mov	r0, r6
 804f844:	f001 fe3c 	bl	80514c0 <atoi>
 804f848:	f895 37a0 	ldrb.w	r3, [r5, #1952]	; 0x7a0
 804f84c:	4298      	cmp	r0, r3
 804f84e:	d004      	beq.n	804f85a <parseRemoteconfig+0xce>
							gu32ParseConfigAvailable = FALSE;
 804f850:	4b7d      	ldr	r3, [pc, #500]	; (804fa48 <parseRemoteconfig+0x2bc>)
 804f852:	2200      	movs	r2, #0
 804f854:	f8c3 21c0 	str.w	r2, [r3, #448]	; 0x1c0
 804f858:	e7a4      	b.n	804f7a4 <parseRemoteconfig+0x18>
							enmDeviceConfigState++;
 804f85a:	f5a6 72e4 	sub.w	r2, r6, #456	; 0x1c8
 804f85e:	f892 31c4 	ldrb.w	r3, [r2, #452]	; 0x1c4
 804f862:	3301      	adds	r3, #1
 804f864:	f882 31c4 	strb.w	r3, [r2, #452]	; 0x1c4
 804f868:	e79c      	b.n	804f7a4 <parseRemoteconfig+0x18>
						if(gau32RemoteConfigSupport[enmCONFIG_ADC] == TRUE)
 804f86a:	4a7b      	ldr	r2, [pc, #492]	; (804fa58 <parseRemoteconfig+0x2cc>)
 804f86c:	f8d2 27a8 	ldr.w	r2, [r2, #1960]	; 0x7a8
 804f870:	2a01      	cmp	r2, #1
 804f872:	d097      	beq.n	804f7a4 <parseRemoteconfig+0x18>
							enmDeviceConfigState++;
 804f874:	3301      	adds	r3, #1
 804f876:	4a74      	ldr	r2, [pc, #464]	; (804fa48 <parseRemoteconfig+0x2bc>)
 804f878:	f882 31c4 	strb.w	r3, [r2, #452]	; 0x1c4
 804f87c:	e792      	b.n	804f7a4 <parseRemoteconfig+0x18>
						if(gau32RemoteConfigSupport[enmCONFIG_DI] == TRUE)
 804f87e:	4a76      	ldr	r2, [pc, #472]	; (804fa58 <parseRemoteconfig+0x2cc>)
 804f880:	f8d2 27ac 	ldr.w	r2, [r2, #1964]	; 0x7ac
 804f884:	2a01      	cmp	r2, #1
 804f886:	d08d      	beq.n	804f7a4 <parseRemoteconfig+0x18>
							enmDeviceConfigState++;
 804f888:	3301      	adds	r3, #1
 804f88a:	4a6f      	ldr	r2, [pc, #444]	; (804fa48 <parseRemoteconfig+0x2bc>)
 804f88c:	f882 31c4 	strb.w	r3, [r2, #452]	; 0x1c4
 804f890:	e788      	b.n	804f7a4 <parseRemoteconfig+0x18>
						if(gau32RemoteConfigSupport[enmCONFIG_DO] == TRUE)
 804f892:	4a71      	ldr	r2, [pc, #452]	; (804fa58 <parseRemoteconfig+0x2cc>)
 804f894:	f8d2 27b0 	ldr.w	r2, [r2, #1968]	; 0x7b0
 804f898:	2a01      	cmp	r2, #1
 804f89a:	d083      	beq.n	804f7a4 <parseRemoteconfig+0x18>
							enmDeviceConfigState++;
 804f89c:	3301      	adds	r3, #1
 804f89e:	4a6a      	ldr	r2, [pc, #424]	; (804fa48 <parseRemoteconfig+0x2bc>)
 804f8a0:	f882 31c4 	strb.w	r3, [r2, #452]	; 0x1c4
 804f8a4:	e77e      	b.n	804f7a4 <parseRemoteconfig+0x18>
						if(gau32RemoteConfigSupport[enmCONFIG_RPM] == TRUE)
 804f8a6:	4a6c      	ldr	r2, [pc, #432]	; (804fa58 <parseRemoteconfig+0x2cc>)
 804f8a8:	f8d2 27b4 	ldr.w	r2, [r2, #1972]	; 0x7b4
 804f8ac:	2a01      	cmp	r2, #1
 804f8ae:	f43f af79 	beq.w	804f7a4 <parseRemoteconfig+0x18>
							enmDeviceConfigState++;
 804f8b2:	3301      	adds	r3, #1
 804f8b4:	4a64      	ldr	r2, [pc, #400]	; (804fa48 <parseRemoteconfig+0x2bc>)
 804f8b6:	f882 31c4 	strb.w	r3, [r2, #452]	; 0x1c4
 804f8ba:	e773      	b.n	804f7a4 <parseRemoteconfig+0x18>
						if(gau32RemoteConfigSupport[enmCONFIG_NETWORK] == TRUE)
 804f8bc:	4a66      	ldr	r2, [pc, #408]	; (804fa58 <parseRemoteconfig+0x2cc>)
 804f8be:	f8d2 27b8 	ldr.w	r2, [r2, #1976]	; 0x7b8
 804f8c2:	2a01      	cmp	r2, #1
 804f8c4:	d004      	beq.n	804f8d0 <parseRemoteconfig+0x144>
							enmDeviceConfigState++;
 804f8c6:	3301      	adds	r3, #1
 804f8c8:	4a5f      	ldr	r2, [pc, #380]	; (804fa48 <parseRemoteconfig+0x2bc>)
 804f8ca:	f882 31c4 	strb.w	r3, [r2, #452]	; 0x1c4
 804f8ce:	e769      	b.n	804f7a4 <parseRemoteconfig+0x18>
							if(gu32ConfigOperationStatus == FALSE)
 804f8d0:	4a5d      	ldr	r2, [pc, #372]	; (804fa48 <parseRemoteconfig+0x2bc>)
 804f8d2:	f8d2 21cc 	ldr.w	r2, [r2, #460]	; 0x1cc
 804f8d6:	2a00      	cmp	r2, #0
 804f8d8:	d137      	bne.n	804f94a <parseRemoteconfig+0x1be>
								if((nwsof != NULL) && (nweof != NULL))
 804f8da:	4a5f      	ldr	r2, [pc, #380]	; (804fa58 <parseRemoteconfig+0x2cc>)
 804f8dc:	f8d2 175c 	ldr.w	r1, [r2, #1884]	; 0x75c
 804f8e0:	b371      	cbz	r1, 804f940 <parseRemoteconfig+0x1b4>
 804f8e2:	f8d2 2760 	ldr.w	r2, [r2, #1888]	; 0x760
 804f8e6:	b35a      	cbz	r2, 804f940 <parseRemoteconfig+0x1b4>
									nwmlen = (nweof - nwsof) + 4 ;
 804f8e8:	1a53      	subs	r3, r2, r1
 804f8ea:	3304      	adds	r3, #4
 804f8ec:	4a56      	ldr	r2, [pc, #344]	; (804fa48 <parseRemoteconfig+0x2bc>)
 804f8ee:	f8c2 31d0 	str.w	r3, [r2, #464]	; 0x1d0
									tempconfig = (char *)malloc(sizeof(char) * 2000);
 804f8f2:	f44f 60fa 	mov.w	r0, #2000	; 0x7d0
 804f8f6:	f001 fe25 	bl	8051544 <malloc>
 804f8fa:	4604      	mov	r4, r0
 804f8fc:	4a56      	ldr	r2, [pc, #344]	; (804fa58 <parseRemoteconfig+0x2cc>)
 804f8fe:	f8c2 07d4 	str.w	r0, [r2, #2004]	; 0x7d4
									memset(tempconfig,0x00,2000 * sizeof(char));
 804f902:	f44f 62fa 	mov.w	r2, #2000	; 0x7d0
 804f906:	2100      	movs	r1, #0
 804f908:	f002 f88a 	bl	8051a20 <memset>
									if(tempconfig != NULL)
 804f90c:	4620      	mov	r0, r4
 804f90e:	b164      	cbz	r4, 804f92a <parseRemoteconfig+0x19e>
										strncat((char *)tempconfig,nwsof,nwmlen);
 804f910:	4b4d      	ldr	r3, [pc, #308]	; (804fa48 <parseRemoteconfig+0x2bc>)
 804f912:	f8d3 21d0 	ldr.w	r2, [r3, #464]	; 0x1d0
 804f916:	4b50      	ldr	r3, [pc, #320]	; (804fa58 <parseRemoteconfig+0x2cc>)
 804f918:	f8d3 175c 	ldr.w	r1, [r3, #1884]	; 0x75c
 804f91c:	f002 f8fa 	bl	8051b14 <strncat>
									gu32ConfigOperationStatus = TRUE;
 804f920:	4b49      	ldr	r3, [pc, #292]	; (804fa48 <parseRemoteconfig+0x2bc>)
 804f922:	2201      	movs	r2, #1
 804f924:	f8c3 21cc 	str.w	r2, [r3, #460]	; 0x1cc
 804f928:	e73c      	b.n	804f7a4 <parseRemoteconfig+0x18>
										gau32RemoteConfigSupport[enmCONFIG_NETWORK] = FALSE;
 804f92a:	4b4b      	ldr	r3, [pc, #300]	; (804fa58 <parseRemoteconfig+0x2cc>)
 804f92c:	2200      	movs	r2, #0
 804f92e:	f8c3 27b8 	str.w	r2, [r3, #1976]	; 0x7b8
										enmDeviceConfigState++;
 804f932:	4a45      	ldr	r2, [pc, #276]	; (804fa48 <parseRemoteconfig+0x2bc>)
 804f934:	f892 31c4 	ldrb.w	r3, [r2, #452]	; 0x1c4
 804f938:	3301      	adds	r3, #1
 804f93a:	f882 31c4 	strb.w	r3, [r2, #452]	; 0x1c4
 804f93e:	e7ef      	b.n	804f920 <parseRemoteconfig+0x194>
									enmDeviceConfigState++;
 804f940:	3301      	adds	r3, #1
 804f942:	4a41      	ldr	r2, [pc, #260]	; (804fa48 <parseRemoteconfig+0x2bc>)
 804f944:	f882 31c4 	strb.w	r3, [r2, #452]	; 0x1c4
 804f948:	e72c      	b.n	804f7a4 <parseRemoteconfig+0x18>
								gu32ConfigOperationStatus = FALSE;
 804f94a:	4a3f      	ldr	r2, [pc, #252]	; (804fa48 <parseRemoteconfig+0x2bc>)
 804f94c:	2100      	movs	r1, #0
 804f94e:	f8c2 11cc 	str.w	r1, [r2, #460]	; 0x1cc
								enmDeviceConfigState++;
 804f952:	3301      	adds	r3, #1
 804f954:	f882 31c4 	strb.w	r3, [r2, #452]	; 0x1c4
 804f958:	e724      	b.n	804f7a4 <parseRemoteconfig+0x18>
						if(gau32RemoteConfigSupport[enmCONFIG_MODBUS485] == TRUE)
 804f95a:	4a3f      	ldr	r2, [pc, #252]	; (804fa58 <parseRemoteconfig+0x2cc>)
 804f95c:	f8d2 27bc 	ldr.w	r2, [r2, #1980]	; 0x7bc
 804f960:	2a01      	cmp	r2, #1
 804f962:	d004      	beq.n	804f96e <parseRemoteconfig+0x1e2>
							enmDeviceConfigState++;
 804f964:	3301      	adds	r3, #1
 804f966:	4a38      	ldr	r2, [pc, #224]	; (804fa48 <parseRemoteconfig+0x2bc>)
 804f968:	f882 31c4 	strb.w	r3, [r2, #452]	; 0x1c4
 804f96c:	e71a      	b.n	804f7a4 <parseRemoteconfig+0x18>
							if(gu32ConfigOperationStatus == FALSE)
 804f96e:	4a36      	ldr	r2, [pc, #216]	; (804fa48 <parseRemoteconfig+0x2bc>)
 804f970:	f8d2 21cc 	ldr.w	r2, [r2, #460]	; 0x1cc
 804f974:	bb22      	cbnz	r2, 804f9c0 <parseRemoteconfig+0x234>
								if((mb485sof != NULL) && (mb485eof != NULL))
 804f976:	4a38      	ldr	r2, [pc, #224]	; (804fa58 <parseRemoteconfig+0x2cc>)
 804f978:	f8d2 1764 	ldr.w	r1, [r2, #1892]	; 0x764
 804f97c:	b1d9      	cbz	r1, 804f9b6 <parseRemoteconfig+0x22a>
 804f97e:	f8d2 2768 	ldr.w	r2, [r2, #1896]	; 0x768
 804f982:	b1c2      	cbz	r2, 804f9b6 <parseRemoteconfig+0x22a>
									mb485mlen = (mb485eof - mb485sof) + 4 ;
 804f984:	1a52      	subs	r2, r2, r1
 804f986:	3204      	adds	r2, #4
 804f988:	482f      	ldr	r0, [pc, #188]	; (804fa48 <parseRemoteconfig+0x2bc>)
 804f98a:	f8c0 21d4 	str.w	r2, [r0, #468]	; 0x1d4
									if(tempconfig != NULL)
 804f98e:	4832      	ldr	r0, [pc, #200]	; (804fa58 <parseRemoteconfig+0x2cc>)
 804f990:	f8d0 07d4 	ldr.w	r0, [r0, #2004]	; 0x7d4
 804f994:	b130      	cbz	r0, 804f9a4 <parseRemoteconfig+0x218>
										strncat((char *)tempconfig,mb485sof,mb485mlen);
 804f996:	f002 f8bd 	bl	8051b14 <strncat>
									gu32ConfigOperationStatus = TRUE;
 804f99a:	4b2b      	ldr	r3, [pc, #172]	; (804fa48 <parseRemoteconfig+0x2bc>)
 804f99c:	2201      	movs	r2, #1
 804f99e:	f8c3 21cc 	str.w	r2, [r3, #460]	; 0x1cc
 804f9a2:	e6ff      	b.n	804f7a4 <parseRemoteconfig+0x18>
										gau32RemoteConfigSupport[enmCONFIG_NETWORK] = FALSE;
 804f9a4:	4a2c      	ldr	r2, [pc, #176]	; (804fa58 <parseRemoteconfig+0x2cc>)
 804f9a6:	2100      	movs	r1, #0
 804f9a8:	f8c2 17b8 	str.w	r1, [r2, #1976]	; 0x7b8
										enmDeviceConfigState++;
 804f9ac:	3301      	adds	r3, #1
 804f9ae:	4a26      	ldr	r2, [pc, #152]	; (804fa48 <parseRemoteconfig+0x2bc>)
 804f9b0:	f882 31c4 	strb.w	r3, [r2, #452]	; 0x1c4
 804f9b4:	e7f1      	b.n	804f99a <parseRemoteconfig+0x20e>
									enmDeviceConfigState++;
 804f9b6:	3301      	adds	r3, #1
 804f9b8:	4a23      	ldr	r2, [pc, #140]	; (804fa48 <parseRemoteconfig+0x2bc>)
 804f9ba:	f882 31c4 	strb.w	r3, [r2, #452]	; 0x1c4
 804f9be:	e6f1      	b.n	804f7a4 <parseRemoteconfig+0x18>
								gu32ConfigOperationStatus = FALSE;
 804f9c0:	4a21      	ldr	r2, [pc, #132]	; (804fa48 <parseRemoteconfig+0x2bc>)
 804f9c2:	2100      	movs	r1, #0
 804f9c4:	f8c2 11cc 	str.w	r1, [r2, #460]	; 0x1cc
								enmDeviceConfigState++;
 804f9c8:	3301      	adds	r3, #1
 804f9ca:	f882 31c4 	strb.w	r3, [r2, #452]	; 0x1c4
 804f9ce:	e6e9      	b.n	804f7a4 <parseRemoteconfig+0x18>
						if(gau32RemoteConfigSupport[enmCONFIG_MODBUSTCP] == TRUE)
 804f9d0:	4a21      	ldr	r2, [pc, #132]	; (804fa58 <parseRemoteconfig+0x2cc>)
 804f9d2:	f8d2 27c0 	ldr.w	r2, [r2, #1984]	; 0x7c0
 804f9d6:	2a01      	cmp	r2, #1
 804f9d8:	d004      	beq.n	804f9e4 <parseRemoteconfig+0x258>
							enmDeviceConfigState++;
 804f9da:	3301      	adds	r3, #1
 804f9dc:	4a1a      	ldr	r2, [pc, #104]	; (804fa48 <parseRemoteconfig+0x2bc>)
 804f9de:	f882 31c4 	strb.w	r3, [r2, #452]	; 0x1c4
 804f9e2:	e6df      	b.n	804f7a4 <parseRemoteconfig+0x18>
								if(gu32ConfigOperationStatus == FALSE)
 804f9e4:	4a18      	ldr	r2, [pc, #96]	; (804fa48 <parseRemoteconfig+0x2bc>)
 804f9e6:	f8d2 21cc 	ldr.w	r2, [r2, #460]	; 0x1cc
 804f9ea:	bb22      	cbnz	r2, 804fa36 <parseRemoteconfig+0x2aa>
									if((mbTCPsof != NULL) && (mbTCPeof != NULL))
 804f9ec:	4a1a      	ldr	r2, [pc, #104]	; (804fa58 <parseRemoteconfig+0x2cc>)
 804f9ee:	f8d2 17d8 	ldr.w	r1, [r2, #2008]	; 0x7d8
 804f9f2:	b1d9      	cbz	r1, 804fa2c <parseRemoteconfig+0x2a0>
 804f9f4:	f8d2 27dc 	ldr.w	r2, [r2, #2012]	; 0x7dc
 804f9f8:	b1c2      	cbz	r2, 804fa2c <parseRemoteconfig+0x2a0>
										mbtcpmlen = (mbTCPeof-mbTCPsof) + 4;
 804f9fa:	1a52      	subs	r2, r2, r1
 804f9fc:	3204      	adds	r2, #4
 804f9fe:	4812      	ldr	r0, [pc, #72]	; (804fa48 <parseRemoteconfig+0x2bc>)
 804fa00:	f8c0 21d8 	str.w	r2, [r0, #472]	; 0x1d8
										if(tempconfig != NULL)
 804fa04:	4814      	ldr	r0, [pc, #80]	; (804fa58 <parseRemoteconfig+0x2cc>)
 804fa06:	f8d0 07d4 	ldr.w	r0, [r0, #2004]	; 0x7d4
 804fa0a:	b130      	cbz	r0, 804fa1a <parseRemoteconfig+0x28e>
											strncat((char *)tempconfig,mbTCPsof,mbtcpmlen);
 804fa0c:	f002 f882 	bl	8051b14 <strncat>
										gu32ConfigOperationStatus = TRUE;
 804fa10:	4b0d      	ldr	r3, [pc, #52]	; (804fa48 <parseRemoteconfig+0x2bc>)
 804fa12:	2201      	movs	r2, #1
 804fa14:	f8c3 21cc 	str.w	r2, [r3, #460]	; 0x1cc
 804fa18:	e6c4      	b.n	804f7a4 <parseRemoteconfig+0x18>
											gau32RemoteConfigSupport[enmCONFIG_MODBUSTCP] = FALSE;
 804fa1a:	4a0f      	ldr	r2, [pc, #60]	; (804fa58 <parseRemoteconfig+0x2cc>)
 804fa1c:	2100      	movs	r1, #0
 804fa1e:	f8c2 17c0 	str.w	r1, [r2, #1984]	; 0x7c0
											enmDeviceConfigState++;
 804fa22:	3301      	adds	r3, #1
 804fa24:	4a08      	ldr	r2, [pc, #32]	; (804fa48 <parseRemoteconfig+0x2bc>)
 804fa26:	f882 31c4 	strb.w	r3, [r2, #452]	; 0x1c4
 804fa2a:	e7f1      	b.n	804fa10 <parseRemoteconfig+0x284>
										enmDeviceConfigState++;
 804fa2c:	3301      	adds	r3, #1
 804fa2e:	4a06      	ldr	r2, [pc, #24]	; (804fa48 <parseRemoteconfig+0x2bc>)
 804fa30:	f882 31c4 	strb.w	r3, [r2, #452]	; 0x1c4
 804fa34:	e6b6      	b.n	804f7a4 <parseRemoteconfig+0x18>
									gu32ConfigOperationStatus = FALSE;
 804fa36:	4a04      	ldr	r2, [pc, #16]	; (804fa48 <parseRemoteconfig+0x2bc>)
 804fa38:	2100      	movs	r1, #0
 804fa3a:	f8c2 11cc 	str.w	r1, [r2, #460]	; 0x1cc
									enmDeviceConfigState++;
 804fa3e:	3301      	adds	r3, #1
 804fa40:	f882 31c4 	strb.w	r3, [r2, #452]	; 0x1c4
 804fa44:	e6ae      	b.n	804f7a4 <parseRemoteconfig+0x18>
 804fa46:	bf00      	nop
 804fa48:	20004d2c 	.word	0x20004d2c
 804fa4c:	20002e0c 	.word	0x20002e0c
 804fa50:	200087e4 	.word	0x200087e4
 804fa54:	40020c00 	.word	0x40020c00
 804fa58:	20002694 	.word	0x20002694
 804fa5c:	081c0000 	.word	0x081c0000
 804fa60:	2000d508 	.word	0x2000d508
 804fa64:	0805a920 	.word	0x0805a920
 804fa68:	20004ef4 	.word	0x20004ef4
						if(gau32RemoteConfigSupport[enmCONFIG_DATAMGMT] == TRUE)
 804fa6c:	4a36      	ldr	r2, [pc, #216]	; (804fb48 <parseRemoteconfig+0x3bc>)
 804fa6e:	f8d2 27c4 	ldr.w	r2, [r2, #1988]	; 0x7c4
 804fa72:	2a01      	cmp	r2, #1
 804fa74:	f43f ae96 	beq.w	804f7a4 <parseRemoteconfig+0x18>
							enmDeviceConfigState++;
 804fa78:	3301      	adds	r3, #1
 804fa7a:	4a34      	ldr	r2, [pc, #208]	; (804fb4c <parseRemoteconfig+0x3c0>)
 804fa7c:	f882 31c4 	strb.w	r3, [r2, #452]	; 0x1c4
 804fa80:	e690      	b.n	804f7a4 <parseRemoteconfig+0x18>
						if(gau32RemoteConfigSupport[enmCONFIG_CAN_1] == TRUE)
 804fa82:	4a31      	ldr	r2, [pc, #196]	; (804fb48 <parseRemoteconfig+0x3bc>)
 804fa84:	f8d2 27c8 	ldr.w	r2, [r2, #1992]	; 0x7c8
 804fa88:	2a01      	cmp	r2, #1
 804fa8a:	f43f ae8b 	beq.w	804f7a4 <parseRemoteconfig+0x18>
							enmDeviceConfigState++;
 804fa8e:	3301      	adds	r3, #1
 804fa90:	4a2e      	ldr	r2, [pc, #184]	; (804fb4c <parseRemoteconfig+0x3c0>)
 804fa92:	f882 31c4 	strb.w	r3, [r2, #452]	; 0x1c4
 804fa96:	e685      	b.n	804f7a4 <parseRemoteconfig+0x18>
						if(gau32RemoteConfigSupport[enmCONFIG_CAN_2] == TRUE)
 804fa98:	4a2b      	ldr	r2, [pc, #172]	; (804fb48 <parseRemoteconfig+0x3bc>)
 804fa9a:	f8d2 27cc 	ldr.w	r2, [r2, #1996]	; 0x7cc
 804fa9e:	2a01      	cmp	r2, #1
 804faa0:	f43f ae80 	beq.w	804f7a4 <parseRemoteconfig+0x18>
							enmDeviceConfigState++;
 804faa4:	3301      	adds	r3, #1
 804faa6:	4a29      	ldr	r2, [pc, #164]	; (804fb4c <parseRemoteconfig+0x3c0>)
 804faa8:	f882 31c4 	strb.w	r3, [r2, #452]	; 0x1c4
 804faac:	e67a      	b.n	804f7a4 <parseRemoteconfig+0x18>
						if(gau32RemoteConfigSupport[enmCONFIG_DEBUG] == TRUE)
 804faae:	4a26      	ldr	r2, [pc, #152]	; (804fb48 <parseRemoteconfig+0x3bc>)
 804fab0:	f8d2 27d0 	ldr.w	r2, [r2, #2000]	; 0x7d0
 804fab4:	2a01      	cmp	r2, #1
 804fab6:	f43f ae75 	beq.w	804f7a4 <parseRemoteconfig+0x18>
							enmDeviceConfigState++;
 804faba:	3301      	adds	r3, #1
 804fabc:	4a23      	ldr	r2, [pc, #140]	; (804fb4c <parseRemoteconfig+0x3c0>)
 804fabe:	f882 31c4 	strb.w	r3, [r2, #452]	; 0x1c4
 804fac2:	e66f      	b.n	804f7a4 <parseRemoteconfig+0x18>
						if(gau32RemoteConfigSupport[enmCONFIG_MQTT] == TRUE)
 804fac4:	4a20      	ldr	r2, [pc, #128]	; (804fb48 <parseRemoteconfig+0x3bc>)
 804fac6:	f8d2 27d4 	ldr.w	r2, [r2, #2004]	; 0x7d4
 804faca:	2a01      	cmp	r2, #1
 804facc:	f43f ae6a 	beq.w	804f7a4 <parseRemoteconfig+0x18>
							enmDeviceConfigState++ ;
 804fad0:	3301      	adds	r3, #1
 804fad2:	4a1e      	ldr	r2, [pc, #120]	; (804fb4c <parseRemoteconfig+0x3c0>)
 804fad4:	f882 31c4 	strb.w	r3, [r2, #452]	; 0x1c4
 804fad8:	e664      	b.n	804f7a4 <parseRemoteconfig+0x18>
						if(FLASH_If_Erase(ADDR_FLASH_SECTOR_11) != FLASHIF_OK)
 804fada:	481d      	ldr	r0, [pc, #116]	; (804fb50 <parseRemoteconfig+0x3c4>)
 804fadc:	f001 fa60 	bl	8050fa0 <FLASH_If_Erase>
 804fae0:	b9c0      	cbnz	r0, 804fb14 <parseRemoteconfig+0x388>
							if(u32LastMemoryWriteLocation == 0)
 804fae2:	4b1c      	ldr	r3, [pc, #112]	; (804fb54 <parseRemoteconfig+0x3c8>)
 804fae4:	681b      	ldr	r3, [r3, #0]
 804fae6:	b913      	cbnz	r3, 804faee <parseRemoteconfig+0x362>
								u32LastMemoryWriteLocation = ADDR_FLASH_SECTOR_11; // against 22
 804fae8:	4b1a      	ldr	r3, [pc, #104]	; (804fb54 <parseRemoteconfig+0x3c8>)
 804faea:	4a19      	ldr	r2, [pc, #100]	; (804fb50 <parseRemoteconfig+0x3c4>)
 804faec:	601a      	str	r2, [r3, #0]
							if(WriteDatatoFlash(u32LastMemoryWriteLocation,(uint8_t *)tempconfig,(nwmlen+mb485mlen+mbtcpmlen+4),1) == SUCCESS)
 804faee:	4a17      	ldr	r2, [pc, #92]	; (804fb4c <parseRemoteconfig+0x3c0>)
 804faf0:	f8d2 31d0 	ldr.w	r3, [r2, #464]	; 0x1d0
 804faf4:	f8d2 11d4 	ldr.w	r1, [r2, #468]	; 0x1d4
 804faf8:	440b      	add	r3, r1
 804fafa:	f8d2 21d8 	ldr.w	r2, [r2, #472]	; 0x1d8
 804fafe:	441a      	add	r2, r3
 804fb00:	2301      	movs	r3, #1
 804fb02:	3204      	adds	r2, #4
 804fb04:	4910      	ldr	r1, [pc, #64]	; (804fb48 <parseRemoteconfig+0x3bc>)
 804fb06:	f8d1 17d4 	ldr.w	r1, [r1, #2004]	; 0x7d4
 804fb0a:	4812      	ldr	r0, [pc, #72]	; (804fb54 <parseRemoteconfig+0x3c8>)
 804fb0c:	6800      	ldr	r0, [r0, #0]
 804fb0e:	f001 fa8d 	bl	805102c <WriteDatatoFlash>
 804fb12:	b120      	cbz	r0, 804fb1e <parseRemoteconfig+0x392>
						gu32ParseConfigAvailable = FALSE;
 804fb14:	4b0d      	ldr	r3, [pc, #52]	; (804fb4c <parseRemoteconfig+0x3c0>)
 804fb16:	2200      	movs	r2, #0
 804fb18:	f8c3 21c0 	str.w	r2, [r3, #448]	; 0x1c0
						break;
 804fb1c:	e642      	b.n	804f7a4 <parseRemoteconfig+0x18>
								tempconfig = NULL;
 804fb1e:	4b0a      	ldr	r3, [pc, #40]	; (804fb48 <parseRemoteconfig+0x3bc>)
 804fb20:	2200      	movs	r2, #0
 804fb22:	f8c3 27d4 	str.w	r2, [r3, #2004]	; 0x7d4
								HAL_Delay(3000);
 804fb26:	f640 30b8 	movw	r0, #3000	; 0xbb8
 804fb2a:	f7f1 facf 	bl	80410cc <HAL_Delay>
								HAL_Delay(1000000);
 804fb2e:	4c0a      	ldr	r4, [pc, #40]	; (804fb58 <parseRemoteconfig+0x3cc>)
 804fb30:	4620      	mov	r0, r4
 804fb32:	f7f1 facb 	bl	80410cc <HAL_Delay>
								HAL_Delay(1000000);
 804fb36:	4620      	mov	r0, r4
 804fb38:	f7f1 fac8 	bl	80410cc <HAL_Delay>
 804fb3c:	e7ea      	b.n	804fb14 <parseRemoteconfig+0x388>
						gu32ParseConfigAvailable = FALSE;
 804fb3e:	4b03      	ldr	r3, [pc, #12]	; (804fb4c <parseRemoteconfig+0x3c0>)
 804fb40:	2200      	movs	r2, #0
 804fb42:	f8c3 21c0 	str.w	r2, [r3, #448]	; 0x1c0
}
 804fb46:	e62d      	b.n	804f7a4 <parseRemoteconfig+0x18>
 804fb48:	20002694 	.word	0x20002694
 804fb4c:	20004d2c 	.word	0x20004d2c
 804fb50:	080e0000 	.word	0x080e0000
 804fb54:	20005038 	.word	0x20005038
 804fb58:	000f4240 	.word	0x000f4240

0804fb5c <extractNewtorkConfiguration>:
{
 804fb5c:	b510      	push	{r4, lr}
	gu32ExtractParamCounter = 0;
 804fb5e:	4b31      	ldr	r3, [pc, #196]	; (804fc24 <extractNewtorkConfiguration+0xc8>)
 804fb60:	2200      	movs	r2, #0
 804fb62:	f8c3 21dc 	str.w	r2, [r3, #476]	; 0x1dc
	char *configptr = strtok(nwsof, ",");
 804fb66:	4930      	ldr	r1, [pc, #192]	; (804fc28 <extractNewtorkConfiguration+0xcc>)
 804fb68:	4b30      	ldr	r3, [pc, #192]	; (804fc2c <extractNewtorkConfiguration+0xd0>)
 804fb6a:	f8d3 075c 	ldr.w	r0, [r3, #1884]	; 0x75c
 804fb6e:	f002 fe41 	bl	80527f4 <strtok>
 804fb72:	4601      	mov	r1, r0
	while(configptr != NULL)
 804fb74:	e00b      	b.n	804fb8e <extractNewtorkConfiguration+0x32>
				strcpy(gau8ConfigNewtorkIsEnabled,configptr);
 804fb76:	482b      	ldr	r0, [pc, #172]	; (804fc24 <extractNewtorkConfiguration+0xc8>)
 804fb78:	f001 ffc4 	bl	8051b04 <strcpy>
		gu32ExtractParamCounter++;
 804fb7c:	3401      	adds	r4, #1
 804fb7e:	4b29      	ldr	r3, [pc, #164]	; (804fc24 <extractNewtorkConfiguration+0xc8>)
 804fb80:	f8c3 41dc 	str.w	r4, [r3, #476]	; 0x1dc
		configptr = strtok(NULL, ",");
 804fb84:	4928      	ldr	r1, [pc, #160]	; (804fc28 <extractNewtorkConfiguration+0xcc>)
 804fb86:	2000      	movs	r0, #0
 804fb88:	f002 fe34 	bl	80527f4 <strtok>
 804fb8c:	4601      	mov	r1, r0
	while(configptr != NULL)
 804fb8e:	2900      	cmp	r1, #0
 804fb90:	d040      	beq.n	804fc14 <extractNewtorkConfiguration+0xb8>
		switch(gu32ExtractParamCounter)
 804fb92:	4b24      	ldr	r3, [pc, #144]	; (804fc24 <extractNewtorkConfiguration+0xc8>)
 804fb94:	f8d3 41dc 	ldr.w	r4, [r3, #476]	; 0x1dc
 804fb98:	1e63      	subs	r3, r4, #1
 804fb9a:	2b09      	cmp	r3, #9
 804fb9c:	d8ee      	bhi.n	804fb7c <extractNewtorkConfiguration+0x20>
 804fb9e:	a201      	add	r2, pc, #4	; (adr r2, 804fba4 <extractNewtorkConfiguration+0x48>)
 804fba0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 804fba4:	0804fb77 	.word	0x0804fb77
 804fba8:	0804fbcd 	.word	0x0804fbcd
 804fbac:	0804fbd5 	.word	0x0804fbd5
 804fbb0:	0804fbdd 	.word	0x0804fbdd
 804fbb4:	0804fbe5 	.word	0x0804fbe5
 804fbb8:	0804fbed 	.word	0x0804fbed
 804fbbc:	0804fbf5 	.word	0x0804fbf5
 804fbc0:	0804fbfd 	.word	0x0804fbfd
 804fbc4:	0804fc05 	.word	0x0804fc05
 804fbc8:	0804fc0d 	.word	0x0804fc0d
				strcpy(gau8ConfigNewtorkServerURL,configptr);
 804fbcc:	4818      	ldr	r0, [pc, #96]	; (804fc30 <extractNewtorkConfiguration+0xd4>)
 804fbce:	f001 ff99 	bl	8051b04 <strcpy>
				break;
 804fbd2:	e7d3      	b.n	804fb7c <extractNewtorkConfiguration+0x20>
				strcpy(gau8ConfigNewtorkConfigURL,configptr);
 804fbd4:	4817      	ldr	r0, [pc, #92]	; (804fc34 <extractNewtorkConfiguration+0xd8>)
 804fbd6:	f001 ff95 	bl	8051b04 <strcpy>
				break;
 804fbda:	e7cf      	b.n	804fb7c <extractNewtorkConfiguration+0x20>
				strcpy(gau8ConfigNewtorkAPN,configptr);
 804fbdc:	4813      	ldr	r0, [pc, #76]	; (804fc2c <extractNewtorkConfiguration+0xd0>)
 804fbde:	f001 ff91 	bl	8051b04 <strcpy>
				break;
 804fbe2:	e7cb      	b.n	804fb7c <extractNewtorkConfiguration+0x20>
				strcpy(gau8ConfigNewtorkUpFreqSupply,configptr);
 804fbe4:	4814      	ldr	r0, [pc, #80]	; (804fc38 <extractNewtorkConfiguration+0xdc>)
 804fbe6:	f001 ff8d 	bl	8051b04 <strcpy>
				break;
 804fbea:	e7c7      	b.n	804fb7c <extractNewtorkConfiguration+0x20>
				strcpy(gau8ConfigNewtorkUpFreqBatt,configptr);
 804fbec:	4813      	ldr	r0, [pc, #76]	; (804fc3c <extractNewtorkConfiguration+0xe0>)
 804fbee:	f001 ff89 	bl	8051b04 <strcpy>
				break;
 804fbf2:	e7c3      	b.n	804fb7c <extractNewtorkConfiguration+0x20>
				strcpy(gau8ConfigNewtorkType,configptr);
 804fbf4:	4812      	ldr	r0, [pc, #72]	; (804fc40 <extractNewtorkConfiguration+0xe4>)
 804fbf6:	f001 ff85 	bl	8051b04 <strcpy>
				break;
 804fbfa:	e7bf      	b.n	804fb7c <extractNewtorkConfiguration+0x20>
				strcpy(gau8ConfigNewtorkGPSEnable,configptr);
 804fbfc:	4811      	ldr	r0, [pc, #68]	; (804fc44 <extractNewtorkConfiguration+0xe8>)
 804fbfe:	f001 ff81 	bl	8051b04 <strcpy>
				break;
 804fc02:	e7bb      	b.n	804fb7c <extractNewtorkConfiguration+0x20>
				strcpy(gau8ConfigNewtorkSendData,configptr);
 804fc04:	4810      	ldr	r0, [pc, #64]	; (804fc48 <extractNewtorkConfiguration+0xec>)
 804fc06:	f001 ff7d 	bl	8051b04 <strcpy>
				break;
 804fc0a:	e7b7      	b.n	804fb7c <extractNewtorkConfiguration+0x20>
				strcpy(gau8ConfigNewtorkSendDataDisableTime,configptr);
 804fc0c:	480f      	ldr	r0, [pc, #60]	; (804fc4c <extractNewtorkConfiguration+0xf0>)
 804fc0e:	f001 ff79 	bl	8051b04 <strcpy>
				break;
 804fc12:	e7b3      	b.n	804fb7c <extractNewtorkConfiguration+0x20>
	gu32ExtractParamCounter = 0;
 804fc14:	4b03      	ldr	r3, [pc, #12]	; (804fc24 <extractNewtorkConfiguration+0xc8>)
 804fc16:	2200      	movs	r2, #0
 804fc18:	f8c3 21dc 	str.w	r2, [r3, #476]	; 0x1dc
	verifyNetworkConfigData();
 804fc1c:	f7ff fb0e 	bl	804f23c <verifyNetworkConfigData>
}
 804fc20:	bd10      	pop	{r4, pc}
 804fc22:	bf00      	nop
 804fc24:	20004d2c 	.word	0x20004d2c
 804fc28:	0805a920 	.word	0x0805a920
 804fc2c:	20002694 	.word	0x20002694
 804fc30:	20004d34 	.word	0x20004d34
 804fc34:	20004dcc 	.word	0x20004dcc
 804fc38:	20004e64 	.word	0x20004e64
 804fc3c:	20004e70 	.word	0x20004e70
 804fc40:	20004e7c 	.word	0x20004e7c
 804fc44:	20004e80 	.word	0x20004e80
 804fc48:	20004e84 	.word	0x20004e84
 804fc4c:	20004e88 	.word	0x20004e88

0804fc50 <extractModbus485Configuration>:
{
 804fc50:	b570      	push	{r4, r5, r6, lr}
	char *configptr = strtok(mb485config, ",");//mb485config
 804fc52:	4977      	ldr	r1, [pc, #476]	; (804fe30 <extractModbus485Configuration+0x1e0>)
 804fc54:	4b77      	ldr	r3, [pc, #476]	; (804fe34 <extractModbus485Configuration+0x1e4>)
 804fc56:	f8d3 07e0 	ldr.w	r0, [r3, #2016]	; 0x7e0
 804fc5a:	f002 fdcb 	bl	80527f4 <strtok>
 804fc5e:	4604      	mov	r4, r0
	gu32ExtractParamCounter = 0;
 804fc60:	4b75      	ldr	r3, [pc, #468]	; (804fe38 <extractModbus485Configuration+0x1e8>)
 804fc62:	2200      	movs	r2, #0
 804fc64:	f8c3 21dc 	str.w	r2, [r3, #476]	; 0x1dc
	while(configptr != NULL)
 804fc68:	e00f      	b.n	804fc8a <extractModbus485Configuration+0x3a>
				strcpy(gau8ConfigModbus485IsEnabled,configptr);
 804fc6a:	4621      	mov	r1, r4
 804fc6c:	4873      	ldr	r0, [pc, #460]	; (804fe3c <extractModbus485Configuration+0x1ec>)
 804fc6e:	f001 ff49 	bl	8051b04 <strcpy>
		if(gu32ExtractParamCounter != 9)
 804fc72:	4b71      	ldr	r3, [pc, #452]	; (804fe38 <extractModbus485Configuration+0x1e8>)
 804fc74:	f8d3 31dc 	ldr.w	r3, [r3, #476]	; 0x1dc
 804fc78:	2b09      	cmp	r3, #9
 804fc7a:	f040 80cc 	bne.w	804fe16 <extractModbus485Configuration+0x1c6>
		gu32ExtractParamCounter++;
 804fc7e:	4a6e      	ldr	r2, [pc, #440]	; (804fe38 <extractModbus485Configuration+0x1e8>)
 804fc80:	f8d2 31dc 	ldr.w	r3, [r2, #476]	; 0x1dc
 804fc84:	3301      	adds	r3, #1
 804fc86:	f8c2 31dc 	str.w	r3, [r2, #476]	; 0x1dc
	while(configptr != NULL)
 804fc8a:	2c00      	cmp	r4, #0
 804fc8c:	f000 80c9 	beq.w	804fe22 <extractModbus485Configuration+0x1d2>
		switch(gu32ExtractParamCounter)
 804fc90:	4b69      	ldr	r3, [pc, #420]	; (804fe38 <extractModbus485Configuration+0x1e8>)
 804fc92:	f8d3 31dc 	ldr.w	r3, [r3, #476]	; 0x1dc
 804fc96:	3b01      	subs	r3, #1
 804fc98:	2b0f      	cmp	r3, #15
 804fc9a:	d8ea      	bhi.n	804fc72 <extractModbus485Configuration+0x22>
 804fc9c:	a201      	add	r2, pc, #4	; (adr r2, 804fca4 <extractModbus485Configuration+0x54>)
 804fc9e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 804fca2:	bf00      	nop
 804fca4:	0804fc6b 	.word	0x0804fc6b
 804fca8:	0804fce5 	.word	0x0804fce5
 804fcac:	0804fcef 	.word	0x0804fcef
 804fcb0:	0804fcf9 	.word	0x0804fcf9
 804fcb4:	0804fd03 	.word	0x0804fd03
 804fcb8:	0804fd0d 	.word	0x0804fd0d
 804fcbc:	0804fd17 	.word	0x0804fd17
 804fcc0:	0804fd21 	.word	0x0804fd21
 804fcc4:	0804fd2b 	.word	0x0804fd2b
 804fcc8:	0804fdd1 	.word	0x0804fdd1
 804fccc:	0804fddb 	.word	0x0804fddb
 804fcd0:	0804fde5 	.word	0x0804fde5
 804fcd4:	0804fdef 	.word	0x0804fdef
 804fcd8:	0804fdf9 	.word	0x0804fdf9
 804fcdc:	0804fe03 	.word	0x0804fe03
 804fce0:	0804fe0d 	.word	0x0804fe0d
				strcpy(gau8ConfigModbus485SlaveID,configptr);
 804fce4:	4621      	mov	r1, r4
 804fce6:	4856      	ldr	r0, [pc, #344]	; (804fe40 <extractModbus485Configuration+0x1f0>)
 804fce8:	f001 ff0c 	bl	8051b04 <strcpy>
				break;
 804fcec:	e7c1      	b.n	804fc72 <extractModbus485Configuration+0x22>
				strcpy(gau8ConfigModbus485Termination,configptr);
 804fcee:	4621      	mov	r1, r4
 804fcf0:	4854      	ldr	r0, [pc, #336]	; (804fe44 <extractModbus485Configuration+0x1f4>)
 804fcf2:	f001 ff07 	bl	8051b04 <strcpy>
				break;
 804fcf6:	e7bc      	b.n	804fc72 <extractModbus485Configuration+0x22>
				strcpy(gau8ConfigModbus485DataPoints,configptr);
 804fcf8:	4621      	mov	r1, r4
 804fcfa:	4853      	ldr	r0, [pc, #332]	; (804fe48 <extractModbus485Configuration+0x1f8>)
 804fcfc:	f001 ff02 	bl	8051b04 <strcpy>
				break;
 804fd00:	e7b7      	b.n	804fc72 <extractModbus485Configuration+0x22>
				strcpy(gau8ConfigModbus485UARTBR,configptr);
 804fd02:	4621      	mov	r1, r4
 804fd04:	4851      	ldr	r0, [pc, #324]	; (804fe4c <extractModbus485Configuration+0x1fc>)
 804fd06:	f001 fefd 	bl	8051b04 <strcpy>
				break;
 804fd0a:	e7b2      	b.n	804fc72 <extractModbus485Configuration+0x22>
				strcpy(gau8ConfigModbus485UARTStartBit,configptr);
 804fd0c:	4621      	mov	r1, r4
 804fd0e:	4850      	ldr	r0, [pc, #320]	; (804fe50 <extractModbus485Configuration+0x200>)
 804fd10:	f001 fef8 	bl	8051b04 <strcpy>
				break;
 804fd14:	e7ad      	b.n	804fc72 <extractModbus485Configuration+0x22>
				strcpy(gau8ConfigModbus485UARTStopBit,configptr);
 804fd16:	4621      	mov	r1, r4
 804fd18:	484e      	ldr	r0, [pc, #312]	; (804fe54 <extractModbus485Configuration+0x204>)
 804fd1a:	f001 fef3 	bl	8051b04 <strcpy>
				break;
 804fd1e:	e7a8      	b.n	804fc72 <extractModbus485Configuration+0x22>
				strcpy(gau8ConfigModbus485UARTParity,configptr);
 804fd20:	4621      	mov	r1, r4
 804fd22:	484d      	ldr	r0, [pc, #308]	; (804fe58 <extractModbus485Configuration+0x208>)
 804fd24:	f001 feee 	bl	8051b04 <strcpy>
				break;
 804fd28:	e7a3      	b.n	804fc72 <extractModbus485Configuration+0x22>
				if(atoi(gau8ConfigModbus485DataPoints) <= CONFIG_MB485_MAXPARAMS)
 804fd2a:	4847      	ldr	r0, [pc, #284]	; (804fe48 <extractModbus485Configuration+0x1f8>)
 804fd2c:	f001 fbc8 	bl	80514c0 <atoi>
 804fd30:	284b      	cmp	r0, #75	; 0x4b
 804fd32:	dc9e      	bgt.n	804fc72 <extractModbus485Configuration+0x22>
					for(u32Loopcounter = 0; u32Loopcounter < atoi(gau8ConfigModbus485DataPoints) ;u32Loopcounter++)
 804fd34:	2600      	movs	r6, #0
 804fd36:	4844      	ldr	r0, [pc, #272]	; (804fe48 <extractModbus485Configuration+0x1f8>)
 804fd38:	f001 fbc2 	bl	80514c0 <atoi>
 804fd3c:	42b0      	cmp	r0, r6
 804fd3e:	d912      	bls.n	804fd66 <extractModbus485Configuration+0x116>
						gau32ConfigModbus485Address[u32Loopcounter] = atoi(configptr);
 804fd40:	4620      	mov	r0, r4
 804fd42:	f001 fbbd 	bl	80514c0 <atoi>
 804fd46:	4d3b      	ldr	r5, [pc, #236]	; (804fe34 <extractModbus485Configuration+0x1e4>)
 804fd48:	eb05 0586 	add.w	r5, r5, r6, lsl #2
 804fd4c:	64a8      	str	r0, [r5, #72]	; 0x48
						gau32ConfigModbusTCPAddress[u32Loopcounter] = atoi(configptr);
 804fd4e:	4620      	mov	r0, r4
 804fd50:	f001 fbb6 	bl	80514c0 <atoi>
 804fd54:	f8c5 03d0 	str.w	r0, [r5, #976]	; 0x3d0
						configptr = strtok(NULL, ",");
 804fd58:	4935      	ldr	r1, [pc, #212]	; (804fe30 <extractModbus485Configuration+0x1e0>)
 804fd5a:	2000      	movs	r0, #0
 804fd5c:	f002 fd4a 	bl	80527f4 <strtok>
 804fd60:	4604      	mov	r4, r0
					for(u32Loopcounter = 0; u32Loopcounter < atoi(gau8ConfigModbus485DataPoints) ;u32Loopcounter++)
 804fd62:	3601      	adds	r6, #1
 804fd64:	e7e7      	b.n	804fd36 <extractModbus485Configuration+0xe6>
					for(u32Loopcounter = 0; u32Loopcounter < atoi(gau8ConfigModbus485DataPoints) ;u32Loopcounter++)
 804fd66:	2600      	movs	r6, #0
 804fd68:	e012      	b.n	804fd90 <extractModbus485Configuration+0x140>
						gau32ConfigModbus485DFunctionCode[u32Loopcounter] = atoi(configptr);
 804fd6a:	4620      	mov	r0, r4
 804fd6c:	f001 fba8 	bl	80514c0 <atoi>
 804fd70:	4d30      	ldr	r5, [pc, #192]	; (804fe34 <extractModbus485Configuration+0x1e4>)
 804fd72:	eb05 0586 	add.w	r5, r5, r6, lsl #2
 804fd76:	f8c5 0174 	str.w	r0, [r5, #372]	; 0x174
						gau32ConfigModbusTCPDFunctionCode[u32Loopcounter] = atoi(configptr);
 804fd7a:	4620      	mov	r0, r4
 804fd7c:	f001 fba0 	bl	80514c0 <atoi>
 804fd80:	f8c5 04fc 	str.w	r0, [r5, #1276]	; 0x4fc
						configptr = strtok(NULL, ",");
 804fd84:	492a      	ldr	r1, [pc, #168]	; (804fe30 <extractModbus485Configuration+0x1e0>)
 804fd86:	2000      	movs	r0, #0
 804fd88:	f002 fd34 	bl	80527f4 <strtok>
 804fd8c:	4604      	mov	r4, r0
					for(u32Loopcounter = 0; u32Loopcounter < atoi(gau8ConfigModbus485DataPoints) ;u32Loopcounter++)
 804fd8e:	3601      	adds	r6, #1
 804fd90:	482d      	ldr	r0, [pc, #180]	; (804fe48 <extractModbus485Configuration+0x1f8>)
 804fd92:	f001 fb95 	bl	80514c0 <atoi>
 804fd96:	42b0      	cmp	r0, r6
 804fd98:	d8e7      	bhi.n	804fd6a <extractModbus485Configuration+0x11a>
					for(u32Loopcounter = 0; u32Loopcounter < atoi(gau8ConfigModbus485DataPoints) ;u32Loopcounter++)
 804fd9a:	2600      	movs	r6, #0
 804fd9c:	e012      	b.n	804fdc4 <extractModbus485Configuration+0x174>
						gau32ConfigModbus485NoPoints[u32Loopcounter] = atoi(configptr);
 804fd9e:	4620      	mov	r0, r4
 804fda0:	f001 fb8e 	bl	80514c0 <atoi>
 804fda4:	4d23      	ldr	r5, [pc, #140]	; (804fe34 <extractModbus485Configuration+0x1e4>)
 804fda6:	eb05 0586 	add.w	r5, r5, r6, lsl #2
 804fdaa:	f8c5 02a0 	str.w	r0, [r5, #672]	; 0x2a0
						gau32ConfigModbusTCPNoPoints[u32Loopcounter] = atoi(configptr);
 804fdae:	4620      	mov	r0, r4
 804fdb0:	f001 fb86 	bl	80514c0 <atoi>
 804fdb4:	f8c5 0628 	str.w	r0, [r5, #1576]	; 0x628
						configptr = strtok(NULL, ",");
 804fdb8:	491d      	ldr	r1, [pc, #116]	; (804fe30 <extractModbus485Configuration+0x1e0>)
 804fdba:	2000      	movs	r0, #0
 804fdbc:	f002 fd1a 	bl	80527f4 <strtok>
 804fdc0:	4604      	mov	r4, r0
					for(u32Loopcounter = 0; u32Loopcounter < atoi(gau8ConfigModbus485DataPoints) ;u32Loopcounter++)
 804fdc2:	3601      	adds	r6, #1
 804fdc4:	4820      	ldr	r0, [pc, #128]	; (804fe48 <extractModbus485Configuration+0x1f8>)
 804fdc6:	f001 fb7b 	bl	80514c0 <atoi>
 804fdca:	42b0      	cmp	r0, r6
 804fdcc:	d8e7      	bhi.n	804fd9e <extractModbus485Configuration+0x14e>
 804fdce:	e750      	b.n	804fc72 <extractModbus485Configuration+0x22>
				strcpy(gau8ConfigModbus485PollingTime,configptr);
 804fdd0:	4621      	mov	r1, r4
 804fdd2:	4822      	ldr	r0, [pc, #136]	; (804fe5c <extractModbus485Configuration+0x20c>)
 804fdd4:	f001 fe96 	bl	8051b04 <strcpy>
				break;
 804fdd8:	e74b      	b.n	804fc72 <extractModbus485Configuration+0x22>
				strcpy(gau8ConfigModbus485ResponseTime,configptr);
 804fdda:	4621      	mov	r1, r4
 804fddc:	4820      	ldr	r0, [pc, #128]	; (804fe60 <extractModbus485Configuration+0x210>)
 804fdde:	f001 fe91 	bl	8051b04 <strcpy>
				break;
 804fde2:	e746      	b.n	804fc72 <extractModbus485Configuration+0x22>
				strcpy(gau8ConfigModbusTCPIPDEVICE,configptr);
 804fde4:	4621      	mov	r1, r4
 804fde6:	481f      	ldr	r0, [pc, #124]	; (804fe64 <extractModbus485Configuration+0x214>)
 804fde8:	f001 fe8c 	bl	8051b04 <strcpy>
				break;
 804fdec:	e741      	b.n	804fc72 <extractModbus485Configuration+0x22>
				strcpy(gau8ConfigModbusTCPIPSUBNET,configptr);
 804fdee:	4621      	mov	r1, r4
 804fdf0:	481d      	ldr	r0, [pc, #116]	; (804fe68 <extractModbus485Configuration+0x218>)
 804fdf2:	f001 fe87 	bl	8051b04 <strcpy>
				break;
 804fdf6:	e73c      	b.n	804fc72 <extractModbus485Configuration+0x22>
				strcpy(gau8ConfigModbusTCPIPSERVER,configptr);
 804fdf8:	4621      	mov	r1, r4
 804fdfa:	481c      	ldr	r0, [pc, #112]	; (804fe6c <extractModbus485Configuration+0x21c>)
 804fdfc:	f001 fe82 	bl	8051b04 <strcpy>
				break;
 804fe00:	e737      	b.n	804fc72 <extractModbus485Configuration+0x22>
				strcpy(gau8ConfigModbusTCPIPGATEWAY,configptr);
 804fe02:	4621      	mov	r1, r4
 804fe04:	481a      	ldr	r0, [pc, #104]	; (804fe70 <extractModbus485Configuration+0x220>)
 804fe06:	f001 fe7d 	bl	8051b04 <strcpy>
				break;
 804fe0a:	e732      	b.n	804fc72 <extractModbus485Configuration+0x22>
				strcpy(gau8ConfigModbusTCPPORT,configptr);
 804fe0c:	4621      	mov	r1, r4
 804fe0e:	4819      	ldr	r0, [pc, #100]	; (804fe74 <extractModbus485Configuration+0x224>)
 804fe10:	f001 fe78 	bl	8051b04 <strcpy>
				break;
 804fe14:	e72d      	b.n	804fc72 <extractModbus485Configuration+0x22>
			configptr = strtok(NULL, ",");
 804fe16:	4906      	ldr	r1, [pc, #24]	; (804fe30 <extractModbus485Configuration+0x1e0>)
 804fe18:	2000      	movs	r0, #0
 804fe1a:	f002 fceb 	bl	80527f4 <strtok>
 804fe1e:	4604      	mov	r4, r0
 804fe20:	e72d      	b.n	804fc7e <extractModbus485Configuration+0x2e>
	gu32ExtractParamCounter = 0;
 804fe22:	4b05      	ldr	r3, [pc, #20]	; (804fe38 <extractModbus485Configuration+0x1e8>)
 804fe24:	2200      	movs	r2, #0
 804fe26:	f8c3 21dc 	str.w	r2, [r3, #476]	; 0x1dc
	verifyModbus485ConfigData();
 804fe2a:	f7ff facf 	bl	804f3cc <verifyModbus485ConfigData>
}
 804fe2e:	bd70      	pop	{r4, r5, r6, pc}
 804fe30:	0805a920 	.word	0x0805a920
 804fe34:	20002694 	.word	0x20002694
 804fe38:	20004d2c 	.word	0x20004d2c
 804fe3c:	20004e94 	.word	0x20004e94
 804fe40:	20004e9c 	.word	0x20004e9c
 804fe44:	20004ea4 	.word	0x20004ea4
 804fe48:	20004ea8 	.word	0x20004ea8
 804fe4c:	200026d0 	.word	0x200026d0
 804fe50:	20004eac 	.word	0x20004eac
 804fe54:	20004eb0 	.word	0x20004eb0
 804fe58:	20004f0c 	.word	0x20004f0c
 804fe5c:	20004eb4 	.word	0x20004eb4
 804fe60:	20004ebc 	.word	0x20004ebc
 804fe64:	20004f10 	.word	0x20004f10
 804fe68:	20004f20 	.word	0x20004f20
 804fe6c:	20004f30 	.word	0x20004f30
 804fe70:	20004f40 	.word	0x20004f40
 804fe74:	20004ec8 	.word	0x20004ec8

0804fe78 <getLastKnownConfiguration>:
*
*******************************************************************************/
/*
 * TODO - If we parse network configuration before modbus then modbus configuration gets corrupted */
void getLastKnownConfiguration(void)
{
 804fe78:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 804fe7c:	af00      	add	r7, sp, #0
	/* Read Sector 22 till we get FF */
	uint32_t flashAddress = ADDR_FLASH_SECTOR_11;
	uint32_t loopCounter = 0;

	if(strlen(tempconfig) == 0)
 804fe7e:	4bc9      	ldr	r3, [pc, #804]	; (80501a4 <getLastKnownConfiguration+0x32c>)
 804fe80:	f8d3 37d4 	ldr.w	r3, [r3, #2004]	; 0x7d4
 804fe84:	781b      	ldrb	r3, [r3, #0]
 804fe86:	2b00      	cmp	r3, #0
 804fe88:	f000 8188 	beq.w	805019c <getLastKnownConfiguration+0x324>
				gau8LastKnownConfiguration[loopCounter] = *(uint8_t *)flashAddress;
				flashAddress++;
			}
		}
	}
}
 804fe8c:	46bd      	mov	sp, r7
 804fe8e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
						mb485mlen = mb485eof - mb485sof;
 804fe92:	1b86      	subs	r6, r0, r6
 804fe94:	4bc4      	ldr	r3, [pc, #784]	; (80501a8 <getLastKnownConfiguration+0x330>)
 804fe96:	f8c3 61d4 	str.w	r6, [r3, #468]	; 0x1d4
						mb485config = (char *)malloc((sizeof(char) *mb485mlen));
 804fe9a:	4630      	mov	r0, r6
 804fe9c:	f001 fb52 	bl	8051544 <malloc>
 804fea0:	4bc0      	ldr	r3, [pc, #768]	; (80501a4 <getLastKnownConfiguration+0x32c>)
 804fea2:	f8c3 07e0 	str.w	r0, [r3, #2016]	; 0x7e0
						if(mb485config!= NULL)
 804fea6:	b180      	cbz	r0, 804feca <getLastKnownConfiguration+0x52>
							memset(mb485config, 0, mb485mlen);
 804fea8:	4632      	mov	r2, r6
 804feaa:	2100      	movs	r1, #0
 804feac:	f001 fdb8 	bl	8051a20 <memset>
							memcpy(mb485config,mb485sof,mb485mlen);
 804feb0:	4bbc      	ldr	r3, [pc, #752]	; (80501a4 <getLastKnownConfiguration+0x32c>)
 804feb2:	4abd      	ldr	r2, [pc, #756]	; (80501a8 <getLastKnownConfiguration+0x330>)
 804feb4:	f8d2 21d4 	ldr.w	r2, [r2, #468]	; 0x1d4
 804feb8:	f8d3 1764 	ldr.w	r1, [r3, #1892]	; 0x764
 804febc:	f8d3 07e0 	ldr.w	r0, [r3, #2016]	; 0x7e0
 804fec0:	f001 fda0 	bl	8051a04 <memcpy>
							extractModbus485Configuration();
 804fec4:	f7ff fec4 	bl	804fc50 <extractModbus485Configuration>
 804fec8:	e0e0      	b.n	805008c <getLastKnownConfiguration+0x214>
							gu32ConfigModbus485ErrorDatabase |= (1 << enmCONFIG_MB485CONFIGNOTFOUND);
 804feca:	4ab7      	ldr	r2, [pc, #732]	; (80501a8 <getLastKnownConfiguration+0x330>)
 804fecc:	f8d2 316c 	ldr.w	r3, [r2, #364]	; 0x16c
 804fed0:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 804fed4:	f8c2 316c 	str.w	r3, [r2, #364]	; 0x16c
 804fed8:	e0d8      	b.n	805008c <getLastKnownConfiguration+0x214>
						nwmlen = nweof - nwsof;
 804feda:	1b0c      	subs	r4, r1, r4
 804fedc:	4bb2      	ldr	r3, [pc, #712]	; (80501a8 <getLastKnownConfiguration+0x330>)
 804fede:	f8c3 41d0 	str.w	r4, [r3, #464]	; 0x1d0
						nwconfig = (char *)malloc((sizeof(char) *nwmlen));
 804fee2:	4620      	mov	r0, r4
 804fee4:	f001 fb2e 	bl	8051544 <malloc>
 804fee8:	4bae      	ldr	r3, [pc, #696]	; (80501a4 <getLastKnownConfiguration+0x32c>)
 804feea:	f8c3 0fb8 	str.w	r0, [r3, #4024]	; 0xfb8
						if(nwconfig!= NULL)
 804feee:	b300      	cbz	r0, 804ff32 <getLastKnownConfiguration+0xba>
						{
 804fef0:	466d      	mov	r5, sp
							char u8temp_array[nwmlen];
 804fef2:	1de3      	adds	r3, r4, #7
 804fef4:	f023 0307 	bic.w	r3, r3, #7
 804fef8:	ebad 0d03 	sub.w	sp, sp, r3
							memset(nwconfig, 0, nwmlen);
 804fefc:	4622      	mov	r2, r4
 804fefe:	2100      	movs	r1, #0
 804ff00:	f001 fd8e 	bl	8051a20 <memset>
							memset(u8temp_array, 0, sizeof(u8temp_array));
 804ff04:	4622      	mov	r2, r4
 804ff06:	2100      	movs	r1, #0
 804ff08:	4668      	mov	r0, sp
 804ff0a:	f001 fd89 	bl	8051a20 <memset>
							memcpy(u8temp_array,nwsof,nwmlen);
 804ff0e:	4ca5      	ldr	r4, [pc, #660]	; (80501a4 <getLastKnownConfiguration+0x32c>)
 804ff10:	4ba5      	ldr	r3, [pc, #660]	; (80501a8 <getLastKnownConfiguration+0x330>)
 804ff12:	f8d3 21d0 	ldr.w	r2, [r3, #464]	; 0x1d0
 804ff16:	f8d4 175c 	ldr.w	r1, [r4, #1884]	; 0x75c
 804ff1a:	4668      	mov	r0, sp
 804ff1c:	f001 fd72 	bl	8051a04 <memcpy>
							strcpy(nwconfig,u8temp_array);
 804ff20:	4669      	mov	r1, sp
 804ff22:	f8d4 0fb8 	ldr.w	r0, [r4, #4024]	; 0xfb8
 804ff26:	f001 fded 	bl	8051b04 <strcpy>
							extractNewtorkConfiguration();
 804ff2a:	f7ff fe17 	bl	804fb5c <extractNewtorkConfiguration>
 804ff2e:	46ad      	mov	sp, r5
 804ff30:	e0bf      	b.n	80500b2 <getLastKnownConfiguration+0x23a>
							gu32ConfigNetworkErrorDatabase |= (1 << enmCONFIG_NWCONFIGNOTFOUND);
 804ff32:	4a9d      	ldr	r2, [pc, #628]	; (80501a8 <getLastKnownConfiguration+0x330>)
 804ff34:	6853      	ldr	r3, [r2, #4]
 804ff36:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 804ff3a:	6053      	str	r3, [r2, #4]
 804ff3c:	e0b9      	b.n	80500b2 <getLastKnownConfiguration+0x23a>
							gu32MBRTUClientAddress[gu32LoopCounter] = gau32ConfigModbus485Address[gu32LoopCounter];
 804ff3e:	4a99      	ldr	r2, [pc, #612]	; (80501a4 <getLastKnownConfiguration+0x32c>)
 804ff40:	eb02 0283 	add.w	r2, r2, r3, lsl #2
 804ff44:	6c90      	ldr	r0, [r2, #72]	; 0x48
 804ff46:	4999      	ldr	r1, [pc, #612]	; (80501ac <getLastKnownConfiguration+0x334>)
 804ff48:	f841 0023 	str.w	r0, [r1, r3, lsl #2]
							gu32MBRTUClientFuncCode[gu32LoopCounter] = gau32ConfigModbus485DFunctionCode[gu32LoopCounter];
 804ff4c:	f8d2 0174 	ldr.w	r0, [r2, #372]	; 0x174
 804ff50:	4997      	ldr	r1, [pc, #604]	; (80501b0 <getLastKnownConfiguration+0x338>)
 804ff52:	f841 0023 	str.w	r0, [r1, r3, lsl #2]
							gu32MBRTUClientNoofPoints[gu32LoopCounter] = gau32ConfigModbus485NoPoints[gu32LoopCounter];
 804ff56:	f8d2 02a0 	ldr.w	r0, [r2, #672]	; 0x2a0
 804ff5a:	4996      	ldr	r1, [pc, #600]	; (80501b4 <getLastKnownConfiguration+0x33c>)
 804ff5c:	f841 0023 	str.w	r0, [r1, r3, lsl #2]
							gu32MBTCPClientAddress[gu32LoopCounter] = gau32ConfigModbusTCPAddress[gu32LoopCounter];
 804ff60:	f8d2 03d0 	ldr.w	r0, [r2, #976]	; 0x3d0
 804ff64:	4994      	ldr	r1, [pc, #592]	; (80501b8 <getLastKnownConfiguration+0x340>)
 804ff66:	f841 0023 	str.w	r0, [r1, r3, lsl #2]
							gu32MBTCPClientFuncCode[gu32LoopCounter] = gau32ConfigModbusTCPDFunctionCode[gu32LoopCounter];
 804ff6a:	f8d2 04fc 	ldr.w	r0, [r2, #1276]	; 0x4fc
 804ff6e:	4993      	ldr	r1, [pc, #588]	; (80501bc <getLastKnownConfiguration+0x344>)
 804ff70:	f841 0023 	str.w	r0, [r1, r3, lsl #2]
							gu32MBTCPClientNoofPoints[gu32LoopCounter] = gau32ConfigModbusTCPNoPoints[gu32LoopCounter];
 804ff74:	f8d2 1628 	ldr.w	r1, [r2, #1576]	; 0x628
 804ff78:	4a91      	ldr	r2, [pc, #580]	; (80501c0 <getLastKnownConfiguration+0x348>)
 804ff7a:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
						for(gu32LoopCounter = 0; gu32LoopCounter <gu32Modbus485RegisterFetch; gu32LoopCounter++)
 804ff7e:	3301      	adds	r3, #1
 804ff80:	4a89      	ldr	r2, [pc, #548]	; (80501a8 <getLastKnownConfiguration+0x330>)
 804ff82:	f8c2 3224 	str.w	r3, [r2, #548]	; 0x224
 804ff86:	4b88      	ldr	r3, [pc, #544]	; (80501a8 <getLastKnownConfiguration+0x330>)
 804ff88:	f8d3 3224 	ldr.w	r3, [r3, #548]	; 0x224
 804ff8c:	4a85      	ldr	r2, [pc, #532]	; (80501a4 <getLastKnownConfiguration+0x32c>)
 804ff8e:	f8d2 2fc4 	ldr.w	r2, [r2, #4036]	; 0xfc4
 804ff92:	4293      	cmp	r3, r2
 804ff94:	d3d3      	bcc.n	804ff3e <getLastKnownConfiguration+0xc6>
						inet_aton(gau8ConfigModbusTCPIPDEVICE,IP_ADDRESS);
 804ff96:	4c84      	ldr	r4, [pc, #528]	; (80501a8 <getLastKnownConfiguration+0x330>)
 804ff98:	498a      	ldr	r1, [pc, #552]	; (80501c4 <getLastKnownConfiguration+0x34c>)
 804ff9a:	f504 70f2 	add.w	r0, r4, #484	; 0x1e4
 804ff9e:	f7fa fe65 	bl	804ac6c <ip4addr_aton>
						inet_aton(gau8ConfigModbusTCPIPSUBNET,NETMASK_ADDRESS);
 804ffa2:	4989      	ldr	r1, [pc, #548]	; (80501c8 <getLastKnownConfiguration+0x350>)
 804ffa4:	f504 70fa 	add.w	r0, r4, #500	; 0x1f4
 804ffa8:	f7fa fe60 	bl	804ac6c <ip4addr_aton>
						inet_aton(gau8ConfigModbusTCPIPGATEWAY,GATEWAY_ADDRESS);
 804ffac:	4987      	ldr	r1, [pc, #540]	; (80501cc <getLastKnownConfiguration+0x354>)
 804ffae:	f504 7005 	add.w	r0, r4, #532	; 0x214
 804ffb2:	f7fa fe5b 	bl	804ac6c <ip4addr_aton>
						inet_aton(gau8ConfigModbusTCPIPSERVER,IP_ADDRESS_DESTI);
 804ffb6:	4d7b      	ldr	r5, [pc, #492]	; (80501a4 <getLastKnownConfiguration+0x32c>)
 804ffb8:	f605 71cc 	addw	r1, r5, #4044	; 0xfcc
 804ffbc:	f504 7001 	add.w	r0, r4, #516	; 0x204
 804ffc0:	f7fa fe54 	bl	804ac6c <ip4addr_aton>
						gu32ModbusTCPPort = atoi(gau8ConfigModbusTCPPORT);
 804ffc4:	f504 70ce 	add.w	r0, r4, #412	; 0x19c
 804ffc8:	f001 fa7a 	bl	80514c0 <atoi>
 804ffcc:	f8c5 0fd0 	str.w	r0, [r5, #4048]	; 0xfd0
					strcpy(gau8LastKnownConfiguration,gau8ConfigurationCopy);
 804ffd0:	497f      	ldr	r1, [pc, #508]	; (80501d0 <getLastKnownConfiguration+0x358>)
 804ffd2:	4880      	ldr	r0, [pc, #512]	; (80501d4 <getLastKnownConfiguration+0x35c>)
 804ffd4:	f001 fd96 	bl	8051b04 <strcpy>
 804ffd8:	e758      	b.n	804fe8c <getLastKnownConfiguration+0x14>
				gau8LastKnownConfiguration[loopCounter] = *(uint8_t *)flashAddress;
 804ffda:	487e      	ldr	r0, [pc, #504]	; (80501d4 <getLastKnownConfiguration+0x35c>)
 804ffdc:	54c1      	strb	r1, [r0, r3]
				flashAddress++;
 804ffde:	3201      	adds	r2, #1
		for(loopCounter = 0 ; loopCounter < 2000; loopCounter++)
 804ffe0:	3301      	adds	r3, #1
 804ffe2:	f5b3 6ffa 	cmp.w	r3, #2000	; 0x7d0
 804ffe6:	f4bf af51 	bcs.w	804fe8c <getLastKnownConfiguration+0x14>
			if(*(uint8_t *)flashAddress == 0xFF)
 804ffea:	7811      	ldrb	r1, [r2, #0]
 804ffec:	29ff      	cmp	r1, #255	; 0xff
 804ffee:	d1f4      	bne.n	804ffda <getLastKnownConfiguration+0x162>
				if(strlen(gau8LastKnownConfiguration) != 0 )
 804fff0:	4b78      	ldr	r3, [pc, #480]	; (80501d4 <getLastKnownConfiguration+0x35c>)
 804fff2:	781b      	ldrb	r3, [r3, #0]
 804fff4:	2b00      	cmp	r3, #0
 804fff6:	f43f af49 	beq.w	804fe8c <getLastKnownConfiguration+0x14>
					memset(nwsof, 0, 5);
 804fffa:	4c6a      	ldr	r4, [pc, #424]	; (80501a4 <getLastKnownConfiguration+0x32c>)
 804fffc:	f8d4 275c 	ldr.w	r2, [r4, #1884]	; 0x75c
 8050000:	2300      	movs	r3, #0
 8050002:	6013      	str	r3, [r2, #0]
 8050004:	7113      	strb	r3, [r2, #4]
					memset(nweof, 0, 5);
 8050006:	f8d4 2760 	ldr.w	r2, [r4, #1888]	; 0x760
 805000a:	6013      	str	r3, [r2, #0]
 805000c:	7113      	strb	r3, [r2, #4]
					memset(mb485sof, 0, 5);
 805000e:	f8d4 2764 	ldr.w	r2, [r4, #1892]	; 0x764
 8050012:	6013      	str	r3, [r2, #0]
 8050014:	7113      	strb	r3, [r2, #4]
					memset(mb485eof, 0,5);
 8050016:	f8d4 2768 	ldr.w	r2, [r4, #1896]	; 0x768
 805001a:	6013      	str	r3, [r2, #0]
 805001c:	7113      	strb	r3, [r2, #4]
					memset(mbTCPsof, 0, 5);
 805001e:	f8d4 27d8 	ldr.w	r2, [r4, #2008]	; 0x7d8
 8050022:	6013      	str	r3, [r2, #0]
 8050024:	7113      	strb	r3, [r2, #4]
					memset(mbTCPeof, 0, 5);
 8050026:	f8d4 27dc 	ldr.w	r2, [r4, #2012]	; 0x7dc
 805002a:	6013      	str	r3, [r2, #0]
 805002c:	7113      	strb	r3, [r2, #4]
					strcpy(gau8ConfigurationCopy, gau8LastKnownConfiguration);
 805002e:	4d69      	ldr	r5, [pc, #420]	; (80501d4 <getLastKnownConfiguration+0x35c>)
 8050030:	4629      	mov	r1, r5
 8050032:	f504 60fd 	add.w	r0, r4, #2024	; 0x7e8
 8050036:	f001 fd65 	bl	8051b04 <strcpy>
					nwsof = strstr(gau8LastKnownConfiguration,"NS,");
 805003a:	4967      	ldr	r1, [pc, #412]	; (80501d8 <getLastKnownConfiguration+0x360>)
 805003c:	4628      	mov	r0, r5
 805003e:	f001 fd8e 	bl	8051b5e <strstr>
 8050042:	f8c4 075c 	str.w	r0, [r4, #1884]	; 0x75c
					nweof = strstr(gau8LastKnownConfiguration,",NE");
 8050046:	4965      	ldr	r1, [pc, #404]	; (80501dc <getLastKnownConfiguration+0x364>)
 8050048:	4628      	mov	r0, r5
 805004a:	f001 fd88 	bl	8051b5e <strstr>
 805004e:	f8c4 0760 	str.w	r0, [r4, #1888]	; 0x760
					mb485sof =  strstr(gau8LastKnownConfiguration,"MS,");
 8050052:	4963      	ldr	r1, [pc, #396]	; (80501e0 <getLastKnownConfiguration+0x368>)
 8050054:	4628      	mov	r0, r5
 8050056:	f001 fd82 	bl	8051b5e <strstr>
 805005a:	4606      	mov	r6, r0
 805005c:	f8c4 0764 	str.w	r0, [r4, #1892]	; 0x764
					mb485eof =  strstr(gau8LastKnownConfiguration,",ME");
 8050060:	4960      	ldr	r1, [pc, #384]	; (80501e4 <getLastKnownConfiguration+0x36c>)
 8050062:	4628      	mov	r0, r5
 8050064:	f001 fd7b 	bl	8051b5e <strstr>
 8050068:	f8c4 0768 	str.w	r0, [r4, #1896]	; 0x768
					if((mb485sof == NULL )|(mb485eof == NULL))
 805006c:	fab0 f380 	clz	r3, r0
 8050070:	095b      	lsrs	r3, r3, #5
 8050072:	2e00      	cmp	r6, #0
 8050074:	bf08      	it	eq
 8050076:	2301      	moveq	r3, #1
 8050078:	2b00      	cmp	r3, #0
 805007a:	f43f af0a 	beq.w	804fe92 <getLastKnownConfiguration+0x1a>
						gu32ConfigModbus485ErrorDatabase |= (1 << enmCONFIG_MB485CONFIGNOTFOUND);
 805007e:	4a4a      	ldr	r2, [pc, #296]	; (80501a8 <getLastKnownConfiguration+0x330>)
 8050080:	f8d2 316c 	ldr.w	r3, [r2, #364]	; 0x16c
 8050084:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 8050088:	f8c2 316c 	str.w	r3, [r2, #364]	; 0x16c
					if((nwsof == NULL )|(nweof == NULL))
 805008c:	4b45      	ldr	r3, [pc, #276]	; (80501a4 <getLastKnownConfiguration+0x32c>)
 805008e:	f8d3 475c 	ldr.w	r4, [r3, #1884]	; 0x75c
 8050092:	f8d3 1760 	ldr.w	r1, [r3, #1888]	; 0x760
 8050096:	fab1 f381 	clz	r3, r1
 805009a:	095b      	lsrs	r3, r3, #5
 805009c:	2c00      	cmp	r4, #0
 805009e:	bf08      	it	eq
 80500a0:	2301      	moveq	r3, #1
 80500a2:	2b00      	cmp	r3, #0
 80500a4:	f43f af19 	beq.w	804feda <getLastKnownConfiguration+0x62>
						gu32ConfigNetworkErrorDatabase |= (1 << enmCONFIG_NWCONFIGNOTFOUND);
 80500a8:	4a3f      	ldr	r2, [pc, #252]	; (80501a8 <getLastKnownConfiguration+0x330>)
 80500aa:	6853      	ldr	r3, [r2, #4]
 80500ac:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 80500b0:	6053      	str	r3, [r2, #4]
					if((gu32ConfigNetworkErrorDatabase == 0 ) && (nwconfig != NULL))
 80500b2:	4b3d      	ldr	r3, [pc, #244]	; (80501a8 <getLastKnownConfiguration+0x330>)
 80500b4:	685b      	ldr	r3, [r3, #4]
 80500b6:	2b00      	cmp	r3, #0
 80500b8:	d141      	bne.n	805013e <getLastKnownConfiguration+0x2c6>
 80500ba:	4b3a      	ldr	r3, [pc, #232]	; (80501a4 <getLastKnownConfiguration+0x32c>)
 80500bc:	f8d3 3fb8 	ldr.w	r3, [r3, #4024]	; 0xfb8
 80500c0:	2b00      	cmp	r3, #0
 80500c2:	d03c      	beq.n	805013e <getLastKnownConfiguration+0x2c6>
						memset(gau8GSM4G_apn,0x00,sizeof(char) * 100);
 80500c4:	4d48      	ldr	r5, [pc, #288]	; (80501e8 <getLastKnownConfiguration+0x370>)
 80500c6:	2664      	movs	r6, #100	; 0x64
 80500c8:	4632      	mov	r2, r6
 80500ca:	2100      	movs	r1, #0
 80500cc:	4628      	mov	r0, r5
 80500ce:	f001 fca7 	bl	8051a20 <memset>
						memcpy(gau8GSM4G_apn,gau8ConfigNewtorkAPN, strlen(gau8ConfigNewtorkAPN));
 80500d2:	4c34      	ldr	r4, [pc, #208]	; (80501a4 <getLastKnownConfiguration+0x32c>)
 80500d4:	4620      	mov	r0, r4
 80500d6:	f7f0 f895 	bl	8040204 <strlen>
 80500da:	4602      	mov	r2, r0
 80500dc:	4621      	mov	r1, r4
 80500de:	4628      	mov	r0, r5
 80500e0:	f001 fc90 	bl	8051a04 <memcpy>
						memset(gau8GSM_url,0x00,sizeof(char) * 100);
 80500e4:	f8df 8108 	ldr.w	r8, [pc, #264]	; 80501f0 <getLastKnownConfiguration+0x378>
 80500e8:	4632      	mov	r2, r6
 80500ea:	2100      	movs	r1, #0
 80500ec:	4640      	mov	r0, r8
 80500ee:	f001 fc97 	bl	8051a20 <memset>
						memcpy( gau8GSM_url, gau8ConfigNewtorkServerURL, strlen(gau8ConfigNewtorkServerURL));
 80500f2:	4d2d      	ldr	r5, [pc, #180]	; (80501a8 <getLastKnownConfiguration+0x330>)
 80500f4:	f105 0908 	add.w	r9, r5, #8
 80500f8:	4648      	mov	r0, r9
 80500fa:	f7f0 f883 	bl	8040204 <strlen>
 80500fe:	4602      	mov	r2, r0
 8050100:	4649      	mov	r1, r9
 8050102:	4640      	mov	r0, r8
 8050104:	f001 fc7e 	bl	8051a04 <memcpy>
						memset(gau8RemoteConfigurationURL,0x00,sizeof(char) * 100);
 8050108:	f8df 80e8 	ldr.w	r8, [pc, #232]	; 80501f4 <getLastKnownConfiguration+0x37c>
 805010c:	4632      	mov	r2, r6
 805010e:	2100      	movs	r1, #0
 8050110:	4640      	mov	r0, r8
 8050112:	f001 fc85 	bl	8051a20 <memset>
						memcpy( gau8RemoteConfigurationURL, gau8ConfigNewtorkConfigURL, strlen(gau8ConfigNewtorkConfigURL));
 8050116:	f105 06a0 	add.w	r6, r5, #160	; 0xa0
 805011a:	4630      	mov	r0, r6
 805011c:	f7f0 f872 	bl	8040204 <strlen>
 8050120:	4602      	mov	r2, r0
 8050122:	4631      	mov	r1, r6
 8050124:	4640      	mov	r0, r8
 8050126:	f001 fc6d 	bl	8051a04 <memcpy>
						gu32UploadTimeSupply = atoi(gau8ConfigNewtorkUpFreqSupply);
 805012a:	f505 709c 	add.w	r0, r5, #312	; 0x138
 805012e:	f001 f9c7 	bl	80514c0 <atoi>
 8050132:	6360      	str	r0, [r4, #52]	; 0x34
						gu32UploadTimeBatt = atoi(gau8ConfigNewtorkUpFreqBatt);
 8050134:	f505 70a2 	add.w	r0, r5, #324	; 0x144
 8050138:	f001 f9c2 	bl	80514c0 <atoi>
 805013c:	63a0      	str	r0, [r4, #56]	; 0x38
					if((gu32ConfigModbus485ErrorDatabase == 0 ) && (mb485config != NULL))
 805013e:	4b1a      	ldr	r3, [pc, #104]	; (80501a8 <getLastKnownConfiguration+0x330>)
 8050140:	f8d3 316c 	ldr.w	r3, [r3, #364]	; 0x16c
 8050144:	2b00      	cmp	r3, #0
 8050146:	f47f af43 	bne.w	804ffd0 <getLastKnownConfiguration+0x158>
 805014a:	4b16      	ldr	r3, [pc, #88]	; (80501a4 <getLastKnownConfiguration+0x32c>)
 805014c:	f8d3 37e0 	ldr.w	r3, [r3, #2016]	; 0x7e0
 8050150:	2b00      	cmp	r3, #0
 8050152:	f43f af3d 	beq.w	804ffd0 <getLastKnownConfiguration+0x158>
						gu32OperateModbus485 = atoi(gau8ConfigModbus485IsEnabled);
 8050156:	4c14      	ldr	r4, [pc, #80]	; (80501a8 <getLastKnownConfiguration+0x330>)
 8050158:	f504 70b4 	add.w	r0, r4, #360	; 0x168
 805015c:	f001 f9b0 	bl	80514c0 <atoi>
 8050160:	4d10      	ldr	r5, [pc, #64]	; (80501a4 <getLastKnownConfiguration+0x32c>)
 8050162:	f8c5 0fbc 	str.w	r0, [r5, #4028]	; 0xfbc
						gu32Modbus485SlaveID = atoi(gau8ConfigModbus485SlaveID);
 8050166:	f504 70b8 	add.w	r0, r4, #368	; 0x170
 805016a:	f001 f9a9 	bl	80514c0 <atoi>
 805016e:	f8c5 0fc0 	str.w	r0, [r5, #4032]	; 0xfc0
						gu32Modbus485RegisterFetch = atoi(gau8ConfigModbus485DataPoints);
 8050172:	f504 70be 	add.w	r0, r4, #380	; 0x17c
 8050176:	f001 f9a3 	bl	80514c0 <atoi>
 805017a:	f8c5 0fc4 	str.w	r0, [r5, #4036]	; 0xfc4
						gu32Modbus485PollingTime = atoi(gau8ConfigModbus485PollingTime);
 805017e:	f504 70c4 	add.w	r0, r4, #392	; 0x188
 8050182:	f001 f99d 	bl	80514c0 <atoi>
 8050186:	6468      	str	r0, [r5, #68]	; 0x44
						gu32Modbus485ResponseTime = atoi(gau8ConfigModbus485ResponseTime);
 8050188:	f504 70c8 	add.w	r0, r4, #400	; 0x190
 805018c:	f001 f998 	bl	80514c0 <atoi>
 8050190:	f8c5 0fc8 	str.w	r0, [r5, #4040]	; 0xfc8
						gu32LoopCounter = 0;
 8050194:	2300      	movs	r3, #0
 8050196:	f8c4 3224 	str.w	r3, [r4, #548]	; 0x224
						for(gu32LoopCounter = 0; gu32LoopCounter <gu32Modbus485RegisterFetch; gu32LoopCounter++)
 805019a:	e6f4      	b.n	804ff86 <getLastKnownConfiguration+0x10e>
		for(loopCounter = 0 ; loopCounter < 2000; loopCounter++)
 805019c:	2300      	movs	r3, #0
	uint32_t flashAddress = ADDR_FLASH_SECTOR_11;
 805019e:	4a13      	ldr	r2, [pc, #76]	; (80501ec <getLastKnownConfiguration+0x374>)
 80501a0:	e71f      	b.n	804ffe2 <getLastKnownConfiguration+0x16a>
 80501a2:	bf00      	nop
 80501a4:	20002694 	.word	0x20002694
 80501a8:	20004d2c 	.word	0x20004d2c
 80501ac:	20000e04 	.word	0x20000e04
 80501b0:	20000cd8 	.word	0x20000cd8
 80501b4:	20000f30 	.word	0x20000f30
 80501b8:	20001a24 	.word	0x20001a24
 80501bc:	200018f8 	.word	0x200018f8
 80501c0:	20001b50 	.word	0x20001b50
 80501c4:	2000d5d4 	.word	0x2000d5d4
 80501c8:	2000d5d0 	.word	0x2000d5d0
 80501cc:	2000d598 	.word	0x2000d598
 80501d0:	20002e7c 	.word	0x20002e7c
 80501d4:	2000eb60 	.word	0x2000eb60
 80501d8:	0805aacc 	.word	0x0805aacc
 80501dc:	0805aad0 	.word	0x0805aad0
 80501e0:	0805aad4 	.word	0x0805aad4
 80501e4:	0805aad8 	.word	0x0805aad8
 80501e8:	20000570 	.word	0x20000570
 80501ec:	080e0000 	.word	0x080e0000
 80501f0:	20000354 	.word	0x20000354
 80501f4:	2000042c 	.word	0x2000042c

080501f8 <MX_RTC_Init>:

RTC_HandleTypeDef hrtc;

/* RTC init function */
void MX_RTC_Init(void)
{
 80501f8:	b500      	push	{lr}
 80501fa:	b08b      	sub	sp, #44	; 0x2c

  /* USER CODE BEGIN RTC_Init 0 */
	readbackedupRTCCalender();
 80501fc:	f000 ffdc 	bl	80511b8 <readbackedupRTCCalender>
  /* USER CODE END RTC_Init 0 */

//  RTC_TimeTypeDef sTime = {0};
//  RTC_DateTypeDef sDate = {0};
  RTC_AlarmTypeDef sAlarm = {0};
 8050200:	2228      	movs	r2, #40	; 0x28
 8050202:	2100      	movs	r1, #0
 8050204:	4668      	mov	r0, sp
 8050206:	f001 fc0b 	bl	8051a20 <memset>
  /* USER CODE BEGIN RTC_Init 1 */

  /* USER CODE END RTC_Init 1 */
  /** Initialize RTC Only
  */
  hrtc.Instance = RTC;
 805020a:	483b      	ldr	r0, [pc, #236]	; (80502f8 <MX_RTC_Init+0x100>)
 805020c:	4b3b      	ldr	r3, [pc, #236]	; (80502fc <MX_RTC_Init+0x104>)
 805020e:	6003      	str	r3, [r0, #0]
  hrtc.Init.HourFormat = RTC_HOURFORMAT_24;
 8050210:	2300      	movs	r3, #0
 8050212:	6043      	str	r3, [r0, #4]
  hrtc.Init.AsynchPrediv = 31;
 8050214:	221f      	movs	r2, #31
 8050216:	6082      	str	r2, [r0, #8]
  hrtc.Init.SynchPrediv = 1023;
 8050218:	f240 32ff 	movw	r2, #1023	; 0x3ff
 805021c:	60c2      	str	r2, [r0, #12]
  hrtc.Init.OutPut = RTC_OUTPUT_DISABLE;
 805021e:	6103      	str	r3, [r0, #16]
  hrtc.Init.OutPutPolarity = RTC_OUTPUT_POLARITY_HIGH;
 8050220:	6143      	str	r3, [r0, #20]
  hrtc.Init.OutPutType = RTC_OUTPUT_TYPE_OPENDRAIN;
 8050222:	6183      	str	r3, [r0, #24]
  if (HAL_RTC_Init(&hrtc) != HAL_OK)
 8050224:	f7f4 facd 	bl	80447c2 <HAL_RTC_Init>
 8050228:	2800      	cmp	r0, #0
 805022a:	d153      	bne.n	80502d4 <MX_RTC_Init+0xdc>

  /* USER CODE END Check_RTC_BKUP */

  /** Initialize RTC and set the Time and Date
  */
  STime1.Hours = sTimeStampget_backup.Hours;
 805022c:	4b34      	ldr	r3, [pc, #208]	; (8050300 <MX_RTC_Init+0x108>)
 805022e:	781a      	ldrb	r2, [r3, #0]
 8050230:	4934      	ldr	r1, [pc, #208]	; (8050304 <MX_RTC_Init+0x10c>)
 8050232:	700a      	strb	r2, [r1, #0]
  STime1.Minutes = sTimeStampget_backup.Minutes;
 8050234:	785a      	ldrb	r2, [r3, #1]
 8050236:	704a      	strb	r2, [r1, #1]
  STime1.Seconds = sTimeStampget_backup.Seconds;
 8050238:	789b      	ldrb	r3, [r3, #2]
 805023a:	708b      	strb	r3, [r1, #2]
  STime1.DayLightSaving = RTC_DAYLIGHTSAVING_NONE;
 805023c:	2300      	movs	r3, #0
 805023e:	60cb      	str	r3, [r1, #12]
  STime1.StoreOperation = RTC_STOREOPERATION_RESET;
 8050240:	610b      	str	r3, [r1, #16]
  if (HAL_RTC_SetTime(&hrtc, &STime1, RTC_FORMAT_BCD) != HAL_OK)
 8050242:	2201      	movs	r2, #1
 8050244:	482c      	ldr	r0, [pc, #176]	; (80502f8 <MX_RTC_Init+0x100>)
 8050246:	f7f4 fb29 	bl	804489c <HAL_RTC_SetTime>
 805024a:	2800      	cmp	r0, #0
 805024c:	d145      	bne.n	80502da <MX_RTC_Init+0xe2>
  {
    Error_Handler();
  }
  SDate1.WeekDay = sTimeStampDateget_backup.WeekDay;
 805024e:	4b2e      	ldr	r3, [pc, #184]	; (8050308 <MX_RTC_Init+0x110>)
 8050250:	781a      	ldrb	r2, [r3, #0]
 8050252:	492c      	ldr	r1, [pc, #176]	; (8050304 <MX_RTC_Init+0x10c>)
 8050254:	750a      	strb	r2, [r1, #20]
  SDate1.Month = sTimeStampDateget_backup.Month;
 8050256:	785a      	ldrb	r2, [r3, #1]
 8050258:	754a      	strb	r2, [r1, #21]
  SDate1.Date = sTimeStampDateget_backup.Date;
 805025a:	789a      	ldrb	r2, [r3, #2]
 805025c:	758a      	strb	r2, [r1, #22]
  SDate1.Year = sTimeStampDateget_backup.Year;
 805025e:	78db      	ldrb	r3, [r3, #3]
 8050260:	75cb      	strb	r3, [r1, #23]

  if (HAL_RTC_SetDate(&hrtc, &SDate1, RTC_FORMAT_BCD) != HAL_OK)
 8050262:	2201      	movs	r2, #1
 8050264:	3114      	adds	r1, #20
 8050266:	4824      	ldr	r0, [pc, #144]	; (80502f8 <MX_RTC_Init+0x100>)
 8050268:	f7f4 fb97 	bl	804499a <HAL_RTC_SetDate>
 805026c:	2800      	cmp	r0, #0
 805026e:	d137      	bne.n	80502e0 <MX_RTC_Init+0xe8>
  {
    Error_Handler();
  }
  /** Enable the Alarm A
  */
  sAlarm.AlarmTime.Hours = 0x0;
 8050270:	2300      	movs	r3, #0
 8050272:	f88d 3000 	strb.w	r3, [sp]
  sAlarm.AlarmTime.Minutes = 0x0;
 8050276:	f88d 3001 	strb.w	r3, [sp, #1]
  sAlarm.AlarmTime.Seconds = 0x0;
 805027a:	f88d 3002 	strb.w	r3, [sp, #2]
  sAlarm.AlarmTime.SubSeconds = 0x0;
 805027e:	9301      	str	r3, [sp, #4]
  sAlarm.AlarmTime.DayLightSaving = RTC_DAYLIGHTSAVING_NONE;
 8050280:	9303      	str	r3, [sp, #12]
  sAlarm.AlarmTime.StoreOperation = RTC_STOREOPERATION_RESET;
 8050282:	9304      	str	r3, [sp, #16]
  sAlarm.AlarmMask = RTC_ALARMMASK_DATEWEEKDAY|RTC_ALARMMASK_HOURS
 8050284:	4a21      	ldr	r2, [pc, #132]	; (805030c <MX_RTC_Init+0x114>)
 8050286:	9205      	str	r2, [sp, #20]
                              |RTC_ALARMMASK_SECONDS;
  sAlarm.AlarmSubSecondMask = RTC_ALARMSUBSECONDMASK_ALL;
 8050288:	9306      	str	r3, [sp, #24]
  sAlarm.AlarmDateWeekDaySel = RTC_ALARMDATEWEEKDAYSEL_DATE;
 805028a:	9307      	str	r3, [sp, #28]
  sAlarm.AlarmDateWeekDay = 0x1;
 805028c:	2201      	movs	r2, #1
 805028e:	f88d 2020 	strb.w	r2, [sp, #32]
  sAlarm.Alarm = RTC_ALARM_A;
 8050292:	f44f 7380 	mov.w	r3, #256	; 0x100
 8050296:	9309      	str	r3, [sp, #36]	; 0x24
  if (HAL_RTC_SetAlarm_IT(&hrtc, &sAlarm, RTC_FORMAT_BCD) != HAL_OK)
 8050298:	4669      	mov	r1, sp
 805029a:	4817      	ldr	r0, [pc, #92]	; (80502f8 <MX_RTC_Init+0x100>)
 805029c:	f7f4 fbea 	bl	8044a74 <HAL_RTC_SetAlarm_IT>
 80502a0:	bb08      	cbnz	r0, 80502e6 <MX_RTC_Init+0xee>
  {
    Error_Handler();
  }
  /** Enable the Alarm B
  */
  sAlarm.Alarm = RTC_ALARM_B;
 80502a2:	f44f 7300 	mov.w	r3, #512	; 0x200
 80502a6:	9309      	str	r3, [sp, #36]	; 0x24
  if (HAL_RTC_SetAlarm_IT(&hrtc, &sAlarm, RTC_FORMAT_BCD) != HAL_OK)
 80502a8:	2201      	movs	r2, #1
 80502aa:	4669      	mov	r1, sp
 80502ac:	4812      	ldr	r0, [pc, #72]	; (80502f8 <MX_RTC_Init+0x100>)
 80502ae:	f7f4 fbe1 	bl	8044a74 <HAL_RTC_SetAlarm_IT>
 80502b2:	b9d8      	cbnz	r0, 80502ec <MX_RTC_Init+0xf4>
  {
    Error_Handler();
  }
  /** Enable the WakeUp
  */
  __HAL_RTC_WAKEUPTIMER_CLEAR_FLAG(&hrtc, RTC_FLAG_WUTF);
 80502b4:	4810      	ldr	r0, [pc, #64]	; (80502f8 <MX_RTC_Init+0x100>)
 80502b6:	6802      	ldr	r2, [r0, #0]
 80502b8:	68d3      	ldr	r3, [r2, #12]
 80502ba:	b2db      	uxtb	r3, r3
 80502bc:	f463 6390 	orn	r3, r3, #1152	; 0x480
 80502c0:	60d3      	str	r3, [r2, #12]
  if (HAL_RTCEx_SetWakeUpTimer_IT(&hrtc, 2074, RTC_WAKEUPCLOCK_RTCCLK_DIV16) != HAL_OK) // 2074 - 1 Sec
 80502c2:	2200      	movs	r2, #0
 80502c4:	f640 011a 	movw	r1, #2074	; 0x81a
 80502c8:	f7f4 fcf4 	bl	8044cb4 <HAL_RTCEx_SetWakeUpTimer_IT>
 80502cc:	b988      	cbnz	r0, 80502f2 <MX_RTC_Init+0xfa>
  /* USER CODE BEGIN RTC_Init 2 */
  // 32768 - 15 Sec interrupt at 180 Mhz
//  __HAL_RCC_RTC_ENABLE();
  /* USER CODE END RTC_Init 2 */

}
 80502ce:	b00b      	add	sp, #44	; 0x2c
 80502d0:	f85d fb04 	ldr.w	pc, [sp], #4
    Error_Handler();
 80502d4:	f7fd fac2 	bl	804d85c <Error_Handler>
 80502d8:	e7a8      	b.n	805022c <MX_RTC_Init+0x34>
    Error_Handler();
 80502da:	f7fd fabf 	bl	804d85c <Error_Handler>
 80502de:	e7b6      	b.n	805024e <MX_RTC_Init+0x56>
    Error_Handler();
 80502e0:	f7fd fabc 	bl	804d85c <Error_Handler>
 80502e4:	e7c4      	b.n	8050270 <MX_RTC_Init+0x78>
    Error_Handler();
 80502e6:	f7fd fab9 	bl	804d85c <Error_Handler>
 80502ea:	e7da      	b.n	80502a2 <MX_RTC_Init+0xaa>
    Error_Handler();
 80502ec:	f7fd fab6 	bl	804d85c <Error_Handler>
 80502f0:	e7e0      	b.n	80502b4 <MX_RTC_Init+0xbc>
    Error_Handler();
 80502f2:	f7fd fab3 	bl	804d85c <Error_Handler>
}
 80502f6:	e7ea      	b.n	80502ce <MX_RTC_Init+0xd6>
 80502f8:	2000f330 	.word	0x2000f330
 80502fc:	40002800 	.word	0x40002800
 8050300:	200088d8 	.word	0x200088d8
 8050304:	20004f60 	.word	0x20004f60
 8050308:	20010090 	.word	0x20010090
 805030c:	80800080 	.word	0x80800080

08050310 <HAL_RTC_MspInit>:

void HAL_RTC_MspInit(RTC_HandleTypeDef* rtcHandle)
{
 8050310:	b510      	push	{r4, lr}
 8050312:	b08c      	sub	sp, #48	; 0x30
 8050314:	4604      	mov	r4, r0

  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
 8050316:	2230      	movs	r2, #48	; 0x30
 8050318:	2100      	movs	r1, #0
 805031a:	4668      	mov	r0, sp
 805031c:	f001 fb80 	bl	8051a20 <memset>
  if(rtcHandle->Instance==RTC)
 8050320:	6822      	ldr	r2, [r4, #0]
 8050322:	4b12      	ldr	r3, [pc, #72]	; (805036c <HAL_RTC_MspInit+0x5c>)
 8050324:	429a      	cmp	r2, r3
 8050326:	d001      	beq.n	805032c <HAL_RTC_MspInit+0x1c>
    HAL_NVIC_EnableIRQ(RTC_Alarm_IRQn);
  /* USER CODE BEGIN RTC_MspInit 1 */

  /* USER CODE END RTC_MspInit 1 */
  }
}
 8050328:	b00c      	add	sp, #48	; 0x30
 805032a:	bd10      	pop	{r4, pc}
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_RTC;
 805032c:	2320      	movs	r3, #32
 805032e:	9300      	str	r3, [sp, #0]
    PeriphClkInitStruct.RTCClockSelection = RCC_RTCCLKSOURCE_LSI;
 8050330:	f44f 7300 	mov.w	r3, #512	; 0x200
 8050334:	930a      	str	r3, [sp, #40]	; 0x28
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 8050336:	4668      	mov	r0, sp
 8050338:	f7f4 f8a8 	bl	804448c <HAL_RCCEx_PeriphCLKConfig>
 805033c:	b998      	cbnz	r0, 8050366 <HAL_RTC_MspInit+0x56>
    __HAL_RCC_RTC_ENABLE();
 805033e:	4b0c      	ldr	r3, [pc, #48]	; (8050370 <HAL_RTC_MspInit+0x60>)
 8050340:	2201      	movs	r2, #1
 8050342:	601a      	str	r2, [r3, #0]
    HAL_NVIC_SetPriority(RTC_WKUP_IRQn, 0, 0);
 8050344:	2200      	movs	r2, #0
 8050346:	4611      	mov	r1, r2
 8050348:	2003      	movs	r0, #3
 805034a:	f7f1 fad1 	bl	80418f0 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(RTC_WKUP_IRQn);
 805034e:	2003      	movs	r0, #3
 8050350:	f7f1 fb02 	bl	8041958 <HAL_NVIC_EnableIRQ>
    HAL_NVIC_SetPriority(RTC_Alarm_IRQn, 0, 0);
 8050354:	2200      	movs	r2, #0
 8050356:	4611      	mov	r1, r2
 8050358:	2029      	movs	r0, #41	; 0x29
 805035a:	f7f1 fac9 	bl	80418f0 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(RTC_Alarm_IRQn);
 805035e:	2029      	movs	r0, #41	; 0x29
 8050360:	f7f1 fafa 	bl	8041958 <HAL_NVIC_EnableIRQ>
}
 8050364:	e7e0      	b.n	8050328 <HAL_RTC_MspInit+0x18>
      Error_Handler();
 8050366:	f7fd fa79 	bl	804d85c <Error_Handler>
 805036a:	e7e8      	b.n	805033e <HAL_RTC_MspInit+0x2e>
 805036c:	40002800 	.word	0x40002800
 8050370:	42470e3c 	.word	0x42470e3c

08050374 <GSM_CharReception_Callback>:
extern uint32_t gu32GSMCharacterTimeout;
volatile uint32_t u8GSMCharRcv = 0;
uint8_t u8gsmResponse = 0;
extern strctGSM gsmInstance;
void GSM_CharReception_Callback(void)
{
 8050374:	b410      	push	{r4}
  return (uint8_t)(READ_BIT(USARTx->DR, USART_DR_DR));
 8050376:	4b0c      	ldr	r3, [pc, #48]	; (80503a8 <GSM_CharReception_Callback+0x34>)
 8050378:	685a      	ldr	r2, [r3, #4]
 805037a:	b2d2      	uxtb	r2, r2
	u8gsmResponse = LL_USART_ReceiveData8(UART4);
 805037c:	490b      	ldr	r1, [pc, #44]	; (80503ac <GSM_CharReception_Callback+0x38>)
 805037e:	700a      	strb	r2, [r1, #0]
	gsmInstance.as8GSM_Response_Buff[gsmInstance.u8GSM_Response_Character_Counter++] = u8gsmResponse;
 8050380:	4b0b      	ldr	r3, [pc, #44]	; (80503b0 <GSM_CharReception_Callback+0x3c>)
 8050382:	f8d3 0e38 	ldr.w	r0, [r3, #3640]	; 0xe38
 8050386:	1c44      	adds	r4, r0, #1
 8050388:	f8c3 4e38 	str.w	r4, [r3, #3640]	; 0xe38
 805038c:	4403      	add	r3, r0
 805038e:	f883 2452 	strb.w	r2, [r3, #1106]	; 0x452
	gu32GSMCharacterTimeout = FIVEHUNDRED_MS;
 8050392:	4b08      	ldr	r3, [pc, #32]	; (80503b4 <GSM_CharReception_Callback+0x40>)
 8050394:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
 8050398:	601a      	str	r2, [r3, #0]
	if(u8GSMCharRcv == 0)
 805039a:	684b      	ldr	r3, [r1, #4]
 805039c:	b90b      	cbnz	r3, 80503a2 <GSM_CharReception_Callback+0x2e>
		u8GSMCharRcv = 1;
 805039e:	2201      	movs	r2, #1
 80503a0:	604a      	str	r2, [r1, #4]
}
 80503a2:	f85d 4b04 	ldr.w	r4, [sp], #4
 80503a6:	4770      	bx	lr
 80503a8:	40004c00 	.word	0x40004c00
 80503ac:	20004f78 	.word	0x20004f78
 80503b0:	2000c398 	.word	0x2000c398
 80503b4:	20005158 	.word	0x20005158

080503b8 <MODBUS_CharReception_Callback>:
 80503b8:	4b14      	ldr	r3, [pc, #80]	; (805040c <MODBUS_CharReception_Callback+0x54>)
 80503ba:	685b      	ldr	r3, [r3, #4]
 80503bc:	b2db      	uxtb	r3, r3
uint8_t u8TestArrayCounter = 0;
volatile uint8_t gu8ModbusInterruptFlag = 0;
void MODBUS_CharReception_Callback(void)
{

	u8receivedChar =LL_USART_ReceiveData8(USART3);
 80503be:	4a14      	ldr	r2, [pc, #80]	; (8050410 <MODBUS_CharReception_Callback+0x58>)
 80503c0:	7013      	strb	r3, [r2, #0]
//
//	 if(u8TestArrayCounter == 25)
//	 {
//		 u8TestArrayCounter = 0;
//	 }
	if(gu8MBResponseFlag == 0)
 80503c2:	4b14      	ldr	r3, [pc, #80]	; (8050414 <MODBUS_CharReception_Callback+0x5c>)
 80503c4:	781b      	ldrb	r3, [r3, #0]
 80503c6:	b983      	cbnz	r3, 80503ea <MODBUS_CharReception_Callback+0x32>
	{
		if(master.u8MBSlave_Address == u8receivedChar)
 80503c8:	4b13      	ldr	r3, [pc, #76]	; (8050418 <MODBUS_CharReception_Callback+0x60>)
 80503ca:	781a      	ldrb	r2, [r3, #0]
 80503cc:	4b10      	ldr	r3, [pc, #64]	; (8050410 <MODBUS_CharReception_Callback+0x58>)
 80503ce:	781b      	ldrb	r3, [r3, #0]
 80503d0:	b2db      	uxtb	r3, r3
 80503d2:	429a      	cmp	r2, r3
 80503d4:	d119      	bne.n	805040a <MODBUS_CharReception_Callback+0x52>
		{
			/* Response from slave is received */
			gu8MBResponseFlag = 1;
 80503d6:	2301      	movs	r3, #1
 80503d8:	4a0e      	ldr	r2, [pc, #56]	; (8050414 <MODBUS_CharReception_Callback+0x5c>)
 80503da:	7013      	strb	r3, [r2, #0]
			gu32ModbusFrameEndTimer = gu32Modbus485ResponseTime;//ONE_SEC;//TWO_SEC;
 80503dc:	4a0f      	ldr	r2, [pc, #60]	; (805041c <MODBUS_CharReception_Callback+0x64>)
 80503de:	6811      	ldr	r1, [r2, #0]
 80503e0:	4a0f      	ldr	r2, [pc, #60]	; (8050420 <MODBUS_CharReception_Callback+0x68>)
 80503e2:	6011      	str	r1, [r2, #0]
			gu32MBRTUClientConnectedFlag = 1;
 80503e4:	4a0f      	ldr	r2, [pc, #60]	; (8050424 <MODBUS_CharReception_Callback+0x6c>)
 80503e6:	6013      	str	r3, [r2, #0]
 80503e8:	4770      	bx	lr
		}
	}
	else
	{
		master.u8SlaveResponseArray[master.u8MBResponseCharacterCounter++] = u8receivedChar;
 80503ea:	4b09      	ldr	r3, [pc, #36]	; (8050410 <MODBUS_CharReception_Callback+0x58>)
 80503ec:	7819      	ldrb	r1, [r3, #0]
 80503ee:	4b0a      	ldr	r3, [pc, #40]	; (8050418 <MODBUS_CharReception_Callback+0x60>)
 80503f0:	f893 2520 	ldrb.w	r2, [r3, #1312]	; 0x520
 80503f4:	1c50      	adds	r0, r2, #1
 80503f6:	f883 0520 	strb.w	r0, [r3, #1312]	; 0x520
 80503fa:	3202      	adds	r2, #2
 80503fc:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 8050400:	6059      	str	r1, [r3, #4]
		gu32ModbusFrameEndTimer = gu32Modbus485ResponseTime;//ONE_SEC;//TWO_SEC;
 8050402:	4b06      	ldr	r3, [pc, #24]	; (805041c <MODBUS_CharReception_Callback+0x64>)
 8050404:	681a      	ldr	r2, [r3, #0]
 8050406:	4b06      	ldr	r3, [pc, #24]	; (8050420 <MODBUS_CharReception_Callback+0x68>)
 8050408:	601a      	str	r2, [r3, #0]
	}
}
 805040a:	4770      	bx	lr
 805040c:	40004800 	.word	0x40004800
 8050410:	2000f36e 	.word	0x2000f36e
 8050414:	20004322 	.word	0x20004322
 8050418:	2000d5e0 	.word	0x2000d5e0
 805041c:	2000365c 	.word	0x2000365c
 8050420:	2000432c 	.word	0x2000432c
 8050424:	20004334 	.word	0x20004334

08050428 <HAL_MspInit>:
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 8050428:	b510      	push	{r4, lr}
 805042a:	b082      	sub	sp, #8
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_SYSCFG_CLK_ENABLE();
 805042c:	2400      	movs	r4, #0
 805042e:	9400      	str	r4, [sp, #0]
 8050430:	4b12      	ldr	r3, [pc, #72]	; (805047c <HAL_MspInit+0x54>)
 8050432:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8050434:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 8050438:	645a      	str	r2, [r3, #68]	; 0x44
 805043a:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 805043c:	f402 4280 	and.w	r2, r2, #16384	; 0x4000
 8050440:	9200      	str	r2, [sp, #0]
 8050442:	9a00      	ldr	r2, [sp, #0]
  __HAL_RCC_PWR_CLK_ENABLE();
 8050444:	9401      	str	r4, [sp, #4]
 8050446:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8050448:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 805044c:	641a      	str	r2, [r3, #64]	; 0x40
 805044e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8050450:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8050454:	9301      	str	r3, [sp, #4]
 8050456:	9b01      	ldr	r3, [sp, #4]

  /* System interrupt init*/

  /* Peripheral interrupt init */
  /* FLASH_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(FLASH_IRQn, 1, 0);
 8050458:	4622      	mov	r2, r4
 805045a:	2101      	movs	r1, #1
 805045c:	2004      	movs	r0, #4
 805045e:	f7f1 fa47 	bl	80418f0 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(FLASH_IRQn);
 8050462:	2004      	movs	r0, #4
 8050464:	f7f1 fa78 	bl	8041958 <HAL_NVIC_EnableIRQ>
  /* RCC_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(RCC_IRQn, 1, 0);
 8050468:	4622      	mov	r2, r4
 805046a:	2101      	movs	r1, #1
 805046c:	2005      	movs	r0, #5
 805046e:	f7f1 fa3f 	bl	80418f0 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(RCC_IRQn);
 8050472:	2005      	movs	r0, #5
 8050474:	f7f1 fa70 	bl	8041958 <HAL_NVIC_EnableIRQ>

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 8050478:	b002      	add	sp, #8
 805047a:	bd10      	pop	{r4, pc}
 805047c:	40023800 	.word	0x40023800

08050480 <NMI_Handler>:
/******************************************************************************/
/**
  * @brief This function handles Non maskable interrupt.
  */
void NMI_Handler(void)
{
 8050480:	b508      	push	{r3, lr}
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */

  /* USER CODE END NonMaskableInt_IRQn 0 */
  HAL_RCC_NMI_IRQHandler();
 8050482:	f7f3 fff1 	bl	8044468 <HAL_RCC_NMI_IRQHandler>
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */

  /* USER CODE END NonMaskableInt_IRQn 1 */
}
 8050486:	bd08      	pop	{r3, pc}

08050488 <HardFault_Handler>:
void HardFault_Handler(void)
{
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
 8050488:	e7fe      	b.n	8050488 <HardFault_Handler>

0805048a <MemManage_Handler>:
void MemManage_Handler(void)
{
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */

  /* USER CODE END MemoryManagement_IRQn 0 */
  while (1)
 805048a:	e7fe      	b.n	805048a <MemManage_Handler>

0805048c <BusFault_Handler>:
void BusFault_Handler(void)
{
  /* USER CODE BEGIN BusFault_IRQn 0 */

  /* USER CODE END BusFault_IRQn 0 */
  while (1)
 805048c:	e7fe      	b.n	805048c <BusFault_Handler>

0805048e <UsageFault_Handler>:
void UsageFault_Handler(void)
{
  /* USER CODE BEGIN UsageFault_IRQn 0 */

  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
 805048e:	e7fe      	b.n	805048e <UsageFault_Handler>

08050490 <SVC_Handler>:

  /* USER CODE END SVCall_IRQn 0 */
  /* USER CODE BEGIN SVCall_IRQn 1 */

  /* USER CODE END SVCall_IRQn 1 */
}
 8050490:	4770      	bx	lr

08050492 <DebugMon_Handler>:

  /* USER CODE END DebugMonitor_IRQn 0 */
  /* USER CODE BEGIN DebugMonitor_IRQn 1 */

  /* USER CODE END DebugMonitor_IRQn 1 */
}
 8050492:	4770      	bx	lr

08050494 <PendSV_Handler>:

  /* USER CODE END PendSV_IRQn 0 */
  /* USER CODE BEGIN PendSV_IRQn 1 */

  /* USER CODE END PendSV_IRQn 1 */
}
 8050494:	4770      	bx	lr

08050496 <SysTick_Handler>:

/**
  * @brief This function handles System tick timer.
  */
void SysTick_Handler(void)
{
 8050496:	b508      	push	{r3, lr}
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
 8050498:	f7f0 fe06 	bl	80410a8 <HAL_IncTick>
  /* USER CODE BEGIN SysTick_IRQn 1 */

  /* USER CODE END SysTick_IRQn 1 */
}
 805049c:	bd08      	pop	{r3, pc}
	...

080504a0 <RTC_WKUP_IRQHandler>:

/**
  * @brief This function handles RTC wake-up interrupt through EXTI line 22.
  */
void RTC_WKUP_IRQHandler(void)
{
 80504a0:	b508      	push	{r3, lr}
  /* USER CODE BEGIN RTC_WKUP_IRQn 0 */

  /* USER CODE END RTC_WKUP_IRQn 0 */
  HAL_RTCEx_WakeUpTimerIRQHandler(&hrtc);
 80504a2:	4802      	ldr	r0, [pc, #8]	; (80504ac <RTC_WKUP_IRQHandler+0xc>)
 80504a4:	f7f4 fc8e 	bl	8044dc4 <HAL_RTCEx_WakeUpTimerIRQHandler>
  /* USER CODE BEGIN RTC_WKUP_IRQn 1 */

  /* USER CODE END RTC_WKUP_IRQn 1 */
}
 80504a8:	bd08      	pop	{r3, pc}
 80504aa:	bf00      	nop
 80504ac:	2000f330 	.word	0x2000f330

080504b0 <FLASH_IRQHandler>:

/**
  * @brief This function handles Flash global interrupt.
  */
void FLASH_IRQHandler(void)
{
 80504b0:	b508      	push	{r3, lr}
  /* USER CODE BEGIN FLASH_IRQn 0 */

  /* USER CODE END FLASH_IRQn 0 */
  HAL_FLASH_IRQHandler();
 80504b2:	f7f2 f967 	bl	8042784 <HAL_FLASH_IRQHandler>
  /* USER CODE BEGIN FLASH_IRQn 1 */

  /* USER CODE END FLASH_IRQn 1 */
}
 80504b6:	bd08      	pop	{r3, pc}

080504b8 <RCC_IRQHandler>:

  /* USER CODE END RCC_IRQn 0 */
  /* USER CODE BEGIN RCC_IRQn 1 */

  /* USER CODE END RCC_IRQn 1 */
}
 80504b8:	4770      	bx	lr
	...

080504bc <ADC_IRQHandler>:

/**
  * @brief This function handles ADC1, ADC2 and ADC3 global interrupts.
  */
void ADC_IRQHandler(void)
{
 80504bc:	b508      	push	{r3, lr}
  /* USER CODE BEGIN ADC_IRQn 0 */

  /* USER CODE END ADC_IRQn 0 */
  HAL_ADC_IRQHandler(&hadc1);
 80504be:	4802      	ldr	r0, [pc, #8]	; (80504c8 <ADC_IRQHandler+0xc>)
 80504c0:	f7f1 f844 	bl	804154c <HAL_ADC_IRQHandler>
  /* USER CODE BEGIN ADC_IRQn 1 */

  /* USER CODE END ADC_IRQn 1 */
}
 80504c4:	bd08      	pop	{r3, pc}
 80504c6:	bf00      	nop
 80504c8:	2000873c 	.word	0x2000873c

080504cc <I2C1_EV_IRQHandler>:

/**
  * @brief This function handles I2C1 event interrupt.
  */
void I2C1_EV_IRQHandler(void)
{
 80504cc:	b508      	push	{r3, lr}
  /* USER CODE BEGIN I2C1_EV_IRQn 0 */

  /* USER CODE END I2C1_EV_IRQn 0 */
  HAL_I2C_EV_IRQHandler(&hi2c1);
 80504ce:	4802      	ldr	r0, [pc, #8]	; (80504d8 <I2C1_EV_IRQHandler+0xc>)
 80504d0:	f7f3 fb0a 	bl	8043ae8 <HAL_I2C_EV_IRQHandler>
  /* USER CODE BEGIN I2C1_EV_IRQn 1 */

  /* USER CODE END I2C1_EV_IRQn 1 */
}
 80504d4:	bd08      	pop	{r3, pc}
 80504d6:	bf00      	nop
 80504d8:	2000d538 	.word	0x2000d538

080504dc <I2C1_ER_IRQHandler>:

/**
  * @brief This function handles I2C1 error interrupt.
  */
void I2C1_ER_IRQHandler(void)
{
 80504dc:	b508      	push	{r3, lr}
  /* USER CODE BEGIN I2C1_ER_IRQn 0 */

  /* USER CODE END I2C1_ER_IRQn 0 */
  HAL_I2C_ER_IRQHandler(&hi2c1);
 80504de:	4802      	ldr	r0, [pc, #8]	; (80504e8 <I2C1_ER_IRQHandler+0xc>)
 80504e0:	f7f3 fbc8 	bl	8043c74 <HAL_I2C_ER_IRQHandler>
  /* USER CODE BEGIN I2C1_ER_IRQn 1 */

  /* USER CODE END I2C1_ER_IRQn 1 */
}
 80504e4:	bd08      	pop	{r3, pc}
 80504e6:	bf00      	nop
 80504e8:	2000d538 	.word	0x2000d538

080504ec <USART3_IRQHandler>:

/**
  * @brief This function handles USART3 global interrupt.
  */
void USART3_IRQHandler(void)
{
 80504ec:	b510      	push	{r4, lr}
  return (READ_BIT(USARTx->SR, USART_SR_RXNE) == (USART_SR_RXNE));
 80504ee:	4b24      	ldr	r3, [pc, #144]	; (8050580 <USART3_IRQHandler+0x94>)
 80504f0:	681b      	ldr	r3, [r3, #0]
  /* USER CODE BEGIN USART3_IRQn 0 */
	if(LL_USART_IsActiveFlag_RXNE(USART3)!=RESET)
 80504f2:	f013 0f20 	tst.w	r3, #32
 80504f6:	d114      	bne.n	8050522 <USART3_IRQHandler+0x36>
  return (READ_BIT(USARTx->SR, USART_SR_TC) == (USART_SR_TC));
 80504f8:	4b21      	ldr	r3, [pc, #132]	; (8050580 <USART3_IRQHandler+0x94>)
 80504fa:	681b      	ldr	r3, [r3, #0]
	{
	/* RXNE flag will be cleared by reading of RDR register (done in call) */
	/* Call function in charge of handling Character reception */
		MODBUS_CharReception_Callback();
	}
	else if(LL_USART_IsActiveFlag_TC(USART3)!=RESET)
 80504fc:	f013 0f40 	tst.w	r3, #64	; 0x40
 8050500:	d011      	beq.n	8050526 <USART3_IRQHandler+0x3a>
	{
		if(u8MBQueryCharacterCounter <= 7)
 8050502:	4b20      	ldr	r3, [pc, #128]	; (8050584 <USART3_IRQHandler+0x98>)
 8050504:	781b      	ldrb	r3, [r3, #0]
 8050506:	b2db      	uxtb	r3, r3
 8050508:	2b07      	cmp	r3, #7
 805050a:	d80d      	bhi.n	8050528 <USART3_IRQHandler+0x3c>
		{
			LL_USART_TransmitData8(USART3,master.u8QueryFrame[u8MBQueryCharacterCounter++]);
 805050c:	4b1d      	ldr	r3, [pc, #116]	; (8050584 <USART3_IRQHandler+0x98>)
 805050e:	7819      	ldrb	r1, [r3, #0]
 8050510:	1c4a      	adds	r2, r1, #1
 8050512:	b2d2      	uxtb	r2, r2
 8050514:	701a      	strb	r2, [r3, #0]
 8050516:	4b1c      	ldr	r3, [pc, #112]	; (8050588 <USART3_IRQHandler+0x9c>)
 8050518:	440b      	add	r3, r1
 805051a:	785a      	ldrb	r2, [r3, #1]
  USARTx->DR = Value;
 805051c:	4b18      	ldr	r3, [pc, #96]	; (8050580 <USART3_IRQHandler+0x94>)
 805051e:	605a      	str	r2, [r3, #4]
}
 8050520:	e001      	b.n	8050526 <USART3_IRQHandler+0x3a>
		MODBUS_CharReception_Callback();
 8050522:	f7ff ff49 	bl	80503b8 <MODBUS_CharReception_Callback>
	}
  /* USER CODE END USART3_IRQn 0 */
  /* USER CODE BEGIN USART3_IRQn 1 */

  /* USER CODE END USART3_IRQn 1 */
}
 8050526:	bd10      	pop	{r4, pc}
			HAL_GPIO_WritePin(MB_RE_GPIO_Port,MB_RE_Pin,GPIO_PIN_RESET);
 8050528:	4c18      	ldr	r4, [pc, #96]	; (805058c <USART3_IRQHandler+0xa0>)
 805052a:	2200      	movs	r2, #0
 805052c:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 8050530:	4620      	mov	r0, r4
 8050532:	f7f2 fbf5 	bl	8042d20 <HAL_GPIO_WritePin>
			HAL_GPIO_WritePin(MB_RE_GPIO_Port,MB_DE_Pin,GPIO_PIN_RESET);
 8050536:	2200      	movs	r2, #0
 8050538:	f44f 6100 	mov.w	r1, #2048	; 0x800
 805053c:	4620      	mov	r0, r4
 805053e:	f7f2 fbef 	bl	8042d20 <HAL_GPIO_WritePin>
			u8MBQueryCharacterCounter = 0;
 8050542:	2200      	movs	r2, #0
 8050544:	4b0f      	ldr	r3, [pc, #60]	; (8050584 <USART3_IRQHandler+0x98>)
 8050546:	701a      	strb	r2, [r3, #0]
			master.u8MBResponseCharacterCounter = 0;
 8050548:	4b0f      	ldr	r3, [pc, #60]	; (8050588 <USART3_IRQHandler+0x9c>)
 805054a:	f883 2520 	strb.w	r2, [r3, #1312]	; 0x520
			modbusState = enmMODBBUS_AWAIT_RESPONSE;
 805054e:	4a10      	ldr	r2, [pc, #64]	; (8050590 <USART3_IRQHandler+0xa4>)
 8050550:	2102      	movs	r1, #2
 8050552:	7011      	strb	r1, [r2, #0]
			gu32ModbusResponseTimeout = FOUR_SEC;
 8050554:	4a0f      	ldr	r2, [pc, #60]	; (8050594 <USART3_IRQHandler+0xa8>)
 8050556:	f44f 617a 	mov.w	r1, #4000	; 0xfa0
 805055a:	6011      	str	r1, [r2, #0]
			gu8MBFrameTransmittedFlag = 1;
 805055c:	4a0e      	ldr	r2, [pc, #56]	; (8050598 <USART3_IRQHandler+0xac>)
 805055e:	2101      	movs	r1, #1
 8050560:	7011      	strb	r1, [r2, #0]
			master.u32PollDelay = ONE_SEC;
 8050562:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 8050566:	f8c3 2e4c 	str.w	r2, [r3, #3660]	; 0xe4c
  CLEAR_BIT(USARTx->CR1, USART_CR1_TCIE);
 805056a:	4b05      	ldr	r3, [pc, #20]	; (8050580 <USART3_IRQHandler+0x94>)
 805056c:	68da      	ldr	r2, [r3, #12]
 805056e:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 8050572:	60da      	str	r2, [r3, #12]
  CLEAR_BIT(USARTx->CR1, USART_CR1_TXEIE);
 8050574:	68da      	ldr	r2, [r3, #12]
 8050576:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 805057a:	60da      	str	r2, [r3, #12]
}
 805057c:	e7d3      	b.n	8050526 <USART3_IRQHandler+0x3a>
 805057e:	bf00      	nop
 8050580:	40004800 	.word	0x40004800
 8050584:	20004328 	.word	0x20004328
 8050588:	2000d5e0 	.word	0x2000d5e0
 805058c:	40021000 	.word	0x40021000
 8050590:	20004321 	.word	0x20004321
 8050594:	20004330 	.word	0x20004330
 8050598:	200047f4 	.word	0x200047f4

0805059c <RTC_Alarm_IRQHandler>:

/**
  * @brief This function handles RTC alarms A and B interrupt through EXTI line 17.
  */
void RTC_Alarm_IRQHandler(void)
{
 805059c:	b508      	push	{r3, lr}
  /* USER CODE BEGIN RTC_Alarm_IRQn 0 */

  /* USER CODE END RTC_Alarm_IRQn 0 */
  HAL_RTC_AlarmIRQHandler(&hrtc);
 805059e:	4802      	ldr	r0, [pc, #8]	; (80505a8 <RTC_Alarm_IRQHandler+0xc>)
 80505a0:	f7f4 f8a8 	bl	80446f4 <HAL_RTC_AlarmIRQHandler>
  /* USER CODE BEGIN RTC_Alarm_IRQn 1 */

  /* USER CODE END RTC_Alarm_IRQn 1 */
}
 80505a4:	bd08      	pop	{r3, pc}
 80505a6:	bf00      	nop
 80505a8:	2000f330 	.word	0x2000f330

080505ac <UART4_IRQHandler>:

/**
  * @brief This function handles UART4 global interrupt.
  */
void UART4_IRQHandler(void)
{
 80505ac:	b508      	push	{r3, lr}
  return (READ_BIT(USARTx->SR, USART_SR_RXNE) == (USART_SR_RXNE));
 80505ae:	4b04      	ldr	r3, [pc, #16]	; (80505c0 <UART4_IRQHandler+0x14>)
 80505b0:	681b      	ldr	r3, [r3, #0]
  /* USER CODE BEGIN UART4_IRQn 0 */
	if(LL_USART_IsActiveFlag_RXNE(UART4)!=RESET)
 80505b2:	f013 0f20 	tst.w	r3, #32
 80505b6:	d100      	bne.n	80505ba <UART4_IRQHandler+0xe>
	}
  /* USER CODE END UART4_IRQn 0 */
  /* USER CODE BEGIN UART4_IRQn 1 */

  /* USER CODE END UART4_IRQn 1 */
}
 80505b8:	bd08      	pop	{r3, pc}
		GSM_CharReception_Callback();
 80505ba:	f7ff fedb 	bl	8050374 <GSM_CharReception_Callback>
}
 80505be:	e7fb      	b.n	80505b8 <UART4_IRQHandler+0xc>
 80505c0:	40004c00 	.word	0x40004c00

080505c4 <TIM7_IRQHandler>:

/**
  * @brief This function handles TIM7 global interrupt.
  */
void TIM7_IRQHandler(void)
{
 80505c4:	b508      	push	{r3, lr}
  /* USER CODE BEGIN TIM7_IRQn 0 */

  /* USER CODE END TIM7_IRQn 0 */
  HAL_TIM_IRQHandler(&htim7);
 80505c6:	4802      	ldr	r0, [pc, #8]	; (80505d0 <TIM7_IRQHandler+0xc>)
 80505c8:	f7f4 fc35 	bl	8044e36 <HAL_TIM_IRQHandler>
  /* USER CODE BEGIN TIM7_IRQn 1 */

  /* USER CODE END TIM7_IRQn 1 */
}
 80505cc:	bd08      	pop	{r3, pc}
 80505ce:	bf00      	nop
 80505d0:	2000f370 	.word	0x2000f370

080505d4 <DMA2_Stream4_IRQHandler>:

/**
  * @brief This function handles DMA2 stream4 global interrupt.
  */
void DMA2_Stream4_IRQHandler(void)
{
 80505d4:	b508      	push	{r3, lr}
  /* USER CODE BEGIN DMA2_Stream4_IRQn 0 */

  /* USER CODE END DMA2_Stream4_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_adc1);
 80505d6:	4802      	ldr	r0, [pc, #8]	; (80505e0 <DMA2_Stream4_IRQHandler+0xc>)
 80505d8:	f7f1 fb28 	bl	8041c2c <HAL_DMA_IRQHandler>
  /* USER CODE BEGIN DMA2_Stream4_IRQn 1 */

  /* USER CODE END DMA2_Stream4_IRQn 1 */
}
 80505dc:	bd08      	pop	{r3, pc}
 80505de:	bf00      	nop
 80505e0:	20008784 	.word	0x20008784

080505e4 <_getpid>:
}

int _getpid(void)
{
	return 1;
}
 80505e4:	2001      	movs	r0, #1
 80505e6:	4770      	bx	lr

080505e8 <_kill>:

int _kill(int pid, int sig)
{
	errno = EINVAL;
 80505e8:	4b02      	ldr	r3, [pc, #8]	; (80505f4 <_kill+0xc>)
 80505ea:	2216      	movs	r2, #22
 80505ec:	601a      	str	r2, [r3, #0]
	return -1;
}
 80505ee:	f04f 30ff 	mov.w	r0, #4294967295
 80505f2:	4770      	bx	lr
 80505f4:	200100a8 	.word	0x200100a8

080505f8 <_exit>:

void _exit (int status)
{
 80505f8:	b508      	push	{r3, lr}
	_kill(status, -1);
 80505fa:	f04f 31ff 	mov.w	r1, #4294967295
 80505fe:	f7ff fff3 	bl	80505e8 <_kill>
	while (1) {}		/* Make sure we hang here */
 8050602:	e7fe      	b.n	8050602 <_exit+0xa>

08050604 <_read>:
}

__attribute__((weak)) int _read(int file, char *ptr, int len)
{
 8050604:	b570      	push	{r4, r5, r6, lr}
 8050606:	460c      	mov	r4, r1
 8050608:	4616      	mov	r6, r2
	int DataIdx;

	for (DataIdx = 0; DataIdx < len; DataIdx++)
 805060a:	2500      	movs	r5, #0
 805060c:	42b5      	cmp	r5, r6
 805060e:	da07      	bge.n	8050620 <_read+0x1c>
	{
		*ptr++ = __io_getchar();
 8050610:	f3af 8000 	nop.w
 8050614:	4621      	mov	r1, r4
 8050616:	f801 0b01 	strb.w	r0, [r1], #1
	for (DataIdx = 0; DataIdx < len; DataIdx++)
 805061a:	3501      	adds	r5, #1
		*ptr++ = __io_getchar();
 805061c:	460c      	mov	r4, r1
 805061e:	e7f5      	b.n	805060c <_read+0x8>
	}

return len;
}
 8050620:	4630      	mov	r0, r6
 8050622:	bd70      	pop	{r4, r5, r6, pc}

08050624 <_write>:

__attribute__((weak)) int _write(int file, char *ptr, int len)
{
 8050624:	b570      	push	{r4, r5, r6, lr}
 8050626:	460c      	mov	r4, r1
 8050628:	4616      	mov	r6, r2
	int DataIdx;

	for (DataIdx = 0; DataIdx < len; DataIdx++)
 805062a:	2500      	movs	r5, #0
 805062c:	42b5      	cmp	r5, r6
 805062e:	da05      	bge.n	805063c <_write+0x18>
	{
		__io_putchar(*ptr++);
 8050630:	f814 0b01 	ldrb.w	r0, [r4], #1
 8050634:	f3af 8000 	nop.w
	for (DataIdx = 0; DataIdx < len; DataIdx++)
 8050638:	3501      	adds	r5, #1
 805063a:	e7f7      	b.n	805062c <_write+0x8>
	}
	return len;
}
 805063c:	4630      	mov	r0, r6
 805063e:	bd70      	pop	{r4, r5, r6, pc}

08050640 <_sbrk>:

caddr_t _sbrk(int incr)
{
 8050640:	4603      	mov	r3, r0
	extern char end asm("end");
	static char *heap_end;
	char *prev_heap_end;

	if (heap_end == 0)
 8050642:	4a0b      	ldr	r2, [pc, #44]	; (8050670 <_sbrk+0x30>)
 8050644:	6812      	ldr	r2, [r2, #0]
 8050646:	b142      	cbz	r2, 805065a <_sbrk+0x1a>
		heap_end = &end;

	prev_heap_end = heap_end;
 8050648:	4a09      	ldr	r2, [pc, #36]	; (8050670 <_sbrk+0x30>)
 805064a:	6810      	ldr	r0, [r2, #0]
	if (heap_end + incr > stack_ptr)
 805064c:	4403      	add	r3, r0
 805064e:	466a      	mov	r2, sp
 8050650:	4293      	cmp	r3, r2
 8050652:	d806      	bhi.n	8050662 <_sbrk+0x22>
//		abort();
		errno = ENOMEM;
		return (caddr_t) -1;
	}

	heap_end += incr;
 8050654:	4a06      	ldr	r2, [pc, #24]	; (8050670 <_sbrk+0x30>)
 8050656:	6013      	str	r3, [r2, #0]

	return (caddr_t) prev_heap_end;
}
 8050658:	4770      	bx	lr
		heap_end = &end;
 805065a:	4a05      	ldr	r2, [pc, #20]	; (8050670 <_sbrk+0x30>)
 805065c:	4905      	ldr	r1, [pc, #20]	; (8050674 <_sbrk+0x34>)
 805065e:	6011      	str	r1, [r2, #0]
 8050660:	e7f2      	b.n	8050648 <_sbrk+0x8>
		errno = ENOMEM;
 8050662:	4b05      	ldr	r3, [pc, #20]	; (8050678 <_sbrk+0x38>)
 8050664:	220c      	movs	r2, #12
 8050666:	601a      	str	r2, [r3, #0]
		return (caddr_t) -1;
 8050668:	f04f 30ff 	mov.w	r0, #4294967295
 805066c:	4770      	bx	lr
 805066e:	bf00      	nop
 8050670:	20004f8c 	.word	0x20004f8c
 8050674:	200100b8 	.word	0x200100b8
 8050678:	200100a8 	.word	0x200100a8

0805067c <_close>:

int _close(int file)
{
	return -1;
}
 805067c:	f04f 30ff 	mov.w	r0, #4294967295
 8050680:	4770      	bx	lr

08050682 <_fstat>:


int _fstat(int file, struct stat *st)
{
	st->st_mode = S_IFCHR;
 8050682:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 8050686:	604b      	str	r3, [r1, #4]
	return 0;
}
 8050688:	2000      	movs	r0, #0
 805068a:	4770      	bx	lr

0805068c <_isatty>:

int _isatty(int file)
{
	return 1;
}
 805068c:	2001      	movs	r0, #1
 805068e:	4770      	bx	lr

08050690 <_lseek>:

int _lseek(int file, int ptr, int dir)
{
	return 0;
}
 8050690:	2000      	movs	r0, #0
 8050692:	4770      	bx	lr

08050694 <SystemInit>:
  */
void SystemInit(void)
{
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 8050694:	490e      	ldr	r1, [pc, #56]	; (80506d0 <SystemInit+0x3c>)
 8050696:	f8d1 3088 	ldr.w	r3, [r1, #136]	; 0x88
 805069a:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
 805069e:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
  #endif
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 80506a2:	4b0c      	ldr	r3, [pc, #48]	; (80506d4 <SystemInit+0x40>)
 80506a4:	681a      	ldr	r2, [r3, #0]
 80506a6:	f042 0201 	orr.w	r2, r2, #1
 80506aa:	601a      	str	r2, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
 80506ac:	2000      	movs	r0, #0
 80506ae:	6098      	str	r0, [r3, #8]

  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 80506b0:	681a      	ldr	r2, [r3, #0]
 80506b2:	f022 7284 	bic.w	r2, r2, #17301504	; 0x1080000
 80506b6:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 80506ba:	601a      	str	r2, [r3, #0]

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x24003010;
 80506bc:	4a06      	ldr	r2, [pc, #24]	; (80506d8 <SystemInit+0x44>)
 80506be:	605a      	str	r2, [r3, #4]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 80506c0:	681a      	ldr	r2, [r3, #0]
 80506c2:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 80506c6:	601a      	str	r2, [r3, #0]

  /* Disable all interrupts */
  RCC->CIR = 0x00000000;
 80506c8:	60d8      	str	r0, [r3, #12]

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 80506ca:	4b04      	ldr	r3, [pc, #16]	; (80506dc <SystemInit+0x48>)
 80506cc:	608b      	str	r3, [r1, #8]
#endif
}
 80506ce:	4770      	bx	lr
 80506d0:	e000ed00 	.word	0xe000ed00
 80506d4:	40023800 	.word	0x40023800
 80506d8:	24003010 	.word	0x24003010
 80506dc:	08040000 	.word	0x08040000

080506e0 <MX_TIM7_Init>:

TIM_HandleTypeDef htim7;

/* TIM7 init function */
void MX_TIM7_Init(void)
{
 80506e0:	b500      	push	{lr}
 80506e2:	b083      	sub	sp, #12
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 80506e4:	2300      	movs	r3, #0
 80506e6:	9300      	str	r3, [sp, #0]
 80506e8:	9301      	str	r3, [sp, #4]

  htim7.Instance = TIM7;
 80506ea:	480f      	ldr	r0, [pc, #60]	; (8050728 <MX_TIM7_Init+0x48>)
 80506ec:	4a0f      	ldr	r2, [pc, #60]	; (805072c <MX_TIM7_Init+0x4c>)
 80506ee:	6002      	str	r2, [r0, #0]
  htim7.Init.Prescaler = 1;
 80506f0:	2201      	movs	r2, #1
 80506f2:	6042      	str	r2, [r0, #4]
  htim7.Init.CounterMode = TIM_COUNTERMODE_UP;
 80506f4:	6083      	str	r3, [r0, #8]
  htim7.Init.Period = 41999;
 80506f6:	f24a 420f 	movw	r2, #41999	; 0xa40f
 80506fa:	60c2      	str	r2, [r0, #12]
  htim7.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 80506fc:	6183      	str	r3, [r0, #24]
  if (HAL_TIM_Base_Init(&htim7) != HAL_OK)
 80506fe:	f7f4 fcbb 	bl	8045078 <HAL_TIM_Base_Init>
 8050702:	b950      	cbnz	r0, 805071a <MX_TIM7_Init+0x3a>
  {
    Error_Handler();
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 8050704:	2300      	movs	r3, #0
 8050706:	9300      	str	r3, [sp, #0]
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 8050708:	9301      	str	r3, [sp, #4]
  if (HAL_TIMEx_MasterConfigSynchronization(&htim7, &sMasterConfig) != HAL_OK)
 805070a:	4669      	mov	r1, sp
 805070c:	4806      	ldr	r0, [pc, #24]	; (8050728 <MX_TIM7_Init+0x48>)
 805070e:	f7f4 fccd 	bl	80450ac <HAL_TIMEx_MasterConfigSynchronization>
 8050712:	b928      	cbnz	r0, 8050720 <MX_TIM7_Init+0x40>
  {
    Error_Handler();
  }

}
 8050714:	b003      	add	sp, #12
 8050716:	f85d fb04 	ldr.w	pc, [sp], #4
    Error_Handler();
 805071a:	f7fd f89f 	bl	804d85c <Error_Handler>
 805071e:	e7f1      	b.n	8050704 <MX_TIM7_Init+0x24>
    Error_Handler();
 8050720:	f7fd f89c 	bl	804d85c <Error_Handler>
}
 8050724:	e7f6      	b.n	8050714 <MX_TIM7_Init+0x34>
 8050726:	bf00      	nop
 8050728:	2000f370 	.word	0x2000f370
 805072c:	40001400 	.word	0x40001400

08050730 <HAL_TIM_Base_MspInit>:

void HAL_TIM_Base_MspInit(TIM_HandleTypeDef* tim_baseHandle)
{

  if(tim_baseHandle->Instance==TIM7)
 8050730:	6802      	ldr	r2, [r0, #0]
 8050732:	4b0e      	ldr	r3, [pc, #56]	; (805076c <HAL_TIM_Base_MspInit+0x3c>)
 8050734:	429a      	cmp	r2, r3
 8050736:	d000      	beq.n	805073a <HAL_TIM_Base_MspInit+0xa>
 8050738:	4770      	bx	lr
{
 805073a:	b500      	push	{lr}
 805073c:	b083      	sub	sp, #12
  {
  /* USER CODE BEGIN TIM7_MspInit 0 */

  /* USER CODE END TIM7_MspInit 0 */
    /* TIM7 clock enable */
    __HAL_RCC_TIM7_CLK_ENABLE();
 805073e:	2200      	movs	r2, #0
 8050740:	9201      	str	r2, [sp, #4]
 8050742:	f503 3309 	add.w	r3, r3, #140288	; 0x22400
 8050746:	6c19      	ldr	r1, [r3, #64]	; 0x40
 8050748:	f041 0120 	orr.w	r1, r1, #32
 805074c:	6419      	str	r1, [r3, #64]	; 0x40
 805074e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8050750:	f003 0320 	and.w	r3, r3, #32
 8050754:	9301      	str	r3, [sp, #4]
 8050756:	9b01      	ldr	r3, [sp, #4]

    /* TIM7 interrupt Init */
    HAL_NVIC_SetPriority(TIM7_IRQn, 1, 0);
 8050758:	2101      	movs	r1, #1
 805075a:	2037      	movs	r0, #55	; 0x37
 805075c:	f7f1 f8c8 	bl	80418f0 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(TIM7_IRQn);
 8050760:	2037      	movs	r0, #55	; 0x37
 8050762:	f7f1 f8f9 	bl	8041958 <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN TIM7_MspInit 1 */

  /* USER CODE END TIM7_MspInit 1 */
  }
}
 8050766:	b003      	add	sp, #12
 8050768:	f85d fb04 	ldr.w	pc, [sp], #4
 805076c:	40001400 	.word	0x40001400

08050770 <MX_UART4_Init>:
#include "externs.h"
/* USER CODE END 0 */

/* UART4 init function */
void MX_UART4_Init(void)
{
 8050770:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8050774:	b090      	sub	sp, #64	; 0x40
  LL_USART_InitTypeDef USART_InitStruct = {0};
 8050776:	2400      	movs	r4, #0
 8050778:	9409      	str	r4, [sp, #36]	; 0x24
 805077a:	940a      	str	r4, [sp, #40]	; 0x28
 805077c:	940b      	str	r4, [sp, #44]	; 0x2c
 805077e:	940c      	str	r4, [sp, #48]	; 0x30
 8050780:	940d      	str	r4, [sp, #52]	; 0x34
 8050782:	940e      	str	r4, [sp, #56]	; 0x38
 8050784:	940f      	str	r4, [sp, #60]	; 0x3c
  * @retval None
*/
__STATIC_INLINE void LL_APB1_GRP1_EnableClock(uint32_t Periphs)
{
  __IO uint32_t tmpreg;
  SET_BIT(RCC->APB1ENR, Periphs);
 8050786:	4b3b      	ldr	r3, [pc, #236]	; (8050874 <MX_UART4_Init+0x104>)
 8050788:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 805078a:	f442 2200 	orr.w	r2, r2, #524288	; 0x80000
 805078e:	641a      	str	r2, [r3, #64]	; 0x40
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_BIT(RCC->APB1ENR, Periphs);
 8050790:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8050792:	f402 2200 	and.w	r2, r2, #524288	; 0x80000
 8050796:	9202      	str	r2, [sp, #8]
  (void)tmpreg;
 8050798:	9a02      	ldr	r2, [sp, #8]
  SET_BIT(RCC->AHB1ENR, Periphs);
 805079a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 805079c:	f042 0201 	orr.w	r2, r2, #1
 80507a0:	631a      	str	r2, [r3, #48]	; 0x30
  tmpreg = READ_BIT(RCC->AHB1ENR, Periphs);
 80507a2:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80507a4:	f002 0201 	and.w	r2, r2, #1
 80507a8:	9201      	str	r2, [sp, #4]
  (void)tmpreg;
 80507aa:	9a01      	ldr	r2, [sp, #4]
  SET_BIT(RCC->AHB1ENR, Periphs);
 80507ac:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80507ae:	f042 0204 	orr.w	r2, r2, #4
 80507b2:	631a      	str	r2, [r3, #48]	; 0x30
  tmpreg = READ_BIT(RCC->AHB1ENR, Periphs);
 80507b4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80507b6:	f003 0304 	and.w	r3, r3, #4
 80507ba:	9300      	str	r3, [sp, #0]
  (void)tmpreg;
 80507bc:	9b00      	ldr	r3, [sp, #0]
  LL_AHB1_GRP1_EnableClock(LL_AHB1_GRP1_PERIPH_GPIOC);
  /**UART4 GPIO Configuration
  PA0/WKUP   ------> UART4_TX
  PC11   ------> UART4_RX
  */
  GPIO_InitStruct.Pin = LL_GPIO_PIN_0;
 80507be:	2501      	movs	r5, #1
 80507c0:	9503      	str	r5, [sp, #12]
  GPIO_InitStruct.Mode = LL_GPIO_MODE_ALTERNATE;
 80507c2:	f04f 0802 	mov.w	r8, #2
 80507c6:	f8cd 8010 	str.w	r8, [sp, #16]
  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_VERY_HIGH;
 80507ca:	2703      	movs	r7, #3
 80507cc:	9705      	str	r7, [sp, #20]
  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
 80507ce:	9406      	str	r4, [sp, #24]
  GPIO_InitStruct.Pull = LL_GPIO_PULL_UP;
 80507d0:	9507      	str	r5, [sp, #28]
  GPIO_InitStruct.Alternate = LL_GPIO_AF_8;
 80507d2:	2608      	movs	r6, #8
 80507d4:	9608      	str	r6, [sp, #32]
  LL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80507d6:	a903      	add	r1, sp, #12
 80507d8:	4827      	ldr	r0, [pc, #156]	; (8050878 <MX_UART4_Init+0x108>)
 80507da:	f7f4 fc8c 	bl	80450f6 <LL_GPIO_Init>

  GPIO_InitStruct.Pin = LL_GPIO_PIN_11;
 80507de:	f44f 6300 	mov.w	r3, #2048	; 0x800
 80507e2:	9303      	str	r3, [sp, #12]
  GPIO_InitStruct.Mode = LL_GPIO_MODE_ALTERNATE;
 80507e4:	f8cd 8010 	str.w	r8, [sp, #16]
  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_VERY_HIGH;
 80507e8:	9705      	str	r7, [sp, #20]
  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
 80507ea:	9406      	str	r4, [sp, #24]
  GPIO_InitStruct.Pull = LL_GPIO_PULL_UP;
 80507ec:	9507      	str	r5, [sp, #28]
  GPIO_InitStruct.Alternate = LL_GPIO_AF_8;
 80507ee:	9608      	str	r6, [sp, #32]
  LL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 80507f0:	a903      	add	r1, sp, #12
 80507f2:	4822      	ldr	r0, [pc, #136]	; (805087c <MX_UART4_Init+0x10c>)
 80507f4:	f7f4 fc7f 	bl	80450f6 <LL_GPIO_Init>
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 80507f8:	4b21      	ldr	r3, [pc, #132]	; (8050880 <MX_UART4_Init+0x110>)
 80507fa:	68da      	ldr	r2, [r3, #12]
 80507fc:	f3c2 2202 	ubfx	r2, r2, #8, #3
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8050800:	f1c2 0307 	rsb	r3, r2, #7
 8050804:	2b04      	cmp	r3, #4
 8050806:	bf28      	it	cs
 8050808:	2304      	movcs	r3, #4
 805080a:	4619      	mov	r1, r3
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 805080c:	1d13      	adds	r3, r2, #4
 805080e:	2b06      	cmp	r3, #6
 8050810:	d92e      	bls.n	8050870 <MX_UART4_Init+0x100>
 8050812:	3a03      	subs	r2, #3
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8050814:	f04f 33ff 	mov.w	r3, #4294967295
 8050818:	408b      	lsls	r3, r1
 805081a:	43db      	mvns	r3, r3
 805081c:	f003 0303 	and.w	r3, r3, #3
 8050820:	4093      	lsls	r3, r2
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8050822:	011b      	lsls	r3, r3, #4
 8050824:	b2db      	uxtb	r3, r3
 8050826:	4a17      	ldr	r2, [pc, #92]	; (8050884 <MX_UART4_Init+0x114>)
 8050828:	f882 3334 	strb.w	r3, [r2, #820]	; 0x334
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 805082c:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 8050830:	6053      	str	r3, [r2, #4]

  /* UART4 interrupt Init */
  NVIC_SetPriority(UART4_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),3, 0));
  NVIC_EnableIRQ(UART4_IRQn);

  USART_InitStruct.BaudRate = 115200;
 8050832:	f44f 33e1 	mov.w	r3, #115200	; 0x1c200
 8050836:	9309      	str	r3, [sp, #36]	; 0x24
  USART_InitStruct.DataWidth = LL_USART_DATAWIDTH_8B;
 8050838:	2300      	movs	r3, #0
 805083a:	930a      	str	r3, [sp, #40]	; 0x28
  USART_InitStruct.StopBits = LL_USART_STOPBITS_1;
 805083c:	930b      	str	r3, [sp, #44]	; 0x2c
  USART_InitStruct.Parity = LL_USART_PARITY_NONE;
 805083e:	930c      	str	r3, [sp, #48]	; 0x30
  USART_InitStruct.TransferDirection = LL_USART_DIRECTION_TX_RX;
 8050840:	220c      	movs	r2, #12
 8050842:	920d      	str	r2, [sp, #52]	; 0x34
  USART_InitStruct.HardwareFlowControl = LL_USART_HWCONTROL_NONE;
 8050844:	930e      	str	r3, [sp, #56]	; 0x38
  USART_InitStruct.OverSampling = LL_USART_OVERSAMPLING_16;
 8050846:	930f      	str	r3, [sp, #60]	; 0x3c
  LL_USART_Init(UART4, &USART_InitStruct);
 8050848:	4c0f      	ldr	r4, [pc, #60]	; (8050888 <MX_UART4_Init+0x118>)
 805084a:	a909      	add	r1, sp, #36	; 0x24
 805084c:	4620      	mov	r0, r4
 805084e:	f7f4 fd5d 	bl	804530c <LL_USART_Init>
  CLEAR_BIT(USARTx->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 8050852:	6923      	ldr	r3, [r4, #16]
 8050854:	f423 4390 	bic.w	r3, r3, #18432	; 0x4800
 8050858:	6123      	str	r3, [r4, #16]
  CLEAR_BIT(USARTx->CR3, (USART_CR3_SCEN | USART_CR3_IREN | USART_CR3_HDSEL));
 805085a:	6963      	ldr	r3, [r4, #20]
 805085c:	f023 032a 	bic.w	r3, r3, #42	; 0x2a
 8050860:	6163      	str	r3, [r4, #20]
  SET_BIT(USARTx->CR1, USART_CR1_UE);
 8050862:	68e3      	ldr	r3, [r4, #12]
 8050864:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8050868:	60e3      	str	r3, [r4, #12]
  LL_USART_ConfigAsyncMode(UART4);
  LL_USART_Enable(UART4);

}
 805086a:	b010      	add	sp, #64	; 0x40
 805086c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8050870:	2200      	movs	r2, #0
 8050872:	e7cf      	b.n	8050814 <MX_UART4_Init+0xa4>
 8050874:	40023800 	.word	0x40023800
 8050878:	40020000 	.word	0x40020000
 805087c:	40020800 	.word	0x40020800
 8050880:	e000ed00 	.word	0xe000ed00
 8050884:	e000e100 	.word	0xe000e100
 8050888:	40004c00 	.word	0x40004c00

0805088c <MX_USART3_UART_Init>:
/* USART3 init function */

void MX_USART3_UART_Init(void)
{
 805088c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8050890:	b090      	sub	sp, #64	; 0x40
  LL_USART_InitTypeDef USART_InitStruct = {0};
 8050892:	2400      	movs	r4, #0
 8050894:	9409      	str	r4, [sp, #36]	; 0x24
 8050896:	940a      	str	r4, [sp, #40]	; 0x28
 8050898:	940b      	str	r4, [sp, #44]	; 0x2c
 805089a:	940c      	str	r4, [sp, #48]	; 0x30
 805089c:	940d      	str	r4, [sp, #52]	; 0x34
 805089e:	940e      	str	r4, [sp, #56]	; 0x38
 80508a0:	940f      	str	r4, [sp, #60]	; 0x3c
  SET_BIT(RCC->APB1ENR, Periphs);
 80508a2:	4b3b      	ldr	r3, [pc, #236]	; (8050990 <MX_USART3_UART_Init+0x104>)
 80508a4:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 80508a6:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
 80508aa:	641a      	str	r2, [r3, #64]	; 0x40
  tmpreg = READ_BIT(RCC->APB1ENR, Periphs);
 80508ac:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 80508ae:	f402 2280 	and.w	r2, r2, #262144	; 0x40000
 80508b2:	9202      	str	r2, [sp, #8]
  (void)tmpreg;
 80508b4:	9a02      	ldr	r2, [sp, #8]
  SET_BIT(RCC->AHB1ENR, Periphs);
 80508b6:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80508b8:	f042 0202 	orr.w	r2, r2, #2
 80508bc:	631a      	str	r2, [r3, #48]	; 0x30
  tmpreg = READ_BIT(RCC->AHB1ENR, Periphs);
 80508be:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80508c0:	f002 0202 	and.w	r2, r2, #2
 80508c4:	9201      	str	r2, [sp, #4]
  (void)tmpreg;
 80508c6:	9a01      	ldr	r2, [sp, #4]
  SET_BIT(RCC->AHB1ENR, Periphs);
 80508c8:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80508ca:	f042 0208 	orr.w	r2, r2, #8
 80508ce:	631a      	str	r2, [r3, #48]	; 0x30
  tmpreg = READ_BIT(RCC->AHB1ENR, Periphs);
 80508d0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80508d2:	f003 0308 	and.w	r3, r3, #8
 80508d6:	9300      	str	r3, [sp, #0]
  (void)tmpreg;
 80508d8:	9b00      	ldr	r3, [sp, #0]
  LL_AHB1_GRP1_EnableClock(LL_AHB1_GRP1_PERIPH_GPIOD);
  /**USART3 GPIO Configuration
  PB10   ------> USART3_TX
  PD9   ------> USART3_RX
  */
  GPIO_InitStruct.Pin = LL_GPIO_PIN_10;
 80508da:	f44f 6380 	mov.w	r3, #1024	; 0x400
 80508de:	9303      	str	r3, [sp, #12]
  GPIO_InitStruct.Mode = LL_GPIO_MODE_ALTERNATE;
 80508e0:	f04f 0802 	mov.w	r8, #2
 80508e4:	f8cd 8010 	str.w	r8, [sp, #16]
  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_VERY_HIGH;
 80508e8:	2703      	movs	r7, #3
 80508ea:	9705      	str	r7, [sp, #20]
  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
 80508ec:	9406      	str	r4, [sp, #24]
  GPIO_InitStruct.Pull = LL_GPIO_PULL_UP;
 80508ee:	2601      	movs	r6, #1
 80508f0:	9607      	str	r6, [sp, #28]
  GPIO_InitStruct.Alternate = LL_GPIO_AF_7;
 80508f2:	2507      	movs	r5, #7
 80508f4:	9508      	str	r5, [sp, #32]
  LL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 80508f6:	a903      	add	r1, sp, #12
 80508f8:	4826      	ldr	r0, [pc, #152]	; (8050994 <MX_USART3_UART_Init+0x108>)
 80508fa:	f7f4 fbfc 	bl	80450f6 <LL_GPIO_Init>

  GPIO_InitStruct.Pin = LL_GPIO_PIN_9;
 80508fe:	f44f 7300 	mov.w	r3, #512	; 0x200
 8050902:	9303      	str	r3, [sp, #12]
  GPIO_InitStruct.Mode = LL_GPIO_MODE_ALTERNATE;
 8050904:	f8cd 8010 	str.w	r8, [sp, #16]
  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_VERY_HIGH;
 8050908:	9705      	str	r7, [sp, #20]
  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
 805090a:	9406      	str	r4, [sp, #24]
  GPIO_InitStruct.Pull = LL_GPIO_PULL_UP;
 805090c:	9607      	str	r6, [sp, #28]
  GPIO_InitStruct.Alternate = LL_GPIO_AF_7;
 805090e:	9508      	str	r5, [sp, #32]
  LL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 8050910:	a903      	add	r1, sp, #12
 8050912:	4821      	ldr	r0, [pc, #132]	; (8050998 <MX_USART3_UART_Init+0x10c>)
 8050914:	f7f4 fbef 	bl	80450f6 <LL_GPIO_Init>
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8050918:	4b20      	ldr	r3, [pc, #128]	; (805099c <MX_USART3_UART_Init+0x110>)
 805091a:	68da      	ldr	r2, [r3, #12]
 805091c:	f3c2 2202 	ubfx	r2, r2, #8, #3
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8050920:	1aab      	subs	r3, r5, r2
 8050922:	2b04      	cmp	r3, #4
 8050924:	bf28      	it	cs
 8050926:	2304      	movcs	r3, #4
 8050928:	4619      	mov	r1, r3
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 805092a:	1d13      	adds	r3, r2, #4
 805092c:	2b06      	cmp	r3, #6
 805092e:	d92d      	bls.n	805098c <MX_USART3_UART_Init+0x100>
 8050930:	3a03      	subs	r2, #3
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8050932:	f04f 33ff 	mov.w	r3, #4294967295
 8050936:	408b      	lsls	r3, r1
 8050938:	43db      	mvns	r3, r3
 805093a:	f003 0304 	and.w	r3, r3, #4
 805093e:	4093      	lsls	r3, r2
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8050940:	011b      	lsls	r3, r3, #4
 8050942:	b2db      	uxtb	r3, r3
 8050944:	4a16      	ldr	r2, [pc, #88]	; (80509a0 <MX_USART3_UART_Init+0x114>)
 8050946:	f882 3327 	strb.w	r3, [r2, #807]	; 0x327
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 805094a:	2380      	movs	r3, #128	; 0x80
 805094c:	6053      	str	r3, [r2, #4]

  /* USART3 interrupt Init */
  NVIC_SetPriority(USART3_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),4, 0));
  NVIC_EnableIRQ(USART3_IRQn);

  USART_InitStruct.BaudRate = 9600;
 805094e:	f44f 5316 	mov.w	r3, #9600	; 0x2580
 8050952:	9309      	str	r3, [sp, #36]	; 0x24
  USART_InitStruct.DataWidth = LL_USART_DATAWIDTH_8B;
 8050954:	2300      	movs	r3, #0
 8050956:	930a      	str	r3, [sp, #40]	; 0x28
  USART_InitStruct.StopBits = LL_USART_STOPBITS_1;
 8050958:	930b      	str	r3, [sp, #44]	; 0x2c
  USART_InitStruct.Parity = LL_USART_PARITY_NONE;
 805095a:	930c      	str	r3, [sp, #48]	; 0x30
  USART_InitStruct.TransferDirection = LL_USART_DIRECTION_TX_RX;
 805095c:	220c      	movs	r2, #12
 805095e:	920d      	str	r2, [sp, #52]	; 0x34
  USART_InitStruct.HardwareFlowControl = LL_USART_HWCONTROL_NONE;
 8050960:	930e      	str	r3, [sp, #56]	; 0x38
  USART_InitStruct.OverSampling = LL_USART_OVERSAMPLING_16;
 8050962:	930f      	str	r3, [sp, #60]	; 0x3c
  LL_USART_Init(USART3, &USART_InitStruct);
 8050964:	4c0f      	ldr	r4, [pc, #60]	; (80509a4 <MX_USART3_UART_Init+0x118>)
 8050966:	a909      	add	r1, sp, #36	; 0x24
 8050968:	4620      	mov	r0, r4
 805096a:	f7f4 fccf 	bl	804530c <LL_USART_Init>
  CLEAR_BIT(USARTx->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 805096e:	6923      	ldr	r3, [r4, #16]
 8050970:	f423 4390 	bic.w	r3, r3, #18432	; 0x4800
 8050974:	6123      	str	r3, [r4, #16]
  CLEAR_BIT(USARTx->CR3, (USART_CR3_SCEN | USART_CR3_IREN | USART_CR3_HDSEL));
 8050976:	6963      	ldr	r3, [r4, #20]
 8050978:	f023 032a 	bic.w	r3, r3, #42	; 0x2a
 805097c:	6163      	str	r3, [r4, #20]
  SET_BIT(USARTx->CR1, USART_CR1_UE);
 805097e:	68e3      	ldr	r3, [r4, #12]
 8050980:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8050984:	60e3      	str	r3, [r4, #12]
  LL_USART_ConfigAsyncMode(USART3);
  LL_USART_Enable(USART3);

}
 8050986:	b010      	add	sp, #64	; 0x40
 8050988:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 805098c:	2200      	movs	r2, #0
 805098e:	e7d0      	b.n	8050932 <MX_USART3_UART_Init+0xa6>
 8050990:	40023800 	.word	0x40023800
 8050994:	40020400 	.word	0x40020400
 8050998:	40020c00 	.word	0x40020c00
 805099c:	e000ed00 	.word	0xe000ed00
 80509a0:	e000e100 	.word	0xe000e100
 80509a4:	40004800 	.word	0x40004800

080509a8 <calculateInputVoltage>:
* </table><br><br>
* <hr>
*
*******************************************************************************/
void calculateInputVoltage(void)
{
 80509a8:	b510      	push	{r4, lr}
 80509aa:	ed2d 8b02 	vpush	{d8}
	/* Calculate Input Votage from adc data */
	gfInputSupplyVoltage = (float) ((MAX_INPUT_VTG * gau32BatteryProcessedData[ADC_VIN + 1])/ADC_RESOLUTION);
 80509ae:	4c2a      	ldr	r4, [pc, #168]	; (8050a58 <calculateInputVoltage+0xb0>)
 80509b0:	6863      	ldr	r3, [r4, #4]
 80509b2:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 80509b6:	00db      	lsls	r3, r3, #3
 80509b8:	4a28      	ldr	r2, [pc, #160]	; (8050a5c <calculateInputVoltage+0xb4>)
 80509ba:	fba2 2303 	umull	r2, r3, r2, r3
 80509be:	0adb      	lsrs	r3, r3, #11
 80509c0:	ee07 3a90 	vmov	s15, r3
 80509c4:	eeb8 8a67 	vcvt.f32.u32	s16, s15
	gfBatteryVoltage = ((((3.3 * ( 2 * gau32BatteryProcessedData[ADC_VIN])) / 4095) * 2 ) / 0.6 ) - 0.2;
 80509c8:	6820      	ldr	r0, [r4, #0]
 80509ca:	0040      	lsls	r0, r0, #1
 80509cc:	f7ef fdba 	bl	8040544 <__aeabi_ui2d>
 80509d0:	a319      	add	r3, pc, #100	; (adr r3, 8050a38 <calculateInputVoltage+0x90>)
 80509d2:	e9d3 2300 	ldrd	r2, r3, [r3]
 80509d6:	f7ef fe2f 	bl	8040638 <__aeabi_dmul>
 80509da:	a319      	add	r3, pc, #100	; (adr r3, 8050a40 <calculateInputVoltage+0x98>)
 80509dc:	e9d3 2300 	ldrd	r2, r3, [r3]
 80509e0:	f7ef ff54 	bl	804088c <__aeabi_ddiv>
 80509e4:	4602      	mov	r2, r0
 80509e6:	460b      	mov	r3, r1
 80509e8:	f7ef fc70 	bl	80402cc <__adddf3>
 80509ec:	a316      	add	r3, pc, #88	; (adr r3, 8050a48 <calculateInputVoltage+0xa0>)
 80509ee:	e9d3 2300 	ldrd	r2, r3, [r3]
 80509f2:	f7ef ff4b 	bl	804088c <__aeabi_ddiv>
 80509f6:	a316      	add	r3, pc, #88	; (adr r3, 8050a50 <calculateInputVoltage+0xa8>)
 80509f8:	e9d3 2300 	ldrd	r2, r3, [r3]
 80509fc:	f7ef fc64 	bl	80402c8 <__aeabi_dsub>
 8050a00:	f7f0 f912 	bl	8040c28 <__aeabi_d2f>
 8050a04:	60a0      	str	r0, [r4, #8]
	/* Add diode drop for actual voltage */
	gfInputSupplyVoltage += INPUT_DIODE_DROP;
 8050a06:	eddf 7a16 	vldr	s15, [pc, #88]	; 8050a60 <calculateInputVoltage+0xb8>
 8050a0a:	ee78 7a27 	vadd.f32	s15, s16, s15
 8050a0e:	edc4 7a03 	vstr	s15, [r4, #12]
	/* Check if system is powered from 8.4 V dc battery pack */
	if(gfInputSupplyVoltage <= VIN_BATTERY_VTG)
 8050a12:	eeb2 7a08 	vmov.f32	s14, #40	; 0x41400000  12.0
 8050a16:	eef4 7ac7 	vcmpe.f32	s15, s14
 8050a1a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8050a1e:	d804      	bhi.n	8050a2a <calculateInputVoltage+0x82>
	{
		gu32InputSupplySwitchedAlert = TRUE;
 8050a20:	2201      	movs	r2, #1
 8050a22:	6122      	str	r2, [r4, #16]
	}
	else
	{
		gu32InputSupplySwitchedAlert = FALSE;
	}
}
 8050a24:	ecbd 8b02 	vpop	{d8}
 8050a28:	bd10      	pop	{r4, pc}
		gu32InputSupplySwitchedAlert = FALSE;
 8050a2a:	4b0b      	ldr	r3, [pc, #44]	; (8050a58 <calculateInputVoltage+0xb0>)
 8050a2c:	2200      	movs	r2, #0
 8050a2e:	611a      	str	r2, [r3, #16]
}
 8050a30:	e7f8      	b.n	8050a24 <calculateInputVoltage+0x7c>
 8050a32:	bf00      	nop
 8050a34:	f3af 8000 	nop.w
 8050a38:	66666666 	.word	0x66666666
 8050a3c:	400a6666 	.word	0x400a6666
 8050a40:	00000000 	.word	0x00000000
 8050a44:	40affe00 	.word	0x40affe00
 8050a48:	33333333 	.word	0x33333333
 8050a4c:	3fe33333 	.word	0x3fe33333
 8050a50:	9999999a 	.word	0x9999999a
 8050a54:	3fc99999 	.word	0x3fc99999
 8050a58:	20004f94 	.word	0x20004f94
 8050a5c:	affea003 	.word	0xaffea003
 8050a60:	3fb33333 	.word	0x3fb33333

08050a64 <operateadc>:
{
 8050a64:	b508      	push	{r3, lr}
	if(gu32ADCPollTimer)
 8050a66:	4b32      	ldr	r3, [pc, #200]	; (8050b30 <operateadc+0xcc>)
 8050a68:	681b      	ldr	r3, [r3, #0]
 8050a6a:	2b00      	cmp	r3, #0
 8050a6c:	d14c      	bne.n	8050b08 <operateadc+0xa4>
	switch(enmAdcSMCurrentState)
 8050a6e:	4b31      	ldr	r3, [pc, #196]	; (8050b34 <operateadc+0xd0>)
 8050a70:	7d1b      	ldrb	r3, [r3, #20]
 8050a72:	2b03      	cmp	r3, #3
 8050a74:	d853      	bhi.n	8050b1e <operateadc+0xba>
 8050a76:	e8df f003 	tbb	[pc, r3]
 8050a7a:	1702      	.short	0x1702
 8050a7c:	4048      	.short	0x4048
			if((HAL_ADC_Start_DMA(&hadc1, (uint32_t*)gau32BatteryPeripheralData, 2) != HAL_OK))
 8050a7e:	2202      	movs	r2, #2
 8050a80:	492d      	ldr	r1, [pc, #180]	; (8050b38 <operateadc+0xd4>)
 8050a82:	482e      	ldr	r0, [pc, #184]	; (8050b3c <operateadc+0xd8>)
 8050a84:	f7f0 fc9c 	bl	80413c0 <HAL_ADC_Start_DMA>
 8050a88:	b118      	cbz	r0, 8050a92 <operateadc+0x2e>
				enmAdcSMCurrentState = enmADC_ERROR;
 8050a8a:	4b2a      	ldr	r3, [pc, #168]	; (8050b34 <operateadc+0xd0>)
 8050a8c:	2203      	movs	r2, #3
 8050a8e:	751a      	strb	r2, [r3, #20]
 8050a90:	e03a      	b.n	8050b08 <operateadc+0xa4>
				HAL_ADC_Start_IT(&hadc1);
 8050a92:	482a      	ldr	r0, [pc, #168]	; (8050b3c <operateadc+0xd8>)
 8050a94:	f7f0 fbf4 	bl	8041280 <HAL_ADC_Start_IT>
				enmAdcSMCurrentState = enmADC_GETDATA;
 8050a98:	4b26      	ldr	r3, [pc, #152]	; (8050b34 <operateadc+0xd0>)
 8050a9a:	2201      	movs	r2, #1
 8050a9c:	751a      	strb	r2, [r3, #20]
				gu32ADCOperationTimer = ONE_MIN;
 8050a9e:	4b28      	ldr	r3, [pc, #160]	; (8050b40 <operateadc+0xdc>)
 8050aa0:	f64e 2260 	movw	r2, #60000	; 0xea60
 8050aa4:	601a      	str	r2, [r3, #0]
 8050aa6:	e02f      	b.n	8050b08 <operateadc+0xa4>
			if((g32AdcConversionStatusBatt == TRUE) && (gu32ADCOperationTimer != 0))
 8050aa8:	4b22      	ldr	r3, [pc, #136]	; (8050b34 <operateadc+0xd0>)
 8050aaa:	6a1b      	ldr	r3, [r3, #32]
 8050aac:	2b01      	cmp	r3, #1
 8050aae:	d013      	beq.n	8050ad8 <operateadc+0x74>
			else if((!g32AdcConversionStatus) | (!g32AdcConversionStatusBatt) | (gu32ADCOperationTimer == 0))
 8050ab0:	4a20      	ldr	r2, [pc, #128]	; (8050b34 <operateadc+0xd0>)
 8050ab2:	6a51      	ldr	r1, [r2, #36]	; 0x24
 8050ab4:	6a13      	ldr	r3, [r2, #32]
 8050ab6:	fab3 f383 	clz	r3, r3
 8050aba:	095b      	lsrs	r3, r3, #5
 8050abc:	2900      	cmp	r1, #0
 8050abe:	bf08      	it	eq
 8050ac0:	2301      	moveq	r3, #1
 8050ac2:	4a1f      	ldr	r2, [pc, #124]	; (8050b40 <operateadc+0xdc>)
 8050ac4:	6812      	ldr	r2, [r2, #0]
 8050ac6:	fab2 f282 	clz	r2, r2
 8050aca:	0952      	lsrs	r2, r2, #5
 8050acc:	b903      	cbnz	r3, 8050ad0 <operateadc+0x6c>
 8050ace:	b1da      	cbz	r2, 8050b08 <operateadc+0xa4>
				enmAdcSMCurrentState = enmADC_IDLE;
 8050ad0:	4b18      	ldr	r3, [pc, #96]	; (8050b34 <operateadc+0xd0>)
 8050ad2:	2200      	movs	r2, #0
 8050ad4:	751a      	strb	r2, [r3, #20]
 8050ad6:	e017      	b.n	8050b08 <operateadc+0xa4>
			if((g32AdcConversionStatusBatt == TRUE) && (gu32ADCOperationTimer != 0))
 8050ad8:	4b19      	ldr	r3, [pc, #100]	; (8050b40 <operateadc+0xdc>)
 8050ada:	681b      	ldr	r3, [r3, #0]
 8050adc:	2b00      	cmp	r3, #0
 8050ade:	d0e7      	beq.n	8050ab0 <operateadc+0x4c>
				gu32ADCOperationTimer = 0;
 8050ae0:	2200      	movs	r2, #0
 8050ae2:	4b17      	ldr	r3, [pc, #92]	; (8050b40 <operateadc+0xdc>)
 8050ae4:	601a      	str	r2, [r3, #0]
				gau32BatteryProcessedData[ADC_VIN + 1] = gau32BatteryPeripheralData[ADC_VIN +1];
 8050ae6:	4b13      	ldr	r3, [pc, #76]	; (8050b34 <operateadc+0xd0>)
 8050ae8:	69d9      	ldr	r1, [r3, #28]
 8050aea:	6059      	str	r1, [r3, #4]
				gau32BatteryProcessedData[ADC_VIN] = gau32BatteryPeripheralData[ADC_VIN];
 8050aec:	6999      	ldr	r1, [r3, #24]
 8050aee:	6019      	str	r1, [r3, #0]
				enmAdcSMCurrentState = enmADC_PROCESSDATA;
 8050af0:	2102      	movs	r1, #2
 8050af2:	7519      	strb	r1, [r3, #20]
				g32AdcConversionStatusBatt = FALSE;
 8050af4:	621a      	str	r2, [r3, #32]
				g32AdcConversionStatus = FALSE;
 8050af6:	625a      	str	r2, [r3, #36]	; 0x24
 8050af8:	e006      	b.n	8050b08 <operateadc+0xa4>
			gu32ADCPollTimer = TEN_SEC;
 8050afa:	4b0d      	ldr	r3, [pc, #52]	; (8050b30 <operateadc+0xcc>)
 8050afc:	f242 7210 	movw	r2, #10000	; 0x2710
 8050b00:	601a      	str	r2, [r3, #0]
			enmAdcSMCurrentState = enmADC_IDLE;
 8050b02:	4b0c      	ldr	r3, [pc, #48]	; (8050b34 <operateadc+0xd0>)
 8050b04:	2200      	movs	r2, #0
 8050b06:	751a      	strb	r2, [r3, #20]
}
 8050b08:	bd08      	pop	{r3, pc}
			calculateInputVoltage();
 8050b0a:	f7ff ff4d 	bl	80509a8 <calculateInputVoltage>
			gu32ADCPollTimer = TEN_SEC;
 8050b0e:	4b08      	ldr	r3, [pc, #32]	; (8050b30 <operateadc+0xcc>)
 8050b10:	f242 7210 	movw	r2, #10000	; 0x2710
 8050b14:	601a      	str	r2, [r3, #0]
			enmAdcSMCurrentState = enmADC_IDLE;
 8050b16:	4b07      	ldr	r3, [pc, #28]	; (8050b34 <operateadc+0xd0>)
 8050b18:	2200      	movs	r2, #0
 8050b1a:	751a      	strb	r2, [r3, #20]
			break;
 8050b1c:	e7f4      	b.n	8050b08 <operateadc+0xa4>
			gu32ADCPollTimer = TEN_SEC;
 8050b1e:	4b04      	ldr	r3, [pc, #16]	; (8050b30 <operateadc+0xcc>)
 8050b20:	f242 7210 	movw	r2, #10000	; 0x2710
 8050b24:	601a      	str	r2, [r3, #0]
			enmAdcSMCurrentState = enmADC_IDLE;
 8050b26:	4b03      	ldr	r3, [pc, #12]	; (8050b34 <operateadc+0xd0>)
 8050b28:	2200      	movs	r2, #0
 8050b2a:	751a      	strb	r2, [r3, #20]
			break;
 8050b2c:	e7ec      	b.n	8050b08 <operateadc+0xa4>
 8050b2e:	bf00      	nop
 8050b30:	2000517c 	.word	0x2000517c
 8050b34:	20004f94 	.word	0x20004f94
 8050b38:	20004fac 	.word	0x20004fac
 8050b3c:	2000873c 	.word	0x2000873c
 8050b40:	20005178 	.word	0x20005178

08050b44 <HAL_ADC_ConvCpltCallback>:
 *
 * */
void HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef* hadc)
{
	/*Sequence conversion complete . Read Processed Value */
	if(hadc->Instance == ADC1)
 8050b44:	6803      	ldr	r3, [r0, #0]
 8050b46:	4a0b      	ldr	r2, [pc, #44]	; (8050b74 <HAL_ADC_ConvCpltCallback+0x30>)
 8050b48:	4293      	cmp	r3, r2
 8050b4a:	d003      	beq.n	8050b54 <HAL_ADC_ConvCpltCallback+0x10>
	{
		if(g32AdcConversionStatusBatt == FALSE)
			g32AdcConversionStatusBatt = TRUE;

	}
	else if(hadc->Instance == ADC3)
 8050b4c:	4a0a      	ldr	r2, [pc, #40]	; (8050b78 <HAL_ADC_ConvCpltCallback+0x34>)
 8050b4e:	4293      	cmp	r3, r2
 8050b50:	d008      	beq.n	8050b64 <HAL_ADC_ConvCpltCallback+0x20>
	}
	else
	{
		/* Unknown Interrupt */
	}
}
 8050b52:	4770      	bx	lr
		if(g32AdcConversionStatusBatt == FALSE)
 8050b54:	4b09      	ldr	r3, [pc, #36]	; (8050b7c <HAL_ADC_ConvCpltCallback+0x38>)
 8050b56:	6a1b      	ldr	r3, [r3, #32]
 8050b58:	2b00      	cmp	r3, #0
 8050b5a:	d1fa      	bne.n	8050b52 <HAL_ADC_ConvCpltCallback+0xe>
			g32AdcConversionStatusBatt = TRUE;
 8050b5c:	4b07      	ldr	r3, [pc, #28]	; (8050b7c <HAL_ADC_ConvCpltCallback+0x38>)
 8050b5e:	2201      	movs	r2, #1
 8050b60:	621a      	str	r2, [r3, #32]
 8050b62:	4770      	bx	lr
		if(g32AdcConversionStatus == FALSE)
 8050b64:	4b05      	ldr	r3, [pc, #20]	; (8050b7c <HAL_ADC_ConvCpltCallback+0x38>)
 8050b66:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8050b68:	2b00      	cmp	r3, #0
 8050b6a:	d1f2      	bne.n	8050b52 <HAL_ADC_ConvCpltCallback+0xe>
			g32AdcConversionStatus = TRUE;
 8050b6c:	4b03      	ldr	r3, [pc, #12]	; (8050b7c <HAL_ADC_ConvCpltCallback+0x38>)
 8050b6e:	2201      	movs	r2, #1
 8050b70:	625a      	str	r2, [r3, #36]	; 0x24
}
 8050b72:	e7ee      	b.n	8050b52 <HAL_ADC_ConvCpltCallback+0xe>
 8050b74:	40012000 	.word	0x40012000
 8050b78:	40012200 	.word	0x40012200
 8050b7c:	20004f94 	.word	0x20004f94

08050b80 <HAL_I2C_ErrorCallback>:
* </table><br><br>
* <hr>
*
*******************************************************************************/
void HAL_I2C_ErrorCallback(I2C_HandleTypeDef *hi2c)
{
 8050b80:	b508      	push	{r3, lr}
	assertError(enmTORERRORS_MEM_I2C,enmERRORSTATE_ACTIVE);
 8050b82:	2101      	movs	r1, #1
 8050b84:	200e      	movs	r0, #14
 8050b86:	f7fa feb7 	bl	804b8f8 <assertError>
}
 8050b8a:	bd08      	pop	{r3, pc}

08050b8c <initMemoryRead>:
* <hr>
*
*******************************************************************************/
void initMemoryRead(void)
{
	gau8MemoryOperationRead[0] = FALSE;
 8050b8c:	4b0b      	ldr	r3, [pc, #44]	; (8050bbc <initMemoryRead+0x30>)
 8050b8e:	2100      	movs	r1, #0
 8050b90:	7119      	strb	r1, [r3, #4]
	gau8MemoryOperationRead[1] = TRUE;
 8050b92:	2201      	movs	r2, #1
 8050b94:	715a      	strb	r2, [r3, #5]
	gau8MemoryOperationRead[2] = TRUE;
 8050b96:	719a      	strb	r2, [r3, #6]
	gau8MemoryOperationRead[3] = TRUE;
 8050b98:	71da      	strb	r2, [r3, #7]
	gau8MemoryOperationRead[4] = TRUE;
 8050b9a:	721a      	strb	r2, [r3, #8]
	gau8MemoryOperationRead[5] = TRUE;
 8050b9c:	725a      	strb	r2, [r3, #9]
	gau8MemoryOperationRead[6] = TRUE;
 8050b9e:	729a      	strb	r2, [r3, #10]
	gau8MemoryOperationRead[7] = TRUE;
 8050ba0:	72da      	strb	r2, [r3, #11]
	gau8MemoryOperationRead[8] = TRUE;
 8050ba2:	731a      	strb	r2, [r3, #12]
	gau8MemoryOperationRead[9] = TRUE;
 8050ba4:	735a      	strb	r2, [r3, #13]
	gau8MemoryOperationRead[10] = TRUE;
 8050ba6:	739a      	strb	r2, [r3, #14]
	gau8MemoryOperationRead[11] = TRUE;
 8050ba8:	73da      	strb	r2, [r3, #15]
	gau8MemoryOperationRead[12] = TRUE;
 8050baa:	741a      	strb	r2, [r3, #16]
	gau8MemoryOperationRead[13] = TRUE;
 8050bac:	745a      	strb	r2, [r3, #17]
	gau8MemoryOperationRead[14] = TRUE;
 8050bae:	749a      	strb	r2, [r3, #18]
	gau8MemoryOperationRead[15] = TRUE;
 8050bb0:	74da      	strb	r2, [r3, #19]
	gau8MemoryOperationRead[16] = TRUE;
 8050bb2:	751a      	strb	r2, [r3, #20]
	gau8MemoryOperationRead[17] = TRUE;
 8050bb4:	755a      	strb	r2, [r3, #21]
	gu32MemoryOperation = EEPROM_OPR_READ;
 8050bb6:	4b02      	ldr	r3, [pc, #8]	; (8050bc0 <initMemoryRead+0x34>)
 8050bb8:	7019      	strb	r1, [r3, #0]
}
 8050bba:	4770      	bx	lr
 8050bbc:	20004fd4 	.word	0x20004fd4
 8050bc0:	2000367c 	.word	0x2000367c

08050bc4 <initSystemDefaultsfromMemory>:
* </table><br><br>
* <hr>
*
*******************************************************************************/
void initSystemDefaultsfromMemory(void)
{
 8050bc4:	b538      	push	{r3, r4, r5, lr}
	/* */
	if(strlen(strI2cEeprom.pu8NetworkAPN) != 0)
 8050bc6:	4b26      	ldr	r3, [pc, #152]	; (8050c60 <initSystemDefaultsfromMemory+0x9c>)
 8050bc8:	f893 3c16 	ldrb.w	r3, [r3, #3094]	; 0xc16
 8050bcc:	b9b3      	cbnz	r3, 8050bfc <initSystemDefaultsfromMemory+0x38>
	{
		memset(gau8GSM4G_apn,0x00,sizeof(char) * 100);
		memcpy(gau8GSM4G_apn,strI2cEeprom.pu8NetworkAPN, strlen(strI2cEeprom.pu8NetworkAPN));
	}
	if(strlen(strI2cEeprom.pu8RdServerURL) != 0)
 8050bce:	4b24      	ldr	r3, [pc, #144]	; (8050c60 <initSystemDefaultsfromMemory+0x9c>)
 8050bd0:	f893 3c2a 	ldrb.w	r3, [r3, #3114]	; 0xc2a
 8050bd4:	bb13      	cbnz	r3, 8050c1c <initSystemDefaultsfromMemory+0x58>
	{
		memset(gau8GSM_url,0x00,sizeof(char) * 100);
		memcpy( gau8GSM_url, strI2cEeprom.pu8RdServerURL, strlen(strI2cEeprom.pu8RdServerURL));
	}
	if(strlen(strI2cEeprom.pu8MobileNumber) != 0)
 8050bd6:	4b22      	ldr	r3, [pc, #136]	; (8050c60 <initSystemDefaultsfromMemory+0x9c>)
 8050bd8:	f893 3c07 	ldrb.w	r3, [r3, #3079]	; 0xc07
 8050bdc:	bb73      	cbnz	r3, 8050c3c <initSystemDefaultsfromMemory+0x78>
	{
		memset(gau8GSM_smsto,0x00,sizeof(char) * 15);
		memcpy(gau8GSM_smsto, strI2cEeprom.pu8MobileNumber,strlen(strI2cEeprom.pu8MobileNumber));
	}
	gsmInstance.u32OFFPayloadUploadFreq = atoi(strI2cEeprom.pu8RdUploadOffFreq);
 8050bde:	4d21      	ldr	r5, [pc, #132]	; (8050c64 <initSystemDefaultsfromMemory+0xa0>)
 8050be0:	4628      	mov	r0, r5
 8050be2:	f000 fc6d 	bl	80514c0 <atoi>
 8050be6:	4c20      	ldr	r4, [pc, #128]	; (8050c68 <initSystemDefaultsfromMemory+0xa4>)
 8050be8:	f8c4 0e28 	str.w	r0, [r4, #3624]	; 0xe28
	gsmInstance.u32ONPayloadUploadFreq = atoi(strI2cEeprom.pu8RdUploadOnFreq);
 8050bec:	1f68      	subs	r0, r5, #5
 8050bee:	f000 fc67 	bl	80514c0 <atoi>
 8050bf2:	f8c4 0e24 	str.w	r0, [r4, #3620]	; 0xe24
	initGSMSIM868();
 8050bf6:	f7fb f8e3 	bl	804bdc0 <initGSMSIM868>
}
 8050bfa:	bd38      	pop	{r3, r4, r5, pc}
		memset(gau8GSM4G_apn,0x00,sizeof(char) * 100);
 8050bfc:	4c1b      	ldr	r4, [pc, #108]	; (8050c6c <initSystemDefaultsfromMemory+0xa8>)
 8050bfe:	2264      	movs	r2, #100	; 0x64
 8050c00:	2100      	movs	r1, #0
 8050c02:	4620      	mov	r0, r4
 8050c04:	f000 ff0c 	bl	8051a20 <memset>
		memcpy(gau8GSM4G_apn,strI2cEeprom.pu8NetworkAPN, strlen(strI2cEeprom.pu8NetworkAPN));
 8050c08:	4d19      	ldr	r5, [pc, #100]	; (8050c70 <initSystemDefaultsfromMemory+0xac>)
 8050c0a:	4628      	mov	r0, r5
 8050c0c:	f7ef fafa 	bl	8040204 <strlen>
 8050c10:	4602      	mov	r2, r0
 8050c12:	4629      	mov	r1, r5
 8050c14:	4620      	mov	r0, r4
 8050c16:	f000 fef5 	bl	8051a04 <memcpy>
 8050c1a:	e7d8      	b.n	8050bce <initSystemDefaultsfromMemory+0xa>
		memset(gau8GSM_url,0x00,sizeof(char) * 100);
 8050c1c:	4c15      	ldr	r4, [pc, #84]	; (8050c74 <initSystemDefaultsfromMemory+0xb0>)
 8050c1e:	2264      	movs	r2, #100	; 0x64
 8050c20:	2100      	movs	r1, #0
 8050c22:	4620      	mov	r0, r4
 8050c24:	f000 fefc 	bl	8051a20 <memset>
		memcpy( gau8GSM_url, strI2cEeprom.pu8RdServerURL, strlen(strI2cEeprom.pu8RdServerURL));
 8050c28:	4d13      	ldr	r5, [pc, #76]	; (8050c78 <initSystemDefaultsfromMemory+0xb4>)
 8050c2a:	4628      	mov	r0, r5
 8050c2c:	f7ef faea 	bl	8040204 <strlen>
 8050c30:	4602      	mov	r2, r0
 8050c32:	4629      	mov	r1, r5
 8050c34:	4620      	mov	r0, r4
 8050c36:	f000 fee5 	bl	8051a04 <memcpy>
 8050c3a:	e7cc      	b.n	8050bd6 <initSystemDefaultsfromMemory+0x12>
		memset(gau8GSM_smsto,0x00,sizeof(char) * 15);
 8050c3c:	4c0f      	ldr	r4, [pc, #60]	; (8050c7c <initSystemDefaultsfromMemory+0xb8>)
 8050c3e:	2300      	movs	r3, #0
 8050c40:	6023      	str	r3, [r4, #0]
 8050c42:	6063      	str	r3, [r4, #4]
 8050c44:	60a3      	str	r3, [r4, #8]
 8050c46:	f8c4 300b 	str.w	r3, [r4, #11]
		memcpy(gau8GSM_smsto, strI2cEeprom.pu8MobileNumber,strlen(strI2cEeprom.pu8MobileNumber));
 8050c4a:	4d0d      	ldr	r5, [pc, #52]	; (8050c80 <initSystemDefaultsfromMemory+0xbc>)
 8050c4c:	4628      	mov	r0, r5
 8050c4e:	f7ef fad9 	bl	8040204 <strlen>
 8050c52:	4602      	mov	r2, r0
 8050c54:	4629      	mov	r1, r5
 8050c56:	4620      	mov	r0, r4
 8050c58:	f000 fed4 	bl	8051a04 <memcpy>
 8050c5c:	e7bf      	b.n	8050bde <initSystemDefaultsfromMemory+0x1a>
 8050c5e:	bf00      	nop
 8050c60:	2000f3b4 	.word	0x2000f3b4
 8050c64:	20010079 	.word	0x20010079
 8050c68:	2000c398 	.word	0x2000c398
 8050c6c:	20000570 	.word	0x20000570
 8050c70:	2000ffca 	.word	0x2000ffca
 8050c74:	20000354 	.word	0x20000354
 8050c78:	2000ffde 	.word	0x2000ffde
 8050c7c:	20000248 	.word	0x20000248
 8050c80:	2000ffbb 	.word	0x2000ffbb

08050c84 <HAL_I2C_MemRxCpltCallback>:
{
 8050c84:	b508      	push	{r3, lr}
	if((gu8MemoryOperationStatus == 1) && (gu32I2CMemoryOperationTimeout !=0)
 8050c86:	4b20      	ldr	r3, [pc, #128]	; (8050d08 <HAL_I2C_MemRxCpltCallback+0x84>)
 8050c88:	f893 3023 	ldrb.w	r3, [r3, #35]	; 0x23
 8050c8c:	2b01      	cmp	r3, #1
 8050c8e:	d006      	beq.n	8050c9e <HAL_I2C_MemRxCpltCallback+0x1a>
		if(gu32EEPROMInitforSerialFlash == 0)
 8050c90:	4b1d      	ldr	r3, [pc, #116]	; (8050d08 <HAL_I2C_MemRxCpltCallback+0x84>)
 8050c92:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8050c94:	b913      	cbnz	r3, 8050c9c <HAL_I2C_MemRxCpltCallback+0x18>
			gu8SignatureReadFlag = TRUE;
 8050c96:	4b1c      	ldr	r3, [pc, #112]	; (8050d08 <HAL_I2C_MemRxCpltCallback+0x84>)
 8050c98:	2201      	movs	r2, #1
 8050c9a:	701a      	strb	r2, [r3, #0]
}
 8050c9c:	bd08      	pop	{r3, pc}
	if((gu8MemoryOperationStatus == 1) && (gu32I2CMemoryOperationTimeout !=0)
 8050c9e:	4b1b      	ldr	r3, [pc, #108]	; (8050d0c <HAL_I2C_MemRxCpltCallback+0x88>)
 8050ca0:	681b      	ldr	r3, [r3, #0]
 8050ca2:	2b00      	cmp	r3, #0
 8050ca4:	d0f4      	beq.n	8050c90 <HAL_I2C_MemRxCpltCallback+0xc>
			&& (gu8OperateSystemStatus != FALSE))
 8050ca6:	4b1a      	ldr	r3, [pc, #104]	; (8050d10 <HAL_I2C_MemRxCpltCallback+0x8c>)
 8050ca8:	789b      	ldrb	r3, [r3, #2]
 8050caa:	2b00      	cmp	r3, #0
 8050cac:	d0f0      	beq.n	8050c90 <HAL_I2C_MemRxCpltCallback+0xc>
		if(gau8MemoryOperationRead[u8RdMemLoopCounter] == TRUE)
 8050cae:	4b16      	ldr	r3, [pc, #88]	; (8050d08 <HAL_I2C_MemRxCpltCallback+0x84>)
 8050cb0:	f893 2024 	ldrb.w	r2, [r3, #36]	; 0x24
 8050cb4:	4413      	add	r3, r2
 8050cb6:	791b      	ldrb	r3, [r3, #4]
 8050cb8:	2b01      	cmp	r3, #1
 8050cba:	d006      	beq.n	8050cca <HAL_I2C_MemRxCpltCallback+0x46>
		gu8MemoryOperationStatus = 0;
 8050cbc:	2300      	movs	r3, #0
 8050cbe:	4a12      	ldr	r2, [pc, #72]	; (8050d08 <HAL_I2C_MemRxCpltCallback+0x84>)
 8050cc0:	f882 3023 	strb.w	r3, [r2, #35]	; 0x23
		gu32I2CMemoryOperationTimeout = 0;
 8050cc4:	4a11      	ldr	r2, [pc, #68]	; (8050d0c <HAL_I2C_MemRxCpltCallback+0x88>)
 8050cc6:	6013      	str	r3, [r2, #0]
 8050cc8:	e7e8      	b.n	8050c9c <HAL_I2C_MemRxCpltCallback+0x18>
			gau8MemoryOperationRead[u8RdMemLoopCounter] = FALSE;
 8050cca:	4b0f      	ldr	r3, [pc, #60]	; (8050d08 <HAL_I2C_MemRxCpltCallback+0x84>)
 8050ccc:	1899      	adds	r1, r3, r2
 8050cce:	2000      	movs	r0, #0
 8050cd0:	7108      	strb	r0, [r1, #4]
			u8RdMemLoopCounter ++;
 8050cd2:	3201      	adds	r2, #1
 8050cd4:	b2d2      	uxtb	r2, r2
 8050cd6:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
			if(u8RdMemLoopCounter >= I2CMEM_MAX_OPRATIONS)
 8050cda:	2a0e      	cmp	r2, #14
 8050cdc:	d9ee      	bls.n	8050cbc <HAL_I2C_MemRxCpltCallback+0x38>
				gu32MemoryOperation = EEPROM_OPR_IDLE;
 8050cde:	4a0c      	ldr	r2, [pc, #48]	; (8050d10 <HAL_I2C_MemRxCpltCallback+0x8c>)
 8050ce0:	2302      	movs	r3, #2
 8050ce2:	7013      	strb	r3, [r2, #0]
				u8RdMemLoopCounter = 0;
 8050ce4:	4b08      	ldr	r3, [pc, #32]	; (8050d08 <HAL_I2C_MemRxCpltCallback+0x84>)
 8050ce6:	f883 0024 	strb.w	r0, [r3, #36]	; 0x24
				gu8MemoryRdOperationFlag = TRUE;
 8050cea:	2101      	movs	r1, #1
 8050cec:	f883 1026 	strb.w	r1, [r3, #38]	; 0x26
				gu8MemoryCycleComplete = TRUE;
 8050cf0:	7051      	strb	r1, [r2, #1]
				if(gu8RestoreSystemSettings == TRUE)
 8050cf2:	f893 3025 	ldrb.w	r3, [r3, #37]	; 0x25
 8050cf6:	428b      	cmp	r3, r1
 8050cf8:	d1e0      	bne.n	8050cbc <HAL_I2C_MemRxCpltCallback+0x38>
					initSystemDefaultsfromMemory();
 8050cfa:	f7ff ff63 	bl	8050bc4 <initSystemDefaultsfromMemory>
					gu8RestoreSystemSettings = FALSE;
 8050cfe:	4b02      	ldr	r3, [pc, #8]	; (8050d08 <HAL_I2C_MemRxCpltCallback+0x84>)
 8050d00:	2200      	movs	r2, #0
 8050d02:	f883 2025 	strb.w	r2, [r3, #37]	; 0x25
 8050d06:	e7d9      	b.n	8050cbc <HAL_I2C_MemRxCpltCallback+0x38>
 8050d08:	20004fd4 	.word	0x20004fd4
 8050d0c:	20005174 	.word	0x20005174
 8050d10:	2000367c 	.word	0x2000367c

08050d14 <systemReset>:
}


void systemReset(void)
{
	while(1);
 8050d14:	e7fe      	b.n	8050d14 <systemReset>
	...

08050d18 <HAL_I2C_MemTxCpltCallback>:
{
 8050d18:	b508      	push	{r3, lr}
	if((gu8MemoryOperationStatus == 1) && (gu32I2CMemoryOperationTimeout !=0))
 8050d1a:	4b25      	ldr	r3, [pc, #148]	; (8050db0 <HAL_I2C_MemTxCpltCallback+0x98>)
 8050d1c:	f893 3023 	ldrb.w	r3, [r3, #35]	; 0x23
 8050d20:	2b01      	cmp	r3, #1
 8050d22:	d000      	beq.n	8050d26 <HAL_I2C_MemTxCpltCallback+0xe>
}
 8050d24:	bd08      	pop	{r3, pc}
	if((gu8MemoryOperationStatus == 1) && (gu32I2CMemoryOperationTimeout !=0))
 8050d26:	4b23      	ldr	r3, [pc, #140]	; (8050db4 <HAL_I2C_MemTxCpltCallback+0x9c>)
 8050d28:	681b      	ldr	r3, [r3, #0]
 8050d2a:	2b00      	cmp	r3, #0
 8050d2c:	d0fa      	beq.n	8050d24 <HAL_I2C_MemTxCpltCallback+0xc>
		if(gau8MemoryOperationWrite[u8WrMemLoopCounter] == TRUE)
 8050d2e:	4b20      	ldr	r3, [pc, #128]	; (8050db0 <HAL_I2C_MemTxCpltCallback+0x98>)
 8050d30:	f893 202c 	ldrb.w	r2, [r3, #44]	; 0x2c
 8050d34:	4413      	add	r3, r2
 8050d36:	7d1b      	ldrb	r3, [r3, #20]
 8050d38:	2b01      	cmp	r3, #1
 8050d3a:	d006      	beq.n	8050d4a <HAL_I2C_MemTxCpltCallback+0x32>
		gu8MemoryOperationStatus = 0;
 8050d3c:	2300      	movs	r3, #0
 8050d3e:	4a1c      	ldr	r2, [pc, #112]	; (8050db0 <HAL_I2C_MemTxCpltCallback+0x98>)
 8050d40:	f882 3023 	strb.w	r3, [r2, #35]	; 0x23
		gu32I2CMemoryOperationTimeout = 0;
 8050d44:	4a1b      	ldr	r2, [pc, #108]	; (8050db4 <HAL_I2C_MemTxCpltCallback+0x9c>)
 8050d46:	6013      	str	r3, [r2, #0]
}
 8050d48:	e7ec      	b.n	8050d24 <HAL_I2C_MemTxCpltCallback+0xc>
			if(gu8PageWriteCycle == TRUE)
 8050d4a:	4b19      	ldr	r3, [pc, #100]	; (8050db0 <HAL_I2C_MemTxCpltCallback+0x98>)
 8050d4c:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 8050d50:	2b01      	cmp	r3, #1
 8050d52:	d019      	beq.n	8050d88 <HAL_I2C_MemTxCpltCallback+0x70>
				gau8MemoryOperationWrite[u8WrMemLoopCounter] = FALSE;
 8050d54:	4b16      	ldr	r3, [pc, #88]	; (8050db0 <HAL_I2C_MemTxCpltCallback+0x98>)
 8050d56:	1899      	adds	r1, r3, r2
 8050d58:	2000      	movs	r0, #0
 8050d5a:	7508      	strb	r0, [r1, #20]
				u8WrMemLoopCounter ++;
 8050d5c:	3201      	adds	r2, #1
 8050d5e:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
			if(u8WrMemLoopCounter >= I2CMEM_MAX_OPRATIONS)
 8050d62:	4b13      	ldr	r3, [pc, #76]	; (8050db0 <HAL_I2C_MemTxCpltCallback+0x98>)
 8050d64:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 8050d68:	2b0e      	cmp	r3, #14
 8050d6a:	d9e7      	bls.n	8050d3c <HAL_I2C_MemTxCpltCallback+0x24>
				gu32MemoryOperation = EEPROM_OPR_READ;
 8050d6c:	4b12      	ldr	r3, [pc, #72]	; (8050db8 <HAL_I2C_MemTxCpltCallback+0xa0>)
 8050d6e:	2200      	movs	r2, #0
 8050d70:	701a      	strb	r2, [r3, #0]
				if(u32DefautParamWriteStatus == TRUE)
 8050d72:	4b0f      	ldr	r3, [pc, #60]	; (8050db0 <HAL_I2C_MemTxCpltCallback+0x98>)
 8050d74:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8050d76:	2b01      	cmp	r3, #1
 8050d78:	d018      	beq.n	8050dac <HAL_I2C_MemTxCpltCallback+0x94>
					initMemoryRead();
 8050d7a:	f7ff ff07 	bl	8050b8c <initMemoryRead>
				u8WrMemLoopCounter = 0;
 8050d7e:	4b0c      	ldr	r3, [pc, #48]	; (8050db0 <HAL_I2C_MemTxCpltCallback+0x98>)
 8050d80:	2200      	movs	r2, #0
 8050d82:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
 8050d86:	e7d9      	b.n	8050d3c <HAL_I2C_MemTxCpltCallback+0x24>
				if(gu8PageWriteCounter > cycleRequired)
 8050d88:	4909      	ldr	r1, [pc, #36]	; (8050db0 <HAL_I2C_MemTxCpltCallback+0x98>)
 8050d8a:	6b0b      	ldr	r3, [r1, #48]	; 0x30
 8050d8c:	6c89      	ldr	r1, [r1, #72]	; 0x48
 8050d8e:	428b      	cmp	r3, r1
 8050d90:	d908      	bls.n	8050da4 <HAL_I2C_MemTxCpltCallback+0x8c>
					gau8MemoryOperationWrite[u8WrMemLoopCounter] = FALSE;
 8050d92:	4b07      	ldr	r3, [pc, #28]	; (8050db0 <HAL_I2C_MemTxCpltCallback+0x98>)
 8050d94:	1898      	adds	r0, r3, r2
 8050d96:	2100      	movs	r1, #0
 8050d98:	7501      	strb	r1, [r0, #20]
					u8WrMemLoopCounter ++;
 8050d9a:	3201      	adds	r2, #1
 8050d9c:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
					gu8PageWriteCounter  = 0;
 8050da0:	6319      	str	r1, [r3, #48]	; 0x30
 8050da2:	e7de      	b.n	8050d62 <HAL_I2C_MemTxCpltCallback+0x4a>
					gu8PageWriteCounter ++;
 8050da4:	3301      	adds	r3, #1
 8050da6:	4a02      	ldr	r2, [pc, #8]	; (8050db0 <HAL_I2C_MemTxCpltCallback+0x98>)
 8050da8:	6313      	str	r3, [r2, #48]	; 0x30
 8050daa:	e7da      	b.n	8050d62 <HAL_I2C_MemTxCpltCallback+0x4a>
					systemReset();						/* IDWT will reset the system */
 8050dac:	f7ff ffb2 	bl	8050d14 <systemReset>
 8050db0:	20004fd4 	.word	0x20004fd4
 8050db4:	20005174 	.word	0x20005174
 8050db8:	2000367c 	.word	0x2000367c

08050dbc <updateEthLinkStatus>:
* </table><br><br>
* <hr>
*
*******************************************************************************/
void updateEthLinkStatus(void)
{
 8050dbc:	b510      	push	{r4, lr}
	HAL_ETH_ReadPHYRegister(&heth, PHY_BSR, &gu32EthLinkStatus);
 8050dbe:	4c09      	ldr	r4, [pc, #36]	; (8050de4 <updateEthLinkStatus+0x28>)
 8050dc0:	4622      	mov	r2, r4
 8050dc2:	2101      	movs	r1, #1
 8050dc4:	4808      	ldr	r0, [pc, #32]	; (8050de8 <updateEthLinkStatus+0x2c>)
 8050dc6:	f7f1 fa78 	bl	80422ba <HAL_ETH_ReadPHYRegister>
	if((gu32EthLinkStatus & PHY_LINKED_STATUS) != PHY_LINKED_STATUS)
 8050dca:	6823      	ldr	r3, [r4, #0]
 8050dcc:	f013 0f04 	tst.w	r3, #4
 8050dd0:	d103      	bne.n	8050dda <updateEthLinkStatus+0x1e>
		gu32EthLinkAlert = 1;
 8050dd2:	4b06      	ldr	r3, [pc, #24]	; (8050dec <updateEthLinkStatus+0x30>)
 8050dd4:	2201      	movs	r2, #1
 8050dd6:	601a      	str	r2, [r3, #0]
	else
		gu32EthLinkAlert = 0;
}
 8050dd8:	bd10      	pop	{r4, pc}
		gu32EthLinkAlert = 0;
 8050dda:	4b04      	ldr	r3, [pc, #16]	; (8050dec <updateEthLinkStatus+0x30>)
 8050ddc:	2200      	movs	r2, #0
 8050dde:	601a      	str	r2, [r3, #0]
}
 8050de0:	e7fa      	b.n	8050dd8 <updateEthLinkStatus+0x1c>
 8050de2:	bf00      	nop
 8050de4:	20005034 	.word	0x20005034
 8050de8:	2000a1bc 	.word	0x2000a1bc
 8050dec:	20003688 	.word	0x20003688

08050df0 <GetSector>:
  */
static uint32_t GetSector(uint32_t Address)
{
  uint32_t sector = 0;

  if((Address < ADDR_FLASH_SECTOR_1) && (Address >= ADDR_FLASH_SECTOR_0))
 8050df0:	f100 4378 	add.w	r3, r0, #4160749568	; 0xf8000000
 8050df4:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 8050df8:	f0c0 809a 	bcc.w	8050f30 <GetSector+0x140>
  {
    sector = FLASH_SECTOR_0;
  }
  else if((Address < ADDR_FLASH_SECTOR_2) && (Address >= ADDR_FLASH_SECTOR_1))
 8050dfc:	f5a3 4380 	sub.w	r3, r3, #16384	; 0x4000
 8050e00:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 8050e04:	f0c0 8096 	bcc.w	8050f34 <GetSector+0x144>
  {
    sector = FLASH_SECTOR_1;
  }
  else if((Address < ADDR_FLASH_SECTOR_3) && (Address >= ADDR_FLASH_SECTOR_2))
 8050e08:	f100 4378 	add.w	r3, r0, #4160749568	; 0xf8000000
 8050e0c:	f5a3 4300 	sub.w	r3, r3, #32768	; 0x8000
 8050e10:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 8050e14:	f0c0 8090 	bcc.w	8050f38 <GetSector+0x148>
  {
    sector = FLASH_SECTOR_2;
  }
  else if((Address < ADDR_FLASH_SECTOR_4) && (Address >= ADDR_FLASH_SECTOR_3))
 8050e18:	f100 4378 	add.w	r3, r0, #4160749568	; 0xf8000000
 8050e1c:	f5a3 4340 	sub.w	r3, r3, #49152	; 0xc000
 8050e20:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 8050e24:	f0c0 808a 	bcc.w	8050f3c <GetSector+0x14c>
  {
    sector = FLASH_SECTOR_3;
  }
  else if((Address < ADDR_FLASH_SECTOR_5) && (Address >= ADDR_FLASH_SECTOR_4))
 8050e28:	f100 4377 	add.w	r3, r0, #4143972352	; 0xf7000000
 8050e2c:	f503 037f 	add.w	r3, r3, #16711680	; 0xff0000
 8050e30:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8050e34:	f0c0 8084 	bcc.w	8050f40 <GetSector+0x150>
  {
    sector = FLASH_SECTOR_4;
  }
  else if((Address < ADDR_FLASH_SECTOR_6) && (Address >= ADDR_FLASH_SECTOR_5))
 8050e38:	f100 4377 	add.w	r3, r0, #4143972352	; 0xf7000000
 8050e3c:	f503 037e 	add.w	r3, r3, #16646144	; 0xfe0000
 8050e40:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 8050e44:	d37e      	bcc.n	8050f44 <GetSector+0x154>
  {
    sector = FLASH_SECTOR_5;
  }
  else if((Address < ADDR_FLASH_SECTOR_7) && (Address >= ADDR_FLASH_SECTOR_6))
 8050e46:	f100 4377 	add.w	r3, r0, #4143972352	; 0xf7000000
 8050e4a:	f503 037c 	add.w	r3, r3, #16515072	; 0xfc0000
 8050e4e:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 8050e52:	d379      	bcc.n	8050f48 <GetSector+0x158>
  {
    sector = FLASH_SECTOR_6;
  }
  else if((Address < ADDR_FLASH_SECTOR_8) && (Address >= ADDR_FLASH_SECTOR_7))
 8050e54:	f100 4377 	add.w	r3, r0, #4143972352	; 0xf7000000
 8050e58:	f503 037a 	add.w	r3, r3, #16384000	; 0xfa0000
 8050e5c:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 8050e60:	d374      	bcc.n	8050f4c <GetSector+0x15c>
  {
    sector = FLASH_SECTOR_7;
  }
  else if((Address < ADDR_FLASH_SECTOR_9) && (Address >= ADDR_FLASH_SECTOR_8))
 8050e62:	f100 4377 	add.w	r3, r0, #4143972352	; 0xf7000000
 8050e66:	f503 0378 	add.w	r3, r3, #16252928	; 0xf80000
 8050e6a:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 8050e6e:	d36f      	bcc.n	8050f50 <GetSector+0x160>
  {
    sector = FLASH_SECTOR_8;
  }
  else if((Address < ADDR_FLASH_SECTOR_10) && (Address >= ADDR_FLASH_SECTOR_9))
 8050e70:	f100 4377 	add.w	r3, r0, #4143972352	; 0xf7000000
 8050e74:	f503 0376 	add.w	r3, r3, #16121856	; 0xf60000
 8050e78:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 8050e7c:	d36a      	bcc.n	8050f54 <GetSector+0x164>
  {
    sector = FLASH_SECTOR_9;
  }
  else if((Address < ADDR_FLASH_SECTOR_11) && (Address >= ADDR_FLASH_SECTOR_10))
 8050e7e:	f100 4377 	add.w	r3, r0, #4143972352	; 0xf7000000
 8050e82:	f503 0374 	add.w	r3, r3, #15990784	; 0xf40000
 8050e86:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 8050e8a:	d365      	bcc.n	8050f58 <GetSector+0x168>
  {
    sector = FLASH_SECTOR_10;
  }
  else if((Address < ADDR_FLASH_SECTOR_12) && (Address >= ADDR_FLASH_SECTOR_11))
 8050e8c:	f100 4377 	add.w	r3, r0, #4143972352	; 0xf7000000
 8050e90:	f503 0372 	add.w	r3, r3, #15859712	; 0xf20000
 8050e94:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 8050e98:	d360      	bcc.n	8050f5c <GetSector+0x16c>
  {
    sector = FLASH_SECTOR_11;
  }
  else if((Address < ADDR_FLASH_SECTOR_13) && (Address >= ADDR_FLASH_SECTOR_12))
 8050e9a:	f1a0 6301 	sub.w	r3, r0, #135266304	; 0x8100000
 8050e9e:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 8050ea2:	d35d      	bcc.n	8050f60 <GetSector+0x170>
  {
    sector = FLASH_SECTOR_12;
  }
  else if((Address < ADDR_FLASH_SECTOR_14) && (Address >= ADDR_FLASH_SECTOR_13))
 8050ea4:	f5a3 4380 	sub.w	r3, r3, #16384	; 0x4000
 8050ea8:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 8050eac:	d35a      	bcc.n	8050f64 <GetSector+0x174>
  {
    sector = FLASH_SECTOR_13;
  }
  else if((Address < ADDR_FLASH_SECTOR_15) && (Address >= ADDR_FLASH_SECTOR_14))
 8050eae:	f1a0 6301 	sub.w	r3, r0, #135266304	; 0x8100000
 8050eb2:	f5a3 4300 	sub.w	r3, r3, #32768	; 0x8000
 8050eb6:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 8050eba:	d355      	bcc.n	8050f68 <GetSector+0x178>
  {
    sector = FLASH_SECTOR_14;
  }
  else if((Address < ADDR_FLASH_SECTOR_16) && (Address >= ADDR_FLASH_SECTOR_15))
 8050ebc:	f1a0 6301 	sub.w	r3, r0, #135266304	; 0x8100000
 8050ec0:	f5a3 4340 	sub.w	r3, r3, #49152	; 0xc000
 8050ec4:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 8050ec8:	d350      	bcc.n	8050f6c <GetSector+0x17c>
  {
    sector = FLASH_SECTOR_15;
  }
  else if((Address < ADDR_FLASH_SECTOR_17) && (Address >= ADDR_FLASH_SECTOR_16))
 8050eca:	f100 4377 	add.w	r3, r0, #4143972352	; 0xf7000000
 8050ece:	f503 036f 	add.w	r3, r3, #15663104	; 0xef0000
 8050ed2:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8050ed6:	d34b      	bcc.n	8050f70 <GetSector+0x180>
  {
    sector = FLASH_SECTOR_16;
  }
  else if((Address < ADDR_FLASH_SECTOR_18) && (Address >= ADDR_FLASH_SECTOR_17))
 8050ed8:	f100 4377 	add.w	r3, r0, #4143972352	; 0xf7000000
 8050edc:	f503 036e 	add.w	r3, r3, #15597568	; 0xee0000
 8050ee0:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 8050ee4:	d346      	bcc.n	8050f74 <GetSector+0x184>
  {
    sector = FLASH_SECTOR_17;
  }
  else if((Address < ADDR_FLASH_SECTOR_19) && (Address >= ADDR_FLASH_SECTOR_18))
 8050ee6:	f100 4377 	add.w	r3, r0, #4143972352	; 0xf7000000
 8050eea:	f503 036c 	add.w	r3, r3, #15466496	; 0xec0000
 8050eee:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 8050ef2:	d341      	bcc.n	8050f78 <GetSector+0x188>
  {
    sector = FLASH_SECTOR_18;
  }
  else if((Address < ADDR_FLASH_SECTOR_20) && (Address >= ADDR_FLASH_SECTOR_19))
 8050ef4:	f100 4377 	add.w	r3, r0, #4143972352	; 0xf7000000
 8050ef8:	f503 036a 	add.w	r3, r3, #15335424	; 0xea0000
 8050efc:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 8050f00:	d33c      	bcc.n	8050f7c <GetSector+0x18c>
  {
    sector = FLASH_SECTOR_19;
  }
  else if((Address < ADDR_FLASH_SECTOR_21) && (Address >= ADDR_FLASH_SECTOR_20))
 8050f02:	f100 4377 	add.w	r3, r0, #4143972352	; 0xf7000000
 8050f06:	f503 0368 	add.w	r3, r3, #15204352	; 0xe80000
 8050f0a:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 8050f0e:	d337      	bcc.n	8050f80 <GetSector+0x190>
  {
    sector = FLASH_SECTOR_20;
  }
  else if((Address < ADDR_FLASH_SECTOR_22) && (Address >= ADDR_FLASH_SECTOR_21))
 8050f10:	f100 4377 	add.w	r3, r0, #4143972352	; 0xf7000000
 8050f14:	f503 0366 	add.w	r3, r3, #15073280	; 0xe60000
 8050f18:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 8050f1c:	d332      	bcc.n	8050f84 <GetSector+0x194>
  {
    sector = FLASH_SECTOR_21;
  }
  else if((Address < ADDR_FLASH_SECTOR_23) && (Address >= ADDR_FLASH_SECTOR_22))
 8050f1e:	f100 4077 	add.w	r0, r0, #4143972352	; 0xf7000000
 8050f22:	f500 0064 	add.w	r0, r0, #14942208	; 0xe40000
 8050f26:	f5b0 3f00 	cmp.w	r0, #131072	; 0x20000
 8050f2a:	d22d      	bcs.n	8050f88 <GetSector+0x198>
  {
    sector = FLASH_SECTOR_22;
 8050f2c:	2016      	movs	r0, #22
 8050f2e:	4770      	bx	lr
    sector = FLASH_SECTOR_0;
 8050f30:	2000      	movs	r0, #0
 8050f32:	4770      	bx	lr
    sector = FLASH_SECTOR_1;
 8050f34:	2001      	movs	r0, #1
 8050f36:	4770      	bx	lr
    sector = FLASH_SECTOR_2;
 8050f38:	2002      	movs	r0, #2
 8050f3a:	4770      	bx	lr
    sector = FLASH_SECTOR_3;
 8050f3c:	2003      	movs	r0, #3
 8050f3e:	4770      	bx	lr
    sector = FLASH_SECTOR_4;
 8050f40:	2004      	movs	r0, #4
 8050f42:	4770      	bx	lr
    sector = FLASH_SECTOR_5;
 8050f44:	2005      	movs	r0, #5
 8050f46:	4770      	bx	lr
    sector = FLASH_SECTOR_6;
 8050f48:	2006      	movs	r0, #6
 8050f4a:	4770      	bx	lr
    sector = FLASH_SECTOR_7;
 8050f4c:	2007      	movs	r0, #7
 8050f4e:	4770      	bx	lr
    sector = FLASH_SECTOR_8;
 8050f50:	2008      	movs	r0, #8
 8050f52:	4770      	bx	lr
    sector = FLASH_SECTOR_9;
 8050f54:	2009      	movs	r0, #9
 8050f56:	4770      	bx	lr
    sector = FLASH_SECTOR_10;
 8050f58:	200a      	movs	r0, #10
 8050f5a:	4770      	bx	lr
    sector = FLASH_SECTOR_11;
 8050f5c:	200b      	movs	r0, #11
 8050f5e:	4770      	bx	lr
    sector = FLASH_SECTOR_12;
 8050f60:	200c      	movs	r0, #12
 8050f62:	4770      	bx	lr
    sector = FLASH_SECTOR_13;
 8050f64:	200d      	movs	r0, #13
 8050f66:	4770      	bx	lr
    sector = FLASH_SECTOR_14;
 8050f68:	200e      	movs	r0, #14
 8050f6a:	4770      	bx	lr
    sector = FLASH_SECTOR_15;
 8050f6c:	200f      	movs	r0, #15
 8050f6e:	4770      	bx	lr
    sector = FLASH_SECTOR_16;
 8050f70:	2010      	movs	r0, #16
 8050f72:	4770      	bx	lr
    sector = FLASH_SECTOR_17;
 8050f74:	2011      	movs	r0, #17
 8050f76:	4770      	bx	lr
    sector = FLASH_SECTOR_18;
 8050f78:	2012      	movs	r0, #18
 8050f7a:	4770      	bx	lr
    sector = FLASH_SECTOR_19;
 8050f7c:	2013      	movs	r0, #19
 8050f7e:	4770      	bx	lr
    sector = FLASH_SECTOR_20;
 8050f80:	2014      	movs	r0, #20
 8050f82:	4770      	bx	lr
    sector = FLASH_SECTOR_21;
 8050f84:	2015      	movs	r0, #21
 8050f86:	4770      	bx	lr
  }
  else/*(Address < FLASH_END_ADDR) && (Address >= ADDR_FLASH_SECTOR_23))*/
  {
    sector = FLASH_SECTOR_23;
 8050f88:	2017      	movs	r0, #23
  }
  return sector;
}
 8050f8a:	4770      	bx	lr

08050f8c <FLASH_If_Init>:
{
 8050f8c:	b508      	push	{r3, lr}
  HAL_FLASH_Unlock();
 8050f8e:	f7f1 fc75 	bl	804287c <HAL_FLASH_Unlock>
  __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP | FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR |
 8050f92:	4b02      	ldr	r3, [pc, #8]	; (8050f9c <FLASH_If_Init+0x10>)
 8050f94:	22f3      	movs	r2, #243	; 0xf3
 8050f96:	60da      	str	r2, [r3, #12]
}
 8050f98:	bd08      	pop	{r3, pc}
 8050f9a:	bf00      	nop
 8050f9c:	40023c00 	.word	0x40023c00

08050fa0 <FLASH_If_Erase>:
{
 8050fa0:	b510      	push	{r4, lr}
 8050fa2:	b086      	sub	sp, #24
 8050fa4:	4604      	mov	r4, r0
  FLASH_If_Init();
 8050fa6:	f7ff fff1 	bl	8050f8c <FLASH_If_Init>
  UserStartSector = GetSector(StartSector);
 8050faa:	4620      	mov	r0, r4
 8050fac:	f7ff ff20 	bl	8050df0 <GetSector>
  pEraseInit.TypeErase = TYPEERASE_SECTORS;
 8050fb0:	2300      	movs	r3, #0
 8050fb2:	9300      	str	r3, [sp, #0]
  pEraseInit.Sector = UserStartSector;
 8050fb4:	9002      	str	r0, [sp, #8]
  pEraseInit.NbSectors = 1;
 8050fb6:	2301      	movs	r3, #1
 8050fb8:	9303      	str	r3, [sp, #12]
  pEraseInit.VoltageRange = VOLTAGE_RANGE_3;
 8050fba:	2302      	movs	r3, #2
 8050fbc:	9304      	str	r3, [sp, #16]
  if (HAL_FLASHEx_Erase(&pEraseInit, &SectorError) != HAL_OK)
 8050fbe:	a905      	add	r1, sp, #20
 8050fc0:	4668      	mov	r0, sp
 8050fc2:	f7f1 fd6f 	bl	8042aa4 <HAL_FLASHEx_Erase>
 8050fc6:	b908      	cbnz	r0, 8050fcc <FLASH_If_Erase+0x2c>
}
 8050fc8:	b006      	add	sp, #24
 8050fca:	bd10      	pop	{r4, pc}
     return (1);
 8050fcc:	2001      	movs	r0, #1
 8050fce:	e7fb      	b.n	8050fc8 <FLASH_If_Erase+0x28>

08050fd0 <FLASH_If_Write>:
{
 8050fd0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8050fd2:	4604      	mov	r4, r0
 8050fd4:	460e      	mov	r6, r1
 8050fd6:	4617      	mov	r7, r2
  FLASH_If_Init();
 8050fd8:	f7ff ffd8 	bl	8050f8c <FLASH_If_Init>
  for (i = 0; (i < (DataLength / 4)) && (FlashAddress <= (USER_FLASH_END_ADDRESS - 4)); i++)//USER_FLASH_END_ADDRESS
 8050fdc:	2500      	movs	r5, #0
 8050fde:	e003      	b.n	8050fe8 <FLASH_If_Write+0x18>
      FlashAddress += 4;
 8050fe0:	3404      	adds	r4, #4
      u32LastMemoryWriteLocation = FlashAddress;
 8050fe2:	4b10      	ldr	r3, [pc, #64]	; (8051024 <FLASH_If_Write+0x54>)
 8050fe4:	601c      	str	r4, [r3, #0]
  for (i = 0; (i < (DataLength / 4)) && (FlashAddress <= (USER_FLASH_END_ADDRESS - 4)); i++)//USER_FLASH_END_ADDRESS
 8050fe6:	3501      	adds	r5, #1
 8050fe8:	ebb5 0f97 	cmp.w	r5, r7, lsr #2
 8050fec:	d211      	bcs.n	8051012 <FLASH_If_Write+0x42>
 8050fee:	4b0e      	ldr	r3, [pc, #56]	; (8051028 <FLASH_If_Write+0x58>)
 8050ff0:	429c      	cmp	r4, r3
 8050ff2:	d80e      	bhi.n	8051012 <FLASH_If_Write+0x42>
    if (HAL_FLASH_Program(TYPEPROGRAM_WORD, FlashAddress, *(uint32_t*)(Data+i)) == HAL_OK)
 8050ff4:	f856 2025 	ldr.w	r2, [r6, r5, lsl #2]
 8050ff8:	2300      	movs	r3, #0
 8050ffa:	4621      	mov	r1, r4
 8050ffc:	2002      	movs	r0, #2
 8050ffe:	f7f1 fc8f 	bl	8042920 <HAL_FLASH_Program>
 8051002:	b960      	cbnz	r0, 805101e <FLASH_If_Write+0x4e>
      if (*(uint32_t*)FlashAddress != *(uint32_t*)(Data+i))
 8051004:	6821      	ldr	r1, [r4, #0]
 8051006:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 805100a:	4299      	cmp	r1, r3
 805100c:	d0e8      	beq.n	8050fe0 <FLASH_If_Write+0x10>
        return(FLASHIF_WRITINGCTRL_ERROR);
 805100e:	2002      	movs	r0, #2
 8051010:	e004      	b.n	805101c <FLASH_If_Write+0x4c>
  u32LastMemoryWriteLocation = FlashAddress;
 8051012:	4b04      	ldr	r3, [pc, #16]	; (8051024 <FLASH_If_Write+0x54>)
 8051014:	601c      	str	r4, [r3, #0]
  HAL_FLASH_Lock();
 8051016:	f7f1 fc49 	bl	80428ac <HAL_FLASH_Lock>
  return (FLASHIF_OK);
 805101a:	2000      	movs	r0, #0
}
 805101c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      return (FLASHIF_WRITING_ERROR);
 805101e:	2003      	movs	r0, #3
 8051020:	e7fc      	b.n	805101c <FLASH_If_Write+0x4c>
 8051022:	bf00      	nop
 8051024:	20005038 	.word	0x20005038
 8051028:	081dfffc 	.word	0x081dfffc

0805102c <WriteDatatoFlash>:
 Change History:
 Author           	Date                Remarks
 KloudQ Team      26-07-2021			Initial Definition
******************************************************************************/
uint32_t WriteDatatoFlash(uint32_t Sector,uint8_t *data,uint32_t configLen,uint32_t writeCycle)
{
 805102c:	b508      	push	{r3, lr}
	if(FLASH_If_Write(Sector,(uint32_t*)data,configLen) == FLASHIF_OK)
 805102e:	f7ff ffcf 	bl	8050fd0 <FLASH_If_Write>
 8051032:	b100      	cbz	r0, 8051036 <WriteDatatoFlash+0xa>
		return SUCCESS;
	else
		return ERROR;
 8051034:	2001      	movs	r0, #1
}
 8051036:	bd08      	pop	{r3, pc}

08051038 <FLASH_If_Erase_User>:
 Author            	Date                Remarks
 KloudQ Team        26/03/2020			initial Definitions
 Kloudq Team		28/04/2020			Memory Segment Logic Added
******************************************************************************/
uint32_t FLASH_If_Erase_User(uint32_t start,enmBootMemorySegment memorySegment)
{
 8051038:	b510      	push	{r4, lr}
 805103a:	b086      	sub	sp, #24
 805103c:	460c      	mov	r4, r1
	uint32_t UserStartSector;
	uint32_t SectorError;
	FLASH_EraseInitTypeDef pEraseInit;

	/* Unlock the Flash to enable the flash control register access *************/
	FLASH_If_Init();
 805103e:	f7ff ffa5 	bl	8050f8c <FLASH_If_Init>

  /* Get the sector where start the user flash area */
  if(memorySegment == enmBOOTSEGMENT_X_JUMP)
 8051042:	2c58      	cmp	r4, #88	; 0x58
 8051044:	d009      	beq.n	805105a <FLASH_If_Erase_User+0x22>
	  else
		  pEraseInit.NbSectors = 1;
	  pEraseInit.VoltageRange = VOLTAGE_RANGE_3;

  }
  else if(memorySegment == enmBOOTSEGMENT_Y_JUMP)
 8051046:	2c59      	cmp	r4, #89	; 0x59
 8051048:	d018      	beq.n	805107c <FLASH_If_Erase_User+0x44>
		  pEraseInit.NbSectors = 1;
	  pEraseInit.VoltageRange = VOLTAGE_RANGE_3;
  }
  /* Lock the Flash to disable the flash control register access (recommended
     to protect the FLASH memory against possible unwanted operation) *********/
	if (HAL_FLASHEx_Erase(&pEraseInit, &SectorError) != HAL_OK)
 805104a:	a905      	add	r1, sp, #20
 805104c:	4668      	mov	r0, sp
 805104e:	f7f1 fd29 	bl	8042aa4 <HAL_FLASHEx_Erase>
 8051052:	bb20      	cbnz	r0, 805109e <FLASH_If_Erase_User+0x66>
	{
		/* Error occurred while page erase */
		return (FLASHIF_WRITING_ERROR);
	}
	else
		return (FLASHIF_OK);
 8051054:	2000      	movs	r0, #0
}
 8051056:	b006      	add	sp, #24
 8051058:	bd10      	pop	{r4, pc}
	  UserStartSector = GetSector(APPLICATION_ADD_X);
 805105a:	4812      	ldr	r0, [pc, #72]	; (80510a4 <FLASH_If_Erase_User+0x6c>)
 805105c:	f7ff fec8 	bl	8050df0 <GetSector>
	  pEraseInit.TypeErase = TYPEERASE_SECTORS;
 8051060:	2300      	movs	r3, #0
 8051062:	9300      	str	r3, [sp, #0]
	  pEraseInit.Sector = UserStartSector;
 8051064:	9002      	str	r0, [sp, #8]
	  if(u32ConfigFileReadComplete == 0)
 8051066:	4b10      	ldr	r3, [pc, #64]	; (80510a8 <FLASH_If_Erase_User+0x70>)
 8051068:	681b      	ldr	r3, [r3, #0]
 805106a:	b923      	cbnz	r3, 8051076 <FLASH_If_Erase_User+0x3e>
		  pEraseInit.NbSectors = 10;
 805106c:	230a      	movs	r3, #10
 805106e:	9303      	str	r3, [sp, #12]
	  pEraseInit.VoltageRange = VOLTAGE_RANGE_3;
 8051070:	2302      	movs	r3, #2
 8051072:	9304      	str	r3, [sp, #16]
 8051074:	e7e9      	b.n	805104a <FLASH_If_Erase_User+0x12>
		  pEraseInit.NbSectors = 1;
 8051076:	2301      	movs	r3, #1
 8051078:	9303      	str	r3, [sp, #12]
 805107a:	e7f9      	b.n	8051070 <FLASH_If_Erase_User+0x38>
	  UserStartSector = GetSector(APPLICATION_ADD_Y);
 805107c:	480b      	ldr	r0, [pc, #44]	; (80510ac <FLASH_If_Erase_User+0x74>)
 805107e:	f7ff feb7 	bl	8050df0 <GetSector>
	  pEraseInit.TypeErase = TYPEERASE_SECTORS;
 8051082:	2300      	movs	r3, #0
 8051084:	9300      	str	r3, [sp, #0]
	  pEraseInit.Sector = UserStartSector;
 8051086:	9002      	str	r0, [sp, #8]
	  if(u32ConfigFileReadComplete == 0)
 8051088:	4b07      	ldr	r3, [pc, #28]	; (80510a8 <FLASH_If_Erase_User+0x70>)
 805108a:	681b      	ldr	r3, [r3, #0]
 805108c:	b923      	cbnz	r3, 8051098 <FLASH_If_Erase_User+0x60>
		  pEraseInit.NbSectors = 10;
 805108e:	230a      	movs	r3, #10
 8051090:	9303      	str	r3, [sp, #12]
	  pEraseInit.VoltageRange = VOLTAGE_RANGE_3;
 8051092:	2302      	movs	r3, #2
 8051094:	9304      	str	r3, [sp, #16]
 8051096:	e7d8      	b.n	805104a <FLASH_If_Erase_User+0x12>
		  pEraseInit.NbSectors = 1;
 8051098:	2301      	movs	r3, #1
 805109a:	9303      	str	r3, [sp, #12]
 805109c:	e7f9      	b.n	8051092 <FLASH_If_Erase_User+0x5a>
		return (FLASHIF_WRITING_ERROR);
 805109e:	2003      	movs	r0, #3
 80510a0:	e7d9      	b.n	8051056 <FLASH_If_Erase_User+0x1e>
 80510a2:	bf00      	nop
 80510a4:	08004000 	.word	0x08004000
 80510a8:	20004294 	.word	0x20004294
 80510ac:	08104000 	.word	0x08104000

080510b0 <getNewFirmwareStorageLocation>:
 KloudQ Team        30/03/2020			initial Definitions
******************************************************************************/
/* TODO:  Need to take care for empty memory  */
enmBootMemorySegment getNewFirmwareStorageLocation(void)
{
	if(BOOTMEMORYINFO == enmBOOTSEGMENT_X_JUMP)
 80510b0:	f04f 6301 	mov.w	r3, #135266304	; 0x8100000
 80510b4:	681b      	ldr	r3, [r3, #0]
 80510b6:	2b58      	cmp	r3, #88	; 0x58
 80510b8:	d009      	beq.n	80510ce <getNewFirmwareStorageLocation+0x1e>
			u32LastMemoryWriteLocation = APPLICATION_ADD_X;

		return enmBOOTSEGMENT_X_JUMP;

	}
	else if(BOOTMEMORYINFO == enmBOOTSEGMENT_Y_JUMP)
 80510ba:	2b59      	cmp	r3, #89	; 0x59
 80510bc:	d00f      	beq.n	80510de <getNewFirmwareStorageLocation+0x2e>
		return enmBOOTSEGMENT_Y_JUMP;
	}
	else
	{
		/* Illegal Firmware Information . Abort FOTA Jumping */
		if(u32ConfigFileReadComplete == 0)
 80510be:	4b0c      	ldr	r3, [pc, #48]	; (80510f0 <getNewFirmwareStorageLocation+0x40>)
 80510c0:	681b      	ldr	r3, [r3, #0]
 80510c2:	b913      	cbnz	r3, 80510ca <getNewFirmwareStorageLocation+0x1a>
			u32LastMemoryWriteLocation = APPLICATION_ADD_Y;
 80510c4:	4b0b      	ldr	r3, [pc, #44]	; (80510f4 <getNewFirmwareStorageLocation+0x44>)
 80510c6:	4a0c      	ldr	r2, [pc, #48]	; (80510f8 <getNewFirmwareStorageLocation+0x48>)
 80510c8:	601a      	str	r2, [r3, #0]

		return enmBOOTSEGMENT_Y_JUMP;//enmBOOTSEGMENT_UNKNOWN;
 80510ca:	2059      	movs	r0, #89	; 0x59
	}
}
 80510cc:	4770      	bx	lr
		if(u32ConfigFileReadComplete == 0)
 80510ce:	4b08      	ldr	r3, [pc, #32]	; (80510f0 <getNewFirmwareStorageLocation+0x40>)
 80510d0:	681b      	ldr	r3, [r3, #0]
 80510d2:	b913      	cbnz	r3, 80510da <getNewFirmwareStorageLocation+0x2a>
			u32LastMemoryWriteLocation = APPLICATION_ADD_X;
 80510d4:	4b07      	ldr	r3, [pc, #28]	; (80510f4 <getNewFirmwareStorageLocation+0x44>)
 80510d6:	4a09      	ldr	r2, [pc, #36]	; (80510fc <getNewFirmwareStorageLocation+0x4c>)
 80510d8:	601a      	str	r2, [r3, #0]
		return enmBOOTSEGMENT_X_JUMP;
 80510da:	2058      	movs	r0, #88	; 0x58
 80510dc:	4770      	bx	lr
		if(u32ConfigFileReadComplete == 0)
 80510de:	4b04      	ldr	r3, [pc, #16]	; (80510f0 <getNewFirmwareStorageLocation+0x40>)
 80510e0:	681b      	ldr	r3, [r3, #0]
 80510e2:	b913      	cbnz	r3, 80510ea <getNewFirmwareStorageLocation+0x3a>
			u32LastMemoryWriteLocation = APPLICATION_ADD_Y;
 80510e4:	4b03      	ldr	r3, [pc, #12]	; (80510f4 <getNewFirmwareStorageLocation+0x44>)
 80510e6:	4a04      	ldr	r2, [pc, #16]	; (80510f8 <getNewFirmwareStorageLocation+0x48>)
 80510e8:	601a      	str	r2, [r3, #0]
		return enmBOOTSEGMENT_Y_JUMP;
 80510ea:	2059      	movs	r0, #89	; 0x59
 80510ec:	4770      	bx	lr
 80510ee:	bf00      	nop
 80510f0:	20004294 	.word	0x20004294
 80510f4:	20005038 	.word	0x20005038
 80510f8:	08104000 	.word	0x08104000
 80510fc:	08004000 	.word	0x08004000

08051100 <flashWriteBootSection>:
 KloudQ Team        26/03/2020			initial Definitions
 Kloudq Team		27/03/2020			Wr/Rd Tested , Timeout added
******************************************************************************/
uint32_t gu32DataFromMemory = 0;
uint32_t flashWriteBootSection(enmBootMemorySegment memorySegment)
{
 8051100:	b538      	push	{r3, r4, r5, lr}
 8051102:	4604      	mov	r4, r0
	uint32_t status = 0;
	if(FLASH_If_Erase(ADDR_FLASH_SECTOR_12) != FLASHIF_OK)
 8051104:	f04f 6001 	mov.w	r0, #135266304	; 0x8100000
 8051108:	f7ff ff4a 	bl	8050fa0 <FLASH_If_Erase>
 805110c:	b9d0      	cbnz	r0, 8051144 <flashWriteBootSection+0x44>
 805110e:	4605      	mov	r5, r0
		status = 1;
	}
	else
	{
		/* FOTA Storage location update  */
		switch(memorySegment)
 8051110:	2c58      	cmp	r4, #88	; 0x58
 8051112:	d003      	beq.n	805111c <flashWriteBootSection+0x1c>
 8051114:	2c59      	cmp	r4, #89	; 0x59
 8051116:	d00b      	beq.n	8051130 <flashWriteBootSection+0x30>
 8051118:	2501      	movs	r5, #1
 805111a:	e014      	b.n	8051146 <flashWriteBootSection+0x46>
		{

			case enmBOOTSEGMENT_X_JUMP:
				u32LastMemoryWriteLocation = ADDR_FLASH_SECTOR_12;
 805111c:	f04f 6101 	mov.w	r1, #135266304	; 0x8100000
 8051120:	4b0a      	ldr	r3, [pc, #40]	; (805114c <flashWriteBootSection+0x4c>)
 8051122:	6019      	str	r1, [r3, #0]
				if (HAL_FLASH_Program(FLASH_TYPEPROGRAM_WORD, u32LastMemoryWriteLocation,(uint32_t)0x58) == HAL_OK)
 8051124:	2258      	movs	r2, #88	; 0x58
 8051126:	2300      	movs	r3, #0
 8051128:	2002      	movs	r0, #2
 805112a:	f7f1 fbf9 	bl	8042920 <HAL_FLASH_Program>
 805112e:	e00a      	b.n	8051146 <flashWriteBootSection+0x46>
					status = 0;
				}
				break;

			case enmBOOTSEGMENT_Y_JUMP:
				u32LastMemoryWriteLocation = ADDR_FLASH_SECTOR_12;
 8051130:	f04f 6101 	mov.w	r1, #135266304	; 0x8100000
 8051134:	4b05      	ldr	r3, [pc, #20]	; (805114c <flashWriteBootSection+0x4c>)
 8051136:	6019      	str	r1, [r3, #0]
				if (HAL_FLASH_Program(FLASH_TYPEPROGRAM_WORD, u32LastMemoryWriteLocation,(uint32_t)0x59) == HAL_OK)
 8051138:	2259      	movs	r2, #89	; 0x59
 805113a:	2300      	movs	r3, #0
 805113c:	2002      	movs	r0, #2
 805113e:	f7f1 fbef 	bl	8042920 <HAL_FLASH_Program>
 8051142:	e000      	b.n	8051146 <flashWriteBootSection+0x46>
		status = 1;
 8051144:	2501      	movs	r5, #1
				status = 1;
				break;
		}
	}
	return status;
}
 8051146:	4628      	mov	r0, r5
 8051148:	bd38      	pop	{r3, r4, r5, pc}
 805114a:	bf00      	nop
 805114c:	20005038 	.word	0x20005038

08051150 <HAL_RTCEx_WakeUpTimerEventCallback>:
*******************************************************************************/

void HAL_RTCEx_WakeUpTimerEventCallback(RTC_HandleTypeDef *hrtc)
{
	//HAL_GPIO_TogglePin(LED_1_GPIO_Port,LED_1_Pin);
}
 8051150:	4770      	bx	lr

08051152 <HAL_RTC_AlarmAEventCallback>:
*
*******************************************************************************/
void HAL_RTC_AlarmAEventCallback(RTC_HandleTypeDef *hrtc)
{

}
 8051152:	4770      	bx	lr

08051154 <getRTCCalender>:
* </table><br><br>
* <hr>
*
*******************************************************************************/
void getRTCCalender(void)
{
 8051154:	b570      	push	{r4, r5, r6, lr}
 8051156:	b082      	sub	sp, #8

  /* Get the RTC current Time */
  HAL_RTC_GetTime(&hrtc, &stimestructureget, RTC_FORMAT_BIN);
 8051158:	4d11      	ldr	r5, [pc, #68]	; (80511a0 <getRTCCalender+0x4c>)
 805115a:	4e12      	ldr	r6, [pc, #72]	; (80511a4 <getRTCCalender+0x50>)
 805115c:	2200      	movs	r2, #0
 805115e:	4629      	mov	r1, r5
 8051160:	4630      	mov	r0, r6
 8051162:	f7f3 fd60 	bl	8044c26 <HAL_RTC_GetTime>
  /* Get the RTC current Date */
  HAL_RTC_GetDate(&hrtc, &sdatestructureget, RTC_FORMAT_BIN);
 8051166:	4c10      	ldr	r4, [pc, #64]	; (80511a8 <getRTCCalender+0x54>)
 8051168:	2200      	movs	r2, #0
 805116a:	4621      	mov	r1, r4
 805116c:	4630      	mov	r0, r6
 805116e:	f7f3 fd82 	bl	8044c76 <HAL_RTC_GetDate>

  /* Display time Format : hh:mm:ss */
  sprintf((char*)aShowTimeStamp,"%.2d:%.2d:%.2d", stimestructureget.Hours, stimestructureget.Minutes, stimestructureget.Seconds);
 8051172:	78ab      	ldrb	r3, [r5, #2]
 8051174:	4e0d      	ldr	r6, [pc, #52]	; (80511ac <getRTCCalender+0x58>)
 8051176:	9300      	str	r3, [sp, #0]
 8051178:	786b      	ldrb	r3, [r5, #1]
 805117a:	782a      	ldrb	r2, [r5, #0]
 805117c:	490c      	ldr	r1, [pc, #48]	; (80511b0 <getRTCCalender+0x5c>)
 805117e:	4630      	mov	r0, r6
 8051180:	f000 fc84 	bl	8051a8c <sprintf>
  /* Display date Format : mm-dd-yy */
  sprintf((char*)aShowDateStamp,"%.2d/%.2d/%.2d",sdatestructureget.Date, sdatestructureget.Month, 2000 + sdatestructureget.Year);
 8051184:	78e3      	ldrb	r3, [r4, #3]
 8051186:	f503 63fa 	add.w	r3, r3, #2000	; 0x7d0
 805118a:	9300      	str	r3, [sp, #0]
 805118c:	7863      	ldrb	r3, [r4, #1]
 805118e:	78a2      	ldrb	r2, [r4, #2]
 8051190:	4908      	ldr	r1, [pc, #32]	; (80511b4 <getRTCCalender+0x60>)
 8051192:	f106 0034 	add.w	r0, r6, #52	; 0x34
 8051196:	f000 fc79 	bl	8051a8c <sprintf>
}
 805119a:	b002      	add	sp, #8
 805119c:	bd70      	pop	{r4, r5, r6, pc}
 805119e:	bf00      	nop
 80511a0:	20010094 	.word	0x20010094
 80511a4:	2000f330 	.word	0x2000f330
 80511a8:	2001008c 	.word	0x2001008c
 80511ac:	20005050 	.word	0x20005050
 80511b0:	0805aadc 	.word	0x0805aadc
 80511b4:	0805aaec 	.word	0x0805aaec

080511b8 <readbackedupRTCCalender>:
* </table><br><br>
* <hr>
*
*******************************************************************************/
void readbackedupRTCCalender(void)
{
 80511b8:	b538      	push	{r3, r4, r5, lr}
   /* Read Data */
   sTimeStampget_backup.Hours = HAL_RTCEx_BKUPRead(&hrtc, RTC_BKP_DR1);
 80511ba:	4c11      	ldr	r4, [pc, #68]	; (8051200 <readbackedupRTCCalender+0x48>)
 80511bc:	2101      	movs	r1, #1
 80511be:	4620      	mov	r0, r4
 80511c0:	f7f3 fe1e 	bl	8044e00 <HAL_RTCEx_BKUPRead>
 80511c4:	4d0f      	ldr	r5, [pc, #60]	; (8051204 <readbackedupRTCCalender+0x4c>)
 80511c6:	7028      	strb	r0, [r5, #0]
   sTimeStampget_backup.Minutes = HAL_RTCEx_BKUPRead(&hrtc, RTC_BKP_DR2);
 80511c8:	2102      	movs	r1, #2
 80511ca:	4620      	mov	r0, r4
 80511cc:	f7f3 fe18 	bl	8044e00 <HAL_RTCEx_BKUPRead>
 80511d0:	7068      	strb	r0, [r5, #1]
   sTimeStampget_backup.Seconds = HAL_RTCEx_BKUPRead(&hrtc, RTC_BKP_DR3);
 80511d2:	2103      	movs	r1, #3
 80511d4:	4620      	mov	r0, r4
 80511d6:	f7f3 fe13 	bl	8044e00 <HAL_RTCEx_BKUPRead>
 80511da:	70a8      	strb	r0, [r5, #2]
   sTimeStampDateget_backup.Date =  HAL_RTCEx_BKUPRead(&hrtc, RTC_BKP_DR4);
 80511dc:	2104      	movs	r1, #4
 80511de:	4620      	mov	r0, r4
 80511e0:	f7f3 fe0e 	bl	8044e00 <HAL_RTCEx_BKUPRead>
 80511e4:	4d08      	ldr	r5, [pc, #32]	; (8051208 <readbackedupRTCCalender+0x50>)
 80511e6:	70a8      	strb	r0, [r5, #2]
   sTimeStampDateget_backup.Month =  HAL_RTCEx_BKUPRead(&hrtc, RTC_BKP_DR5);
 80511e8:	2105      	movs	r1, #5
 80511ea:	4620      	mov	r0, r4
 80511ec:	f7f3 fe08 	bl	8044e00 <HAL_RTCEx_BKUPRead>
 80511f0:	7068      	strb	r0, [r5, #1]
   sTimeStampDateget_backup.Year =  HAL_RTCEx_BKUPRead(&hrtc, RTC_BKP_DR6);
 80511f2:	2106      	movs	r1, #6
 80511f4:	4620      	mov	r0, r4
 80511f6:	f7f3 fe03 	bl	8044e00 <HAL_RTCEx_BKUPRead>
 80511fa:	70e8      	strb	r0, [r5, #3]
}
 80511fc:	bd38      	pop	{r3, r4, r5, pc}
 80511fe:	bf00      	nop
 8051200:	2000f330 	.word	0x2000f330
 8051204:	200088d8 	.word	0x200088d8
 8051208:	20010090 	.word	0x20010090

0805120c <DecimalToBCD>:
* <hr>
*
*******************************************************************************/
uint32_t DecimalToBCD (uint32_t Decimal)
{
   return (((Decimal/10) << 4) | (Decimal % 10));
 805120c:	4b05      	ldr	r3, [pc, #20]	; (8051224 <DecimalToBCD+0x18>)
 805120e:	fba3 2300 	umull	r2, r3, r3, r0
 8051212:	08db      	lsrs	r3, r3, #3
 8051214:	eb03 0283 	add.w	r2, r3, r3, lsl #2
 8051218:	eba0 0042 	sub.w	r0, r0, r2, lsl #1
}
 805121c:	ea40 1003 	orr.w	r0, r0, r3, lsl #4
 8051220:	4770      	bx	lr
 8051222:	bf00      	nop
 8051224:	cccccccd 	.word	0xcccccccd

08051228 <BCDToDecimal>:
* <hr>
*
*******************************************************************************/
uint32_t BCDToDecimal(uint32_t BCD)
{
   return (((BCD >> 4) * 10) + (BCD & 0xF));
 8051228:	0903      	lsrs	r3, r0, #4
 805122a:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 805122e:	f000 000f 	and.w	r0, r0, #15
}
 8051232:	eb00 0043 	add.w	r0, r0, r3, lsl #1
 8051236:	4770      	bx	lr

08051238 <getrtcStamp>:
* </table><br><br>
* <hr>
*
*******************************************************************************/
void getrtcStamp(void)
{
 8051238:	b570      	push	{r4, r5, r6, lr}
	HAL_RTC_GetTime(&hrtc,&STime1,RTC_FORMAT_BCD);
 805123a:	4d1f      	ldr	r5, [pc, #124]	; (80512b8 <getrtcStamp+0x80>)
 805123c:	4c1f      	ldr	r4, [pc, #124]	; (80512bc <getrtcStamp+0x84>)
 805123e:	2201      	movs	r2, #1
 8051240:	4629      	mov	r1, r5
 8051242:	4620      	mov	r0, r4
 8051244:	f7f3 fcef 	bl	8044c26 <HAL_RTC_GetTime>
	HAL_RTC_GetDate(&hrtc,&SDate1,RTC_FORMAT_BCD);
 8051248:	4e1d      	ldr	r6, [pc, #116]	; (80512c0 <getrtcStamp+0x88>)
 805124a:	2201      	movs	r2, #1
 805124c:	4631      	mov	r1, r6
 805124e:	4620      	mov	r0, r4
 8051250:	f7f3 fd11 	bl	8044c76 <HAL_RTC_GetDate>

	itoa(BCDToDecimal(SDate1.Year),gau8Year,PAYLOAD_DATA_STRING_RADIX);
 8051254:	78f0      	ldrb	r0, [r6, #3]
 8051256:	f7ff ffe7 	bl	8051228 <BCDToDecimal>
 805125a:	4c1a      	ldr	r4, [pc, #104]	; (80512c4 <getrtcStamp+0x8c>)
 805125c:	220a      	movs	r2, #10
 805125e:	4621      	mov	r1, r4
 8051260:	f000 f96e 	bl	8051540 <itoa>
	itoa(BCDToDecimal(SDate1.Month),gau8Month,PAYLOAD_DATA_STRING_RADIX);
 8051264:	7870      	ldrb	r0, [r6, #1]
 8051266:	f7ff ffdf 	bl	8051228 <BCDToDecimal>
 805126a:	220a      	movs	r2, #10
 805126c:	f104 0108 	add.w	r1, r4, #8
 8051270:	f000 f966 	bl	8051540 <itoa>
	itoa(BCDToDecimal(SDate1.Date),gau8Date,PAYLOAD_DATA_STRING_RADIX);
 8051274:	78b0      	ldrb	r0, [r6, #2]
 8051276:	f7ff ffd7 	bl	8051228 <BCDToDecimal>
 805127a:	220a      	movs	r2, #10
 805127c:	f104 0110 	add.w	r1, r4, #16
 8051280:	f000 f95e 	bl	8051540 <itoa>

	itoa(BCDToDecimal(STime1.Hours),gau8Hour,PAYLOAD_DATA_STRING_RADIX);
 8051284:	7828      	ldrb	r0, [r5, #0]
 8051286:	f7ff ffcf 	bl	8051228 <BCDToDecimal>
 805128a:	220a      	movs	r2, #10
 805128c:	f104 0118 	add.w	r1, r4, #24
 8051290:	f000 f956 	bl	8051540 <itoa>
	itoa(BCDToDecimal(STime1.Minutes),gau8Minutes,PAYLOAD_DATA_STRING_RADIX);
 8051294:	7868      	ldrb	r0, [r5, #1]
 8051296:	f7ff ffc7 	bl	8051228 <BCDToDecimal>
 805129a:	220a      	movs	r2, #10
 805129c:	f104 0120 	add.w	r1, r4, #32
 80512a0:	f000 f94e 	bl	8051540 <itoa>
	itoa(BCDToDecimal(STime1.Seconds),gau8Seconds,PAYLOAD_DATA_STRING_RADIX);
 80512a4:	78a8      	ldrb	r0, [r5, #2]
 80512a6:	f7ff ffbf 	bl	8051228 <BCDToDecimal>
 80512aa:	220a      	movs	r2, #10
 80512ac:	f104 0128 	add.w	r1, r4, #40	; 0x28
 80512b0:	f000 f946 	bl	8051540 <itoa>
}
 80512b4:	bd70      	pop	{r4, r5, r6, pc}
 80512b6:	bf00      	nop
 80512b8:	20004f60 	.word	0x20004f60
 80512bc:	2000f330 	.word	0x2000f330
 80512c0:	20004f74 	.word	0x20004f74
 80512c4:	2000368c 	.word	0x2000368c

080512c8 <HAL_TIM_PeriodElapsedCallback>:
volatile uint32_t gu32UploadFailTimer = TEN_MIN;

void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
	/* Timer 7 . 1 ms Interrupt */
	if(htim->Instance == TIM7)
 80512c8:	6802      	ldr	r2, [r0, #0]
 80512ca:	4b5d      	ldr	r3, [pc, #372]	; (8051440 <HAL_TIM_PeriodElapsedCallback+0x178>)
 80512cc:	429a      	cmp	r2, r3
 80512ce:	d000      	beq.n	80512d2 <HAL_TIM_PeriodElapsedCallback+0xa>
		if(gu32LinkDownTimer)gu32LinkDownTimer--;
		if(gu32SystemResetTimer)gu32SystemResetTimer--;
		if(gu32UploadFailTimer)gu32UploadFailTimer--;

	}
	}
 80512d0:	4770      	bx	lr
		if(gu32MBTCPTimer)gu32MBTCPTimer--;
 80512d2:	4b5c      	ldr	r3, [pc, #368]	; (8051444 <HAL_TIM_PeriodElapsedCallback+0x17c>)
 80512d4:	681b      	ldr	r3, [r3, #0]
 80512d6:	b113      	cbz	r3, 80512de <HAL_TIM_PeriodElapsedCallback+0x16>
 80512d8:	3b01      	subs	r3, #1
 80512da:	4a5a      	ldr	r2, [pc, #360]	; (8051444 <HAL_TIM_PeriodElapsedCallback+0x17c>)
 80512dc:	6013      	str	r3, [r2, #0]
		if(gu32MBPOLLTimer)gu32MBPOLLTimer--;
 80512de:	4b5a      	ldr	r3, [pc, #360]	; (8051448 <HAL_TIM_PeriodElapsedCallback+0x180>)
 80512e0:	681b      	ldr	r3, [r3, #0]
 80512e2:	b113      	cbz	r3, 80512ea <HAL_TIM_PeriodElapsedCallback+0x22>
 80512e4:	3b01      	subs	r3, #1
 80512e6:	4a58      	ldr	r2, [pc, #352]	; (8051448 <HAL_TIM_PeriodElapsedCallback+0x180>)
 80512e8:	6013      	str	r3, [r2, #0]
		if(master.u32PollDelay)master.u32PollDelay--;
 80512ea:	4b58      	ldr	r3, [pc, #352]	; (805144c <HAL_TIM_PeriodElapsedCallback+0x184>)
 80512ec:	f8d3 3e4c 	ldr.w	r3, [r3, #3660]	; 0xe4c
 80512f0:	b11b      	cbz	r3, 80512fa <HAL_TIM_PeriodElapsedCallback+0x32>
 80512f2:	3b01      	subs	r3, #1
 80512f4:	4a55      	ldr	r2, [pc, #340]	; (805144c <HAL_TIM_PeriodElapsedCallback+0x184>)
 80512f6:	f8c2 3e4c 	str.w	r3, [r2, #3660]	; 0xe4c
		if(gu32MBCharacterDelay)gu32MBCharacterDelay--;
 80512fa:	4b55      	ldr	r3, [pc, #340]	; (8051450 <HAL_TIM_PeriodElapsedCallback+0x188>)
 80512fc:	681b      	ldr	r3, [r3, #0]
 80512fe:	b113      	cbz	r3, 8051306 <HAL_TIM_PeriodElapsedCallback+0x3e>
 8051300:	3b01      	subs	r3, #1
 8051302:	4a53      	ldr	r2, [pc, #332]	; (8051450 <HAL_TIM_PeriodElapsedCallback+0x188>)
 8051304:	6013      	str	r3, [r2, #0]
		if(gu32ModbusFrameEndTimer)gu32ModbusFrameEndTimer--;
 8051306:	4b53      	ldr	r3, [pc, #332]	; (8051454 <HAL_TIM_PeriodElapsedCallback+0x18c>)
 8051308:	681b      	ldr	r3, [r3, #0]
 805130a:	b113      	cbz	r3, 8051312 <HAL_TIM_PeriodElapsedCallback+0x4a>
 805130c:	3b01      	subs	r3, #1
 805130e:	4a51      	ldr	r2, [pc, #324]	; (8051454 <HAL_TIM_PeriodElapsedCallback+0x18c>)
 8051310:	6013      	str	r3, [r2, #0]
		if(gu32ModbusResponseTimeout)gu32ModbusResponseTimeout--;
 8051312:	4b51      	ldr	r3, [pc, #324]	; (8051458 <HAL_TIM_PeriodElapsedCallback+0x190>)
 8051314:	681b      	ldr	r3, [r3, #0]
 8051316:	b113      	cbz	r3, 805131e <HAL_TIM_PeriodElapsedCallback+0x56>
 8051318:	3b01      	subs	r3, #1
 805131a:	4a4f      	ldr	r2, [pc, #316]	; (8051458 <HAL_TIM_PeriodElapsedCallback+0x190>)
 805131c:	6013      	str	r3, [r2, #0]
		if(gu32LinkDisconnectTimer)gu32LinkDisconnectTimer--;
 805131e:	4b4f      	ldr	r3, [pc, #316]	; (805145c <HAL_TIM_PeriodElapsedCallback+0x194>)
 8051320:	681b      	ldr	r3, [r3, #0]
 8051322:	b11b      	cbz	r3, 805132c <HAL_TIM_PeriodElapsedCallback+0x64>
 8051324:	4a4d      	ldr	r2, [pc, #308]	; (805145c <HAL_TIM_PeriodElapsedCallback+0x194>)
 8051326:	6813      	ldr	r3, [r2, #0]
 8051328:	3b01      	subs	r3, #1
 805132a:	6013      	str	r3, [r2, #0]
		if(gu32GSMCharacterTimeout)gu32GSMCharacterTimeout--;
 805132c:	4b4c      	ldr	r3, [pc, #304]	; (8051460 <HAL_TIM_PeriodElapsedCallback+0x198>)
 805132e:	681b      	ldr	r3, [r3, #0]
 8051330:	b113      	cbz	r3, 8051338 <HAL_TIM_PeriodElapsedCallback+0x70>
 8051332:	3b01      	subs	r3, #1
 8051334:	4a4a      	ldr	r2, [pc, #296]	; (8051460 <HAL_TIM_PeriodElapsedCallback+0x198>)
 8051336:	6013      	str	r3, [r2, #0]
		if(gsmInstance.u32GSMTimer)gsmInstance.u32GSMTimer--;
 8051338:	4b4a      	ldr	r3, [pc, #296]	; (8051464 <HAL_TIM_PeriodElapsedCallback+0x19c>)
 805133a:	f8d3 3e20 	ldr.w	r3, [r3, #3616]	; 0xe20
 805133e:	b12b      	cbz	r3, 805134c <HAL_TIM_PeriodElapsedCallback+0x84>
 8051340:	4a48      	ldr	r2, [pc, #288]	; (8051464 <HAL_TIM_PeriodElapsedCallback+0x19c>)
 8051342:	f8d2 3e20 	ldr.w	r3, [r2, #3616]	; 0xe20
 8051346:	3b01      	subs	r3, #1
 8051348:	f8c2 3e20 	str.w	r3, [r2, #3616]	; 0xe20
		if(gsmInstance.u32GSMResponseTimer)gsmInstance.u32GSMResponseTimer--;
 805134c:	4b45      	ldr	r3, [pc, #276]	; (8051464 <HAL_TIM_PeriodElapsedCallback+0x19c>)
 805134e:	f8d3 3e34 	ldr.w	r3, [r3, #3636]	; 0xe34
 8051352:	b12b      	cbz	r3, 8051360 <HAL_TIM_PeriodElapsedCallback+0x98>
 8051354:	4a43      	ldr	r2, [pc, #268]	; (8051464 <HAL_TIM_PeriodElapsedCallback+0x19c>)
 8051356:	f8d2 3e34 	ldr.w	r3, [r2, #3636]	; 0xe34
 805135a:	3b01      	subs	r3, #1
 805135c:	f8c2 3e34 	str.w	r3, [r2, #3636]	; 0xe34
		if(gsmInstance.u32GSMHeartbeatTimer)gsmInstance.u32GSMHeartbeatTimer--;
 8051360:	4b40      	ldr	r3, [pc, #256]	; (8051464 <HAL_TIM_PeriodElapsedCallback+0x19c>)
 8051362:	f8d3 3e2c 	ldr.w	r3, [r3, #3628]	; 0xe2c
 8051366:	b11b      	cbz	r3, 8051370 <HAL_TIM_PeriodElapsedCallback+0xa8>
 8051368:	3b01      	subs	r3, #1
 805136a:	4a3e      	ldr	r2, [pc, #248]	; (8051464 <HAL_TIM_PeriodElapsedCallback+0x19c>)
 805136c:	f8c2 3e2c 	str.w	r3, [r2, #3628]	; 0xe2c
		if(gu32GSMHangTimer)gu32GSMHangTimer--;
 8051370:	4b3b      	ldr	r3, [pc, #236]	; (8051460 <HAL_TIM_PeriodElapsedCallback+0x198>)
 8051372:	685b      	ldr	r3, [r3, #4]
 8051374:	b11b      	cbz	r3, 805137e <HAL_TIM_PeriodElapsedCallback+0xb6>
 8051376:	4a3a      	ldr	r2, [pc, #232]	; (8051460 <HAL_TIM_PeriodElapsedCallback+0x198>)
 8051378:	6853      	ldr	r3, [r2, #4]
 805137a:	3b01      	subs	r3, #1
 805137c:	6053      	str	r3, [r2, #4]
		if(gu32GPSCharacterTimeout)gu32GPSCharacterTimeout--;
 805137e:	4b38      	ldr	r3, [pc, #224]	; (8051460 <HAL_TIM_PeriodElapsedCallback+0x198>)
 8051380:	689b      	ldr	r3, [r3, #8]
 8051382:	b113      	cbz	r3, 805138a <HAL_TIM_PeriodElapsedCallback+0xc2>
 8051384:	3b01      	subs	r3, #1
 8051386:	4a36      	ldr	r2, [pc, #216]	; (8051460 <HAL_TIM_PeriodElapsedCallback+0x198>)
 8051388:	6093      	str	r3, [r2, #8]
		if(gu32PayloadQueueEnqueue)gu32PayloadQueueEnqueue--;
 805138a:	4b35      	ldr	r3, [pc, #212]	; (8051460 <HAL_TIM_PeriodElapsedCallback+0x198>)
 805138c:	68db      	ldr	r3, [r3, #12]
 805138e:	b11b      	cbz	r3, 8051398 <HAL_TIM_PeriodElapsedCallback+0xd0>
 8051390:	4a33      	ldr	r2, [pc, #204]	; (8051460 <HAL_TIM_PeriodElapsedCallback+0x198>)
 8051392:	68d3      	ldr	r3, [r2, #12]
 8051394:	3b01      	subs	r3, #1
 8051396:	60d3      	str	r3, [r2, #12]
		if(gu32TempPayloadQueueEnqueue)gu32TempPayloadQueueEnqueue--;
 8051398:	4b31      	ldr	r3, [pc, #196]	; (8051460 <HAL_TIM_PeriodElapsedCallback+0x198>)
 805139a:	691b      	ldr	r3, [r3, #16]
 805139c:	b11b      	cbz	r3, 80513a6 <HAL_TIM_PeriodElapsedCallback+0xde>
 805139e:	4a30      	ldr	r2, [pc, #192]	; (8051460 <HAL_TIM_PeriodElapsedCallback+0x198>)
 80513a0:	6913      	ldr	r3, [r2, #16]
 80513a2:	3b01      	subs	r3, #1
 80513a4:	6113      	str	r3, [r2, #16]
		if(gu32FotaFileReadTimer)gu32FotaFileReadTimer--;
 80513a6:	4b2e      	ldr	r3, [pc, #184]	; (8051460 <HAL_TIM_PeriodElapsedCallback+0x198>)
 80513a8:	695b      	ldr	r3, [r3, #20]
 80513aa:	b11b      	cbz	r3, 80513b4 <HAL_TIM_PeriodElapsedCallback+0xec>
 80513ac:	4a2c      	ldr	r2, [pc, #176]	; (8051460 <HAL_TIM_PeriodElapsedCallback+0x198>)
 80513ae:	6953      	ldr	r3, [r2, #20]
 80513b0:	3b01      	subs	r3, #1
 80513b2:	6153      	str	r3, [r2, #20]
		if(gu32GSMRestartTimer)gu32GSMRestartTimer--; /* Added on 6/2/22 . Was Missing :P */
 80513b4:	4b29      	ldr	r3, [pc, #164]	; (805145c <HAL_TIM_PeriodElapsedCallback+0x194>)
 80513b6:	685b      	ldr	r3, [r3, #4]
 80513b8:	b11b      	cbz	r3, 80513c2 <HAL_TIM_PeriodElapsedCallback+0xfa>
 80513ba:	4a28      	ldr	r2, [pc, #160]	; (805145c <HAL_TIM_PeriodElapsedCallback+0x194>)
 80513bc:	6853      	ldr	r3, [r2, #4]
 80513be:	3b01      	subs	r3, #1
 80513c0:	6053      	str	r3, [r2, #4]
		if(gu32RTCUpdateTimer)gu32RTCUpdateTimer--;
 80513c2:	4b27      	ldr	r3, [pc, #156]	; (8051460 <HAL_TIM_PeriodElapsedCallback+0x198>)
 80513c4:	699b      	ldr	r3, [r3, #24]
 80513c6:	b113      	cbz	r3, 80513ce <HAL_TIM_PeriodElapsedCallback+0x106>
 80513c8:	3b01      	subs	r3, #1
 80513ca:	4a25      	ldr	r2, [pc, #148]	; (8051460 <HAL_TIM_PeriodElapsedCallback+0x198>)
 80513cc:	6193      	str	r3, [r2, #24]
		if(gu32I2CMemoryOperationTimeout)gu32I2CMemoryOperationTimeout--;
 80513ce:	4b24      	ldr	r3, [pc, #144]	; (8051460 <HAL_TIM_PeriodElapsedCallback+0x198>)
 80513d0:	69db      	ldr	r3, [r3, #28]
 80513d2:	b113      	cbz	r3, 80513da <HAL_TIM_PeriodElapsedCallback+0x112>
 80513d4:	3b01      	subs	r3, #1
 80513d6:	4a22      	ldr	r2, [pc, #136]	; (8051460 <HAL_TIM_PeriodElapsedCallback+0x198>)
 80513d8:	61d3      	str	r3, [r2, #28]
		if(gu32ADCOperationTimer)gu32ADCOperationTimer--;
 80513da:	4b21      	ldr	r3, [pc, #132]	; (8051460 <HAL_TIM_PeriodElapsedCallback+0x198>)
 80513dc:	6a1b      	ldr	r3, [r3, #32]
 80513de:	b113      	cbz	r3, 80513e6 <HAL_TIM_PeriodElapsedCallback+0x11e>
 80513e0:	3b01      	subs	r3, #1
 80513e2:	4a1f      	ldr	r2, [pc, #124]	; (8051460 <HAL_TIM_PeriodElapsedCallback+0x198>)
 80513e4:	6213      	str	r3, [r2, #32]
		if(gu32ADCPollTimer)gu32ADCPollTimer--;
 80513e6:	4b1e      	ldr	r3, [pc, #120]	; (8051460 <HAL_TIM_PeriodElapsedCallback+0x198>)
 80513e8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80513ea:	b113      	cbz	r3, 80513f2 <HAL_TIM_PeriodElapsedCallback+0x12a>
 80513ec:	3b01      	subs	r3, #1
 80513ee:	4a1c      	ldr	r2, [pc, #112]	; (8051460 <HAL_TIM_PeriodElapsedCallback+0x198>)
 80513f0:	6253      	str	r3, [r2, #36]	; 0x24
		if(gu32LedTimer)gu32LedTimer--;
 80513f2:	4b1b      	ldr	r3, [pc, #108]	; (8051460 <HAL_TIM_PeriodElapsedCallback+0x198>)
 80513f4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80513f6:	b11b      	cbz	r3, 8051400 <HAL_TIM_PeriodElapsedCallback+0x138>
 80513f8:	4a19      	ldr	r2, [pc, #100]	; (8051460 <HAL_TIM_PeriodElapsedCallback+0x198>)
 80513fa:	6a93      	ldr	r3, [r2, #40]	; 0x28
 80513fc:	3b01      	subs	r3, #1
 80513fe:	6293      	str	r3, [r2, #40]	; 0x28
		if(gu32GSMConfigCheckTimer)gu32GSMConfigCheckTimer--;
 8051400:	4b17      	ldr	r3, [pc, #92]	; (8051460 <HAL_TIM_PeriodElapsedCallback+0x198>)
 8051402:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8051404:	b11b      	cbz	r3, 805140e <HAL_TIM_PeriodElapsedCallback+0x146>
 8051406:	4a16      	ldr	r2, [pc, #88]	; (8051460 <HAL_TIM_PeriodElapsedCallback+0x198>)
 8051408:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
 805140a:	3b01      	subs	r3, #1
 805140c:	62d3      	str	r3, [r2, #44]	; 0x2c
		if(gu32LinkDownTimer)gu32LinkDownTimer--;
 805140e:	4b13      	ldr	r3, [pc, #76]	; (805145c <HAL_TIM_PeriodElapsedCallback+0x194>)
 8051410:	689b      	ldr	r3, [r3, #8]
 8051412:	b11b      	cbz	r3, 805141c <HAL_TIM_PeriodElapsedCallback+0x154>
 8051414:	4a11      	ldr	r2, [pc, #68]	; (805145c <HAL_TIM_PeriodElapsedCallback+0x194>)
 8051416:	6893      	ldr	r3, [r2, #8]
 8051418:	3b01      	subs	r3, #1
 805141a:	6093      	str	r3, [r2, #8]
		if(gu32SystemResetTimer)gu32SystemResetTimer--;
 805141c:	4b0f      	ldr	r3, [pc, #60]	; (805145c <HAL_TIM_PeriodElapsedCallback+0x194>)
 805141e:	68db      	ldr	r3, [r3, #12]
 8051420:	b11b      	cbz	r3, 805142a <HAL_TIM_PeriodElapsedCallback+0x162>
 8051422:	4a0e      	ldr	r2, [pc, #56]	; (805145c <HAL_TIM_PeriodElapsedCallback+0x194>)
 8051424:	68d3      	ldr	r3, [r2, #12]
 8051426:	3b01      	subs	r3, #1
 8051428:	60d3      	str	r3, [r2, #12]
		if(gu32UploadFailTimer)gu32UploadFailTimer--;
 805142a:	4b0c      	ldr	r3, [pc, #48]	; (805145c <HAL_TIM_PeriodElapsedCallback+0x194>)
 805142c:	691b      	ldr	r3, [r3, #16]
 805142e:	2b00      	cmp	r3, #0
 8051430:	f43f af4e 	beq.w	80512d0 <HAL_TIM_PeriodElapsedCallback+0x8>
 8051434:	4a09      	ldr	r2, [pc, #36]	; (805145c <HAL_TIM_PeriodElapsedCallback+0x194>)
 8051436:	6913      	ldr	r3, [r2, #16]
 8051438:	3b01      	subs	r3, #1
 805143a:	6113      	str	r3, [r2, #16]
	}
 805143c:	e748      	b.n	80512d0 <HAL_TIM_PeriodElapsedCallback+0x8>
 805143e:	bf00      	nop
 8051440:	40001400 	.word	0x40001400
 8051444:	2000481c 	.word	0x2000481c
 8051448:	20004cf0 	.word	0x20004cf0
 805144c:	2000d5e0 	.word	0x2000d5e0
 8051450:	200047f8 	.word	0x200047f8
 8051454:	2000432c 	.word	0x2000432c
 8051458:	20004330 	.word	0x20004330
 805145c:	200036bc 	.word	0x200036bc
 8051460:	20005158 	.word	0x20005158
 8051464:	2000c398 	.word	0x2000c398

08051468 <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  
  ldr   sp, =_estack     /* set stack pointer */
 8051468:	f8df d034 	ldr.w	sp, [pc, #52]	; 80514a0 <LoopFillZerobss+0x14>

/* Copy the data segment initializers from flash to SRAM */  
  movs  r1, #0
 805146c:	2100      	movs	r1, #0
  b  LoopCopyDataInit
 805146e:	e003      	b.n	8051478 <LoopCopyDataInit>

08051470 <CopyDataInit>:

CopyDataInit:
  ldr  r3, =_sidata
 8051470:	4b0c      	ldr	r3, [pc, #48]	; (80514a4 <LoopFillZerobss+0x18>)
  ldr  r3, [r3, r1]
 8051472:	585b      	ldr	r3, [r3, r1]
  str  r3, [r0, r1]
 8051474:	5043      	str	r3, [r0, r1]
  adds  r1, r1, #4
 8051476:	3104      	adds	r1, #4

08051478 <LoopCopyDataInit>:
    
LoopCopyDataInit:
  ldr  r0, =_sdata
 8051478:	480b      	ldr	r0, [pc, #44]	; (80514a8 <LoopFillZerobss+0x1c>)
  ldr  r3, =_edata
 805147a:	4b0c      	ldr	r3, [pc, #48]	; (80514ac <LoopFillZerobss+0x20>)
  adds  r2, r0, r1
 805147c:	1842      	adds	r2, r0, r1
  cmp  r2, r3
 805147e:	429a      	cmp	r2, r3
  bcc  CopyDataInit
 8051480:	d3f6      	bcc.n	8051470 <CopyDataInit>
  ldr  r2, =_sbss
 8051482:	4a0b      	ldr	r2, [pc, #44]	; (80514b0 <LoopFillZerobss+0x24>)
  b  LoopFillZerobss
 8051484:	e002      	b.n	805148c <LoopFillZerobss>

08051486 <FillZerobss>:
/* Zero fill the bss segment. */  
FillZerobss:
  movs  r3, #0
 8051486:	2300      	movs	r3, #0
  str  r3, [r2], #4
 8051488:	f842 3b04 	str.w	r3, [r2], #4

0805148c <LoopFillZerobss>:
    
LoopFillZerobss:
  ldr  r3, = _ebss
 805148c:	4b09      	ldr	r3, [pc, #36]	; (80514b4 <LoopFillZerobss+0x28>)
  cmp  r2, r3
 805148e:	429a      	cmp	r2, r3
  bcc  FillZerobss
 8051490:	d3f9      	bcc.n	8051486 <FillZerobss>

/* Call the clock system intitialization function.*/
  bl  SystemInit   
 8051492:	f7ff f8ff 	bl	8050694 <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 8051496:	f000 f817 	bl	80514c8 <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
 805149a:	f7fc f8a9 	bl	804d5f0 <main>
  bx  lr    
 805149e:	4770      	bx	lr
  ldr   sp, =_estack     /* set stack pointer */
 80514a0:	20030000 	.word	0x20030000
  ldr  r3, =_sidata
 80514a4:	0805afb4 	.word	0x0805afb4
  ldr  r0, =_sdata
 80514a8:	20000000 	.word	0x20000000
  ldr  r3, =_edata
 80514ac:	20004084 	.word	0x20004084
  ldr  r2, =_sbss
 80514b0:	20004084 	.word	0x20004084
  ldr  r3, = _ebss
 80514b4:	200100b8 	.word	0x200100b8

080514b8 <CAN1_RX0_IRQHandler>:
 * @retval None       
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
 80514b8:	e7fe      	b.n	80514b8 <CAN1_RX0_IRQHandler>

080514ba <atof>:
 80514ba:	2100      	movs	r1, #0
 80514bc:	f001 b98e 	b.w	80527dc <strtod>

080514c0 <atoi>:
 80514c0:	220a      	movs	r2, #10
 80514c2:	2100      	movs	r1, #0
 80514c4:	f001 ba4a 	b.w	805295c <strtol>

080514c8 <__libc_init_array>:
 80514c8:	b570      	push	{r4, r5, r6, lr}
 80514ca:	4d0d      	ldr	r5, [pc, #52]	; (8051500 <__libc_init_array+0x38>)
 80514cc:	4c0d      	ldr	r4, [pc, #52]	; (8051504 <__libc_init_array+0x3c>)
 80514ce:	1b64      	subs	r4, r4, r5
 80514d0:	10a4      	asrs	r4, r4, #2
 80514d2:	2600      	movs	r6, #0
 80514d4:	42a6      	cmp	r6, r4
 80514d6:	d109      	bne.n	80514ec <__libc_init_array+0x24>
 80514d8:	4d0b      	ldr	r5, [pc, #44]	; (8051508 <__libc_init_array+0x40>)
 80514da:	4c0c      	ldr	r4, [pc, #48]	; (805150c <__libc_init_array+0x44>)
 80514dc:	f007 fc2a 	bl	8058d34 <_init>
 80514e0:	1b64      	subs	r4, r4, r5
 80514e2:	10a4      	asrs	r4, r4, #2
 80514e4:	2600      	movs	r6, #0
 80514e6:	42a6      	cmp	r6, r4
 80514e8:	d105      	bne.n	80514f6 <__libc_init_array+0x2e>
 80514ea:	bd70      	pop	{r4, r5, r6, pc}
 80514ec:	f855 3b04 	ldr.w	r3, [r5], #4
 80514f0:	4798      	blx	r3
 80514f2:	3601      	adds	r6, #1
 80514f4:	e7ee      	b.n	80514d4 <__libc_init_array+0xc>
 80514f6:	f855 3b04 	ldr.w	r3, [r5], #4
 80514fa:	4798      	blx	r3
 80514fc:	3601      	adds	r6, #1
 80514fe:	e7f2      	b.n	80514e6 <__libc_init_array+0x1e>
 8051500:	0805afa8 	.word	0x0805afa8
 8051504:	0805afa8 	.word	0x0805afa8
 8051508:	0805afa8 	.word	0x0805afa8
 805150c:	0805afb0 	.word	0x0805afb0

08051510 <__itoa>:
 8051510:	1e93      	subs	r3, r2, #2
 8051512:	2b22      	cmp	r3, #34	; 0x22
 8051514:	b510      	push	{r4, lr}
 8051516:	460c      	mov	r4, r1
 8051518:	d904      	bls.n	8051524 <__itoa+0x14>
 805151a:	2300      	movs	r3, #0
 805151c:	700b      	strb	r3, [r1, #0]
 805151e:	461c      	mov	r4, r3
 8051520:	4620      	mov	r0, r4
 8051522:	bd10      	pop	{r4, pc}
 8051524:	2a0a      	cmp	r2, #10
 8051526:	d109      	bne.n	805153c <__itoa+0x2c>
 8051528:	2800      	cmp	r0, #0
 805152a:	da07      	bge.n	805153c <__itoa+0x2c>
 805152c:	232d      	movs	r3, #45	; 0x2d
 805152e:	700b      	strb	r3, [r1, #0]
 8051530:	4240      	negs	r0, r0
 8051532:	2101      	movs	r1, #1
 8051534:	4421      	add	r1, r4
 8051536:	f002 fc09 	bl	8053d4c <__utoa>
 805153a:	e7f1      	b.n	8051520 <__itoa+0x10>
 805153c:	2100      	movs	r1, #0
 805153e:	e7f9      	b.n	8051534 <__itoa+0x24>

08051540 <itoa>:
 8051540:	f7ff bfe6 	b.w	8051510 <__itoa>

08051544 <malloc>:
 8051544:	4b02      	ldr	r3, [pc, #8]	; (8051550 <malloc+0xc>)
 8051546:	4601      	mov	r1, r0
 8051548:	6818      	ldr	r0, [r3, #0]
 805154a:	f000 b80b 	b.w	8051564 <_malloc_r>
 805154e:	bf00      	nop
 8051550:	200036d0 	.word	0x200036d0

08051554 <free>:
 8051554:	4b02      	ldr	r3, [pc, #8]	; (8051560 <free+0xc>)
 8051556:	4601      	mov	r1, r0
 8051558:	6818      	ldr	r0, [r3, #0]
 805155a:	f004 bf09 	b.w	8056370 <_free_r>
 805155e:	bf00      	nop
 8051560:	200036d0 	.word	0x200036d0

08051564 <_malloc_r>:
 8051564:	f101 030b 	add.w	r3, r1, #11
 8051568:	2b16      	cmp	r3, #22
 805156a:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 805156e:	4605      	mov	r5, r0
 8051570:	d906      	bls.n	8051580 <_malloc_r+0x1c>
 8051572:	f033 0707 	bics.w	r7, r3, #7
 8051576:	d504      	bpl.n	8051582 <_malloc_r+0x1e>
 8051578:	230c      	movs	r3, #12
 805157a:	602b      	str	r3, [r5, #0]
 805157c:	2400      	movs	r4, #0
 805157e:	e1ae      	b.n	80518de <_malloc_r+0x37a>
 8051580:	2710      	movs	r7, #16
 8051582:	42b9      	cmp	r1, r7
 8051584:	d8f8      	bhi.n	8051578 <_malloc_r+0x14>
 8051586:	4628      	mov	r0, r5
 8051588:	f000 fa52 	bl	8051a30 <__malloc_lock>
 805158c:	f5b7 7ffc 	cmp.w	r7, #504	; 0x1f8
 8051590:	4ec3      	ldr	r6, [pc, #780]	; (80518a0 <_malloc_r+0x33c>)
 8051592:	d238      	bcs.n	8051606 <_malloc_r+0xa2>
 8051594:	f107 0208 	add.w	r2, r7, #8
 8051598:	4432      	add	r2, r6
 805159a:	f1a2 0108 	sub.w	r1, r2, #8
 805159e:	6854      	ldr	r4, [r2, #4]
 80515a0:	428c      	cmp	r4, r1
 80515a2:	ea4f 03d7 	mov.w	r3, r7, lsr #3
 80515a6:	d102      	bne.n	80515ae <_malloc_r+0x4a>
 80515a8:	68d4      	ldr	r4, [r2, #12]
 80515aa:	42a2      	cmp	r2, r4
 80515ac:	d010      	beq.n	80515d0 <_malloc_r+0x6c>
 80515ae:	6863      	ldr	r3, [r4, #4]
 80515b0:	e9d4 1202 	ldrd	r1, r2, [r4, #8]
 80515b4:	f023 0303 	bic.w	r3, r3, #3
 80515b8:	60ca      	str	r2, [r1, #12]
 80515ba:	4423      	add	r3, r4
 80515bc:	6091      	str	r1, [r2, #8]
 80515be:	685a      	ldr	r2, [r3, #4]
 80515c0:	f042 0201 	orr.w	r2, r2, #1
 80515c4:	605a      	str	r2, [r3, #4]
 80515c6:	4628      	mov	r0, r5
 80515c8:	f000 fa38 	bl	8051a3c <__malloc_unlock>
 80515cc:	3408      	adds	r4, #8
 80515ce:	e186      	b.n	80518de <_malloc_r+0x37a>
 80515d0:	3302      	adds	r3, #2
 80515d2:	4ab4      	ldr	r2, [pc, #720]	; (80518a4 <_malloc_r+0x340>)
 80515d4:	6934      	ldr	r4, [r6, #16]
 80515d6:	4294      	cmp	r4, r2
 80515d8:	4611      	mov	r1, r2
 80515da:	d077      	beq.n	80516cc <_malloc_r+0x168>
 80515dc:	6860      	ldr	r0, [r4, #4]
 80515de:	f020 0c03 	bic.w	ip, r0, #3
 80515e2:	ebac 0007 	sub.w	r0, ip, r7
 80515e6:	280f      	cmp	r0, #15
 80515e8:	dd48      	ble.n	805167c <_malloc_r+0x118>
 80515ea:	19e1      	adds	r1, r4, r7
 80515ec:	f040 0301 	orr.w	r3, r0, #1
 80515f0:	f047 0701 	orr.w	r7, r7, #1
 80515f4:	6067      	str	r7, [r4, #4]
 80515f6:	e9c6 1104 	strd	r1, r1, [r6, #16]
 80515fa:	e9c1 2202 	strd	r2, r2, [r1, #8]
 80515fe:	604b      	str	r3, [r1, #4]
 8051600:	f844 000c 	str.w	r0, [r4, ip]
 8051604:	e7df      	b.n	80515c6 <_malloc_r+0x62>
 8051606:	0a7b      	lsrs	r3, r7, #9
 8051608:	d02a      	beq.n	8051660 <_malloc_r+0xfc>
 805160a:	2b04      	cmp	r3, #4
 805160c:	d812      	bhi.n	8051634 <_malloc_r+0xd0>
 805160e:	09bb      	lsrs	r3, r7, #6
 8051610:	3338      	adds	r3, #56	; 0x38
 8051612:	1c5a      	adds	r2, r3, #1
 8051614:	eb06 02c2 	add.w	r2, r6, r2, lsl #3
 8051618:	f1a2 0c08 	sub.w	ip, r2, #8
 805161c:	6854      	ldr	r4, [r2, #4]
 805161e:	4564      	cmp	r4, ip
 8051620:	d006      	beq.n	8051630 <_malloc_r+0xcc>
 8051622:	6862      	ldr	r2, [r4, #4]
 8051624:	f022 0203 	bic.w	r2, r2, #3
 8051628:	1bd0      	subs	r0, r2, r7
 805162a:	280f      	cmp	r0, #15
 805162c:	dd1c      	ble.n	8051668 <_malloc_r+0x104>
 805162e:	3b01      	subs	r3, #1
 8051630:	3301      	adds	r3, #1
 8051632:	e7ce      	b.n	80515d2 <_malloc_r+0x6e>
 8051634:	2b14      	cmp	r3, #20
 8051636:	d801      	bhi.n	805163c <_malloc_r+0xd8>
 8051638:	335b      	adds	r3, #91	; 0x5b
 805163a:	e7ea      	b.n	8051612 <_malloc_r+0xae>
 805163c:	2b54      	cmp	r3, #84	; 0x54
 805163e:	d802      	bhi.n	8051646 <_malloc_r+0xe2>
 8051640:	0b3b      	lsrs	r3, r7, #12
 8051642:	336e      	adds	r3, #110	; 0x6e
 8051644:	e7e5      	b.n	8051612 <_malloc_r+0xae>
 8051646:	f5b3 7faa 	cmp.w	r3, #340	; 0x154
 805164a:	d802      	bhi.n	8051652 <_malloc_r+0xee>
 805164c:	0bfb      	lsrs	r3, r7, #15
 805164e:	3377      	adds	r3, #119	; 0x77
 8051650:	e7df      	b.n	8051612 <_malloc_r+0xae>
 8051652:	f240 5254 	movw	r2, #1364	; 0x554
 8051656:	4293      	cmp	r3, r2
 8051658:	d804      	bhi.n	8051664 <_malloc_r+0x100>
 805165a:	0cbb      	lsrs	r3, r7, #18
 805165c:	337c      	adds	r3, #124	; 0x7c
 805165e:	e7d8      	b.n	8051612 <_malloc_r+0xae>
 8051660:	233f      	movs	r3, #63	; 0x3f
 8051662:	e7d6      	b.n	8051612 <_malloc_r+0xae>
 8051664:	237e      	movs	r3, #126	; 0x7e
 8051666:	e7d4      	b.n	8051612 <_malloc_r+0xae>
 8051668:	2800      	cmp	r0, #0
 805166a:	68e1      	ldr	r1, [r4, #12]
 805166c:	db04      	blt.n	8051678 <_malloc_r+0x114>
 805166e:	68a3      	ldr	r3, [r4, #8]
 8051670:	60d9      	str	r1, [r3, #12]
 8051672:	608b      	str	r3, [r1, #8]
 8051674:	18a3      	adds	r3, r4, r2
 8051676:	e7a2      	b.n	80515be <_malloc_r+0x5a>
 8051678:	460c      	mov	r4, r1
 805167a:	e7d0      	b.n	805161e <_malloc_r+0xba>
 805167c:	2800      	cmp	r0, #0
 805167e:	e9c6 2204 	strd	r2, r2, [r6, #16]
 8051682:	db07      	blt.n	8051694 <_malloc_r+0x130>
 8051684:	44a4      	add	ip, r4
 8051686:	f8dc 3004 	ldr.w	r3, [ip, #4]
 805168a:	f043 0301 	orr.w	r3, r3, #1
 805168e:	f8cc 3004 	str.w	r3, [ip, #4]
 8051692:	e798      	b.n	80515c6 <_malloc_r+0x62>
 8051694:	f5bc 7f00 	cmp.w	ip, #512	; 0x200
 8051698:	6870      	ldr	r0, [r6, #4]
 805169a:	f080 809e 	bcs.w	80517da <_malloc_r+0x276>
 805169e:	ea4f 02dc 	mov.w	r2, ip, lsr #3
 80516a2:	ea4f 1e5c 	mov.w	lr, ip, lsr #5
 80516a6:	f04f 0c01 	mov.w	ip, #1
 80516aa:	3201      	adds	r2, #1
 80516ac:	fa0c fc0e 	lsl.w	ip, ip, lr
 80516b0:	ea4c 0000 	orr.w	r0, ip, r0
 80516b4:	6070      	str	r0, [r6, #4]
 80516b6:	f856 c032 	ldr.w	ip, [r6, r2, lsl #3]
 80516ba:	eb06 00c2 	add.w	r0, r6, r2, lsl #3
 80516be:	3808      	subs	r0, #8
 80516c0:	e9c4 c002 	strd	ip, r0, [r4, #8]
 80516c4:	f846 4032 	str.w	r4, [r6, r2, lsl #3]
 80516c8:	f8cc 400c 	str.w	r4, [ip, #12]
 80516cc:	2001      	movs	r0, #1
 80516ce:	109a      	asrs	r2, r3, #2
 80516d0:	fa00 f202 	lsl.w	r2, r0, r2
 80516d4:	6870      	ldr	r0, [r6, #4]
 80516d6:	4290      	cmp	r0, r2
 80516d8:	d326      	bcc.n	8051728 <_malloc_r+0x1c4>
 80516da:	4210      	tst	r0, r2
 80516dc:	d106      	bne.n	80516ec <_malloc_r+0x188>
 80516de:	f023 0303 	bic.w	r3, r3, #3
 80516e2:	0052      	lsls	r2, r2, #1
 80516e4:	4210      	tst	r0, r2
 80516e6:	f103 0304 	add.w	r3, r3, #4
 80516ea:	d0fa      	beq.n	80516e2 <_malloc_r+0x17e>
 80516ec:	eb06 08c3 	add.w	r8, r6, r3, lsl #3
 80516f0:	46c1      	mov	r9, r8
 80516f2:	469e      	mov	lr, r3
 80516f4:	f8d9 400c 	ldr.w	r4, [r9, #12]
 80516f8:	454c      	cmp	r4, r9
 80516fa:	f040 80b3 	bne.w	8051864 <_malloc_r+0x300>
 80516fe:	f10e 0e01 	add.w	lr, lr, #1
 8051702:	f01e 0f03 	tst.w	lr, #3
 8051706:	f109 0908 	add.w	r9, r9, #8
 805170a:	d1f3      	bne.n	80516f4 <_malloc_r+0x190>
 805170c:	0798      	lsls	r0, r3, #30
 805170e:	f040 80ec 	bne.w	80518ea <_malloc_r+0x386>
 8051712:	6873      	ldr	r3, [r6, #4]
 8051714:	ea23 0302 	bic.w	r3, r3, r2
 8051718:	6073      	str	r3, [r6, #4]
 805171a:	6870      	ldr	r0, [r6, #4]
 805171c:	0052      	lsls	r2, r2, #1
 805171e:	4290      	cmp	r0, r2
 8051720:	d302      	bcc.n	8051728 <_malloc_r+0x1c4>
 8051722:	2a00      	cmp	r2, #0
 8051724:	f040 80ee 	bne.w	8051904 <_malloc_r+0x3a0>
 8051728:	f8d6 b008 	ldr.w	fp, [r6, #8]
 805172c:	f8db 1004 	ldr.w	r1, [fp, #4]
 8051730:	f021 0903 	bic.w	r9, r1, #3
 8051734:	45b9      	cmp	r9, r7
 8051736:	d304      	bcc.n	8051742 <_malloc_r+0x1de>
 8051738:	eba9 0207 	sub.w	r2, r9, r7
 805173c:	2a0f      	cmp	r2, #15
 805173e:	f300 8149 	bgt.w	80519d4 <_malloc_r+0x470>
 8051742:	4a59      	ldr	r2, [pc, #356]	; (80518a8 <_malloc_r+0x344>)
 8051744:	6811      	ldr	r1, [r2, #0]
 8051746:	3110      	adds	r1, #16
 8051748:	eb0b 0309 	add.w	r3, fp, r9
 805174c:	4439      	add	r1, r7
 805174e:	2008      	movs	r0, #8
 8051750:	9301      	str	r3, [sp, #4]
 8051752:	9100      	str	r1, [sp, #0]
 8051754:	f002 faec 	bl	8053d30 <sysconf>
 8051758:	4a54      	ldr	r2, [pc, #336]	; (80518ac <_malloc_r+0x348>)
 805175a:	e9dd 1300 	ldrd	r1, r3, [sp]
 805175e:	4680      	mov	r8, r0
 8051760:	6810      	ldr	r0, [r2, #0]
 8051762:	3001      	adds	r0, #1
 8051764:	bf1f      	itttt	ne
 8051766:	f101 31ff 	addne.w	r1, r1, #4294967295
 805176a:	4441      	addne	r1, r8
 805176c:	f1c8 0000 	rsbne	r0, r8, #0
 8051770:	4001      	andne	r1, r0
 8051772:	4628      	mov	r0, r5
 8051774:	e9cd 1300 	strd	r1, r3, [sp]
 8051778:	f000 f978 	bl	8051a6c <_sbrk_r>
 805177c:	1c42      	adds	r2, r0, #1
 805177e:	4604      	mov	r4, r0
 8051780:	f000 80fc 	beq.w	805197c <_malloc_r+0x418>
 8051784:	9b01      	ldr	r3, [sp, #4]
 8051786:	9900      	ldr	r1, [sp, #0]
 8051788:	4a48      	ldr	r2, [pc, #288]	; (80518ac <_malloc_r+0x348>)
 805178a:	4283      	cmp	r3, r0
 805178c:	d902      	bls.n	8051794 <_malloc_r+0x230>
 805178e:	45b3      	cmp	fp, r6
 8051790:	f040 80f4 	bne.w	805197c <_malloc_r+0x418>
 8051794:	f8df a120 	ldr.w	sl, [pc, #288]	; 80518b8 <_malloc_r+0x354>
 8051798:	f8da 0000 	ldr.w	r0, [sl]
 805179c:	42a3      	cmp	r3, r4
 805179e:	eb00 0e01 	add.w	lr, r0, r1
 80517a2:	f8ca e000 	str.w	lr, [sl]
 80517a6:	f108 3cff 	add.w	ip, r8, #4294967295
 80517aa:	f040 80ad 	bne.w	8051908 <_malloc_r+0x3a4>
 80517ae:	ea13 0f0c 	tst.w	r3, ip
 80517b2:	f040 80a9 	bne.w	8051908 <_malloc_r+0x3a4>
 80517b6:	68b3      	ldr	r3, [r6, #8]
 80517b8:	4449      	add	r1, r9
 80517ba:	f041 0101 	orr.w	r1, r1, #1
 80517be:	6059      	str	r1, [r3, #4]
 80517c0:	4a3b      	ldr	r2, [pc, #236]	; (80518b0 <_malloc_r+0x34c>)
 80517c2:	f8da 3000 	ldr.w	r3, [sl]
 80517c6:	6811      	ldr	r1, [r2, #0]
 80517c8:	428b      	cmp	r3, r1
 80517ca:	bf88      	it	hi
 80517cc:	6013      	strhi	r3, [r2, #0]
 80517ce:	4a39      	ldr	r2, [pc, #228]	; (80518b4 <_malloc_r+0x350>)
 80517d0:	6811      	ldr	r1, [r2, #0]
 80517d2:	428b      	cmp	r3, r1
 80517d4:	bf88      	it	hi
 80517d6:	6013      	strhi	r3, [r2, #0]
 80517d8:	e0d0      	b.n	805197c <_malloc_r+0x418>
 80517da:	f5bc 6f20 	cmp.w	ip, #2560	; 0xa00
 80517de:	ea4f 225c 	mov.w	r2, ip, lsr #9
 80517e2:	d218      	bcs.n	8051816 <_malloc_r+0x2b2>
 80517e4:	ea4f 129c 	mov.w	r2, ip, lsr #6
 80517e8:	3238      	adds	r2, #56	; 0x38
 80517ea:	f102 0e01 	add.w	lr, r2, #1
 80517ee:	eb06 08c2 	add.w	r8, r6, r2, lsl #3
 80517f2:	f856 e03e 	ldr.w	lr, [r6, lr, lsl #3]
 80517f6:	45f0      	cmp	r8, lr
 80517f8:	d12b      	bne.n	8051852 <_malloc_r+0x2ee>
 80517fa:	1092      	asrs	r2, r2, #2
 80517fc:	f04f 0c01 	mov.w	ip, #1
 8051800:	fa0c f202 	lsl.w	r2, ip, r2
 8051804:	4310      	orrs	r0, r2
 8051806:	6070      	str	r0, [r6, #4]
 8051808:	e9c4 e802 	strd	lr, r8, [r4, #8]
 805180c:	f8c8 4008 	str.w	r4, [r8, #8]
 8051810:	f8ce 400c 	str.w	r4, [lr, #12]
 8051814:	e75a      	b.n	80516cc <_malloc_r+0x168>
 8051816:	2a14      	cmp	r2, #20
 8051818:	d801      	bhi.n	805181e <_malloc_r+0x2ba>
 805181a:	325b      	adds	r2, #91	; 0x5b
 805181c:	e7e5      	b.n	80517ea <_malloc_r+0x286>
 805181e:	2a54      	cmp	r2, #84	; 0x54
 8051820:	d803      	bhi.n	805182a <_malloc_r+0x2c6>
 8051822:	ea4f 321c 	mov.w	r2, ip, lsr #12
 8051826:	326e      	adds	r2, #110	; 0x6e
 8051828:	e7df      	b.n	80517ea <_malloc_r+0x286>
 805182a:	f5b2 7faa 	cmp.w	r2, #340	; 0x154
 805182e:	d803      	bhi.n	8051838 <_malloc_r+0x2d4>
 8051830:	ea4f 32dc 	mov.w	r2, ip, lsr #15
 8051834:	3277      	adds	r2, #119	; 0x77
 8051836:	e7d8      	b.n	80517ea <_malloc_r+0x286>
 8051838:	f240 5e54 	movw	lr, #1364	; 0x554
 805183c:	4572      	cmp	r2, lr
 805183e:	bf9a      	itte	ls
 8051840:	ea4f 429c 	movls.w	r2, ip, lsr #18
 8051844:	327c      	addls	r2, #124	; 0x7c
 8051846:	227e      	movhi	r2, #126	; 0x7e
 8051848:	e7cf      	b.n	80517ea <_malloc_r+0x286>
 805184a:	f8de e008 	ldr.w	lr, [lr, #8]
 805184e:	45f0      	cmp	r8, lr
 8051850:	d005      	beq.n	805185e <_malloc_r+0x2fa>
 8051852:	f8de 2004 	ldr.w	r2, [lr, #4]
 8051856:	f022 0203 	bic.w	r2, r2, #3
 805185a:	4562      	cmp	r2, ip
 805185c:	d8f5      	bhi.n	805184a <_malloc_r+0x2e6>
 805185e:	f8de 800c 	ldr.w	r8, [lr, #12]
 8051862:	e7d1      	b.n	8051808 <_malloc_r+0x2a4>
 8051864:	6860      	ldr	r0, [r4, #4]
 8051866:	f8d4 c00c 	ldr.w	ip, [r4, #12]
 805186a:	f020 0003 	bic.w	r0, r0, #3
 805186e:	eba0 0a07 	sub.w	sl, r0, r7
 8051872:	f1ba 0f0f 	cmp.w	sl, #15
 8051876:	dd21      	ble.n	80518bc <_malloc_r+0x358>
 8051878:	68a3      	ldr	r3, [r4, #8]
 805187a:	19e2      	adds	r2, r4, r7
 805187c:	f047 0701 	orr.w	r7, r7, #1
 8051880:	6067      	str	r7, [r4, #4]
 8051882:	f8c3 c00c 	str.w	ip, [r3, #12]
 8051886:	f8cc 3008 	str.w	r3, [ip, #8]
 805188a:	f04a 0301 	orr.w	r3, sl, #1
 805188e:	e9c6 2204 	strd	r2, r2, [r6, #16]
 8051892:	e9c2 1102 	strd	r1, r1, [r2, #8]
 8051896:	6053      	str	r3, [r2, #4]
 8051898:	f844 a000 	str.w	sl, [r4, r0]
 805189c:	e693      	b.n	80515c6 <_malloc_r+0x62>
 805189e:	bf00      	nop
 80518a0:	20003b00 	.word	0x20003b00
 80518a4:	20003b08 	.word	0x20003b08
 80518a8:	200051c8 	.word	0x200051c8
 80518ac:	20003f08 	.word	0x20003f08
 80518b0:	200051c0 	.word	0x200051c0
 80518b4:	200051c4 	.word	0x200051c4
 80518b8:	20005198 	.word	0x20005198
 80518bc:	f1ba 0f00 	cmp.w	sl, #0
 80518c0:	db11      	blt.n	80518e6 <_malloc_r+0x382>
 80518c2:	4420      	add	r0, r4
 80518c4:	6843      	ldr	r3, [r0, #4]
 80518c6:	f043 0301 	orr.w	r3, r3, #1
 80518ca:	6043      	str	r3, [r0, #4]
 80518cc:	f854 3f08 	ldr.w	r3, [r4, #8]!
 80518d0:	4628      	mov	r0, r5
 80518d2:	f8c3 c00c 	str.w	ip, [r3, #12]
 80518d6:	f8cc 3008 	str.w	r3, [ip, #8]
 80518da:	f000 f8af 	bl	8051a3c <__malloc_unlock>
 80518de:	4620      	mov	r0, r4
 80518e0:	b003      	add	sp, #12
 80518e2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80518e6:	4664      	mov	r4, ip
 80518e8:	e706      	b.n	80516f8 <_malloc_r+0x194>
 80518ea:	f858 0908 	ldr.w	r0, [r8], #-8
 80518ee:	4540      	cmp	r0, r8
 80518f0:	f103 33ff 	add.w	r3, r3, #4294967295
 80518f4:	f43f af0a 	beq.w	805170c <_malloc_r+0x1a8>
 80518f8:	e70f      	b.n	805171a <_malloc_r+0x1b6>
 80518fa:	3304      	adds	r3, #4
 80518fc:	0052      	lsls	r2, r2, #1
 80518fe:	4210      	tst	r0, r2
 8051900:	d0fb      	beq.n	80518fa <_malloc_r+0x396>
 8051902:	e6f3      	b.n	80516ec <_malloc_r+0x188>
 8051904:	4673      	mov	r3, lr
 8051906:	e7fa      	b.n	80518fe <_malloc_r+0x39a>
 8051908:	6810      	ldr	r0, [r2, #0]
 805190a:	3001      	adds	r0, #1
 805190c:	bf1b      	ittet	ne
 805190e:	1ae3      	subne	r3, r4, r3
 8051910:	4473      	addne	r3, lr
 8051912:	6014      	streq	r4, [r2, #0]
 8051914:	f8ca 3000 	strne.w	r3, [sl]
 8051918:	f014 0307 	ands.w	r3, r4, #7
 805191c:	bf1a      	itte	ne
 805191e:	f1c3 0008 	rsbne	r0, r3, #8
 8051922:	1824      	addne	r4, r4, r0
 8051924:	4618      	moveq	r0, r3
 8051926:	1862      	adds	r2, r4, r1
 8051928:	ea02 010c 	and.w	r1, r2, ip
 805192c:	4480      	add	r8, r0
 805192e:	eba8 0801 	sub.w	r8, r8, r1
 8051932:	ea08 080c 	and.w	r8, r8, ip
 8051936:	4641      	mov	r1, r8
 8051938:	4628      	mov	r0, r5
 805193a:	9301      	str	r3, [sp, #4]
 805193c:	9200      	str	r2, [sp, #0]
 805193e:	f000 f895 	bl	8051a6c <_sbrk_r>
 8051942:	1c43      	adds	r3, r0, #1
 8051944:	e9dd 2300 	ldrd	r2, r3, [sp]
 8051948:	d105      	bne.n	8051956 <_malloc_r+0x3f2>
 805194a:	b32b      	cbz	r3, 8051998 <_malloc_r+0x434>
 805194c:	f1a3 0008 	sub.w	r0, r3, #8
 8051950:	4410      	add	r0, r2
 8051952:	f04f 0800 	mov.w	r8, #0
 8051956:	f8da 2000 	ldr.w	r2, [sl]
 805195a:	60b4      	str	r4, [r6, #8]
 805195c:	1b00      	subs	r0, r0, r4
 805195e:	4440      	add	r0, r8
 8051960:	4442      	add	r2, r8
 8051962:	f040 0001 	orr.w	r0, r0, #1
 8051966:	45b3      	cmp	fp, r6
 8051968:	f8ca 2000 	str.w	r2, [sl]
 805196c:	6060      	str	r0, [r4, #4]
 805196e:	f43f af27 	beq.w	80517c0 <_malloc_r+0x25c>
 8051972:	f1b9 0f0f 	cmp.w	r9, #15
 8051976:	d812      	bhi.n	805199e <_malloc_r+0x43a>
 8051978:	2301      	movs	r3, #1
 805197a:	6063      	str	r3, [r4, #4]
 805197c:	68b3      	ldr	r3, [r6, #8]
 805197e:	685b      	ldr	r3, [r3, #4]
 8051980:	f023 0303 	bic.w	r3, r3, #3
 8051984:	42bb      	cmp	r3, r7
 8051986:	eba3 0207 	sub.w	r2, r3, r7
 805198a:	d301      	bcc.n	8051990 <_malloc_r+0x42c>
 805198c:	2a0f      	cmp	r2, #15
 805198e:	dc21      	bgt.n	80519d4 <_malloc_r+0x470>
 8051990:	4628      	mov	r0, r5
 8051992:	f000 f853 	bl	8051a3c <__malloc_unlock>
 8051996:	e5f1      	b.n	805157c <_malloc_r+0x18>
 8051998:	4610      	mov	r0, r2
 805199a:	4698      	mov	r8, r3
 805199c:	e7db      	b.n	8051956 <_malloc_r+0x3f2>
 805199e:	f8db 3004 	ldr.w	r3, [fp, #4]
 80519a2:	f1a9 090c 	sub.w	r9, r9, #12
 80519a6:	f029 0907 	bic.w	r9, r9, #7
 80519aa:	f003 0301 	and.w	r3, r3, #1
 80519ae:	ea43 0309 	orr.w	r3, r3, r9
 80519b2:	f8cb 3004 	str.w	r3, [fp, #4]
 80519b6:	2205      	movs	r2, #5
 80519b8:	eb0b 0309 	add.w	r3, fp, r9
 80519bc:	f1b9 0f0f 	cmp.w	r9, #15
 80519c0:	e9c3 2201 	strd	r2, r2, [r3, #4]
 80519c4:	f67f aefc 	bls.w	80517c0 <_malloc_r+0x25c>
 80519c8:	f10b 0108 	add.w	r1, fp, #8
 80519cc:	4628      	mov	r0, r5
 80519ce:	f004 fccf 	bl	8056370 <_free_r>
 80519d2:	e6f5      	b.n	80517c0 <_malloc_r+0x25c>
 80519d4:	68b4      	ldr	r4, [r6, #8]
 80519d6:	f047 0301 	orr.w	r3, r7, #1
 80519da:	4427      	add	r7, r4
 80519dc:	f042 0201 	orr.w	r2, r2, #1
 80519e0:	6063      	str	r3, [r4, #4]
 80519e2:	60b7      	str	r7, [r6, #8]
 80519e4:	607a      	str	r2, [r7, #4]
 80519e6:	e5ee      	b.n	80515c6 <_malloc_r+0x62>

080519e8 <memcmp>:
 80519e8:	b530      	push	{r4, r5, lr}
 80519ea:	3901      	subs	r1, #1
 80519ec:	2400      	movs	r4, #0
 80519ee:	42a2      	cmp	r2, r4
 80519f0:	d101      	bne.n	80519f6 <memcmp+0xe>
 80519f2:	2000      	movs	r0, #0
 80519f4:	e005      	b.n	8051a02 <memcmp+0x1a>
 80519f6:	5d03      	ldrb	r3, [r0, r4]
 80519f8:	3401      	adds	r4, #1
 80519fa:	5d0d      	ldrb	r5, [r1, r4]
 80519fc:	42ab      	cmp	r3, r5
 80519fe:	d0f6      	beq.n	80519ee <memcmp+0x6>
 8051a00:	1b58      	subs	r0, r3, r5
 8051a02:	bd30      	pop	{r4, r5, pc}

08051a04 <memcpy>:
 8051a04:	440a      	add	r2, r1
 8051a06:	4291      	cmp	r1, r2
 8051a08:	f100 33ff 	add.w	r3, r0, #4294967295
 8051a0c:	d100      	bne.n	8051a10 <memcpy+0xc>
 8051a0e:	4770      	bx	lr
 8051a10:	b510      	push	{r4, lr}
 8051a12:	f811 4b01 	ldrb.w	r4, [r1], #1
 8051a16:	f803 4f01 	strb.w	r4, [r3, #1]!
 8051a1a:	4291      	cmp	r1, r2
 8051a1c:	d1f9      	bne.n	8051a12 <memcpy+0xe>
 8051a1e:	bd10      	pop	{r4, pc}

08051a20 <memset>:
 8051a20:	4402      	add	r2, r0
 8051a22:	4603      	mov	r3, r0
 8051a24:	4293      	cmp	r3, r2
 8051a26:	d100      	bne.n	8051a2a <memset+0xa>
 8051a28:	4770      	bx	lr
 8051a2a:	f803 1b01 	strb.w	r1, [r3], #1
 8051a2e:	e7f9      	b.n	8051a24 <memset+0x4>

08051a30 <__malloc_lock>:
 8051a30:	4801      	ldr	r0, [pc, #4]	; (8051a38 <__malloc_lock+0x8>)
 8051a32:	f005 b8f7 	b.w	8056c24 <__retarget_lock_acquire_recursive>
 8051a36:	bf00      	nop
 8051a38:	200100b0 	.word	0x200100b0

08051a3c <__malloc_unlock>:
 8051a3c:	4801      	ldr	r0, [pc, #4]	; (8051a44 <__malloc_unlock+0x8>)
 8051a3e:	f005 b8f2 	b.w	8056c26 <__retarget_lock_release_recursive>
 8051a42:	bf00      	nop
 8051a44:	200100b0 	.word	0x200100b0

08051a48 <printf>:
 8051a48:	b40f      	push	{r0, r1, r2, r3}
 8051a4a:	b507      	push	{r0, r1, r2, lr}
 8051a4c:	4906      	ldr	r1, [pc, #24]	; (8051a68 <printf+0x20>)
 8051a4e:	ab04      	add	r3, sp, #16
 8051a50:	6808      	ldr	r0, [r1, #0]
 8051a52:	f853 2b04 	ldr.w	r2, [r3], #4
 8051a56:	6881      	ldr	r1, [r0, #8]
 8051a58:	9301      	str	r3, [sp, #4]
 8051a5a:	f002 f9b9 	bl	8053dd0 <_vfprintf_r>
 8051a5e:	b003      	add	sp, #12
 8051a60:	f85d eb04 	ldr.w	lr, [sp], #4
 8051a64:	b004      	add	sp, #16
 8051a66:	4770      	bx	lr
 8051a68:	200036d0 	.word	0x200036d0

08051a6c <_sbrk_r>:
 8051a6c:	b538      	push	{r3, r4, r5, lr}
 8051a6e:	4d06      	ldr	r5, [pc, #24]	; (8051a88 <_sbrk_r+0x1c>)
 8051a70:	2300      	movs	r3, #0
 8051a72:	4604      	mov	r4, r0
 8051a74:	4608      	mov	r0, r1
 8051a76:	602b      	str	r3, [r5, #0]
 8051a78:	f7fe fde2 	bl	8050640 <_sbrk>
 8051a7c:	1c43      	adds	r3, r0, #1
 8051a7e:	d102      	bne.n	8051a86 <_sbrk_r+0x1a>
 8051a80:	682b      	ldr	r3, [r5, #0]
 8051a82:	b103      	cbz	r3, 8051a86 <_sbrk_r+0x1a>
 8051a84:	6023      	str	r3, [r4, #0]
 8051a86:	bd38      	pop	{r3, r4, r5, pc}
 8051a88:	200100a8 	.word	0x200100a8

08051a8c <sprintf>:
 8051a8c:	b40e      	push	{r1, r2, r3}
 8051a8e:	b500      	push	{lr}
 8051a90:	b09c      	sub	sp, #112	; 0x70
 8051a92:	ab1d      	add	r3, sp, #116	; 0x74
 8051a94:	9002      	str	r0, [sp, #8]
 8051a96:	9006      	str	r0, [sp, #24]
 8051a98:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
 8051a9c:	4809      	ldr	r0, [pc, #36]	; (8051ac4 <sprintf+0x38>)
 8051a9e:	9107      	str	r1, [sp, #28]
 8051aa0:	9104      	str	r1, [sp, #16]
 8051aa2:	4909      	ldr	r1, [pc, #36]	; (8051ac8 <sprintf+0x3c>)
 8051aa4:	f853 2b04 	ldr.w	r2, [r3], #4
 8051aa8:	9105      	str	r1, [sp, #20]
 8051aaa:	6800      	ldr	r0, [r0, #0]
 8051aac:	9301      	str	r3, [sp, #4]
 8051aae:	a902      	add	r1, sp, #8
 8051ab0:	f000 ff5e 	bl	8052970 <_svfprintf_r>
 8051ab4:	9b02      	ldr	r3, [sp, #8]
 8051ab6:	2200      	movs	r2, #0
 8051ab8:	701a      	strb	r2, [r3, #0]
 8051aba:	b01c      	add	sp, #112	; 0x70
 8051abc:	f85d eb04 	ldr.w	lr, [sp], #4
 8051ac0:	b003      	add	sp, #12
 8051ac2:	4770      	bx	lr
 8051ac4:	200036d0 	.word	0x200036d0
 8051ac8:	ffff0208 	.word	0xffff0208

08051acc <strcat>:
 8051acc:	b510      	push	{r4, lr}
 8051ace:	4602      	mov	r2, r0
 8051ad0:	7814      	ldrb	r4, [r2, #0]
 8051ad2:	4613      	mov	r3, r2
 8051ad4:	3201      	adds	r2, #1
 8051ad6:	2c00      	cmp	r4, #0
 8051ad8:	d1fa      	bne.n	8051ad0 <strcat+0x4>
 8051ada:	3b01      	subs	r3, #1
 8051adc:	f811 2b01 	ldrb.w	r2, [r1], #1
 8051ae0:	f803 2f01 	strb.w	r2, [r3, #1]!
 8051ae4:	2a00      	cmp	r2, #0
 8051ae6:	d1f9      	bne.n	8051adc <strcat+0x10>
 8051ae8:	bd10      	pop	{r4, pc}

08051aea <strchr>:
 8051aea:	b2c9      	uxtb	r1, r1
 8051aec:	4603      	mov	r3, r0
 8051aee:	f810 2b01 	ldrb.w	r2, [r0], #1
 8051af2:	b11a      	cbz	r2, 8051afc <strchr+0x12>
 8051af4:	428a      	cmp	r2, r1
 8051af6:	d1f9      	bne.n	8051aec <strchr+0x2>
 8051af8:	4618      	mov	r0, r3
 8051afa:	4770      	bx	lr
 8051afc:	2900      	cmp	r1, #0
 8051afe:	bf18      	it	ne
 8051b00:	2300      	movne	r3, #0
 8051b02:	e7f9      	b.n	8051af8 <strchr+0xe>

08051b04 <strcpy>:
 8051b04:	4603      	mov	r3, r0
 8051b06:	f811 2b01 	ldrb.w	r2, [r1], #1
 8051b0a:	f803 2b01 	strb.w	r2, [r3], #1
 8051b0e:	2a00      	cmp	r2, #0
 8051b10:	d1f9      	bne.n	8051b06 <strcpy+0x2>
 8051b12:	4770      	bx	lr

08051b14 <strncat>:
 8051b14:	b530      	push	{r4, r5, lr}
 8051b16:	4604      	mov	r4, r0
 8051b18:	7825      	ldrb	r5, [r4, #0]
 8051b1a:	4623      	mov	r3, r4
 8051b1c:	3401      	adds	r4, #1
 8051b1e:	2d00      	cmp	r5, #0
 8051b20:	d1fa      	bne.n	8051b18 <strncat+0x4>
 8051b22:	3a01      	subs	r2, #1
 8051b24:	d304      	bcc.n	8051b30 <strncat+0x1c>
 8051b26:	f811 4b01 	ldrb.w	r4, [r1], #1
 8051b2a:	f803 4b01 	strb.w	r4, [r3], #1
 8051b2e:	b904      	cbnz	r4, 8051b32 <strncat+0x1e>
 8051b30:	bd30      	pop	{r4, r5, pc}
 8051b32:	2a00      	cmp	r2, #0
 8051b34:	d1f5      	bne.n	8051b22 <strncat+0xe>
 8051b36:	701a      	strb	r2, [r3, #0]
 8051b38:	e7f3      	b.n	8051b22 <strncat+0xe>

08051b3a <strncmp>:
 8051b3a:	b510      	push	{r4, lr}
 8051b3c:	b16a      	cbz	r2, 8051b5a <strncmp+0x20>
 8051b3e:	3901      	subs	r1, #1
 8051b40:	1884      	adds	r4, r0, r2
 8051b42:	f810 3b01 	ldrb.w	r3, [r0], #1
 8051b46:	f811 2f01 	ldrb.w	r2, [r1, #1]!
 8051b4a:	4293      	cmp	r3, r2
 8051b4c:	d103      	bne.n	8051b56 <strncmp+0x1c>
 8051b4e:	42a0      	cmp	r0, r4
 8051b50:	d001      	beq.n	8051b56 <strncmp+0x1c>
 8051b52:	2b00      	cmp	r3, #0
 8051b54:	d1f5      	bne.n	8051b42 <strncmp+0x8>
 8051b56:	1a98      	subs	r0, r3, r2
 8051b58:	bd10      	pop	{r4, pc}
 8051b5a:	4610      	mov	r0, r2
 8051b5c:	e7fc      	b.n	8051b58 <strncmp+0x1e>

08051b5e <strstr>:
 8051b5e:	b5f0      	push	{r4, r5, r6, r7, lr}
 8051b60:	780c      	ldrb	r4, [r1, #0]
 8051b62:	b164      	cbz	r4, 8051b7e <strstr+0x20>
 8051b64:	4603      	mov	r3, r0
 8051b66:	781a      	ldrb	r2, [r3, #0]
 8051b68:	4618      	mov	r0, r3
 8051b6a:	1c5e      	adds	r6, r3, #1
 8051b6c:	b90a      	cbnz	r2, 8051b72 <strstr+0x14>
 8051b6e:	4610      	mov	r0, r2
 8051b70:	e005      	b.n	8051b7e <strstr+0x20>
 8051b72:	4294      	cmp	r4, r2
 8051b74:	d108      	bne.n	8051b88 <strstr+0x2a>
 8051b76:	460d      	mov	r5, r1
 8051b78:	f815 2f01 	ldrb.w	r2, [r5, #1]!
 8051b7c:	b902      	cbnz	r2, 8051b80 <strstr+0x22>
 8051b7e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8051b80:	f813 7f01 	ldrb.w	r7, [r3, #1]!
 8051b84:	4297      	cmp	r7, r2
 8051b86:	d0f7      	beq.n	8051b78 <strstr+0x1a>
 8051b88:	4633      	mov	r3, r6
 8051b8a:	e7ec      	b.n	8051b66 <strstr+0x8>

08051b8c <sulp>:
 8051b8c:	b570      	push	{r4, r5, r6, lr}
 8051b8e:	4604      	mov	r4, r0
 8051b90:	460d      	mov	r5, r1
 8051b92:	ec45 4b10 	vmov	d0, r4, r5
 8051b96:	4616      	mov	r6, r2
 8051b98:	f005 fbe2 	bl	8057360 <__ulp>
 8051b9c:	ec51 0b10 	vmov	r0, r1, d0
 8051ba0:	b17e      	cbz	r6, 8051bc2 <sulp+0x36>
 8051ba2:	f3c5 530a 	ubfx	r3, r5, #20, #11
 8051ba6:	f1c3 036b 	rsb	r3, r3, #107	; 0x6b
 8051baa:	2b00      	cmp	r3, #0
 8051bac:	dd09      	ble.n	8051bc2 <sulp+0x36>
 8051bae:	051b      	lsls	r3, r3, #20
 8051bb0:	f103 557f 	add.w	r5, r3, #1069547520	; 0x3fc00000
 8051bb4:	2400      	movs	r4, #0
 8051bb6:	f505 1540 	add.w	r5, r5, #3145728	; 0x300000
 8051bba:	4622      	mov	r2, r4
 8051bbc:	462b      	mov	r3, r5
 8051bbe:	f7ee fd3b 	bl	8040638 <__aeabi_dmul>
 8051bc2:	bd70      	pop	{r4, r5, r6, pc}
 8051bc4:	0000      	movs	r0, r0
	...

08051bc8 <_strtod_l>:
 8051bc8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8051bcc:	b0a3      	sub	sp, #140	; 0x8c
 8051bce:	461f      	mov	r7, r3
 8051bd0:	2300      	movs	r3, #0
 8051bd2:	931e      	str	r3, [sp, #120]	; 0x78
 8051bd4:	4ba4      	ldr	r3, [pc, #656]	; (8051e68 <_strtod_l+0x2a0>)
 8051bd6:	9219      	str	r2, [sp, #100]	; 0x64
 8051bd8:	681b      	ldr	r3, [r3, #0]
 8051bda:	9307      	str	r3, [sp, #28]
 8051bdc:	4604      	mov	r4, r0
 8051bde:	4618      	mov	r0, r3
 8051be0:	4688      	mov	r8, r1
 8051be2:	f7ee fb0f 	bl	8040204 <strlen>
 8051be6:	f04f 0a00 	mov.w	sl, #0
 8051bea:	4605      	mov	r5, r0
 8051bec:	f04f 0b00 	mov.w	fp, #0
 8051bf0:	f8cd 8074 	str.w	r8, [sp, #116]	; 0x74
 8051bf4:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 8051bf6:	781a      	ldrb	r2, [r3, #0]
 8051bf8:	2a2b      	cmp	r2, #43	; 0x2b
 8051bfa:	d04c      	beq.n	8051c96 <_strtod_l+0xce>
 8051bfc:	d839      	bhi.n	8051c72 <_strtod_l+0xaa>
 8051bfe:	2a0d      	cmp	r2, #13
 8051c00:	d832      	bhi.n	8051c68 <_strtod_l+0xa0>
 8051c02:	2a08      	cmp	r2, #8
 8051c04:	d832      	bhi.n	8051c6c <_strtod_l+0xa4>
 8051c06:	2a00      	cmp	r2, #0
 8051c08:	d03c      	beq.n	8051c84 <_strtod_l+0xbc>
 8051c0a:	2300      	movs	r3, #0
 8051c0c:	930e      	str	r3, [sp, #56]	; 0x38
 8051c0e:	9e1d      	ldr	r6, [sp, #116]	; 0x74
 8051c10:	7833      	ldrb	r3, [r6, #0]
 8051c12:	2b30      	cmp	r3, #48	; 0x30
 8051c14:	f040 80b4 	bne.w	8051d80 <_strtod_l+0x1b8>
 8051c18:	7873      	ldrb	r3, [r6, #1]
 8051c1a:	f003 03df 	and.w	r3, r3, #223	; 0xdf
 8051c1e:	2b58      	cmp	r3, #88	; 0x58
 8051c20:	d16c      	bne.n	8051cfc <_strtod_l+0x134>
 8051c22:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8051c24:	9301      	str	r3, [sp, #4]
 8051c26:	ab1e      	add	r3, sp, #120	; 0x78
 8051c28:	9702      	str	r7, [sp, #8]
 8051c2a:	9300      	str	r3, [sp, #0]
 8051c2c:	4a8f      	ldr	r2, [pc, #572]	; (8051e6c <_strtod_l+0x2a4>)
 8051c2e:	ab1f      	add	r3, sp, #124	; 0x7c
 8051c30:	a91d      	add	r1, sp, #116	; 0x74
 8051c32:	4620      	mov	r0, r4
 8051c34:	f004 fce2 	bl	80565fc <__gethex>
 8051c38:	f010 0707 	ands.w	r7, r0, #7
 8051c3c:	4605      	mov	r5, r0
 8051c3e:	d005      	beq.n	8051c4c <_strtod_l+0x84>
 8051c40:	2f06      	cmp	r7, #6
 8051c42:	d12a      	bne.n	8051c9a <_strtod_l+0xd2>
 8051c44:	3601      	adds	r6, #1
 8051c46:	2300      	movs	r3, #0
 8051c48:	961d      	str	r6, [sp, #116]	; 0x74
 8051c4a:	930e      	str	r3, [sp, #56]	; 0x38
 8051c4c:	9b19      	ldr	r3, [sp, #100]	; 0x64
 8051c4e:	2b00      	cmp	r3, #0
 8051c50:	f040 8596 	bne.w	8052780 <_strtod_l+0xbb8>
 8051c54:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8051c56:	b1db      	cbz	r3, 8051c90 <_strtod_l+0xc8>
 8051c58:	4652      	mov	r2, sl
 8051c5a:	f10b 4300 	add.w	r3, fp, #2147483648	; 0x80000000
 8051c5e:	ec43 2b10 	vmov	d0, r2, r3
 8051c62:	b023      	add	sp, #140	; 0x8c
 8051c64:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8051c68:	2a20      	cmp	r2, #32
 8051c6a:	d1ce      	bne.n	8051c0a <_strtod_l+0x42>
 8051c6c:	3301      	adds	r3, #1
 8051c6e:	931d      	str	r3, [sp, #116]	; 0x74
 8051c70:	e7c0      	b.n	8051bf4 <_strtod_l+0x2c>
 8051c72:	2a2d      	cmp	r2, #45	; 0x2d
 8051c74:	d1c9      	bne.n	8051c0a <_strtod_l+0x42>
 8051c76:	2201      	movs	r2, #1
 8051c78:	920e      	str	r2, [sp, #56]	; 0x38
 8051c7a:	1c5a      	adds	r2, r3, #1
 8051c7c:	921d      	str	r2, [sp, #116]	; 0x74
 8051c7e:	785b      	ldrb	r3, [r3, #1]
 8051c80:	2b00      	cmp	r3, #0
 8051c82:	d1c4      	bne.n	8051c0e <_strtod_l+0x46>
 8051c84:	9b19      	ldr	r3, [sp, #100]	; 0x64
 8051c86:	f8cd 8074 	str.w	r8, [sp, #116]	; 0x74
 8051c8a:	2b00      	cmp	r3, #0
 8051c8c:	f040 8576 	bne.w	805277c <_strtod_l+0xbb4>
 8051c90:	4652      	mov	r2, sl
 8051c92:	465b      	mov	r3, fp
 8051c94:	e7e3      	b.n	8051c5e <_strtod_l+0x96>
 8051c96:	2200      	movs	r2, #0
 8051c98:	e7ee      	b.n	8051c78 <_strtod_l+0xb0>
 8051c9a:	9a1e      	ldr	r2, [sp, #120]	; 0x78
 8051c9c:	b13a      	cbz	r2, 8051cae <_strtod_l+0xe6>
 8051c9e:	2135      	movs	r1, #53	; 0x35
 8051ca0:	a820      	add	r0, sp, #128	; 0x80
 8051ca2:	f005 fc68 	bl	8057576 <__copybits>
 8051ca6:	991e      	ldr	r1, [sp, #120]	; 0x78
 8051ca8:	4620      	mov	r0, r4
 8051caa:	f005 f860 	bl	8056d6e <_Bfree>
 8051cae:	3f01      	subs	r7, #1
 8051cb0:	2f05      	cmp	r7, #5
 8051cb2:	d807      	bhi.n	8051cc4 <_strtod_l+0xfc>
 8051cb4:	e8df f007 	tbb	[pc, r7]
 8051cb8:	1d180b0e 	.word	0x1d180b0e
 8051cbc:	030e      	.short	0x030e
 8051cbe:	f04f 0b00 	mov.w	fp, #0
 8051cc2:	46da      	mov	sl, fp
 8051cc4:	0728      	lsls	r0, r5, #28
 8051cc6:	d5c1      	bpl.n	8051c4c <_strtod_l+0x84>
 8051cc8:	f04b 4b00 	orr.w	fp, fp, #2147483648	; 0x80000000
 8051ccc:	e7be      	b.n	8051c4c <_strtod_l+0x84>
 8051cce:	e9dd ab20 	ldrd	sl, fp, [sp, #128]	; 0x80
 8051cd2:	e7f7      	b.n	8051cc4 <_strtod_l+0xfc>
 8051cd4:	e9dd a320 	ldrd	sl, r3, [sp, #128]	; 0x80
 8051cd8:	9a1f      	ldr	r2, [sp, #124]	; 0x7c
 8051cda:	f423 1380 	bic.w	r3, r3, #1048576	; 0x100000
 8051cde:	f202 4233 	addw	r2, r2, #1075	; 0x433
 8051ce2:	ea43 5b02 	orr.w	fp, r3, r2, lsl #20
 8051ce6:	e7ed      	b.n	8051cc4 <_strtod_l+0xfc>
 8051ce8:	f8df b184 	ldr.w	fp, [pc, #388]	; 8051e70 <_strtod_l+0x2a8>
 8051cec:	f04f 0a00 	mov.w	sl, #0
 8051cf0:	e7e8      	b.n	8051cc4 <_strtod_l+0xfc>
 8051cf2:	f06f 4b00 	mvn.w	fp, #2147483648	; 0x80000000
 8051cf6:	f04f 3aff 	mov.w	sl, #4294967295
 8051cfa:	e7e3      	b.n	8051cc4 <_strtod_l+0xfc>
 8051cfc:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 8051cfe:	1c5a      	adds	r2, r3, #1
 8051d00:	921d      	str	r2, [sp, #116]	; 0x74
 8051d02:	785b      	ldrb	r3, [r3, #1]
 8051d04:	2b30      	cmp	r3, #48	; 0x30
 8051d06:	d0f9      	beq.n	8051cfc <_strtod_l+0x134>
 8051d08:	2b00      	cmp	r3, #0
 8051d0a:	d09f      	beq.n	8051c4c <_strtod_l+0x84>
 8051d0c:	2301      	movs	r3, #1
 8051d0e:	f04f 0900 	mov.w	r9, #0
 8051d12:	9304      	str	r3, [sp, #16]
 8051d14:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 8051d16:	930a      	str	r3, [sp, #40]	; 0x28
 8051d18:	f8cd 9024 	str.w	r9, [sp, #36]	; 0x24
 8051d1c:	464f      	mov	r7, r9
 8051d1e:	220a      	movs	r2, #10
 8051d20:	981d      	ldr	r0, [sp, #116]	; 0x74
 8051d22:	7806      	ldrb	r6, [r0, #0]
 8051d24:	f1a6 0330 	sub.w	r3, r6, #48	; 0x30
 8051d28:	b2d9      	uxtb	r1, r3
 8051d2a:	2909      	cmp	r1, #9
 8051d2c:	d92a      	bls.n	8051d84 <_strtod_l+0x1bc>
 8051d2e:	9907      	ldr	r1, [sp, #28]
 8051d30:	462a      	mov	r2, r5
 8051d32:	f7ff ff02 	bl	8051b3a <strncmp>
 8051d36:	b398      	cbz	r0, 8051da0 <_strtod_l+0x1d8>
 8051d38:	2000      	movs	r0, #0
 8051d3a:	4633      	mov	r3, r6
 8051d3c:	463d      	mov	r5, r7
 8051d3e:	9007      	str	r0, [sp, #28]
 8051d40:	4602      	mov	r2, r0
 8051d42:	2b65      	cmp	r3, #101	; 0x65
 8051d44:	d001      	beq.n	8051d4a <_strtod_l+0x182>
 8051d46:	2b45      	cmp	r3, #69	; 0x45
 8051d48:	d118      	bne.n	8051d7c <_strtod_l+0x1b4>
 8051d4a:	b91d      	cbnz	r5, 8051d54 <_strtod_l+0x18c>
 8051d4c:	9b04      	ldr	r3, [sp, #16]
 8051d4e:	4303      	orrs	r3, r0
 8051d50:	d098      	beq.n	8051c84 <_strtod_l+0xbc>
 8051d52:	2500      	movs	r5, #0
 8051d54:	f8dd 8074 	ldr.w	r8, [sp, #116]	; 0x74
 8051d58:	f108 0301 	add.w	r3, r8, #1
 8051d5c:	931d      	str	r3, [sp, #116]	; 0x74
 8051d5e:	f898 3001 	ldrb.w	r3, [r8, #1]
 8051d62:	2b2b      	cmp	r3, #43	; 0x2b
 8051d64:	d075      	beq.n	8051e52 <_strtod_l+0x28a>
 8051d66:	2b2d      	cmp	r3, #45	; 0x2d
 8051d68:	d07b      	beq.n	8051e62 <_strtod_l+0x29a>
 8051d6a:	f04f 0c00 	mov.w	ip, #0
 8051d6e:	f1a3 0130 	sub.w	r1, r3, #48	; 0x30
 8051d72:	2909      	cmp	r1, #9
 8051d74:	f240 8082 	bls.w	8051e7c <_strtod_l+0x2b4>
 8051d78:	f8cd 8074 	str.w	r8, [sp, #116]	; 0x74
 8051d7c:	2600      	movs	r6, #0
 8051d7e:	e09d      	b.n	8051ebc <_strtod_l+0x2f4>
 8051d80:	2300      	movs	r3, #0
 8051d82:	e7c4      	b.n	8051d0e <_strtod_l+0x146>
 8051d84:	2f08      	cmp	r7, #8
 8051d86:	bfd8      	it	le
 8051d88:	9909      	ldrle	r1, [sp, #36]	; 0x24
 8051d8a:	f100 0001 	add.w	r0, r0, #1
 8051d8e:	bfda      	itte	le
 8051d90:	fb02 3301 	mlale	r3, r2, r1, r3
 8051d94:	9309      	strle	r3, [sp, #36]	; 0x24
 8051d96:	fb02 3909 	mlagt	r9, r2, r9, r3
 8051d9a:	3701      	adds	r7, #1
 8051d9c:	901d      	str	r0, [sp, #116]	; 0x74
 8051d9e:	e7bf      	b.n	8051d20 <_strtod_l+0x158>
 8051da0:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 8051da2:	195a      	adds	r2, r3, r5
 8051da4:	921d      	str	r2, [sp, #116]	; 0x74
 8051da6:	5d5b      	ldrb	r3, [r3, r5]
 8051da8:	2f00      	cmp	r7, #0
 8051daa:	d037      	beq.n	8051e1c <_strtod_l+0x254>
 8051dac:	9007      	str	r0, [sp, #28]
 8051dae:	463d      	mov	r5, r7
 8051db0:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
 8051db4:	2a09      	cmp	r2, #9
 8051db6:	d912      	bls.n	8051dde <_strtod_l+0x216>
 8051db8:	2201      	movs	r2, #1
 8051dba:	e7c2      	b.n	8051d42 <_strtod_l+0x17a>
 8051dbc:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 8051dbe:	1c5a      	adds	r2, r3, #1
 8051dc0:	921d      	str	r2, [sp, #116]	; 0x74
 8051dc2:	785b      	ldrb	r3, [r3, #1]
 8051dc4:	3001      	adds	r0, #1
 8051dc6:	2b30      	cmp	r3, #48	; 0x30
 8051dc8:	d0f8      	beq.n	8051dbc <_strtod_l+0x1f4>
 8051dca:	f1a3 0231 	sub.w	r2, r3, #49	; 0x31
 8051dce:	2a08      	cmp	r2, #8
 8051dd0:	f200 84db 	bhi.w	805278a <_strtod_l+0xbc2>
 8051dd4:	9a1d      	ldr	r2, [sp, #116]	; 0x74
 8051dd6:	9007      	str	r0, [sp, #28]
 8051dd8:	2000      	movs	r0, #0
 8051dda:	920a      	str	r2, [sp, #40]	; 0x28
 8051ddc:	4605      	mov	r5, r0
 8051dde:	3b30      	subs	r3, #48	; 0x30
 8051de0:	f100 0201 	add.w	r2, r0, #1
 8051de4:	d014      	beq.n	8051e10 <_strtod_l+0x248>
 8051de6:	9907      	ldr	r1, [sp, #28]
 8051de8:	4411      	add	r1, r2
 8051dea:	9107      	str	r1, [sp, #28]
 8051dec:	462a      	mov	r2, r5
 8051dee:	eb00 0e05 	add.w	lr, r0, r5
 8051df2:	210a      	movs	r1, #10
 8051df4:	4572      	cmp	r2, lr
 8051df6:	d113      	bne.n	8051e20 <_strtod_l+0x258>
 8051df8:	182a      	adds	r2, r5, r0
 8051dfa:	2a08      	cmp	r2, #8
 8051dfc:	f105 0501 	add.w	r5, r5, #1
 8051e00:	4405      	add	r5, r0
 8051e02:	dc1c      	bgt.n	8051e3e <_strtod_l+0x276>
 8051e04:	9909      	ldr	r1, [sp, #36]	; 0x24
 8051e06:	220a      	movs	r2, #10
 8051e08:	fb02 3301 	mla	r3, r2, r1, r3
 8051e0c:	9309      	str	r3, [sp, #36]	; 0x24
 8051e0e:	2200      	movs	r2, #0
 8051e10:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 8051e12:	1c59      	adds	r1, r3, #1
 8051e14:	911d      	str	r1, [sp, #116]	; 0x74
 8051e16:	785b      	ldrb	r3, [r3, #1]
 8051e18:	4610      	mov	r0, r2
 8051e1a:	e7c9      	b.n	8051db0 <_strtod_l+0x1e8>
 8051e1c:	4638      	mov	r0, r7
 8051e1e:	e7d2      	b.n	8051dc6 <_strtod_l+0x1fe>
 8051e20:	2a08      	cmp	r2, #8
 8051e22:	dc04      	bgt.n	8051e2e <_strtod_l+0x266>
 8051e24:	9e09      	ldr	r6, [sp, #36]	; 0x24
 8051e26:	434e      	muls	r6, r1
 8051e28:	9609      	str	r6, [sp, #36]	; 0x24
 8051e2a:	3201      	adds	r2, #1
 8051e2c:	e7e2      	b.n	8051df4 <_strtod_l+0x22c>
 8051e2e:	f102 0c01 	add.w	ip, r2, #1
 8051e32:	f1bc 0f10 	cmp.w	ip, #16
 8051e36:	bfd8      	it	le
 8051e38:	fb01 f909 	mulle.w	r9, r1, r9
 8051e3c:	e7f5      	b.n	8051e2a <_strtod_l+0x262>
 8051e3e:	2d10      	cmp	r5, #16
 8051e40:	bfdc      	itt	le
 8051e42:	220a      	movle	r2, #10
 8051e44:	fb02 3909 	mlale	r9, r2, r9, r3
 8051e48:	e7e1      	b.n	8051e0e <_strtod_l+0x246>
 8051e4a:	2300      	movs	r3, #0
 8051e4c:	9307      	str	r3, [sp, #28]
 8051e4e:	2201      	movs	r2, #1
 8051e50:	e77c      	b.n	8051d4c <_strtod_l+0x184>
 8051e52:	f04f 0c00 	mov.w	ip, #0
 8051e56:	f108 0302 	add.w	r3, r8, #2
 8051e5a:	931d      	str	r3, [sp, #116]	; 0x74
 8051e5c:	f898 3002 	ldrb.w	r3, [r8, #2]
 8051e60:	e785      	b.n	8051d6e <_strtod_l+0x1a6>
 8051e62:	f04f 0c01 	mov.w	ip, #1
 8051e66:	e7f6      	b.n	8051e56 <_strtod_l+0x28e>
 8051e68:	0805add0 	.word	0x0805add0
 8051e6c:	0805ab00 	.word	0x0805ab00
 8051e70:	7ff00000 	.word	0x7ff00000
 8051e74:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 8051e76:	1c59      	adds	r1, r3, #1
 8051e78:	911d      	str	r1, [sp, #116]	; 0x74
 8051e7a:	785b      	ldrb	r3, [r3, #1]
 8051e7c:	2b30      	cmp	r3, #48	; 0x30
 8051e7e:	d0f9      	beq.n	8051e74 <_strtod_l+0x2ac>
 8051e80:	f1a3 0131 	sub.w	r1, r3, #49	; 0x31
 8051e84:	2908      	cmp	r1, #8
 8051e86:	f63f af79 	bhi.w	8051d7c <_strtod_l+0x1b4>
 8051e8a:	f1a3 0e30 	sub.w	lr, r3, #48	; 0x30
 8051e8e:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 8051e90:	9308      	str	r3, [sp, #32]
 8051e92:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 8051e94:	1c59      	adds	r1, r3, #1
 8051e96:	911d      	str	r1, [sp, #116]	; 0x74
 8051e98:	785b      	ldrb	r3, [r3, #1]
 8051e9a:	f1a3 0630 	sub.w	r6, r3, #48	; 0x30
 8051e9e:	2e09      	cmp	r6, #9
 8051ea0:	d937      	bls.n	8051f12 <_strtod_l+0x34a>
 8051ea2:	9e08      	ldr	r6, [sp, #32]
 8051ea4:	1b89      	subs	r1, r1, r6
 8051ea6:	2908      	cmp	r1, #8
 8051ea8:	f644 661f 	movw	r6, #19999	; 0x4e1f
 8051eac:	dc02      	bgt.n	8051eb4 <_strtod_l+0x2ec>
 8051eae:	4576      	cmp	r6, lr
 8051eb0:	bfa8      	it	ge
 8051eb2:	4676      	movge	r6, lr
 8051eb4:	f1bc 0f00 	cmp.w	ip, #0
 8051eb8:	d000      	beq.n	8051ebc <_strtod_l+0x2f4>
 8051eba:	4276      	negs	r6, r6
 8051ebc:	2d00      	cmp	r5, #0
 8051ebe:	d14f      	bne.n	8051f60 <_strtod_l+0x398>
 8051ec0:	9904      	ldr	r1, [sp, #16]
 8051ec2:	4301      	orrs	r1, r0
 8051ec4:	f47f aec2 	bne.w	8051c4c <_strtod_l+0x84>
 8051ec8:	2a00      	cmp	r2, #0
 8051eca:	f47f aedb 	bne.w	8051c84 <_strtod_l+0xbc>
 8051ece:	2b69      	cmp	r3, #105	; 0x69
 8051ed0:	d027      	beq.n	8051f22 <_strtod_l+0x35a>
 8051ed2:	dc24      	bgt.n	8051f1e <_strtod_l+0x356>
 8051ed4:	2b49      	cmp	r3, #73	; 0x49
 8051ed6:	d024      	beq.n	8051f22 <_strtod_l+0x35a>
 8051ed8:	2b4e      	cmp	r3, #78	; 0x4e
 8051eda:	f47f aed3 	bne.w	8051c84 <_strtod_l+0xbc>
 8051ede:	499e      	ldr	r1, [pc, #632]	; (8052158 <_strtod_l+0x590>)
 8051ee0:	a81d      	add	r0, sp, #116	; 0x74
 8051ee2:	f004 fde3 	bl	8056aac <__match>
 8051ee6:	2800      	cmp	r0, #0
 8051ee8:	f43f aecc 	beq.w	8051c84 <_strtod_l+0xbc>
 8051eec:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 8051eee:	781b      	ldrb	r3, [r3, #0]
 8051ef0:	2b28      	cmp	r3, #40	; 0x28
 8051ef2:	d12d      	bne.n	8051f50 <_strtod_l+0x388>
 8051ef4:	4999      	ldr	r1, [pc, #612]	; (805215c <_strtod_l+0x594>)
 8051ef6:	aa20      	add	r2, sp, #128	; 0x80
 8051ef8:	a81d      	add	r0, sp, #116	; 0x74
 8051efa:	f004 fdeb 	bl	8056ad4 <__hexnan>
 8051efe:	2805      	cmp	r0, #5
 8051f00:	d126      	bne.n	8051f50 <_strtod_l+0x388>
 8051f02:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8051f04:	f8dd a080 	ldr.w	sl, [sp, #128]	; 0x80
 8051f08:	f043 4bff 	orr.w	fp, r3, #2139095040	; 0x7f800000
 8051f0c:	f44b 0be0 	orr.w	fp, fp, #7340032	; 0x700000
 8051f10:	e69c      	b.n	8051c4c <_strtod_l+0x84>
 8051f12:	210a      	movs	r1, #10
 8051f14:	fb01 3e0e 	mla	lr, r1, lr, r3
 8051f18:	f1ae 0e30 	sub.w	lr, lr, #48	; 0x30
 8051f1c:	e7b9      	b.n	8051e92 <_strtod_l+0x2ca>
 8051f1e:	2b6e      	cmp	r3, #110	; 0x6e
 8051f20:	e7db      	b.n	8051eda <_strtod_l+0x312>
 8051f22:	498f      	ldr	r1, [pc, #572]	; (8052160 <_strtod_l+0x598>)
 8051f24:	a81d      	add	r0, sp, #116	; 0x74
 8051f26:	f004 fdc1 	bl	8056aac <__match>
 8051f2a:	2800      	cmp	r0, #0
 8051f2c:	f43f aeaa 	beq.w	8051c84 <_strtod_l+0xbc>
 8051f30:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 8051f32:	498c      	ldr	r1, [pc, #560]	; (8052164 <_strtod_l+0x59c>)
 8051f34:	3b01      	subs	r3, #1
 8051f36:	a81d      	add	r0, sp, #116	; 0x74
 8051f38:	931d      	str	r3, [sp, #116]	; 0x74
 8051f3a:	f004 fdb7 	bl	8056aac <__match>
 8051f3e:	b910      	cbnz	r0, 8051f46 <_strtod_l+0x37e>
 8051f40:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 8051f42:	3301      	adds	r3, #1
 8051f44:	931d      	str	r3, [sp, #116]	; 0x74
 8051f46:	f8df b22c 	ldr.w	fp, [pc, #556]	; 8052174 <_strtod_l+0x5ac>
 8051f4a:	f04f 0a00 	mov.w	sl, #0
 8051f4e:	e67d      	b.n	8051c4c <_strtod_l+0x84>
 8051f50:	4885      	ldr	r0, [pc, #532]	; (8052168 <_strtod_l+0x5a0>)
 8051f52:	f005 fb8d 	bl	8057670 <nan>
 8051f56:	ed8d 0b04 	vstr	d0, [sp, #16]
 8051f5a:	e9dd ab04 	ldrd	sl, fp, [sp, #16]
 8051f5e:	e675      	b.n	8051c4c <_strtod_l+0x84>
 8051f60:	9b07      	ldr	r3, [sp, #28]
 8051f62:	9809      	ldr	r0, [sp, #36]	; 0x24
 8051f64:	1af3      	subs	r3, r6, r3
 8051f66:	2f00      	cmp	r7, #0
 8051f68:	bf08      	it	eq
 8051f6a:	462f      	moveq	r7, r5
 8051f6c:	2d10      	cmp	r5, #16
 8051f6e:	9308      	str	r3, [sp, #32]
 8051f70:	46a8      	mov	r8, r5
 8051f72:	bfa8      	it	ge
 8051f74:	f04f 0810 	movge.w	r8, #16
 8051f78:	f7ee fae4 	bl	8040544 <__aeabi_ui2d>
 8051f7c:	2d09      	cmp	r5, #9
 8051f7e:	4682      	mov	sl, r0
 8051f80:	468b      	mov	fp, r1
 8051f82:	dd13      	ble.n	8051fac <_strtod_l+0x3e4>
 8051f84:	4b79      	ldr	r3, [pc, #484]	; (805216c <_strtod_l+0x5a4>)
 8051f86:	eb03 03c8 	add.w	r3, r3, r8, lsl #3
 8051f8a:	e953 2312 	ldrd	r2, r3, [r3, #-72]	; 0x48
 8051f8e:	f7ee fb53 	bl	8040638 <__aeabi_dmul>
 8051f92:	4682      	mov	sl, r0
 8051f94:	4648      	mov	r0, r9
 8051f96:	468b      	mov	fp, r1
 8051f98:	f7ee fad4 	bl	8040544 <__aeabi_ui2d>
 8051f9c:	4602      	mov	r2, r0
 8051f9e:	460b      	mov	r3, r1
 8051fa0:	4650      	mov	r0, sl
 8051fa2:	4659      	mov	r1, fp
 8051fa4:	f7ee f992 	bl	80402cc <__adddf3>
 8051fa8:	4682      	mov	sl, r0
 8051faa:	468b      	mov	fp, r1
 8051fac:	2d0f      	cmp	r5, #15
 8051fae:	dc38      	bgt.n	8052022 <_strtod_l+0x45a>
 8051fb0:	9b08      	ldr	r3, [sp, #32]
 8051fb2:	2b00      	cmp	r3, #0
 8051fb4:	f43f ae4a 	beq.w	8051c4c <_strtod_l+0x84>
 8051fb8:	dd24      	ble.n	8052004 <_strtod_l+0x43c>
 8051fba:	2b16      	cmp	r3, #22
 8051fbc:	dc0b      	bgt.n	8051fd6 <_strtod_l+0x40e>
 8051fbe:	4d6b      	ldr	r5, [pc, #428]	; (805216c <_strtod_l+0x5a4>)
 8051fc0:	eb05 05c3 	add.w	r5, r5, r3, lsl #3
 8051fc4:	e9d5 0100 	ldrd	r0, r1, [r5]
 8051fc8:	4652      	mov	r2, sl
 8051fca:	465b      	mov	r3, fp
 8051fcc:	f7ee fb34 	bl	8040638 <__aeabi_dmul>
 8051fd0:	4682      	mov	sl, r0
 8051fd2:	468b      	mov	fp, r1
 8051fd4:	e63a      	b.n	8051c4c <_strtod_l+0x84>
 8051fd6:	9a08      	ldr	r2, [sp, #32]
 8051fd8:	f1c5 0325 	rsb	r3, r5, #37	; 0x25
 8051fdc:	4293      	cmp	r3, r2
 8051fde:	db20      	blt.n	8052022 <_strtod_l+0x45a>
 8051fe0:	4c62      	ldr	r4, [pc, #392]	; (805216c <_strtod_l+0x5a4>)
 8051fe2:	f1c5 050f 	rsb	r5, r5, #15
 8051fe6:	eb04 01c5 	add.w	r1, r4, r5, lsl #3
 8051fea:	4652      	mov	r2, sl
 8051fec:	465b      	mov	r3, fp
 8051fee:	e9d1 0100 	ldrd	r0, r1, [r1]
 8051ff2:	f7ee fb21 	bl	8040638 <__aeabi_dmul>
 8051ff6:	9b08      	ldr	r3, [sp, #32]
 8051ff8:	1b5d      	subs	r5, r3, r5
 8051ffa:	eb04 04c5 	add.w	r4, r4, r5, lsl #3
 8051ffe:	e9d4 2300 	ldrd	r2, r3, [r4]
 8052002:	e7e3      	b.n	8051fcc <_strtod_l+0x404>
 8052004:	9b08      	ldr	r3, [sp, #32]
 8052006:	3316      	adds	r3, #22
 8052008:	db0b      	blt.n	8052022 <_strtod_l+0x45a>
 805200a:	9b07      	ldr	r3, [sp, #28]
 805200c:	4a57      	ldr	r2, [pc, #348]	; (805216c <_strtod_l+0x5a4>)
 805200e:	1b9e      	subs	r6, r3, r6
 8052010:	eb02 06c6 	add.w	r6, r2, r6, lsl #3
 8052014:	e9d6 2300 	ldrd	r2, r3, [r6]
 8052018:	4650      	mov	r0, sl
 805201a:	4659      	mov	r1, fp
 805201c:	f7ee fc36 	bl	804088c <__aeabi_ddiv>
 8052020:	e7d6      	b.n	8051fd0 <_strtod_l+0x408>
 8052022:	9b08      	ldr	r3, [sp, #32]
 8052024:	eba5 0808 	sub.w	r8, r5, r8
 8052028:	4498      	add	r8, r3
 805202a:	f1b8 0f00 	cmp.w	r8, #0
 805202e:	dd71      	ble.n	8052114 <_strtod_l+0x54c>
 8052030:	f018 030f 	ands.w	r3, r8, #15
 8052034:	d00a      	beq.n	805204c <_strtod_l+0x484>
 8052036:	494d      	ldr	r1, [pc, #308]	; (805216c <_strtod_l+0x5a4>)
 8052038:	eb01 01c3 	add.w	r1, r1, r3, lsl #3
 805203c:	4652      	mov	r2, sl
 805203e:	465b      	mov	r3, fp
 8052040:	e9d1 0100 	ldrd	r0, r1, [r1]
 8052044:	f7ee faf8 	bl	8040638 <__aeabi_dmul>
 8052048:	4682      	mov	sl, r0
 805204a:	468b      	mov	fp, r1
 805204c:	f038 080f 	bics.w	r8, r8, #15
 8052050:	d04d      	beq.n	80520ee <_strtod_l+0x526>
 8052052:	f5b8 7f9a 	cmp.w	r8, #308	; 0x134
 8052056:	dd22      	ble.n	805209e <_strtod_l+0x4d6>
 8052058:	2500      	movs	r5, #0
 805205a:	462e      	mov	r6, r5
 805205c:	9509      	str	r5, [sp, #36]	; 0x24
 805205e:	9507      	str	r5, [sp, #28]
 8052060:	2322      	movs	r3, #34	; 0x22
 8052062:	f8df b110 	ldr.w	fp, [pc, #272]	; 8052174 <_strtod_l+0x5ac>
 8052066:	6023      	str	r3, [r4, #0]
 8052068:	f04f 0a00 	mov.w	sl, #0
 805206c:	9b09      	ldr	r3, [sp, #36]	; 0x24
 805206e:	2b00      	cmp	r3, #0
 8052070:	f43f adec 	beq.w	8051c4c <_strtod_l+0x84>
 8052074:	991e      	ldr	r1, [sp, #120]	; 0x78
 8052076:	4620      	mov	r0, r4
 8052078:	f004 fe79 	bl	8056d6e <_Bfree>
 805207c:	9907      	ldr	r1, [sp, #28]
 805207e:	4620      	mov	r0, r4
 8052080:	f004 fe75 	bl	8056d6e <_Bfree>
 8052084:	4631      	mov	r1, r6
 8052086:	4620      	mov	r0, r4
 8052088:	f004 fe71 	bl	8056d6e <_Bfree>
 805208c:	9909      	ldr	r1, [sp, #36]	; 0x24
 805208e:	4620      	mov	r0, r4
 8052090:	f004 fe6d 	bl	8056d6e <_Bfree>
 8052094:	4629      	mov	r1, r5
 8052096:	4620      	mov	r0, r4
 8052098:	f004 fe69 	bl	8056d6e <_Bfree>
 805209c:	e5d6      	b.n	8051c4c <_strtod_l+0x84>
 805209e:	2300      	movs	r3, #0
 80520a0:	ea4f 1828 	mov.w	r8, r8, asr #4
 80520a4:	4650      	mov	r0, sl
 80520a6:	4659      	mov	r1, fp
 80520a8:	4699      	mov	r9, r3
 80520aa:	f1b8 0f01 	cmp.w	r8, #1
 80520ae:	dc21      	bgt.n	80520f4 <_strtod_l+0x52c>
 80520b0:	b10b      	cbz	r3, 80520b6 <_strtod_l+0x4ee>
 80520b2:	4682      	mov	sl, r0
 80520b4:	468b      	mov	fp, r1
 80520b6:	4b2e      	ldr	r3, [pc, #184]	; (8052170 <_strtod_l+0x5a8>)
 80520b8:	f1ab 7b54 	sub.w	fp, fp, #55574528	; 0x3500000
 80520bc:	eb03 09c9 	add.w	r9, r3, r9, lsl #3
 80520c0:	4652      	mov	r2, sl
 80520c2:	465b      	mov	r3, fp
 80520c4:	e9d9 0100 	ldrd	r0, r1, [r9]
 80520c8:	f7ee fab6 	bl	8040638 <__aeabi_dmul>
 80520cc:	4b29      	ldr	r3, [pc, #164]	; (8052174 <_strtod_l+0x5ac>)
 80520ce:	460a      	mov	r2, r1
 80520d0:	400b      	ands	r3, r1
 80520d2:	4929      	ldr	r1, [pc, #164]	; (8052178 <_strtod_l+0x5b0>)
 80520d4:	428b      	cmp	r3, r1
 80520d6:	4682      	mov	sl, r0
 80520d8:	d8be      	bhi.n	8052058 <_strtod_l+0x490>
 80520da:	f5a1 1180 	sub.w	r1, r1, #1048576	; 0x100000
 80520de:	428b      	cmp	r3, r1
 80520e0:	bf86      	itte	hi
 80520e2:	f8df b098 	ldrhi.w	fp, [pc, #152]	; 805217c <_strtod_l+0x5b4>
 80520e6:	f04f 3aff 	movhi.w	sl, #4294967295
 80520ea:	f102 7b54 	addls.w	fp, r2, #55574528	; 0x3500000
 80520ee:	2300      	movs	r3, #0
 80520f0:	9304      	str	r3, [sp, #16]
 80520f2:	e081      	b.n	80521f8 <_strtod_l+0x630>
 80520f4:	f018 0f01 	tst.w	r8, #1
 80520f8:	d007      	beq.n	805210a <_strtod_l+0x542>
 80520fa:	4b1d      	ldr	r3, [pc, #116]	; (8052170 <_strtod_l+0x5a8>)
 80520fc:	eb03 03c9 	add.w	r3, r3, r9, lsl #3
 8052100:	e9d3 2300 	ldrd	r2, r3, [r3]
 8052104:	f7ee fa98 	bl	8040638 <__aeabi_dmul>
 8052108:	2301      	movs	r3, #1
 805210a:	f109 0901 	add.w	r9, r9, #1
 805210e:	ea4f 0868 	mov.w	r8, r8, asr #1
 8052112:	e7ca      	b.n	80520aa <_strtod_l+0x4e2>
 8052114:	d0eb      	beq.n	80520ee <_strtod_l+0x526>
 8052116:	f1c8 0800 	rsb	r8, r8, #0
 805211a:	f018 020f 	ands.w	r2, r8, #15
 805211e:	d00a      	beq.n	8052136 <_strtod_l+0x56e>
 8052120:	4b12      	ldr	r3, [pc, #72]	; (805216c <_strtod_l+0x5a4>)
 8052122:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 8052126:	4650      	mov	r0, sl
 8052128:	4659      	mov	r1, fp
 805212a:	e9d3 2300 	ldrd	r2, r3, [r3]
 805212e:	f7ee fbad 	bl	804088c <__aeabi_ddiv>
 8052132:	4682      	mov	sl, r0
 8052134:	468b      	mov	fp, r1
 8052136:	ea5f 1828 	movs.w	r8, r8, asr #4
 805213a:	d0d8      	beq.n	80520ee <_strtod_l+0x526>
 805213c:	f1b8 0f1f 	cmp.w	r8, #31
 8052140:	dd1e      	ble.n	8052180 <_strtod_l+0x5b8>
 8052142:	2500      	movs	r5, #0
 8052144:	462e      	mov	r6, r5
 8052146:	9509      	str	r5, [sp, #36]	; 0x24
 8052148:	9507      	str	r5, [sp, #28]
 805214a:	2322      	movs	r3, #34	; 0x22
 805214c:	f04f 0a00 	mov.w	sl, #0
 8052150:	f04f 0b00 	mov.w	fp, #0
 8052154:	6023      	str	r3, [r4, #0]
 8052156:	e789      	b.n	805206c <_strtod_l+0x4a4>
 8052158:	0805ab5d 	.word	0x0805ab5d
 805215c:	0805ab14 	.word	0x0805ab14
 8052160:	0805ab55 	.word	0x0805ab55
 8052164:	0805acf1 	.word	0x0805acf1
 8052168:	0805af9f 	.word	0x0805af9f
 805216c:	0805ae70 	.word	0x0805ae70
 8052170:	0805ae48 	.word	0x0805ae48
 8052174:	7ff00000 	.word	0x7ff00000
 8052178:	7ca00000 	.word	0x7ca00000
 805217c:	7fefffff 	.word	0x7fefffff
 8052180:	f018 0310 	ands.w	r3, r8, #16
 8052184:	bf18      	it	ne
 8052186:	236a      	movne	r3, #106	; 0x6a
 8052188:	f8df 93b4 	ldr.w	r9, [pc, #948]	; 8052540 <_strtod_l+0x978>
 805218c:	9304      	str	r3, [sp, #16]
 805218e:	4650      	mov	r0, sl
 8052190:	4659      	mov	r1, fp
 8052192:	2300      	movs	r3, #0
 8052194:	f018 0f01 	tst.w	r8, #1
 8052198:	d004      	beq.n	80521a4 <_strtod_l+0x5dc>
 805219a:	e9d9 2300 	ldrd	r2, r3, [r9]
 805219e:	f7ee fa4b 	bl	8040638 <__aeabi_dmul>
 80521a2:	2301      	movs	r3, #1
 80521a4:	ea5f 0868 	movs.w	r8, r8, asr #1
 80521a8:	f109 0908 	add.w	r9, r9, #8
 80521ac:	d1f2      	bne.n	8052194 <_strtod_l+0x5cc>
 80521ae:	b10b      	cbz	r3, 80521b4 <_strtod_l+0x5ec>
 80521b0:	4682      	mov	sl, r0
 80521b2:	468b      	mov	fp, r1
 80521b4:	9b04      	ldr	r3, [sp, #16]
 80521b6:	b1bb      	cbz	r3, 80521e8 <_strtod_l+0x620>
 80521b8:	f3cb 530a 	ubfx	r3, fp, #20, #11
 80521bc:	f1c3 036b 	rsb	r3, r3, #107	; 0x6b
 80521c0:	2b00      	cmp	r3, #0
 80521c2:	4659      	mov	r1, fp
 80521c4:	dd10      	ble.n	80521e8 <_strtod_l+0x620>
 80521c6:	2b1f      	cmp	r3, #31
 80521c8:	f340 8128 	ble.w	805241c <_strtod_l+0x854>
 80521cc:	2b34      	cmp	r3, #52	; 0x34
 80521ce:	bfde      	ittt	le
 80521d0:	3b20      	suble	r3, #32
 80521d2:	f04f 32ff 	movle.w	r2, #4294967295
 80521d6:	fa02 f303 	lslle.w	r3, r2, r3
 80521da:	f04f 0a00 	mov.w	sl, #0
 80521de:	bfcc      	ite	gt
 80521e0:	f04f 7b5c 	movgt.w	fp, #57671680	; 0x3700000
 80521e4:	ea03 0b01 	andle.w	fp, r3, r1
 80521e8:	2200      	movs	r2, #0
 80521ea:	2300      	movs	r3, #0
 80521ec:	4650      	mov	r0, sl
 80521ee:	4659      	mov	r1, fp
 80521f0:	f7ee fc8a 	bl	8040b08 <__aeabi_dcmpeq>
 80521f4:	2800      	cmp	r0, #0
 80521f6:	d1a4      	bne.n	8052142 <_strtod_l+0x57a>
 80521f8:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80521fa:	9300      	str	r3, [sp, #0]
 80521fc:	990a      	ldr	r1, [sp, #40]	; 0x28
 80521fe:	462b      	mov	r3, r5
 8052200:	463a      	mov	r2, r7
 8052202:	4620      	mov	r0, r4
 8052204:	f004 fe06 	bl	8056e14 <__s2b>
 8052208:	9009      	str	r0, [sp, #36]	; 0x24
 805220a:	2800      	cmp	r0, #0
 805220c:	f43f af24 	beq.w	8052058 <_strtod_l+0x490>
 8052210:	9b07      	ldr	r3, [sp, #28]
 8052212:	1b9e      	subs	r6, r3, r6
 8052214:	9b08      	ldr	r3, [sp, #32]
 8052216:	2b00      	cmp	r3, #0
 8052218:	bfb4      	ite	lt
 805221a:	4633      	movlt	r3, r6
 805221c:	2300      	movge	r3, #0
 805221e:	9310      	str	r3, [sp, #64]	; 0x40
 8052220:	9b08      	ldr	r3, [sp, #32]
 8052222:	2500      	movs	r5, #0
 8052224:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 8052228:	9318      	str	r3, [sp, #96]	; 0x60
 805222a:	462e      	mov	r6, r5
 805222c:	9b09      	ldr	r3, [sp, #36]	; 0x24
 805222e:	4620      	mov	r0, r4
 8052230:	6859      	ldr	r1, [r3, #4]
 8052232:	f004 fd77 	bl	8056d24 <_Balloc>
 8052236:	9007      	str	r0, [sp, #28]
 8052238:	2800      	cmp	r0, #0
 805223a:	f43f af11 	beq.w	8052060 <_strtod_l+0x498>
 805223e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8052240:	691a      	ldr	r2, [r3, #16]
 8052242:	3202      	adds	r2, #2
 8052244:	f103 010c 	add.w	r1, r3, #12
 8052248:	0092      	lsls	r2, r2, #2
 805224a:	300c      	adds	r0, #12
 805224c:	f7ff fbda 	bl	8051a04 <memcpy>
 8052250:	ec4b ab10 	vmov	d0, sl, fp
 8052254:	aa20      	add	r2, sp, #128	; 0x80
 8052256:	a91f      	add	r1, sp, #124	; 0x7c
 8052258:	4620      	mov	r0, r4
 805225a:	e9cd ab0a 	strd	sl, fp, [sp, #40]	; 0x28
 805225e:	f005 f8fb 	bl	8057458 <__d2b>
 8052262:	901e      	str	r0, [sp, #120]	; 0x78
 8052264:	2800      	cmp	r0, #0
 8052266:	f43f aefb 	beq.w	8052060 <_strtod_l+0x498>
 805226a:	2101      	movs	r1, #1
 805226c:	4620      	mov	r0, r4
 805226e:	f004 fe6b 	bl	8056f48 <__i2b>
 8052272:	4606      	mov	r6, r0
 8052274:	2800      	cmp	r0, #0
 8052276:	f43f aef3 	beq.w	8052060 <_strtod_l+0x498>
 805227a:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 805227c:	9904      	ldr	r1, [sp, #16]
 805227e:	2b00      	cmp	r3, #0
 8052280:	bfab      	itete	ge
 8052282:	9a10      	ldrge	r2, [sp, #64]	; 0x40
 8052284:	9a18      	ldrlt	r2, [sp, #96]	; 0x60
 8052286:	9f18      	ldrge	r7, [sp, #96]	; 0x60
 8052288:	f8dd 9040 	ldrlt.w	r9, [sp, #64]	; 0x40
 805228c:	bfac      	ite	ge
 805228e:	eb03 0902 	addge.w	r9, r3, r2
 8052292:	1ad7      	sublt	r7, r2, r3
 8052294:	9a20      	ldr	r2, [sp, #128]	; 0x80
 8052296:	eba3 0801 	sub.w	r8, r3, r1
 805229a:	4490      	add	r8, r2
 805229c:	4ba3      	ldr	r3, [pc, #652]	; (805252c <_strtod_l+0x964>)
 805229e:	f108 38ff 	add.w	r8, r8, #4294967295
 80522a2:	4598      	cmp	r8, r3
 80522a4:	f1c2 0236 	rsb	r2, r2, #54	; 0x36
 80522a8:	f280 80cc 	bge.w	8052444 <_strtod_l+0x87c>
 80522ac:	eba3 0308 	sub.w	r3, r3, r8
 80522b0:	2b1f      	cmp	r3, #31
 80522b2:	eba2 0203 	sub.w	r2, r2, r3
 80522b6:	f04f 0101 	mov.w	r1, #1
 80522ba:	f300 80b6 	bgt.w	805242a <_strtod_l+0x862>
 80522be:	fa01 f303 	lsl.w	r3, r1, r3
 80522c2:	9311      	str	r3, [sp, #68]	; 0x44
 80522c4:	2300      	movs	r3, #0
 80522c6:	930c      	str	r3, [sp, #48]	; 0x30
 80522c8:	eb09 0802 	add.w	r8, r9, r2
 80522cc:	9b04      	ldr	r3, [sp, #16]
 80522ce:	45c1      	cmp	r9, r8
 80522d0:	4417      	add	r7, r2
 80522d2:	441f      	add	r7, r3
 80522d4:	464b      	mov	r3, r9
 80522d6:	bfa8      	it	ge
 80522d8:	4643      	movge	r3, r8
 80522da:	42bb      	cmp	r3, r7
 80522dc:	bfa8      	it	ge
 80522de:	463b      	movge	r3, r7
 80522e0:	2b00      	cmp	r3, #0
 80522e2:	bfc2      	ittt	gt
 80522e4:	eba8 0803 	subgt.w	r8, r8, r3
 80522e8:	1aff      	subgt	r7, r7, r3
 80522ea:	eba9 0903 	subgt.w	r9, r9, r3
 80522ee:	9b10      	ldr	r3, [sp, #64]	; 0x40
 80522f0:	2b00      	cmp	r3, #0
 80522f2:	dd17      	ble.n	8052324 <_strtod_l+0x75c>
 80522f4:	4631      	mov	r1, r6
 80522f6:	461a      	mov	r2, r3
 80522f8:	4620      	mov	r0, r4
 80522fa:	f004 fee1 	bl	80570c0 <__pow5mult>
 80522fe:	4606      	mov	r6, r0
 8052300:	2800      	cmp	r0, #0
 8052302:	f43f aead 	beq.w	8052060 <_strtod_l+0x498>
 8052306:	4601      	mov	r1, r0
 8052308:	9a1e      	ldr	r2, [sp, #120]	; 0x78
 805230a:	4620      	mov	r0, r4
 805230c:	f004 fe32 	bl	8056f74 <__multiply>
 8052310:	900f      	str	r0, [sp, #60]	; 0x3c
 8052312:	2800      	cmp	r0, #0
 8052314:	f43f aea4 	beq.w	8052060 <_strtod_l+0x498>
 8052318:	991e      	ldr	r1, [sp, #120]	; 0x78
 805231a:	4620      	mov	r0, r4
 805231c:	f004 fd27 	bl	8056d6e <_Bfree>
 8052320:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8052322:	931e      	str	r3, [sp, #120]	; 0x78
 8052324:	f1b8 0f00 	cmp.w	r8, #0
 8052328:	f300 8091 	bgt.w	805244e <_strtod_l+0x886>
 805232c:	9b08      	ldr	r3, [sp, #32]
 805232e:	2b00      	cmp	r3, #0
 8052330:	dd08      	ble.n	8052344 <_strtod_l+0x77c>
 8052332:	9a18      	ldr	r2, [sp, #96]	; 0x60
 8052334:	9907      	ldr	r1, [sp, #28]
 8052336:	4620      	mov	r0, r4
 8052338:	f004 fec2 	bl	80570c0 <__pow5mult>
 805233c:	9007      	str	r0, [sp, #28]
 805233e:	2800      	cmp	r0, #0
 8052340:	f43f ae8e 	beq.w	8052060 <_strtod_l+0x498>
 8052344:	2f00      	cmp	r7, #0
 8052346:	dd08      	ble.n	805235a <_strtod_l+0x792>
 8052348:	9907      	ldr	r1, [sp, #28]
 805234a:	463a      	mov	r2, r7
 805234c:	4620      	mov	r0, r4
 805234e:	f004 fef7 	bl	8057140 <__lshift>
 8052352:	9007      	str	r0, [sp, #28]
 8052354:	2800      	cmp	r0, #0
 8052356:	f43f ae83 	beq.w	8052060 <_strtod_l+0x498>
 805235a:	f1b9 0f00 	cmp.w	r9, #0
 805235e:	dd08      	ble.n	8052372 <_strtod_l+0x7aa>
 8052360:	4631      	mov	r1, r6
 8052362:	464a      	mov	r2, r9
 8052364:	4620      	mov	r0, r4
 8052366:	f004 feeb 	bl	8057140 <__lshift>
 805236a:	4606      	mov	r6, r0
 805236c:	2800      	cmp	r0, #0
 805236e:	f43f ae77 	beq.w	8052060 <_strtod_l+0x498>
 8052372:	9a07      	ldr	r2, [sp, #28]
 8052374:	991e      	ldr	r1, [sp, #120]	; 0x78
 8052376:	4620      	mov	r0, r4
 8052378:	f004 ff6a 	bl	8057250 <__mdiff>
 805237c:	4605      	mov	r5, r0
 805237e:	2800      	cmp	r0, #0
 8052380:	f43f ae6e 	beq.w	8052060 <_strtod_l+0x498>
 8052384:	68c3      	ldr	r3, [r0, #12]
 8052386:	930f      	str	r3, [sp, #60]	; 0x3c
 8052388:	2300      	movs	r3, #0
 805238a:	60c3      	str	r3, [r0, #12]
 805238c:	4631      	mov	r1, r6
 805238e:	f004 ff43 	bl	8057218 <__mcmp>
 8052392:	2800      	cmp	r0, #0
 8052394:	da65      	bge.n	8052462 <_strtod_l+0x89a>
 8052396:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8052398:	ea53 030a 	orrs.w	r3, r3, sl
 805239c:	f040 8087 	bne.w	80524ae <_strtod_l+0x8e6>
 80523a0:	f3cb 0313 	ubfx	r3, fp, #0, #20
 80523a4:	2b00      	cmp	r3, #0
 80523a6:	f040 8082 	bne.w	80524ae <_strtod_l+0x8e6>
 80523aa:	f02b 4300 	bic.w	r3, fp, #2147483648	; 0x80000000
 80523ae:	0d1b      	lsrs	r3, r3, #20
 80523b0:	051b      	lsls	r3, r3, #20
 80523b2:	f1b3 6fd6 	cmp.w	r3, #112197632	; 0x6b00000
 80523b6:	d97a      	bls.n	80524ae <_strtod_l+0x8e6>
 80523b8:	696b      	ldr	r3, [r5, #20]
 80523ba:	b913      	cbnz	r3, 80523c2 <_strtod_l+0x7fa>
 80523bc:	692b      	ldr	r3, [r5, #16]
 80523be:	2b01      	cmp	r3, #1
 80523c0:	dd75      	ble.n	80524ae <_strtod_l+0x8e6>
 80523c2:	4629      	mov	r1, r5
 80523c4:	2201      	movs	r2, #1
 80523c6:	4620      	mov	r0, r4
 80523c8:	f004 feba 	bl	8057140 <__lshift>
 80523cc:	4631      	mov	r1, r6
 80523ce:	4605      	mov	r5, r0
 80523d0:	f004 ff22 	bl	8057218 <__mcmp>
 80523d4:	2800      	cmp	r0, #0
 80523d6:	dd6a      	ble.n	80524ae <_strtod_l+0x8e6>
 80523d8:	9904      	ldr	r1, [sp, #16]
 80523da:	4a55      	ldr	r2, [pc, #340]	; (8052530 <_strtod_l+0x968>)
 80523dc:	465b      	mov	r3, fp
 80523de:	2900      	cmp	r1, #0
 80523e0:	f000 8085 	beq.w	80524ee <_strtod_l+0x926>
 80523e4:	ea02 010b 	and.w	r1, r2, fp
 80523e8:	f1b1 6fd6 	cmp.w	r1, #112197632	; 0x6b00000
 80523ec:	dc7f      	bgt.n	80524ee <_strtod_l+0x926>
 80523ee:	f1b1 7f5c 	cmp.w	r1, #57671680	; 0x3700000
 80523f2:	f77f aeaa 	ble.w	805214a <_strtod_l+0x582>
 80523f6:	4a4f      	ldr	r2, [pc, #316]	; (8052534 <_strtod_l+0x96c>)
 80523f8:	2300      	movs	r3, #0
 80523fa:	e9cd 3216 	strd	r3, r2, [sp, #88]	; 0x58
 80523fe:	4650      	mov	r0, sl
 8052400:	e9dd 2316 	ldrd	r2, r3, [sp, #88]	; 0x58
 8052404:	4659      	mov	r1, fp
 8052406:	f7ee f917 	bl	8040638 <__aeabi_dmul>
 805240a:	460b      	mov	r3, r1
 805240c:	4303      	orrs	r3, r0
 805240e:	bf08      	it	eq
 8052410:	2322      	moveq	r3, #34	; 0x22
 8052412:	4682      	mov	sl, r0
 8052414:	468b      	mov	fp, r1
 8052416:	bf08      	it	eq
 8052418:	6023      	streq	r3, [r4, #0]
 805241a:	e62b      	b.n	8052074 <_strtod_l+0x4ac>
 805241c:	f04f 32ff 	mov.w	r2, #4294967295
 8052420:	fa02 f303 	lsl.w	r3, r2, r3
 8052424:	ea03 0a0a 	and.w	sl, r3, sl
 8052428:	e6de      	b.n	80521e8 <_strtod_l+0x620>
 805242a:	f1c8 487f 	rsb	r8, r8, #4278190080	; 0xff000000
 805242e:	f508 087f 	add.w	r8, r8, #16711680	; 0xff0000
 8052432:	f508 487b 	add.w	r8, r8, #64256	; 0xfb00
 8052436:	f108 08e2 	add.w	r8, r8, #226	; 0xe2
 805243a:	fa01 f308 	lsl.w	r3, r1, r8
 805243e:	930c      	str	r3, [sp, #48]	; 0x30
 8052440:	9111      	str	r1, [sp, #68]	; 0x44
 8052442:	e741      	b.n	80522c8 <_strtod_l+0x700>
 8052444:	2300      	movs	r3, #0
 8052446:	930c      	str	r3, [sp, #48]	; 0x30
 8052448:	2301      	movs	r3, #1
 805244a:	9311      	str	r3, [sp, #68]	; 0x44
 805244c:	e73c      	b.n	80522c8 <_strtod_l+0x700>
 805244e:	991e      	ldr	r1, [sp, #120]	; 0x78
 8052450:	4642      	mov	r2, r8
 8052452:	4620      	mov	r0, r4
 8052454:	f004 fe74 	bl	8057140 <__lshift>
 8052458:	901e      	str	r0, [sp, #120]	; 0x78
 805245a:	2800      	cmp	r0, #0
 805245c:	f47f af66 	bne.w	805232c <_strtod_l+0x764>
 8052460:	e5fe      	b.n	8052060 <_strtod_l+0x498>
 8052462:	465f      	mov	r7, fp
 8052464:	d16e      	bne.n	8052544 <_strtod_l+0x97c>
 8052466:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8052468:	f3cb 0313 	ubfx	r3, fp, #0, #20
 805246c:	b342      	cbz	r2, 80524c0 <_strtod_l+0x8f8>
 805246e:	4a32      	ldr	r2, [pc, #200]	; (8052538 <_strtod_l+0x970>)
 8052470:	4293      	cmp	r3, r2
 8052472:	d128      	bne.n	80524c6 <_strtod_l+0x8fe>
 8052474:	9b04      	ldr	r3, [sp, #16]
 8052476:	4650      	mov	r0, sl
 8052478:	b1eb      	cbz	r3, 80524b6 <_strtod_l+0x8ee>
 805247a:	4a2d      	ldr	r2, [pc, #180]	; (8052530 <_strtod_l+0x968>)
 805247c:	403a      	ands	r2, r7
 805247e:	f1b2 6fd4 	cmp.w	r2, #111149056	; 0x6a00000
 8052482:	f04f 31ff 	mov.w	r1, #4294967295
 8052486:	d819      	bhi.n	80524bc <_strtod_l+0x8f4>
 8052488:	0d12      	lsrs	r2, r2, #20
 805248a:	f1c2 036b 	rsb	r3, r2, #107	; 0x6b
 805248e:	fa01 f303 	lsl.w	r3, r1, r3
 8052492:	4298      	cmp	r0, r3
 8052494:	d117      	bne.n	80524c6 <_strtod_l+0x8fe>
 8052496:	4b29      	ldr	r3, [pc, #164]	; (805253c <_strtod_l+0x974>)
 8052498:	429f      	cmp	r7, r3
 805249a:	d102      	bne.n	80524a2 <_strtod_l+0x8da>
 805249c:	3001      	adds	r0, #1
 805249e:	f43f addf 	beq.w	8052060 <_strtod_l+0x498>
 80524a2:	4b23      	ldr	r3, [pc, #140]	; (8052530 <_strtod_l+0x968>)
 80524a4:	403b      	ands	r3, r7
 80524a6:	f503 1b80 	add.w	fp, r3, #1048576	; 0x100000
 80524aa:	f04f 0a00 	mov.w	sl, #0
 80524ae:	9b04      	ldr	r3, [sp, #16]
 80524b0:	2b00      	cmp	r3, #0
 80524b2:	d1a0      	bne.n	80523f6 <_strtod_l+0x82e>
 80524b4:	e5de      	b.n	8052074 <_strtod_l+0x4ac>
 80524b6:	f04f 33ff 	mov.w	r3, #4294967295
 80524ba:	e7ea      	b.n	8052492 <_strtod_l+0x8ca>
 80524bc:	460b      	mov	r3, r1
 80524be:	e7e8      	b.n	8052492 <_strtod_l+0x8ca>
 80524c0:	ea53 030a 	orrs.w	r3, r3, sl
 80524c4:	d088      	beq.n	80523d8 <_strtod_l+0x810>
 80524c6:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80524c8:	b1db      	cbz	r3, 8052502 <_strtod_l+0x93a>
 80524ca:	423b      	tst	r3, r7
 80524cc:	d0ef      	beq.n	80524ae <_strtod_l+0x8e6>
 80524ce:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 80524d0:	9a04      	ldr	r2, [sp, #16]
 80524d2:	4650      	mov	r0, sl
 80524d4:	4659      	mov	r1, fp
 80524d6:	b1c3      	cbz	r3, 805250a <_strtod_l+0x942>
 80524d8:	f7ff fb58 	bl	8051b8c <sulp>
 80524dc:	4602      	mov	r2, r0
 80524de:	460b      	mov	r3, r1
 80524e0:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
 80524e4:	f7ed fef2 	bl	80402cc <__adddf3>
 80524e8:	4682      	mov	sl, r0
 80524ea:	468b      	mov	fp, r1
 80524ec:	e7df      	b.n	80524ae <_strtod_l+0x8e6>
 80524ee:	4013      	ands	r3, r2
 80524f0:	f5a3 1380 	sub.w	r3, r3, #1048576	; 0x100000
 80524f4:	ea6f 5b13 	mvn.w	fp, r3, lsr #20
 80524f8:	ea6f 5b0b 	mvn.w	fp, fp, lsl #20
 80524fc:	f04f 3aff 	mov.w	sl, #4294967295
 8052500:	e7d5      	b.n	80524ae <_strtod_l+0x8e6>
 8052502:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8052504:	ea13 0f0a 	tst.w	r3, sl
 8052508:	e7e0      	b.n	80524cc <_strtod_l+0x904>
 805250a:	f7ff fb3f 	bl	8051b8c <sulp>
 805250e:	4602      	mov	r2, r0
 8052510:	460b      	mov	r3, r1
 8052512:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
 8052516:	f7ed fed7 	bl	80402c8 <__aeabi_dsub>
 805251a:	2200      	movs	r2, #0
 805251c:	2300      	movs	r3, #0
 805251e:	4682      	mov	sl, r0
 8052520:	468b      	mov	fp, r1
 8052522:	f7ee faf1 	bl	8040b08 <__aeabi_dcmpeq>
 8052526:	2800      	cmp	r0, #0
 8052528:	d0c1      	beq.n	80524ae <_strtod_l+0x8e6>
 805252a:	e60e      	b.n	805214a <_strtod_l+0x582>
 805252c:	fffffc02 	.word	0xfffffc02
 8052530:	7ff00000 	.word	0x7ff00000
 8052534:	39500000 	.word	0x39500000
 8052538:	000fffff 	.word	0x000fffff
 805253c:	7fefffff 	.word	0x7fefffff
 8052540:	0805ab28 	.word	0x0805ab28
 8052544:	4631      	mov	r1, r6
 8052546:	4628      	mov	r0, r5
 8052548:	f004 ffe2 	bl	8057510 <__ratio>
 805254c:	ec59 8b10 	vmov	r8, r9, d0
 8052550:	ee10 0a10 	vmov	r0, s0
 8052554:	2200      	movs	r2, #0
 8052556:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 805255a:	4649      	mov	r1, r9
 805255c:	f7ee fae8 	bl	8040b30 <__aeabi_dcmple>
 8052560:	2800      	cmp	r0, #0
 8052562:	d07c      	beq.n	805265e <_strtod_l+0xa96>
 8052564:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8052566:	2b00      	cmp	r3, #0
 8052568:	d04c      	beq.n	8052604 <_strtod_l+0xa3c>
 805256a:	4b95      	ldr	r3, [pc, #596]	; (80527c0 <_strtod_l+0xbf8>)
 805256c:	2200      	movs	r2, #0
 805256e:	e9cd 230c 	strd	r2, r3, [sp, #48]	; 0x30
 8052572:	f8df 924c 	ldr.w	r9, [pc, #588]	; 80527c0 <_strtod_l+0xbf8>
 8052576:	f04f 0800 	mov.w	r8, #0
 805257a:	4b92      	ldr	r3, [pc, #584]	; (80527c4 <_strtod_l+0xbfc>)
 805257c:	403b      	ands	r3, r7
 805257e:	9311      	str	r3, [sp, #68]	; 0x44
 8052580:	9a11      	ldr	r2, [sp, #68]	; 0x44
 8052582:	4b91      	ldr	r3, [pc, #580]	; (80527c8 <_strtod_l+0xc00>)
 8052584:	429a      	cmp	r2, r3
 8052586:	f040 80b2 	bne.w	80526ee <_strtod_l+0xb26>
 805258a:	e9dd 230a 	ldrd	r2, r3, [sp, #40]	; 0x28
 805258e:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
 8052592:	f1a7 7b54 	sub.w	fp, r7, #55574528	; 0x3500000
 8052596:	ec4b ab10 	vmov	d0, sl, fp
 805259a:	e9cd 2316 	strd	r2, r3, [sp, #88]	; 0x58
 805259e:	e9cd 010c 	strd	r0, r1, [sp, #48]	; 0x30
 80525a2:	f004 fedd 	bl	8057360 <__ulp>
 80525a6:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
 80525aa:	ec53 2b10 	vmov	r2, r3, d0
 80525ae:	f7ee f843 	bl	8040638 <__aeabi_dmul>
 80525b2:	4652      	mov	r2, sl
 80525b4:	465b      	mov	r3, fp
 80525b6:	f7ed fe89 	bl	80402cc <__adddf3>
 80525ba:	460b      	mov	r3, r1
 80525bc:	4981      	ldr	r1, [pc, #516]	; (80527c4 <_strtod_l+0xbfc>)
 80525be:	4a83      	ldr	r2, [pc, #524]	; (80527cc <_strtod_l+0xc04>)
 80525c0:	4019      	ands	r1, r3
 80525c2:	4291      	cmp	r1, r2
 80525c4:	4682      	mov	sl, r0
 80525c6:	d95e      	bls.n	8052686 <_strtod_l+0xabe>
 80525c8:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80525ca:	f102 7254 	add.w	r2, r2, #55574528	; 0x3500000
 80525ce:	4293      	cmp	r3, r2
 80525d0:	d103      	bne.n	80525da <_strtod_l+0xa12>
 80525d2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80525d4:	3301      	adds	r3, #1
 80525d6:	f43f ad43 	beq.w	8052060 <_strtod_l+0x498>
 80525da:	f8df b1fc 	ldr.w	fp, [pc, #508]	; 80527d8 <_strtod_l+0xc10>
 80525de:	f04f 3aff 	mov.w	sl, #4294967295
 80525e2:	991e      	ldr	r1, [sp, #120]	; 0x78
 80525e4:	4620      	mov	r0, r4
 80525e6:	f004 fbc2 	bl	8056d6e <_Bfree>
 80525ea:	9907      	ldr	r1, [sp, #28]
 80525ec:	4620      	mov	r0, r4
 80525ee:	f004 fbbe 	bl	8056d6e <_Bfree>
 80525f2:	4631      	mov	r1, r6
 80525f4:	4620      	mov	r0, r4
 80525f6:	f004 fbba 	bl	8056d6e <_Bfree>
 80525fa:	4629      	mov	r1, r5
 80525fc:	4620      	mov	r0, r4
 80525fe:	f004 fbb6 	bl	8056d6e <_Bfree>
 8052602:	e613      	b.n	805222c <_strtod_l+0x664>
 8052604:	f1ba 0f00 	cmp.w	sl, #0
 8052608:	d11b      	bne.n	8052642 <_strtod_l+0xa7a>
 805260a:	f3cb 0313 	ubfx	r3, fp, #0, #20
 805260e:	b9f3      	cbnz	r3, 805264e <_strtod_l+0xa86>
 8052610:	4b6b      	ldr	r3, [pc, #428]	; (80527c0 <_strtod_l+0xbf8>)
 8052612:	2200      	movs	r2, #0
 8052614:	4640      	mov	r0, r8
 8052616:	4649      	mov	r1, r9
 8052618:	f7ee fa80 	bl	8040b1c <__aeabi_dcmplt>
 805261c:	b9d0      	cbnz	r0, 8052654 <_strtod_l+0xa8c>
 805261e:	4640      	mov	r0, r8
 8052620:	4649      	mov	r1, r9
 8052622:	4b6b      	ldr	r3, [pc, #428]	; (80527d0 <_strtod_l+0xc08>)
 8052624:	2200      	movs	r2, #0
 8052626:	f7ee f807 	bl	8040638 <__aeabi_dmul>
 805262a:	4680      	mov	r8, r0
 805262c:	4689      	mov	r9, r1
 805262e:	f109 4300 	add.w	r3, r9, #2147483648	; 0x80000000
 8052632:	f8cd 8068 	str.w	r8, [sp, #104]	; 0x68
 8052636:	931b      	str	r3, [sp, #108]	; 0x6c
 8052638:	e9dd 231a 	ldrd	r2, r3, [sp, #104]	; 0x68
 805263c:	e9cd 230c 	strd	r2, r3, [sp, #48]	; 0x30
 8052640:	e79b      	b.n	805257a <_strtod_l+0x9b2>
 8052642:	f1ba 0f01 	cmp.w	sl, #1
 8052646:	d102      	bne.n	805264e <_strtod_l+0xa86>
 8052648:	2f00      	cmp	r7, #0
 805264a:	f43f ad7e 	beq.w	805214a <_strtod_l+0x582>
 805264e:	4b61      	ldr	r3, [pc, #388]	; (80527d4 <_strtod_l+0xc0c>)
 8052650:	2200      	movs	r2, #0
 8052652:	e78c      	b.n	805256e <_strtod_l+0x9a6>
 8052654:	f8df 9178 	ldr.w	r9, [pc, #376]	; 80527d0 <_strtod_l+0xc08>
 8052658:	f04f 0800 	mov.w	r8, #0
 805265c:	e7e7      	b.n	805262e <_strtod_l+0xa66>
 805265e:	4b5c      	ldr	r3, [pc, #368]	; (80527d0 <_strtod_l+0xc08>)
 8052660:	4640      	mov	r0, r8
 8052662:	4649      	mov	r1, r9
 8052664:	2200      	movs	r2, #0
 8052666:	f7ed ffe7 	bl	8040638 <__aeabi_dmul>
 805266a:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 805266c:	4680      	mov	r8, r0
 805266e:	4689      	mov	r9, r1
 8052670:	b933      	cbnz	r3, 8052680 <_strtod_l+0xab8>
 8052672:	f101 4300 	add.w	r3, r1, #2147483648	; 0x80000000
 8052676:	9012      	str	r0, [sp, #72]	; 0x48
 8052678:	9313      	str	r3, [sp, #76]	; 0x4c
 805267a:	e9dd 2312 	ldrd	r2, r3, [sp, #72]	; 0x48
 805267e:	e7dd      	b.n	805263c <_strtod_l+0xa74>
 8052680:	e9cd 8912 	strd	r8, r9, [sp, #72]	; 0x48
 8052684:	e7f9      	b.n	805267a <_strtod_l+0xab2>
 8052686:	f103 7b54 	add.w	fp, r3, #55574528	; 0x3500000
 805268a:	9b04      	ldr	r3, [sp, #16]
 805268c:	2b00      	cmp	r3, #0
 805268e:	d1a8      	bne.n	80525e2 <_strtod_l+0xa1a>
 8052690:	f02b 4300 	bic.w	r3, fp, #2147483648	; 0x80000000
 8052694:	9a11      	ldr	r2, [sp, #68]	; 0x44
 8052696:	0d1b      	lsrs	r3, r3, #20
 8052698:	051b      	lsls	r3, r3, #20
 805269a:	429a      	cmp	r2, r3
 805269c:	d1a1      	bne.n	80525e2 <_strtod_l+0xa1a>
 805269e:	4640      	mov	r0, r8
 80526a0:	4649      	mov	r1, r9
 80526a2:	f7ee fb29 	bl	8040cf8 <__aeabi_d2lz>
 80526a6:	f7ed ff99 	bl	80405dc <__aeabi_l2d>
 80526aa:	4602      	mov	r2, r0
 80526ac:	460b      	mov	r3, r1
 80526ae:	4640      	mov	r0, r8
 80526b0:	4649      	mov	r1, r9
 80526b2:	f7ed fe09 	bl	80402c8 <__aeabi_dsub>
 80526b6:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 80526b8:	f3cb 0313 	ubfx	r3, fp, #0, #20
 80526bc:	ea43 030a 	orr.w	r3, r3, sl
 80526c0:	4313      	orrs	r3, r2
 80526c2:	4680      	mov	r8, r0
 80526c4:	4689      	mov	r9, r1
 80526c6:	d053      	beq.n	8052770 <_strtod_l+0xba8>
 80526c8:	a335      	add	r3, pc, #212	; (adr r3, 80527a0 <_strtod_l+0xbd8>)
 80526ca:	e9d3 2300 	ldrd	r2, r3, [r3]
 80526ce:	f7ee fa25 	bl	8040b1c <__aeabi_dcmplt>
 80526d2:	2800      	cmp	r0, #0
 80526d4:	f47f acce 	bne.w	8052074 <_strtod_l+0x4ac>
 80526d8:	a333      	add	r3, pc, #204	; (adr r3, 80527a8 <_strtod_l+0xbe0>)
 80526da:	e9d3 2300 	ldrd	r2, r3, [r3]
 80526de:	4640      	mov	r0, r8
 80526e0:	4649      	mov	r1, r9
 80526e2:	f7ee fa39 	bl	8040b58 <__aeabi_dcmpgt>
 80526e6:	2800      	cmp	r0, #0
 80526e8:	f43f af7b 	beq.w	80525e2 <_strtod_l+0xa1a>
 80526ec:	e4c2      	b.n	8052074 <_strtod_l+0x4ac>
 80526ee:	9b04      	ldr	r3, [sp, #16]
 80526f0:	b333      	cbz	r3, 8052740 <_strtod_l+0xb78>
 80526f2:	9b11      	ldr	r3, [sp, #68]	; 0x44
 80526f4:	f1b3 6fd4 	cmp.w	r3, #111149056	; 0x6a00000
 80526f8:	d822      	bhi.n	8052740 <_strtod_l+0xb78>
 80526fa:	a32d      	add	r3, pc, #180	; (adr r3, 80527b0 <_strtod_l+0xbe8>)
 80526fc:	e9d3 2300 	ldrd	r2, r3, [r3]
 8052700:	4640      	mov	r0, r8
 8052702:	4649      	mov	r1, r9
 8052704:	f7ee fa14 	bl	8040b30 <__aeabi_dcmple>
 8052708:	b1a0      	cbz	r0, 8052734 <_strtod_l+0xb6c>
 805270a:	4649      	mov	r1, r9
 805270c:	4640      	mov	r0, r8
 805270e:	f7ee fa6b 	bl	8040be8 <__aeabi_d2uiz>
 8052712:	2801      	cmp	r0, #1
 8052714:	bf38      	it	cc
 8052716:	2001      	movcc	r0, #1
 8052718:	f7ed ff14 	bl	8040544 <__aeabi_ui2d>
 805271c:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 805271e:	4680      	mov	r8, r0
 8052720:	4689      	mov	r9, r1
 8052722:	bb13      	cbnz	r3, 805276a <_strtod_l+0xba2>
 8052724:	f101 4300 	add.w	r3, r1, #2147483648	; 0x80000000
 8052728:	9014      	str	r0, [sp, #80]	; 0x50
 805272a:	9315      	str	r3, [sp, #84]	; 0x54
 805272c:	e9dd 2314 	ldrd	r2, r3, [sp, #80]	; 0x50
 8052730:	e9cd 230c 	strd	r2, r3, [sp, #48]	; 0x30
 8052734:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8052736:	9a11      	ldr	r2, [sp, #68]	; 0x44
 8052738:	f103 63d6 	add.w	r3, r3, #112197632	; 0x6b00000
 805273c:	1a9b      	subs	r3, r3, r2
 805273e:	930d      	str	r3, [sp, #52]	; 0x34
 8052740:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
 8052744:	ed9d 0b0a 	vldr	d0, [sp, #40]	; 0x28
 8052748:	e9cd 010c 	strd	r0, r1, [sp, #48]	; 0x30
 805274c:	f004 fe08 	bl	8057360 <__ulp>
 8052750:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
 8052754:	ec53 2b10 	vmov	r2, r3, d0
 8052758:	f7ed ff6e 	bl	8040638 <__aeabi_dmul>
 805275c:	e9dd 230a 	ldrd	r2, r3, [sp, #40]	; 0x28
 8052760:	f7ed fdb4 	bl	80402cc <__adddf3>
 8052764:	4682      	mov	sl, r0
 8052766:	468b      	mov	fp, r1
 8052768:	e78f      	b.n	805268a <_strtod_l+0xac2>
 805276a:	e9cd 8914 	strd	r8, r9, [sp, #80]	; 0x50
 805276e:	e7dd      	b.n	805272c <_strtod_l+0xb64>
 8052770:	a311      	add	r3, pc, #68	; (adr r3, 80527b8 <_strtod_l+0xbf0>)
 8052772:	e9d3 2300 	ldrd	r2, r3, [r3]
 8052776:	f7ee f9d1 	bl	8040b1c <__aeabi_dcmplt>
 805277a:	e7b4      	b.n	80526e6 <_strtod_l+0xb1e>
 805277c:	2300      	movs	r3, #0
 805277e:	930e      	str	r3, [sp, #56]	; 0x38
 8052780:	9a19      	ldr	r2, [sp, #100]	; 0x64
 8052782:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 8052784:	6013      	str	r3, [r2, #0]
 8052786:	f7ff ba65 	b.w	8051c54 <_strtod_l+0x8c>
 805278a:	2b65      	cmp	r3, #101	; 0x65
 805278c:	f43f ab5d 	beq.w	8051e4a <_strtod_l+0x282>
 8052790:	2b45      	cmp	r3, #69	; 0x45
 8052792:	f43f ab5a 	beq.w	8051e4a <_strtod_l+0x282>
 8052796:	2201      	movs	r2, #1
 8052798:	f7ff bb92 	b.w	8051ec0 <_strtod_l+0x2f8>
 805279c:	f3af 8000 	nop.w
 80527a0:	94a03595 	.word	0x94a03595
 80527a4:	3fdfffff 	.word	0x3fdfffff
 80527a8:	35afe535 	.word	0x35afe535
 80527ac:	3fe00000 	.word	0x3fe00000
 80527b0:	ffc00000 	.word	0xffc00000
 80527b4:	41dfffff 	.word	0x41dfffff
 80527b8:	94a03595 	.word	0x94a03595
 80527bc:	3fcfffff 	.word	0x3fcfffff
 80527c0:	3ff00000 	.word	0x3ff00000
 80527c4:	7ff00000 	.word	0x7ff00000
 80527c8:	7fe00000 	.word	0x7fe00000
 80527cc:	7c9fffff 	.word	0x7c9fffff
 80527d0:	3fe00000 	.word	0x3fe00000
 80527d4:	bff00000 	.word	0xbff00000
 80527d8:	7fefffff 	.word	0x7fefffff

080527dc <strtod>:
 80527dc:	460a      	mov	r2, r1
 80527de:	4601      	mov	r1, r0
 80527e0:	4802      	ldr	r0, [pc, #8]	; (80527ec <strtod+0x10>)
 80527e2:	4b03      	ldr	r3, [pc, #12]	; (80527f0 <strtod+0x14>)
 80527e4:	6800      	ldr	r0, [r0, #0]
 80527e6:	f7ff b9ef 	b.w	8051bc8 <_strtod_l>
 80527ea:	bf00      	nop
 80527ec:	200036d0 	.word	0x200036d0
 80527f0:	20003f18 	.word	0x20003f18

080527f4 <strtok>:
 80527f4:	4b02      	ldr	r3, [pc, #8]	; (8052800 <strtok+0xc>)
 80527f6:	681a      	ldr	r2, [r3, #0]
 80527f8:	2301      	movs	r3, #1
 80527fa:	325c      	adds	r2, #92	; 0x5c
 80527fc:	f000 b802 	b.w	8052804 <__strtok_r>
 8052800:	200036d0 	.word	0x200036d0

08052804 <__strtok_r>:
 8052804:	b5f0      	push	{r4, r5, r6, r7, lr}
 8052806:	b908      	cbnz	r0, 805280c <__strtok_r+0x8>
 8052808:	6810      	ldr	r0, [r2, #0]
 805280a:	b188      	cbz	r0, 8052830 <__strtok_r+0x2c>
 805280c:	4604      	mov	r4, r0
 805280e:	4620      	mov	r0, r4
 8052810:	f814 5b01 	ldrb.w	r5, [r4], #1
 8052814:	460f      	mov	r7, r1
 8052816:	f817 6b01 	ldrb.w	r6, [r7], #1
 805281a:	b91e      	cbnz	r6, 8052824 <__strtok_r+0x20>
 805281c:	b965      	cbnz	r5, 8052838 <__strtok_r+0x34>
 805281e:	6015      	str	r5, [r2, #0]
 8052820:	4628      	mov	r0, r5
 8052822:	e005      	b.n	8052830 <__strtok_r+0x2c>
 8052824:	42b5      	cmp	r5, r6
 8052826:	d1f6      	bne.n	8052816 <__strtok_r+0x12>
 8052828:	2b00      	cmp	r3, #0
 805282a:	d1f0      	bne.n	805280e <__strtok_r+0xa>
 805282c:	6014      	str	r4, [r2, #0]
 805282e:	7003      	strb	r3, [r0, #0]
 8052830:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8052832:	461c      	mov	r4, r3
 8052834:	e00c      	b.n	8052850 <__strtok_r+0x4c>
 8052836:	b915      	cbnz	r5, 805283e <__strtok_r+0x3a>
 8052838:	f814 3b01 	ldrb.w	r3, [r4], #1
 805283c:	460e      	mov	r6, r1
 805283e:	f816 5b01 	ldrb.w	r5, [r6], #1
 8052842:	42ab      	cmp	r3, r5
 8052844:	d1f7      	bne.n	8052836 <__strtok_r+0x32>
 8052846:	2b00      	cmp	r3, #0
 8052848:	d0f3      	beq.n	8052832 <__strtok_r+0x2e>
 805284a:	2300      	movs	r3, #0
 805284c:	f804 3c01 	strb.w	r3, [r4, #-1]
 8052850:	6014      	str	r4, [r2, #0]
 8052852:	e7ed      	b.n	8052830 <__strtok_r+0x2c>

08052854 <_strtol_l.isra.0>:
 8052854:	2b01      	cmp	r3, #1
 8052856:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 805285a:	d001      	beq.n	8052860 <_strtol_l.isra.0+0xc>
 805285c:	2b24      	cmp	r3, #36	; 0x24
 805285e:	d906      	bls.n	805286e <_strtol_l.isra.0+0x1a>
 8052860:	f003 fbf6 	bl	8056050 <__errno>
 8052864:	2316      	movs	r3, #22
 8052866:	6003      	str	r3, [r0, #0]
 8052868:	2000      	movs	r0, #0
 805286a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 805286e:	4f3a      	ldr	r7, [pc, #232]	; (8052958 <_strtol_l.isra.0+0x104>)
 8052870:	468e      	mov	lr, r1
 8052872:	4676      	mov	r6, lr
 8052874:	f81e 4b01 	ldrb.w	r4, [lr], #1
 8052878:	5de5      	ldrb	r5, [r4, r7]
 805287a:	f015 0508 	ands.w	r5, r5, #8
 805287e:	d1f8      	bne.n	8052872 <_strtol_l.isra.0+0x1e>
 8052880:	2c2d      	cmp	r4, #45	; 0x2d
 8052882:	d134      	bne.n	80528ee <_strtol_l.isra.0+0x9a>
 8052884:	f89e 4000 	ldrb.w	r4, [lr]
 8052888:	f04f 0801 	mov.w	r8, #1
 805288c:	f106 0e02 	add.w	lr, r6, #2
 8052890:	2b00      	cmp	r3, #0
 8052892:	d05c      	beq.n	805294e <_strtol_l.isra.0+0xfa>
 8052894:	2b10      	cmp	r3, #16
 8052896:	d10c      	bne.n	80528b2 <_strtol_l.isra.0+0x5e>
 8052898:	2c30      	cmp	r4, #48	; 0x30
 805289a:	d10a      	bne.n	80528b2 <_strtol_l.isra.0+0x5e>
 805289c:	f89e 4000 	ldrb.w	r4, [lr]
 80528a0:	f004 04df 	and.w	r4, r4, #223	; 0xdf
 80528a4:	2c58      	cmp	r4, #88	; 0x58
 80528a6:	d14d      	bne.n	8052944 <_strtol_l.isra.0+0xf0>
 80528a8:	f89e 4001 	ldrb.w	r4, [lr, #1]
 80528ac:	2310      	movs	r3, #16
 80528ae:	f10e 0e02 	add.w	lr, lr, #2
 80528b2:	f108 4c00 	add.w	ip, r8, #2147483648	; 0x80000000
 80528b6:	f10c 3cff 	add.w	ip, ip, #4294967295
 80528ba:	2600      	movs	r6, #0
 80528bc:	fbbc f9f3 	udiv	r9, ip, r3
 80528c0:	4635      	mov	r5, r6
 80528c2:	fb03 ca19 	mls	sl, r3, r9, ip
 80528c6:	f1a4 0730 	sub.w	r7, r4, #48	; 0x30
 80528ca:	2f09      	cmp	r7, #9
 80528cc:	d818      	bhi.n	8052900 <_strtol_l.isra.0+0xac>
 80528ce:	463c      	mov	r4, r7
 80528d0:	42a3      	cmp	r3, r4
 80528d2:	dd24      	ble.n	805291e <_strtol_l.isra.0+0xca>
 80528d4:	2e00      	cmp	r6, #0
 80528d6:	db1f      	blt.n	8052918 <_strtol_l.isra.0+0xc4>
 80528d8:	45a9      	cmp	r9, r5
 80528da:	d31d      	bcc.n	8052918 <_strtol_l.isra.0+0xc4>
 80528dc:	d101      	bne.n	80528e2 <_strtol_l.isra.0+0x8e>
 80528de:	45a2      	cmp	sl, r4
 80528e0:	db1a      	blt.n	8052918 <_strtol_l.isra.0+0xc4>
 80528e2:	fb05 4503 	mla	r5, r5, r3, r4
 80528e6:	2601      	movs	r6, #1
 80528e8:	f81e 4b01 	ldrb.w	r4, [lr], #1
 80528ec:	e7eb      	b.n	80528c6 <_strtol_l.isra.0+0x72>
 80528ee:	2c2b      	cmp	r4, #43	; 0x2b
 80528f0:	bf08      	it	eq
 80528f2:	f89e 4000 	ldrbeq.w	r4, [lr]
 80528f6:	46a8      	mov	r8, r5
 80528f8:	bf08      	it	eq
 80528fa:	f106 0e02 	addeq.w	lr, r6, #2
 80528fe:	e7c7      	b.n	8052890 <_strtol_l.isra.0+0x3c>
 8052900:	f1a4 0741 	sub.w	r7, r4, #65	; 0x41
 8052904:	2f19      	cmp	r7, #25
 8052906:	d801      	bhi.n	805290c <_strtol_l.isra.0+0xb8>
 8052908:	3c37      	subs	r4, #55	; 0x37
 805290a:	e7e1      	b.n	80528d0 <_strtol_l.isra.0+0x7c>
 805290c:	f1a4 0761 	sub.w	r7, r4, #97	; 0x61
 8052910:	2f19      	cmp	r7, #25
 8052912:	d804      	bhi.n	805291e <_strtol_l.isra.0+0xca>
 8052914:	3c57      	subs	r4, #87	; 0x57
 8052916:	e7db      	b.n	80528d0 <_strtol_l.isra.0+0x7c>
 8052918:	f04f 36ff 	mov.w	r6, #4294967295
 805291c:	e7e4      	b.n	80528e8 <_strtol_l.isra.0+0x94>
 805291e:	2e00      	cmp	r6, #0
 8052920:	da05      	bge.n	805292e <_strtol_l.isra.0+0xda>
 8052922:	2322      	movs	r3, #34	; 0x22
 8052924:	6003      	str	r3, [r0, #0]
 8052926:	4665      	mov	r5, ip
 8052928:	b942      	cbnz	r2, 805293c <_strtol_l.isra.0+0xe8>
 805292a:	4628      	mov	r0, r5
 805292c:	e79d      	b.n	805286a <_strtol_l.isra.0+0x16>
 805292e:	f1b8 0f00 	cmp.w	r8, #0
 8052932:	d000      	beq.n	8052936 <_strtol_l.isra.0+0xe2>
 8052934:	426d      	negs	r5, r5
 8052936:	2a00      	cmp	r2, #0
 8052938:	d0f7      	beq.n	805292a <_strtol_l.isra.0+0xd6>
 805293a:	b10e      	cbz	r6, 8052940 <_strtol_l.isra.0+0xec>
 805293c:	f10e 31ff 	add.w	r1, lr, #4294967295
 8052940:	6011      	str	r1, [r2, #0]
 8052942:	e7f2      	b.n	805292a <_strtol_l.isra.0+0xd6>
 8052944:	2430      	movs	r4, #48	; 0x30
 8052946:	2b00      	cmp	r3, #0
 8052948:	d1b3      	bne.n	80528b2 <_strtol_l.isra.0+0x5e>
 805294a:	2308      	movs	r3, #8
 805294c:	e7b1      	b.n	80528b2 <_strtol_l.isra.0+0x5e>
 805294e:	2c30      	cmp	r4, #48	; 0x30
 8052950:	d0a4      	beq.n	805289c <_strtol_l.isra.0+0x48>
 8052952:	230a      	movs	r3, #10
 8052954:	e7ad      	b.n	80528b2 <_strtol_l.isra.0+0x5e>
 8052956:	bf00      	nop
 8052958:	0805abea 	.word	0x0805abea

0805295c <strtol>:
 805295c:	4613      	mov	r3, r2
 805295e:	460a      	mov	r2, r1
 8052960:	4601      	mov	r1, r0
 8052962:	4802      	ldr	r0, [pc, #8]	; (805296c <strtol+0x10>)
 8052964:	6800      	ldr	r0, [r0, #0]
 8052966:	f7ff bf75 	b.w	8052854 <_strtol_l.isra.0>
 805296a:	bf00      	nop
 805296c:	200036d0 	.word	0x200036d0

08052970 <_svfprintf_r>:
 8052970:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8052974:	ed2d 8b04 	vpush	{d8-d9}
 8052978:	b0cf      	sub	sp, #316	; 0x13c
 805297a:	4689      	mov	r9, r1
 805297c:	4693      	mov	fp, r2
 805297e:	461e      	mov	r6, r3
 8052980:	4682      	mov	sl, r0
 8052982:	f004 f949 	bl	8056c18 <_localeconv_r>
 8052986:	6803      	ldr	r3, [r0, #0]
 8052988:	9313      	str	r3, [sp, #76]	; 0x4c
 805298a:	4618      	mov	r0, r3
 805298c:	f7ed fc3a 	bl	8040204 <strlen>
 8052990:	f8b9 300c 	ldrh.w	r3, [r9, #12]
 8052994:	900e      	str	r0, [sp, #56]	; 0x38
 8052996:	0618      	lsls	r0, r3, #24
 8052998:	d51a      	bpl.n	80529d0 <_svfprintf_r+0x60>
 805299a:	f8d9 3010 	ldr.w	r3, [r9, #16]
 805299e:	b9bb      	cbnz	r3, 80529d0 <_svfprintf_r+0x60>
 80529a0:	2140      	movs	r1, #64	; 0x40
 80529a2:	4650      	mov	r0, sl
 80529a4:	f7fe fdde 	bl	8051564 <_malloc_r>
 80529a8:	f8c9 0000 	str.w	r0, [r9]
 80529ac:	f8c9 0010 	str.w	r0, [r9, #16]
 80529b0:	b958      	cbnz	r0, 80529ca <_svfprintf_r+0x5a>
 80529b2:	230c      	movs	r3, #12
 80529b4:	f8ca 3000 	str.w	r3, [sl]
 80529b8:	f04f 33ff 	mov.w	r3, #4294967295
 80529bc:	930f      	str	r3, [sp, #60]	; 0x3c
 80529be:	980f      	ldr	r0, [sp, #60]	; 0x3c
 80529c0:	b04f      	add	sp, #316	; 0x13c
 80529c2:	ecbd 8b04 	vpop	{d8-d9}
 80529c6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80529ca:	2340      	movs	r3, #64	; 0x40
 80529cc:	f8c9 3014 	str.w	r3, [r9, #20]
 80529d0:	ed9f 7b93 	vldr	d7, [pc, #588]	; 8052c20 <_svfprintf_r+0x2b0>
 80529d4:	2500      	movs	r5, #0
 80529d6:	e9cd 5523 	strd	r5, r5, [sp, #140]	; 0x8c
 80529da:	ed8d 7b0c 	vstr	d7, [sp, #48]	; 0x30
 80529de:	e9cd 5515 	strd	r5, r5, [sp, #84]	; 0x54
 80529e2:	ac25      	add	r4, sp, #148	; 0x94
 80529e4:	9422      	str	r4, [sp, #136]	; 0x88
 80529e6:	9505      	str	r5, [sp, #20]
 80529e8:	950a      	str	r5, [sp, #40]	; 0x28
 80529ea:	9512      	str	r5, [sp, #72]	; 0x48
 80529ec:	9514      	str	r5, [sp, #80]	; 0x50
 80529ee:	950f      	str	r5, [sp, #60]	; 0x3c
 80529f0:	465b      	mov	r3, fp
 80529f2:	461d      	mov	r5, r3
 80529f4:	f813 2b01 	ldrb.w	r2, [r3], #1
 80529f8:	b10a      	cbz	r2, 80529fe <_svfprintf_r+0x8e>
 80529fa:	2a25      	cmp	r2, #37	; 0x25
 80529fc:	d1f9      	bne.n	80529f2 <_svfprintf_r+0x82>
 80529fe:	ebb5 070b 	subs.w	r7, r5, fp
 8052a02:	d00d      	beq.n	8052a20 <_svfprintf_r+0xb0>
 8052a04:	9b24      	ldr	r3, [sp, #144]	; 0x90
 8052a06:	443b      	add	r3, r7
 8052a08:	9324      	str	r3, [sp, #144]	; 0x90
 8052a0a:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 8052a0c:	3301      	adds	r3, #1
 8052a0e:	2b07      	cmp	r3, #7
 8052a10:	e9c4 b700 	strd	fp, r7, [r4]
 8052a14:	9323      	str	r3, [sp, #140]	; 0x8c
 8052a16:	dc79      	bgt.n	8052b0c <_svfprintf_r+0x19c>
 8052a18:	3408      	adds	r4, #8
 8052a1a:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8052a1c:	443b      	add	r3, r7
 8052a1e:	930f      	str	r3, [sp, #60]	; 0x3c
 8052a20:	782b      	ldrb	r3, [r5, #0]
 8052a22:	2b00      	cmp	r3, #0
 8052a24:	f001 8140 	beq.w	8053ca8 <_svfprintf_r+0x1338>
 8052a28:	2300      	movs	r3, #0
 8052a2a:	f04f 32ff 	mov.w	r2, #4294967295
 8052a2e:	3501      	adds	r5, #1
 8052a30:	f88d 306b 	strb.w	r3, [sp, #107]	; 0x6b
 8052a34:	9204      	str	r2, [sp, #16]
 8052a36:	9310      	str	r3, [sp, #64]	; 0x40
 8052a38:	4698      	mov	r8, r3
 8052a3a:	270a      	movs	r7, #10
 8052a3c:	212b      	movs	r1, #43	; 0x2b
 8052a3e:	462a      	mov	r2, r5
 8052a40:	f812 3b01 	ldrb.w	r3, [r2], #1
 8052a44:	9307      	str	r3, [sp, #28]
 8052a46:	920b      	str	r2, [sp, #44]	; 0x2c
 8052a48:	9b07      	ldr	r3, [sp, #28]
 8052a4a:	3b20      	subs	r3, #32
 8052a4c:	2b5a      	cmp	r3, #90	; 0x5a
 8052a4e:	f200 85b4 	bhi.w	80535ba <_svfprintf_r+0xc4a>
 8052a52:	e8df f013 	tbh	[pc, r3, lsl #1]
 8052a56:	007e      	.short	0x007e
 8052a58:	05b205b2 	.word	0x05b205b2
 8052a5c:	05b20086 	.word	0x05b20086
 8052a60:	05b205b2 	.word	0x05b205b2
 8052a64:	05b20065 	.word	0x05b20065
 8052a68:	008905b2 	.word	0x008905b2
 8052a6c:	05b20093 	.word	0x05b20093
 8052a70:	00960090 	.word	0x00960090
 8052a74:	00b305b2 	.word	0x00b305b2
 8052a78:	00b600b6 	.word	0x00b600b6
 8052a7c:	00b600b6 	.word	0x00b600b6
 8052a80:	00b600b6 	.word	0x00b600b6
 8052a84:	00b600b6 	.word	0x00b600b6
 8052a88:	05b200b6 	.word	0x05b200b6
 8052a8c:	05b205b2 	.word	0x05b205b2
 8052a90:	05b205b2 	.word	0x05b205b2
 8052a94:	05b205b2 	.word	0x05b205b2
 8052a98:	05b20127 	.word	0x05b20127
 8052a9c:	00fc00e9 	.word	0x00fc00e9
 8052aa0:	01270127 	.word	0x01270127
 8052aa4:	05b20127 	.word	0x05b20127
 8052aa8:	05b205b2 	.word	0x05b205b2
 8052aac:	00c605b2 	.word	0x00c605b2
 8052ab0:	05b205b2 	.word	0x05b205b2
 8052ab4:	05b20492 	.word	0x05b20492
 8052ab8:	05b205b2 	.word	0x05b205b2
 8052abc:	05b204d9 	.word	0x05b204d9
 8052ac0:	05b204fa 	.word	0x05b204fa
 8052ac4:	051905b2 	.word	0x051905b2
 8052ac8:	05b205b2 	.word	0x05b205b2
 8052acc:	05b205b2 	.word	0x05b205b2
 8052ad0:	05b205b2 	.word	0x05b205b2
 8052ad4:	05b205b2 	.word	0x05b205b2
 8052ad8:	05b20127 	.word	0x05b20127
 8052adc:	00fe00e9 	.word	0x00fe00e9
 8052ae0:	01270127 	.word	0x01270127
 8052ae4:	00c90127 	.word	0x00c90127
 8052ae8:	00dd00fe 	.word	0x00dd00fe
 8052aec:	00d605b2 	.word	0x00d605b2
 8052af0:	046f05b2 	.word	0x046f05b2
 8052af4:	04c80494 	.word	0x04c80494
 8052af8:	05b200dd 	.word	0x05b200dd
 8052afc:	007c04d9 	.word	0x007c04d9
 8052b00:	05b204fc 	.word	0x05b204fc
 8052b04:	053605b2 	.word	0x053605b2
 8052b08:	007c05b2 	.word	0x007c05b2
 8052b0c:	aa22      	add	r2, sp, #136	; 0x88
 8052b0e:	4649      	mov	r1, r9
 8052b10:	4650      	mov	r0, sl
 8052b12:	f004 fe0b 	bl	805772c <__ssprint_r>
 8052b16:	2800      	cmp	r0, #0
 8052b18:	f040 8132 	bne.w	8052d80 <_svfprintf_r+0x410>
 8052b1c:	ac25      	add	r4, sp, #148	; 0x94
 8052b1e:	e77c      	b.n	8052a1a <_svfprintf_r+0xaa>
 8052b20:	4650      	mov	r0, sl
 8052b22:	f004 f879 	bl	8056c18 <_localeconv_r>
 8052b26:	6843      	ldr	r3, [r0, #4]
 8052b28:	9314      	str	r3, [sp, #80]	; 0x50
 8052b2a:	4618      	mov	r0, r3
 8052b2c:	f7ed fb6a 	bl	8040204 <strlen>
 8052b30:	9012      	str	r0, [sp, #72]	; 0x48
 8052b32:	4650      	mov	r0, sl
 8052b34:	f004 f870 	bl	8056c18 <_localeconv_r>
 8052b38:	6883      	ldr	r3, [r0, #8]
 8052b3a:	930a      	str	r3, [sp, #40]	; 0x28
 8052b3c:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8052b3e:	212b      	movs	r1, #43	; 0x2b
 8052b40:	b12b      	cbz	r3, 8052b4e <_svfprintf_r+0x1de>
 8052b42:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8052b44:	b11b      	cbz	r3, 8052b4e <_svfprintf_r+0x1de>
 8052b46:	781b      	ldrb	r3, [r3, #0]
 8052b48:	b10b      	cbz	r3, 8052b4e <_svfprintf_r+0x1de>
 8052b4a:	f448 6880 	orr.w	r8, r8, #1024	; 0x400
 8052b4e:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
 8052b50:	e775      	b.n	8052a3e <_svfprintf_r+0xce>
 8052b52:	f89d 306b 	ldrb.w	r3, [sp, #107]	; 0x6b
 8052b56:	2b00      	cmp	r3, #0
 8052b58:	d1f9      	bne.n	8052b4e <_svfprintf_r+0x1de>
 8052b5a:	2320      	movs	r3, #32
 8052b5c:	f88d 306b 	strb.w	r3, [sp, #107]	; 0x6b
 8052b60:	e7f5      	b.n	8052b4e <_svfprintf_r+0x1de>
 8052b62:	f048 0801 	orr.w	r8, r8, #1
 8052b66:	e7f2      	b.n	8052b4e <_svfprintf_r+0x1de>
 8052b68:	f856 3b04 	ldr.w	r3, [r6], #4
 8052b6c:	9310      	str	r3, [sp, #64]	; 0x40
 8052b6e:	2b00      	cmp	r3, #0
 8052b70:	daed      	bge.n	8052b4e <_svfprintf_r+0x1de>
 8052b72:	425b      	negs	r3, r3
 8052b74:	9310      	str	r3, [sp, #64]	; 0x40
 8052b76:	f048 0804 	orr.w	r8, r8, #4
 8052b7a:	e7e8      	b.n	8052b4e <_svfprintf_r+0x1de>
 8052b7c:	f88d 106b 	strb.w	r1, [sp, #107]	; 0x6b
 8052b80:	e7e5      	b.n	8052b4e <_svfprintf_r+0x1de>
 8052b82:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8052b84:	f812 3b01 	ldrb.w	r3, [r2], #1
 8052b88:	9307      	str	r3, [sp, #28]
 8052b8a:	2b2a      	cmp	r3, #42	; 0x2a
 8052b8c:	d113      	bne.n	8052bb6 <_svfprintf_r+0x246>
 8052b8e:	f856 0b04 	ldr.w	r0, [r6], #4
 8052b92:	920b      	str	r2, [sp, #44]	; 0x2c
 8052b94:	ea40 73e0 	orr.w	r3, r0, r0, asr #31
 8052b98:	9304      	str	r3, [sp, #16]
 8052b9a:	e7d8      	b.n	8052b4e <_svfprintf_r+0x1de>
 8052b9c:	9804      	ldr	r0, [sp, #16]
 8052b9e:	fb07 3300 	mla	r3, r7, r0, r3
 8052ba2:	9304      	str	r3, [sp, #16]
 8052ba4:	f812 3b01 	ldrb.w	r3, [r2], #1
 8052ba8:	9307      	str	r3, [sp, #28]
 8052baa:	9b07      	ldr	r3, [sp, #28]
 8052bac:	3b30      	subs	r3, #48	; 0x30
 8052bae:	2b09      	cmp	r3, #9
 8052bb0:	d9f4      	bls.n	8052b9c <_svfprintf_r+0x22c>
 8052bb2:	920b      	str	r2, [sp, #44]	; 0x2c
 8052bb4:	e748      	b.n	8052a48 <_svfprintf_r+0xd8>
 8052bb6:	2300      	movs	r3, #0
 8052bb8:	9304      	str	r3, [sp, #16]
 8052bba:	e7f6      	b.n	8052baa <_svfprintf_r+0x23a>
 8052bbc:	f048 0880 	orr.w	r8, r8, #128	; 0x80
 8052bc0:	e7c5      	b.n	8052b4e <_svfprintf_r+0x1de>
 8052bc2:	2300      	movs	r3, #0
 8052bc4:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8052bc6:	9310      	str	r3, [sp, #64]	; 0x40
 8052bc8:	9b07      	ldr	r3, [sp, #28]
 8052bca:	9810      	ldr	r0, [sp, #64]	; 0x40
 8052bcc:	3b30      	subs	r3, #48	; 0x30
 8052bce:	fb07 3300 	mla	r3, r7, r0, r3
 8052bd2:	9310      	str	r3, [sp, #64]	; 0x40
 8052bd4:	f812 3b01 	ldrb.w	r3, [r2], #1
 8052bd8:	9307      	str	r3, [sp, #28]
 8052bda:	3b30      	subs	r3, #48	; 0x30
 8052bdc:	2b09      	cmp	r3, #9
 8052bde:	d9f3      	bls.n	8052bc8 <_svfprintf_r+0x258>
 8052be0:	e7e7      	b.n	8052bb2 <_svfprintf_r+0x242>
 8052be2:	f048 0808 	orr.w	r8, r8, #8
 8052be6:	e7b2      	b.n	8052b4e <_svfprintf_r+0x1de>
 8052be8:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8052bea:	781b      	ldrb	r3, [r3, #0]
 8052bec:	2b68      	cmp	r3, #104	; 0x68
 8052bee:	bf01      	itttt	eq
 8052bf0:	9b0b      	ldreq	r3, [sp, #44]	; 0x2c
 8052bf2:	3301      	addeq	r3, #1
 8052bf4:	930b      	streq	r3, [sp, #44]	; 0x2c
 8052bf6:	f448 7800 	orreq.w	r8, r8, #512	; 0x200
 8052bfa:	bf18      	it	ne
 8052bfc:	f048 0840 	orrne.w	r8, r8, #64	; 0x40
 8052c00:	e7a5      	b.n	8052b4e <_svfprintf_r+0x1de>
 8052c02:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8052c04:	781b      	ldrb	r3, [r3, #0]
 8052c06:	2b6c      	cmp	r3, #108	; 0x6c
 8052c08:	d105      	bne.n	8052c16 <_svfprintf_r+0x2a6>
 8052c0a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8052c0c:	3301      	adds	r3, #1
 8052c0e:	930b      	str	r3, [sp, #44]	; 0x2c
 8052c10:	f048 0820 	orr.w	r8, r8, #32
 8052c14:	e79b      	b.n	8052b4e <_svfprintf_r+0x1de>
 8052c16:	f048 0810 	orr.w	r8, r8, #16
 8052c1a:	e798      	b.n	8052b4e <_svfprintf_r+0x1de>
 8052c1c:	f3af 8000 	nop.w
	...
 8052c28:	4632      	mov	r2, r6
 8052c2a:	2000      	movs	r0, #0
 8052c2c:	f852 3b04 	ldr.w	r3, [r2], #4
 8052c30:	9206      	str	r2, [sp, #24]
 8052c32:	f88d 30d4 	strb.w	r3, [sp, #212]	; 0xd4
 8052c36:	f88d 006b 	strb.w	r0, [sp, #107]	; 0x6b
 8052c3a:	2301      	movs	r3, #1
 8052c3c:	e9cd 0008 	strd	r0, r0, [sp, #32]
 8052c40:	9003      	str	r0, [sp, #12]
 8052c42:	9304      	str	r3, [sp, #16]
 8052c44:	4606      	mov	r6, r0
 8052c46:	4605      	mov	r5, r0
 8052c48:	f10d 0bd4 	add.w	fp, sp, #212	; 0xd4
 8052c4c:	e1b8      	b.n	8052fc0 <_svfprintf_r+0x650>
 8052c4e:	f048 0810 	orr.w	r8, r8, #16
 8052c52:	f018 0f20 	tst.w	r8, #32
 8052c56:	d012      	beq.n	8052c7e <_svfprintf_r+0x30e>
 8052c58:	3607      	adds	r6, #7
 8052c5a:	f026 0307 	bic.w	r3, r6, #7
 8052c5e:	e8f3 6702 	ldrd	r6, r7, [r3], #8
 8052c62:	9306      	str	r3, [sp, #24]
 8052c64:	2e00      	cmp	r6, #0
 8052c66:	f177 0300 	sbcs.w	r3, r7, #0
 8052c6a:	da06      	bge.n	8052c7a <_svfprintf_r+0x30a>
 8052c6c:	4276      	negs	r6, r6
 8052c6e:	f04f 032d 	mov.w	r3, #45	; 0x2d
 8052c72:	eb67 0747 	sbc.w	r7, r7, r7, lsl #1
 8052c76:	f88d 306b 	strb.w	r3, [sp, #107]	; 0x6b
 8052c7a:	2301      	movs	r3, #1
 8052c7c:	e38e      	b.n	805339c <_svfprintf_r+0xa2c>
 8052c7e:	1d33      	adds	r3, r6, #4
 8052c80:	f018 0f10 	tst.w	r8, #16
 8052c84:	9306      	str	r3, [sp, #24]
 8052c86:	d002      	beq.n	8052c8e <_svfprintf_r+0x31e>
 8052c88:	6836      	ldr	r6, [r6, #0]
 8052c8a:	17f7      	asrs	r7, r6, #31
 8052c8c:	e7ea      	b.n	8052c64 <_svfprintf_r+0x2f4>
 8052c8e:	f018 0f40 	tst.w	r8, #64	; 0x40
 8052c92:	6836      	ldr	r6, [r6, #0]
 8052c94:	d001      	beq.n	8052c9a <_svfprintf_r+0x32a>
 8052c96:	b236      	sxth	r6, r6
 8052c98:	e7f7      	b.n	8052c8a <_svfprintf_r+0x31a>
 8052c9a:	f418 7f00 	tst.w	r8, #512	; 0x200
 8052c9e:	bf18      	it	ne
 8052ca0:	b276      	sxtbne	r6, r6
 8052ca2:	e7f2      	b.n	8052c8a <_svfprintf_r+0x31a>
 8052ca4:	3607      	adds	r6, #7
 8052ca6:	f026 0307 	bic.w	r3, r6, #7
 8052caa:	ecb3 7b02 	vldmia	r3!, {d7}
 8052cae:	ed8d 7b0c 	vstr	d7, [sp, #48]	; 0x30
 8052cb2:	9306      	str	r3, [sp, #24]
 8052cb4:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8052cb6:	ee09 3a10 	vmov	s18, r3
 8052cba:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8052cbc:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 8052cc0:	ee09 3a90 	vmov	s19, r3
 8052cc4:	f04f 32ff 	mov.w	r2, #4294967295
 8052cc8:	4b3a      	ldr	r3, [pc, #232]	; (8052db4 <_svfprintf_r+0x444>)
 8052cca:	ec51 0b19 	vmov	r0, r1, d9
 8052cce:	f7ed ff4d 	bl	8040b6c <__aeabi_dcmpun>
 8052cd2:	bb10      	cbnz	r0, 8052d1a <_svfprintf_r+0x3aa>
 8052cd4:	4b37      	ldr	r3, [pc, #220]	; (8052db4 <_svfprintf_r+0x444>)
 8052cd6:	ec51 0b19 	vmov	r0, r1, d9
 8052cda:	f04f 32ff 	mov.w	r2, #4294967295
 8052cde:	f7ed ff27 	bl	8040b30 <__aeabi_dcmple>
 8052ce2:	b9d0      	cbnz	r0, 8052d1a <_svfprintf_r+0x3aa>
 8052ce4:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
 8052ce8:	2200      	movs	r2, #0
 8052cea:	2300      	movs	r3, #0
 8052cec:	f7ed ff16 	bl	8040b1c <__aeabi_dcmplt>
 8052cf0:	b110      	cbz	r0, 8052cf8 <_svfprintf_r+0x388>
 8052cf2:	232d      	movs	r3, #45	; 0x2d
 8052cf4:	f88d 306b 	strb.w	r3, [sp, #107]	; 0x6b
 8052cf8:	4a2f      	ldr	r2, [pc, #188]	; (8052db8 <_svfprintf_r+0x448>)
 8052cfa:	4830      	ldr	r0, [pc, #192]	; (8052dbc <_svfprintf_r+0x44c>)
 8052cfc:	9b07      	ldr	r3, [sp, #28]
 8052cfe:	2100      	movs	r1, #0
 8052d00:	2b47      	cmp	r3, #71	; 0x47
 8052d02:	bfd4      	ite	le
 8052d04:	4693      	movle	fp, r2
 8052d06:	4683      	movgt	fp, r0
 8052d08:	2303      	movs	r3, #3
 8052d0a:	e9cd 1303 	strd	r1, r3, [sp, #12]
 8052d0e:	f028 0880 	bic.w	r8, r8, #128	; 0x80
 8052d12:	2600      	movs	r6, #0
 8052d14:	4633      	mov	r3, r6
 8052d16:	f001 b802 	b.w	8053d1e <_svfprintf_r+0x13ae>
 8052d1a:	e9dd 230c 	ldrd	r2, r3, [sp, #48]	; 0x30
 8052d1e:	4610      	mov	r0, r2
 8052d20:	4619      	mov	r1, r3
 8052d22:	f7ed ff23 	bl	8040b6c <__aeabi_dcmpun>
 8052d26:	b140      	cbz	r0, 8052d3a <_svfprintf_r+0x3ca>
 8052d28:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8052d2a:	4a25      	ldr	r2, [pc, #148]	; (8052dc0 <_svfprintf_r+0x450>)
 8052d2c:	4825      	ldr	r0, [pc, #148]	; (8052dc4 <_svfprintf_r+0x454>)
 8052d2e:	2b00      	cmp	r3, #0
 8052d30:	bfbc      	itt	lt
 8052d32:	232d      	movlt	r3, #45	; 0x2d
 8052d34:	f88d 306b 	strblt.w	r3, [sp, #107]	; 0x6b
 8052d38:	e7e0      	b.n	8052cfc <_svfprintf_r+0x38c>
 8052d3a:	9b07      	ldr	r3, [sp, #28]
 8052d3c:	f023 0320 	bic.w	r3, r3, #32
 8052d40:	2b41      	cmp	r3, #65	; 0x41
 8052d42:	9308      	str	r3, [sp, #32]
 8052d44:	d125      	bne.n	8052d92 <_svfprintf_r+0x422>
 8052d46:	2330      	movs	r3, #48	; 0x30
 8052d48:	f88d 306c 	strb.w	r3, [sp, #108]	; 0x6c
 8052d4c:	9b07      	ldr	r3, [sp, #28]
 8052d4e:	2b61      	cmp	r3, #97	; 0x61
 8052d50:	bf0c      	ite	eq
 8052d52:	2378      	moveq	r3, #120	; 0x78
 8052d54:	2358      	movne	r3, #88	; 0x58
 8052d56:	f88d 306d 	strb.w	r3, [sp, #109]	; 0x6d
 8052d5a:	9b04      	ldr	r3, [sp, #16]
 8052d5c:	2b63      	cmp	r3, #99	; 0x63
 8052d5e:	f048 0802 	orr.w	r8, r8, #2
 8052d62:	dd31      	ble.n	8052dc8 <_svfprintf_r+0x458>
 8052d64:	1c59      	adds	r1, r3, #1
 8052d66:	4650      	mov	r0, sl
 8052d68:	f7fe fbfc 	bl	8051564 <_malloc_r>
 8052d6c:	4683      	mov	fp, r0
 8052d6e:	2800      	cmp	r0, #0
 8052d70:	f040 81fe 	bne.w	8053170 <_svfprintf_r+0x800>
 8052d74:	f8b9 300c 	ldrh.w	r3, [r9, #12]
 8052d78:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8052d7c:	f8a9 300c 	strh.w	r3, [r9, #12]
 8052d80:	f8b9 300c 	ldrh.w	r3, [r9, #12]
 8052d84:	f013 0f40 	tst.w	r3, #64	; 0x40
 8052d88:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8052d8a:	bf18      	it	ne
 8052d8c:	f04f 33ff 	movne.w	r3, #4294967295
 8052d90:	e614      	b.n	80529bc <_svfprintf_r+0x4c>
 8052d92:	9b04      	ldr	r3, [sp, #16]
 8052d94:	3301      	adds	r3, #1
 8052d96:	f000 81ed 	beq.w	8053174 <_svfprintf_r+0x804>
 8052d9a:	9b08      	ldr	r3, [sp, #32]
 8052d9c:	2b47      	cmp	r3, #71	; 0x47
 8052d9e:	f040 81ec 	bne.w	805317a <_svfprintf_r+0x80a>
 8052da2:	9b04      	ldr	r3, [sp, #16]
 8052da4:	2b00      	cmp	r3, #0
 8052da6:	f040 81e8 	bne.w	805317a <_svfprintf_r+0x80a>
 8052daa:	9303      	str	r3, [sp, #12]
 8052dac:	2301      	movs	r3, #1
 8052dae:	9304      	str	r3, [sp, #16]
 8052db0:	e00d      	b.n	8052dce <_svfprintf_r+0x45e>
 8052db2:	bf00      	nop
 8052db4:	7fefffff 	.word	0x7fefffff
 8052db8:	0805ab50 	.word	0x0805ab50
 8052dbc:	0805ab54 	.word	0x0805ab54
 8052dc0:	0805ab58 	.word	0x0805ab58
 8052dc4:	0805ab5c 	.word	0x0805ab5c
 8052dc8:	9003      	str	r0, [sp, #12]
 8052dca:	f10d 0bd4 	add.w	fp, sp, #212	; 0xd4
 8052dce:	f448 7380 	orr.w	r3, r8, #256	; 0x100
 8052dd2:	9311      	str	r3, [sp, #68]	; 0x44
 8052dd4:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8052dd6:	2b00      	cmp	r3, #0
 8052dd8:	f280 81d1 	bge.w	805317e <_svfprintf_r+0x80e>
 8052ddc:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8052dde:	ee08 3a10 	vmov	s16, r3
 8052de2:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8052de4:	f103 4300 	add.w	r3, r3, #2147483648	; 0x80000000
 8052de8:	ee08 3a90 	vmov	s17, r3
 8052dec:	232d      	movs	r3, #45	; 0x2d
 8052dee:	9318      	str	r3, [sp, #96]	; 0x60
 8052df0:	9b08      	ldr	r3, [sp, #32]
 8052df2:	2b41      	cmp	r3, #65	; 0x41
 8052df4:	f040 81e1 	bne.w	80531ba <_svfprintf_r+0x84a>
 8052df8:	eeb0 0a48 	vmov.f32	s0, s16
 8052dfc:	eef0 0a68 	vmov.f32	s1, s17
 8052e00:	a81c      	add	r0, sp, #112	; 0x70
 8052e02:	f004 fbfd 	bl	8057600 <frexp>
 8052e06:	2200      	movs	r2, #0
 8052e08:	f04f 537f 	mov.w	r3, #1069547520	; 0x3fc00000
 8052e0c:	ec51 0b10 	vmov	r0, r1, d0
 8052e10:	f7ed fc12 	bl	8040638 <__aeabi_dmul>
 8052e14:	2200      	movs	r2, #0
 8052e16:	2300      	movs	r3, #0
 8052e18:	4606      	mov	r6, r0
 8052e1a:	460f      	mov	r7, r1
 8052e1c:	f7ed fe74 	bl	8040b08 <__aeabi_dcmpeq>
 8052e20:	b108      	cbz	r0, 8052e26 <_svfprintf_r+0x4b6>
 8052e22:	2301      	movs	r3, #1
 8052e24:	931c      	str	r3, [sp, #112]	; 0x70
 8052e26:	4bb4      	ldr	r3, [pc, #720]	; (80530f8 <_svfprintf_r+0x788>)
 8052e28:	4ab4      	ldr	r2, [pc, #720]	; (80530fc <_svfprintf_r+0x78c>)
 8052e2a:	9907      	ldr	r1, [sp, #28]
 8052e2c:	2961      	cmp	r1, #97	; 0x61
 8052e2e:	bf18      	it	ne
 8052e30:	461a      	movne	r2, r3
 8052e32:	9b04      	ldr	r3, [sp, #16]
 8052e34:	9217      	str	r2, [sp, #92]	; 0x5c
 8052e36:	3b01      	subs	r3, #1
 8052e38:	9305      	str	r3, [sp, #20]
 8052e3a:	465d      	mov	r5, fp
 8052e3c:	4bb0      	ldr	r3, [pc, #704]	; (8053100 <_svfprintf_r+0x790>)
 8052e3e:	2200      	movs	r2, #0
 8052e40:	4630      	mov	r0, r6
 8052e42:	4639      	mov	r1, r7
 8052e44:	f7ed fbf8 	bl	8040638 <__aeabi_dmul>
 8052e48:	460f      	mov	r7, r1
 8052e4a:	4606      	mov	r6, r0
 8052e4c:	f7ed fea4 	bl	8040b98 <__aeabi_d2iz>
 8052e50:	9019      	str	r0, [sp, #100]	; 0x64
 8052e52:	f7ed fb87 	bl	8040564 <__aeabi_i2d>
 8052e56:	4602      	mov	r2, r0
 8052e58:	460b      	mov	r3, r1
 8052e5a:	4630      	mov	r0, r6
 8052e5c:	4639      	mov	r1, r7
 8052e5e:	f7ed fa33 	bl	80402c8 <__aeabi_dsub>
 8052e62:	9a19      	ldr	r2, [sp, #100]	; 0x64
 8052e64:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 8052e66:	5c9b      	ldrb	r3, [r3, r2]
 8052e68:	f805 3b01 	strb.w	r3, [r5], #1
 8052e6c:	9b05      	ldr	r3, [sp, #20]
 8052e6e:	9309      	str	r3, [sp, #36]	; 0x24
 8052e70:	1c5a      	adds	r2, r3, #1
 8052e72:	4606      	mov	r6, r0
 8052e74:	460f      	mov	r7, r1
 8052e76:	d007      	beq.n	8052e88 <_svfprintf_r+0x518>
 8052e78:	3b01      	subs	r3, #1
 8052e7a:	9305      	str	r3, [sp, #20]
 8052e7c:	2200      	movs	r2, #0
 8052e7e:	2300      	movs	r3, #0
 8052e80:	f7ed fe42 	bl	8040b08 <__aeabi_dcmpeq>
 8052e84:	2800      	cmp	r0, #0
 8052e86:	d0d9      	beq.n	8052e3c <_svfprintf_r+0x4cc>
 8052e88:	4b9e      	ldr	r3, [pc, #632]	; (8053104 <_svfprintf_r+0x794>)
 8052e8a:	2200      	movs	r2, #0
 8052e8c:	4630      	mov	r0, r6
 8052e8e:	4639      	mov	r1, r7
 8052e90:	f7ed fe62 	bl	8040b58 <__aeabi_dcmpgt>
 8052e94:	b960      	cbnz	r0, 8052eb0 <_svfprintf_r+0x540>
 8052e96:	4b9b      	ldr	r3, [pc, #620]	; (8053104 <_svfprintf_r+0x794>)
 8052e98:	2200      	movs	r2, #0
 8052e9a:	4630      	mov	r0, r6
 8052e9c:	4639      	mov	r1, r7
 8052e9e:	f7ed fe33 	bl	8040b08 <__aeabi_dcmpeq>
 8052ea2:	2800      	cmp	r0, #0
 8052ea4:	f000 8184 	beq.w	80531b0 <_svfprintf_r+0x840>
 8052ea8:	9b19      	ldr	r3, [sp, #100]	; 0x64
 8052eaa:	07df      	lsls	r7, r3, #31
 8052eac:	f140 8180 	bpl.w	80531b0 <_svfprintf_r+0x840>
 8052eb0:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 8052eb2:	9520      	str	r5, [sp, #128]	; 0x80
 8052eb4:	7bd9      	ldrb	r1, [r3, #15]
 8052eb6:	2030      	movs	r0, #48	; 0x30
 8052eb8:	9a20      	ldr	r2, [sp, #128]	; 0x80
 8052eba:	1e53      	subs	r3, r2, #1
 8052ebc:	9320      	str	r3, [sp, #128]	; 0x80
 8052ebe:	f812 3c01 	ldrb.w	r3, [r2, #-1]
 8052ec2:	428b      	cmp	r3, r1
 8052ec4:	f000 8163 	beq.w	805318e <_svfprintf_r+0x81e>
 8052ec8:	2b39      	cmp	r3, #57	; 0x39
 8052eca:	bf0b      	itete	eq
 8052ecc:	9b17      	ldreq	r3, [sp, #92]	; 0x5c
 8052ece:	3301      	addne	r3, #1
 8052ed0:	7a9b      	ldrbeq	r3, [r3, #10]
 8052ed2:	b2db      	uxtbne	r3, r3
 8052ed4:	f802 3c01 	strb.w	r3, [r2, #-1]
 8052ed8:	eba5 030b 	sub.w	r3, r5, fp
 8052edc:	9305      	str	r3, [sp, #20]
 8052ede:	9b08      	ldr	r3, [sp, #32]
 8052ee0:	9d1c      	ldr	r5, [sp, #112]	; 0x70
 8052ee2:	2b47      	cmp	r3, #71	; 0x47
 8052ee4:	f040 81b1 	bne.w	805324a <_svfprintf_r+0x8da>
 8052ee8:	1cee      	adds	r6, r5, #3
 8052eea:	db03      	blt.n	8052ef4 <_svfprintf_r+0x584>
 8052eec:	9b04      	ldr	r3, [sp, #16]
 8052eee:	42ab      	cmp	r3, r5
 8052ef0:	f280 81d6 	bge.w	80532a0 <_svfprintf_r+0x930>
 8052ef4:	9b07      	ldr	r3, [sp, #28]
 8052ef6:	3b02      	subs	r3, #2
 8052ef8:	9307      	str	r3, [sp, #28]
 8052efa:	9907      	ldr	r1, [sp, #28]
 8052efc:	f89d 201c 	ldrb.w	r2, [sp, #28]
 8052f00:	f021 0120 	bic.w	r1, r1, #32
 8052f04:	2941      	cmp	r1, #65	; 0x41
 8052f06:	bf08      	it	eq
 8052f08:	320f      	addeq	r2, #15
 8052f0a:	f105 33ff 	add.w	r3, r5, #4294967295
 8052f0e:	bf06      	itte	eq
 8052f10:	b2d2      	uxtbeq	r2, r2
 8052f12:	2101      	moveq	r1, #1
 8052f14:	2100      	movne	r1, #0
 8052f16:	2b00      	cmp	r3, #0
 8052f18:	931c      	str	r3, [sp, #112]	; 0x70
 8052f1a:	bfb8      	it	lt
 8052f1c:	f1c5 0301 	rsblt	r3, r5, #1
 8052f20:	f88d 2078 	strb.w	r2, [sp, #120]	; 0x78
 8052f24:	bfb4      	ite	lt
 8052f26:	222d      	movlt	r2, #45	; 0x2d
 8052f28:	222b      	movge	r2, #43	; 0x2b
 8052f2a:	2b09      	cmp	r3, #9
 8052f2c:	f88d 2079 	strb.w	r2, [sp, #121]	; 0x79
 8052f30:	f340 81a4 	ble.w	805327c <_svfprintf_r+0x90c>
 8052f34:	f10d 0287 	add.w	r2, sp, #135	; 0x87
 8052f38:	260a      	movs	r6, #10
 8052f3a:	4611      	mov	r1, r2
 8052f3c:	fb93 f5f6 	sdiv	r5, r3, r6
 8052f40:	fb06 3015 	mls	r0, r6, r5, r3
 8052f44:	3030      	adds	r0, #48	; 0x30
 8052f46:	f801 0c01 	strb.w	r0, [r1, #-1]
 8052f4a:	4618      	mov	r0, r3
 8052f4c:	2863      	cmp	r0, #99	; 0x63
 8052f4e:	f102 32ff 	add.w	r2, r2, #4294967295
 8052f52:	462b      	mov	r3, r5
 8052f54:	dcf1      	bgt.n	8052f3a <_svfprintf_r+0x5ca>
 8052f56:	3330      	adds	r3, #48	; 0x30
 8052f58:	1e88      	subs	r0, r1, #2
 8052f5a:	f802 3c01 	strb.w	r3, [r2, #-1]
 8052f5e:	f10d 0587 	add.w	r5, sp, #135	; 0x87
 8052f62:	f10d 027a 	add.w	r2, sp, #122	; 0x7a
 8052f66:	4603      	mov	r3, r0
 8052f68:	42ab      	cmp	r3, r5
 8052f6a:	f0c0 8182 	bcc.w	8053272 <_svfprintf_r+0x902>
 8052f6e:	f10d 0289 	add.w	r2, sp, #137	; 0x89
 8052f72:	1a52      	subs	r2, r2, r1
 8052f74:	42a8      	cmp	r0, r5
 8052f76:	bf88      	it	hi
 8052f78:	2200      	movhi	r2, #0
 8052f7a:	f10d 037a 	add.w	r3, sp, #122	; 0x7a
 8052f7e:	441a      	add	r2, r3
 8052f80:	ab1e      	add	r3, sp, #120	; 0x78
 8052f82:	1ad3      	subs	r3, r2, r3
 8052f84:	9a05      	ldr	r2, [sp, #20]
 8052f86:	9315      	str	r3, [sp, #84]	; 0x54
 8052f88:	2a01      	cmp	r2, #1
 8052f8a:	4413      	add	r3, r2
 8052f8c:	9304      	str	r3, [sp, #16]
 8052f8e:	dc02      	bgt.n	8052f96 <_svfprintf_r+0x626>
 8052f90:	f018 0f01 	tst.w	r8, #1
 8052f94:	d003      	beq.n	8052f9e <_svfprintf_r+0x62e>
 8052f96:	9b04      	ldr	r3, [sp, #16]
 8052f98:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 8052f9a:	4413      	add	r3, r2
 8052f9c:	9304      	str	r3, [sp, #16]
 8052f9e:	f428 6380 	bic.w	r3, r8, #1024	; 0x400
 8052fa2:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8052fa6:	9311      	str	r3, [sp, #68]	; 0x44
 8052fa8:	2300      	movs	r3, #0
 8052faa:	e9cd 3308 	strd	r3, r3, [sp, #32]
 8052fae:	461d      	mov	r5, r3
 8052fb0:	9b18      	ldr	r3, [sp, #96]	; 0x60
 8052fb2:	b113      	cbz	r3, 8052fba <_svfprintf_r+0x64a>
 8052fb4:	232d      	movs	r3, #45	; 0x2d
 8052fb6:	f88d 306b 	strb.w	r3, [sp, #107]	; 0x6b
 8052fba:	f8dd 8044 	ldr.w	r8, [sp, #68]	; 0x44
 8052fbe:	2600      	movs	r6, #0
 8052fc0:	9b04      	ldr	r3, [sp, #16]
 8052fc2:	42b3      	cmp	r3, r6
 8052fc4:	bfb8      	it	lt
 8052fc6:	4633      	movlt	r3, r6
 8052fc8:	9311      	str	r3, [sp, #68]	; 0x44
 8052fca:	f89d 306b 	ldrb.w	r3, [sp, #107]	; 0x6b
 8052fce:	b113      	cbz	r3, 8052fd6 <_svfprintf_r+0x666>
 8052fd0:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8052fd2:	3301      	adds	r3, #1
 8052fd4:	9311      	str	r3, [sp, #68]	; 0x44
 8052fd6:	f018 0302 	ands.w	r3, r8, #2
 8052fda:	9317      	str	r3, [sp, #92]	; 0x5c
 8052fdc:	bf1e      	ittt	ne
 8052fde:	9b11      	ldrne	r3, [sp, #68]	; 0x44
 8052fe0:	3302      	addne	r3, #2
 8052fe2:	9311      	strne	r3, [sp, #68]	; 0x44
 8052fe4:	f018 0384 	ands.w	r3, r8, #132	; 0x84
 8052fe8:	9318      	str	r3, [sp, #96]	; 0x60
 8052fea:	d11f      	bne.n	805302c <_svfprintf_r+0x6bc>
 8052fec:	e9dd 3210 	ldrd	r3, r2, [sp, #64]	; 0x40
 8052ff0:	1a9f      	subs	r7, r3, r2
 8052ff2:	2f00      	cmp	r7, #0
 8052ff4:	dd1a      	ble.n	805302c <_svfprintf_r+0x6bc>
 8052ff6:	e9dd 3223 	ldrd	r3, r2, [sp, #140]	; 0x8c
 8052ffa:	4843      	ldr	r0, [pc, #268]	; (8053108 <_svfprintf_r+0x798>)
 8052ffc:	6020      	str	r0, [r4, #0]
 8052ffe:	2f10      	cmp	r7, #16
 8053000:	f103 0301 	add.w	r3, r3, #1
 8053004:	f104 0108 	add.w	r1, r4, #8
 8053008:	f300 82e6 	bgt.w	80535d8 <_svfprintf_r+0xc68>
 805300c:	6067      	str	r7, [r4, #4]
 805300e:	2b07      	cmp	r3, #7
 8053010:	4417      	add	r7, r2
 8053012:	e9cd 3723 	strd	r3, r7, [sp, #140]	; 0x8c
 8053016:	f340 82f2 	ble.w	80535fe <_svfprintf_r+0xc8e>
 805301a:	aa22      	add	r2, sp, #136	; 0x88
 805301c:	4649      	mov	r1, r9
 805301e:	4650      	mov	r0, sl
 8053020:	f004 fb84 	bl	805772c <__ssprint_r>
 8053024:	2800      	cmp	r0, #0
 8053026:	f040 861d 	bne.w	8053c64 <_svfprintf_r+0x12f4>
 805302a:	ac25      	add	r4, sp, #148	; 0x94
 805302c:	f89d 306b 	ldrb.w	r3, [sp, #107]	; 0x6b
 8053030:	b173      	cbz	r3, 8053050 <_svfprintf_r+0x6e0>
 8053032:	f10d 036b 	add.w	r3, sp, #107	; 0x6b
 8053036:	6023      	str	r3, [r4, #0]
 8053038:	2301      	movs	r3, #1
 805303a:	6063      	str	r3, [r4, #4]
 805303c:	9b24      	ldr	r3, [sp, #144]	; 0x90
 805303e:	3301      	adds	r3, #1
 8053040:	9324      	str	r3, [sp, #144]	; 0x90
 8053042:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 8053044:	3301      	adds	r3, #1
 8053046:	2b07      	cmp	r3, #7
 8053048:	9323      	str	r3, [sp, #140]	; 0x8c
 805304a:	f300 82da 	bgt.w	8053602 <_svfprintf_r+0xc92>
 805304e:	3408      	adds	r4, #8
 8053050:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 8053052:	b16b      	cbz	r3, 8053070 <_svfprintf_r+0x700>
 8053054:	ab1b      	add	r3, sp, #108	; 0x6c
 8053056:	6023      	str	r3, [r4, #0]
 8053058:	2302      	movs	r3, #2
 805305a:	6063      	str	r3, [r4, #4]
 805305c:	9b24      	ldr	r3, [sp, #144]	; 0x90
 805305e:	3302      	adds	r3, #2
 8053060:	9324      	str	r3, [sp, #144]	; 0x90
 8053062:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 8053064:	3301      	adds	r3, #1
 8053066:	2b07      	cmp	r3, #7
 8053068:	9323      	str	r3, [sp, #140]	; 0x8c
 805306a:	f300 82d4 	bgt.w	8053616 <_svfprintf_r+0xca6>
 805306e:	3408      	adds	r4, #8
 8053070:	9b18      	ldr	r3, [sp, #96]	; 0x60
 8053072:	2b80      	cmp	r3, #128	; 0x80
 8053074:	d11f      	bne.n	80530b6 <_svfprintf_r+0x746>
 8053076:	e9dd 3210 	ldrd	r3, r2, [sp, #64]	; 0x40
 805307a:	1a9f      	subs	r7, r3, r2
 805307c:	2f00      	cmp	r7, #0
 805307e:	dd1a      	ble.n	80530b6 <_svfprintf_r+0x746>
 8053080:	e9dd 3223 	ldrd	r3, r2, [sp, #140]	; 0x8c
 8053084:	4821      	ldr	r0, [pc, #132]	; (805310c <_svfprintf_r+0x79c>)
 8053086:	6020      	str	r0, [r4, #0]
 8053088:	2f10      	cmp	r7, #16
 805308a:	f103 0301 	add.w	r3, r3, #1
 805308e:	f104 0108 	add.w	r1, r4, #8
 8053092:	f300 82ca 	bgt.w	805362a <_svfprintf_r+0xcba>
 8053096:	6067      	str	r7, [r4, #4]
 8053098:	2b07      	cmp	r3, #7
 805309a:	4417      	add	r7, r2
 805309c:	e9cd 3723 	strd	r3, r7, [sp, #140]	; 0x8c
 80530a0:	f340 82d6 	ble.w	8053650 <_svfprintf_r+0xce0>
 80530a4:	aa22      	add	r2, sp, #136	; 0x88
 80530a6:	4649      	mov	r1, r9
 80530a8:	4650      	mov	r0, sl
 80530aa:	f004 fb3f 	bl	805772c <__ssprint_r>
 80530ae:	2800      	cmp	r0, #0
 80530b0:	f040 85d8 	bne.w	8053c64 <_svfprintf_r+0x12f4>
 80530b4:	ac25      	add	r4, sp, #148	; 0x94
 80530b6:	9b04      	ldr	r3, [sp, #16]
 80530b8:	1af6      	subs	r6, r6, r3
 80530ba:	2e00      	cmp	r6, #0
 80530bc:	dd28      	ble.n	8053110 <_svfprintf_r+0x7a0>
 80530be:	4f13      	ldr	r7, [pc, #76]	; (805310c <_svfprintf_r+0x79c>)
 80530c0:	6027      	str	r7, [r4, #0]
 80530c2:	e9dd 3223 	ldrd	r3, r2, [sp, #140]	; 0x8c
 80530c6:	2e10      	cmp	r6, #16
 80530c8:	f103 0301 	add.w	r3, r3, #1
 80530cc:	f104 0108 	add.w	r1, r4, #8
 80530d0:	f300 82c0 	bgt.w	8053654 <_svfprintf_r+0xce4>
 80530d4:	6066      	str	r6, [r4, #4]
 80530d6:	2b07      	cmp	r3, #7
 80530d8:	4416      	add	r6, r2
 80530da:	e9cd 3623 	strd	r3, r6, [sp, #140]	; 0x8c
 80530de:	f340 82cc 	ble.w	805367a <_svfprintf_r+0xd0a>
 80530e2:	aa22      	add	r2, sp, #136	; 0x88
 80530e4:	4649      	mov	r1, r9
 80530e6:	4650      	mov	r0, sl
 80530e8:	f004 fb20 	bl	805772c <__ssprint_r>
 80530ec:	2800      	cmp	r0, #0
 80530ee:	f040 85b9 	bne.w	8053c64 <_svfprintf_r+0x12f4>
 80530f2:	ac25      	add	r4, sp, #148	; 0x94
 80530f4:	e00c      	b.n	8053110 <_svfprintf_r+0x7a0>
 80530f6:	bf00      	nop
 80530f8:	0805ab71 	.word	0x0805ab71
 80530fc:	0805ab60 	.word	0x0805ab60
 8053100:	40300000 	.word	0x40300000
 8053104:	3fe00000 	.word	0x3fe00000
 8053108:	0805ab84 	.word	0x0805ab84
 805310c:	0805ab94 	.word	0x0805ab94
 8053110:	f418 7f80 	tst.w	r8, #256	; 0x100
 8053114:	9e24      	ldr	r6, [sp, #144]	; 0x90
 8053116:	f040 82b7 	bne.w	8053688 <_svfprintf_r+0xd18>
 805311a:	9b04      	ldr	r3, [sp, #16]
 805311c:	f8c4 b000 	str.w	fp, [r4]
 8053120:	441e      	add	r6, r3
 8053122:	6063      	str	r3, [r4, #4]
 8053124:	9624      	str	r6, [sp, #144]	; 0x90
 8053126:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 8053128:	3301      	adds	r3, #1
 805312a:	2b07      	cmp	r3, #7
 805312c:	9323      	str	r3, [sp, #140]	; 0x8c
 805312e:	f300 82f0 	bgt.w	8053712 <_svfprintf_r+0xda2>
 8053132:	3408      	adds	r4, #8
 8053134:	f018 0f04 	tst.w	r8, #4
 8053138:	f040 8576 	bne.w	8053c28 <_svfprintf_r+0x12b8>
 805313c:	e9dd 320f 	ldrd	r3, r2, [sp, #60]	; 0x3c
 8053140:	9911      	ldr	r1, [sp, #68]	; 0x44
 8053142:	428a      	cmp	r2, r1
 8053144:	bfac      	ite	ge
 8053146:	189b      	addge	r3, r3, r2
 8053148:	185b      	addlt	r3, r3, r1
 805314a:	930f      	str	r3, [sp, #60]	; 0x3c
 805314c:	9b24      	ldr	r3, [sp, #144]	; 0x90
 805314e:	b13b      	cbz	r3, 8053160 <_svfprintf_r+0x7f0>
 8053150:	aa22      	add	r2, sp, #136	; 0x88
 8053152:	4649      	mov	r1, r9
 8053154:	4650      	mov	r0, sl
 8053156:	f004 fae9 	bl	805772c <__ssprint_r>
 805315a:	2800      	cmp	r0, #0
 805315c:	f040 8582 	bne.w	8053c64 <_svfprintf_r+0x12f4>
 8053160:	2300      	movs	r3, #0
 8053162:	9323      	str	r3, [sp, #140]	; 0x8c
 8053164:	9b03      	ldr	r3, [sp, #12]
 8053166:	2b00      	cmp	r3, #0
 8053168:	f040 8598 	bne.w	8053c9c <_svfprintf_r+0x132c>
 805316c:	ac25      	add	r4, sp, #148	; 0x94
 805316e:	e0ed      	b.n	805334c <_svfprintf_r+0x9dc>
 8053170:	9003      	str	r0, [sp, #12]
 8053172:	e62c      	b.n	8052dce <_svfprintf_r+0x45e>
 8053174:	9003      	str	r0, [sp, #12]
 8053176:	2306      	movs	r3, #6
 8053178:	e619      	b.n	8052dae <_svfprintf_r+0x43e>
 805317a:	9003      	str	r0, [sp, #12]
 805317c:	e627      	b.n	8052dce <_svfprintf_r+0x45e>
 805317e:	ed9d 7b0c 	vldr	d7, [sp, #48]	; 0x30
 8053182:	2300      	movs	r3, #0
 8053184:	eeb0 8a47 	vmov.f32	s16, s14
 8053188:	eef0 8a67 	vmov.f32	s17, s15
 805318c:	e62f      	b.n	8052dee <_svfprintf_r+0x47e>
 805318e:	f802 0c01 	strb.w	r0, [r2, #-1]
 8053192:	e691      	b.n	8052eb8 <_svfprintf_r+0x548>
 8053194:	f803 0b01 	strb.w	r0, [r3], #1
 8053198:	1aca      	subs	r2, r1, r3
 805319a:	2a00      	cmp	r2, #0
 805319c:	dafa      	bge.n	8053194 <_svfprintf_r+0x824>
 805319e:	9a09      	ldr	r2, [sp, #36]	; 0x24
 80531a0:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80531a2:	3201      	adds	r2, #1
 80531a4:	f103 0301 	add.w	r3, r3, #1
 80531a8:	bfb8      	it	lt
 80531aa:	2300      	movlt	r3, #0
 80531ac:	441d      	add	r5, r3
 80531ae:	e693      	b.n	8052ed8 <_svfprintf_r+0x568>
 80531b0:	9a09      	ldr	r2, [sp, #36]	; 0x24
 80531b2:	462b      	mov	r3, r5
 80531b4:	18a9      	adds	r1, r5, r2
 80531b6:	2030      	movs	r0, #48	; 0x30
 80531b8:	e7ee      	b.n	8053198 <_svfprintf_r+0x828>
 80531ba:	9b08      	ldr	r3, [sp, #32]
 80531bc:	2b46      	cmp	r3, #70	; 0x46
 80531be:	d005      	beq.n	80531cc <_svfprintf_r+0x85c>
 80531c0:	2b45      	cmp	r3, #69	; 0x45
 80531c2:	d11b      	bne.n	80531fc <_svfprintf_r+0x88c>
 80531c4:	9b04      	ldr	r3, [sp, #16]
 80531c6:	1c5d      	adds	r5, r3, #1
 80531c8:	2102      	movs	r1, #2
 80531ca:	e001      	b.n	80531d0 <_svfprintf_r+0x860>
 80531cc:	9d04      	ldr	r5, [sp, #16]
 80531ce:	2103      	movs	r1, #3
 80531d0:	ab20      	add	r3, sp, #128	; 0x80
 80531d2:	9301      	str	r3, [sp, #4]
 80531d4:	ab1d      	add	r3, sp, #116	; 0x74
 80531d6:	9300      	str	r3, [sp, #0]
 80531d8:	462a      	mov	r2, r5
 80531da:	ab1c      	add	r3, sp, #112	; 0x70
 80531dc:	4650      	mov	r0, sl
 80531de:	eeb0 0a48 	vmov.f32	s0, s16
 80531e2:	eef0 0a68 	vmov.f32	s1, s17
 80531e6:	f002 f95f 	bl	80554a8 <_dtoa_r>
 80531ea:	9b08      	ldr	r3, [sp, #32]
 80531ec:	2b47      	cmp	r3, #71	; 0x47
 80531ee:	4683      	mov	fp, r0
 80531f0:	d106      	bne.n	8053200 <_svfprintf_r+0x890>
 80531f2:	f018 0f01 	tst.w	r8, #1
 80531f6:	d103      	bne.n	8053200 <_svfprintf_r+0x890>
 80531f8:	9d20      	ldr	r5, [sp, #128]	; 0x80
 80531fa:	e66d      	b.n	8052ed8 <_svfprintf_r+0x568>
 80531fc:	9d04      	ldr	r5, [sp, #16]
 80531fe:	e7e3      	b.n	80531c8 <_svfprintf_r+0x858>
 8053200:	9b08      	ldr	r3, [sp, #32]
 8053202:	2b46      	cmp	r3, #70	; 0x46
 8053204:	eb0b 0605 	add.w	r6, fp, r5
 8053208:	d10f      	bne.n	805322a <_svfprintf_r+0x8ba>
 805320a:	f89b 3000 	ldrb.w	r3, [fp]
 805320e:	2b30      	cmp	r3, #48	; 0x30
 8053210:	d109      	bne.n	8053226 <_svfprintf_r+0x8b6>
 8053212:	ec51 0b18 	vmov	r0, r1, d8
 8053216:	2200      	movs	r2, #0
 8053218:	2300      	movs	r3, #0
 805321a:	f7ed fc75 	bl	8040b08 <__aeabi_dcmpeq>
 805321e:	b910      	cbnz	r0, 8053226 <_svfprintf_r+0x8b6>
 8053220:	f1c5 0501 	rsb	r5, r5, #1
 8053224:	951c      	str	r5, [sp, #112]	; 0x70
 8053226:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 8053228:	441e      	add	r6, r3
 805322a:	ec51 0b18 	vmov	r0, r1, d8
 805322e:	2200      	movs	r2, #0
 8053230:	2300      	movs	r3, #0
 8053232:	f7ed fc69 	bl	8040b08 <__aeabi_dcmpeq>
 8053236:	b100      	cbz	r0, 805323a <_svfprintf_r+0x8ca>
 8053238:	9620      	str	r6, [sp, #128]	; 0x80
 805323a:	2230      	movs	r2, #48	; 0x30
 805323c:	9b20      	ldr	r3, [sp, #128]	; 0x80
 805323e:	429e      	cmp	r6, r3
 8053240:	d9da      	bls.n	80531f8 <_svfprintf_r+0x888>
 8053242:	1c59      	adds	r1, r3, #1
 8053244:	9120      	str	r1, [sp, #128]	; 0x80
 8053246:	701a      	strb	r2, [r3, #0]
 8053248:	e7f8      	b.n	805323c <_svfprintf_r+0x8cc>
 805324a:	9b08      	ldr	r3, [sp, #32]
 805324c:	2b46      	cmp	r3, #70	; 0x46
 805324e:	f47f ae54 	bne.w	8052efa <_svfprintf_r+0x58a>
 8053252:	9a04      	ldr	r2, [sp, #16]
 8053254:	f008 0301 	and.w	r3, r8, #1
 8053258:	2d00      	cmp	r5, #0
 805325a:	ea43 0302 	orr.w	r3, r3, r2
 805325e:	dd1a      	ble.n	8053296 <_svfprintf_r+0x926>
 8053260:	2b00      	cmp	r3, #0
 8053262:	d034      	beq.n	80532ce <_svfprintf_r+0x95e>
 8053264:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8053266:	18eb      	adds	r3, r5, r3
 8053268:	441a      	add	r2, r3
 805326a:	9204      	str	r2, [sp, #16]
 805326c:	2366      	movs	r3, #102	; 0x66
 805326e:	9307      	str	r3, [sp, #28]
 8053270:	e033      	b.n	80532da <_svfprintf_r+0x96a>
 8053272:	f813 6b01 	ldrb.w	r6, [r3], #1
 8053276:	f802 6b01 	strb.w	r6, [r2], #1
 805327a:	e675      	b.n	8052f68 <_svfprintf_r+0x5f8>
 805327c:	b941      	cbnz	r1, 8053290 <_svfprintf_r+0x920>
 805327e:	2230      	movs	r2, #48	; 0x30
 8053280:	f88d 207a 	strb.w	r2, [sp, #122]	; 0x7a
 8053284:	f10d 027b 	add.w	r2, sp, #123	; 0x7b
 8053288:	3330      	adds	r3, #48	; 0x30
 805328a:	f802 3b01 	strb.w	r3, [r2], #1
 805328e:	e677      	b.n	8052f80 <_svfprintf_r+0x610>
 8053290:	f10d 027a 	add.w	r2, sp, #122	; 0x7a
 8053294:	e7f8      	b.n	8053288 <_svfprintf_r+0x918>
 8053296:	b1e3      	cbz	r3, 80532d2 <_svfprintf_r+0x962>
 8053298:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 805329a:	9a04      	ldr	r2, [sp, #16]
 805329c:	3301      	adds	r3, #1
 805329e:	e7e3      	b.n	8053268 <_svfprintf_r+0x8f8>
 80532a0:	9b05      	ldr	r3, [sp, #20]
 80532a2:	429d      	cmp	r5, r3
 80532a4:	db07      	blt.n	80532b6 <_svfprintf_r+0x946>
 80532a6:	f018 0f01 	tst.w	r8, #1
 80532aa:	d02d      	beq.n	8053308 <_svfprintf_r+0x998>
 80532ac:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80532ae:	18eb      	adds	r3, r5, r3
 80532b0:	9304      	str	r3, [sp, #16]
 80532b2:	2367      	movs	r3, #103	; 0x67
 80532b4:	e7db      	b.n	805326e <_svfprintf_r+0x8fe>
 80532b6:	9b05      	ldr	r3, [sp, #20]
 80532b8:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 80532ba:	2d00      	cmp	r5, #0
 80532bc:	4413      	add	r3, r2
 80532be:	9304      	str	r3, [sp, #16]
 80532c0:	dcf7      	bgt.n	80532b2 <_svfprintf_r+0x942>
 80532c2:	9a04      	ldr	r2, [sp, #16]
 80532c4:	f1c5 0301 	rsb	r3, r5, #1
 80532c8:	441a      	add	r2, r3
 80532ca:	4613      	mov	r3, r2
 80532cc:	e7f0      	b.n	80532b0 <_svfprintf_r+0x940>
 80532ce:	9504      	str	r5, [sp, #16]
 80532d0:	e7cc      	b.n	805326c <_svfprintf_r+0x8fc>
 80532d2:	2366      	movs	r3, #102	; 0x66
 80532d4:	9307      	str	r3, [sp, #28]
 80532d6:	2301      	movs	r3, #1
 80532d8:	9304      	str	r3, [sp, #16]
 80532da:	f418 6380 	ands.w	r3, r8, #1024	; 0x400
 80532de:	9309      	str	r3, [sp, #36]	; 0x24
 80532e0:	d025      	beq.n	805332e <_svfprintf_r+0x9be>
 80532e2:	2300      	movs	r3, #0
 80532e4:	2d00      	cmp	r5, #0
 80532e6:	e9cd 3308 	strd	r3, r3, [sp, #32]
 80532ea:	f77f ae61 	ble.w	8052fb0 <_svfprintf_r+0x640>
 80532ee:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80532f0:	781b      	ldrb	r3, [r3, #0]
 80532f2:	2bff      	cmp	r3, #255	; 0xff
 80532f4:	d10a      	bne.n	805330c <_svfprintf_r+0x99c>
 80532f6:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
 80532fa:	9904      	ldr	r1, [sp, #16]
 80532fc:	4413      	add	r3, r2
 80532fe:	9a12      	ldr	r2, [sp, #72]	; 0x48
 8053300:	fb02 1303 	mla	r3, r2, r3, r1
 8053304:	9304      	str	r3, [sp, #16]
 8053306:	e653      	b.n	8052fb0 <_svfprintf_r+0x640>
 8053308:	9504      	str	r5, [sp, #16]
 805330a:	e7d2      	b.n	80532b2 <_svfprintf_r+0x942>
 805330c:	42ab      	cmp	r3, r5
 805330e:	daf2      	bge.n	80532f6 <_svfprintf_r+0x986>
 8053310:	1aed      	subs	r5, r5, r3
 8053312:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8053314:	785b      	ldrb	r3, [r3, #1]
 8053316:	b133      	cbz	r3, 8053326 <_svfprintf_r+0x9b6>
 8053318:	9b09      	ldr	r3, [sp, #36]	; 0x24
 805331a:	3301      	adds	r3, #1
 805331c:	9309      	str	r3, [sp, #36]	; 0x24
 805331e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8053320:	3301      	adds	r3, #1
 8053322:	930a      	str	r3, [sp, #40]	; 0x28
 8053324:	e7e3      	b.n	80532ee <_svfprintf_r+0x97e>
 8053326:	9b08      	ldr	r3, [sp, #32]
 8053328:	3301      	adds	r3, #1
 805332a:	9308      	str	r3, [sp, #32]
 805332c:	e7df      	b.n	80532ee <_svfprintf_r+0x97e>
 805332e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8053330:	9308      	str	r3, [sp, #32]
 8053332:	e63d      	b.n	8052fb0 <_svfprintf_r+0x640>
 8053334:	4632      	mov	r2, r6
 8053336:	f018 0f20 	tst.w	r8, #32
 805333a:	f852 3b04 	ldr.w	r3, [r2], #4
 805333e:	9206      	str	r2, [sp, #24]
 8053340:	d009      	beq.n	8053356 <_svfprintf_r+0x9e6>
 8053342:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8053344:	4610      	mov	r0, r2
 8053346:	17d1      	asrs	r1, r2, #31
 8053348:	e9c3 0100 	strd	r0, r1, [r3]
 805334c:	9e06      	ldr	r6, [sp, #24]
 805334e:	f8dd b02c 	ldr.w	fp, [sp, #44]	; 0x2c
 8053352:	f7ff bb4d 	b.w	80529f0 <_svfprintf_r+0x80>
 8053356:	f018 0f10 	tst.w	r8, #16
 805335a:	d002      	beq.n	8053362 <_svfprintf_r+0x9f2>
 805335c:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 805335e:	601a      	str	r2, [r3, #0]
 8053360:	e7f4      	b.n	805334c <_svfprintf_r+0x9dc>
 8053362:	f018 0f40 	tst.w	r8, #64	; 0x40
 8053366:	d002      	beq.n	805336e <_svfprintf_r+0x9fe>
 8053368:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 805336a:	801a      	strh	r2, [r3, #0]
 805336c:	e7ee      	b.n	805334c <_svfprintf_r+0x9dc>
 805336e:	f418 7f00 	tst.w	r8, #512	; 0x200
 8053372:	d0f3      	beq.n	805335c <_svfprintf_r+0x9ec>
 8053374:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8053376:	701a      	strb	r2, [r3, #0]
 8053378:	e7e8      	b.n	805334c <_svfprintf_r+0x9dc>
 805337a:	f048 0810 	orr.w	r8, r8, #16
 805337e:	f018 0f20 	tst.w	r8, #32
 8053382:	d01e      	beq.n	80533c2 <_svfprintf_r+0xa52>
 8053384:	3607      	adds	r6, #7
 8053386:	f026 0307 	bic.w	r3, r6, #7
 805338a:	e8f3 6702 	ldrd	r6, r7, [r3], #8
 805338e:	9306      	str	r3, [sp, #24]
 8053390:	f428 6880 	bic.w	r8, r8, #1024	; 0x400
 8053394:	2300      	movs	r3, #0
 8053396:	2200      	movs	r2, #0
 8053398:	f88d 206b 	strb.w	r2, [sp, #107]	; 0x6b
 805339c:	9a04      	ldr	r2, [sp, #16]
 805339e:	3201      	adds	r2, #1
 80533a0:	f000 848d 	beq.w	8053cbe <_svfprintf_r+0x134e>
 80533a4:	f028 0280 	bic.w	r2, r8, #128	; 0x80
 80533a8:	9203      	str	r2, [sp, #12]
 80533aa:	ea56 0207 	orrs.w	r2, r6, r7
 80533ae:	f040 848c 	bne.w	8053cca <_svfprintf_r+0x135a>
 80533b2:	9a04      	ldr	r2, [sp, #16]
 80533b4:	2a00      	cmp	r2, #0
 80533b6:	f000 80f5 	beq.w	80535a4 <_svfprintf_r+0xc34>
 80533ba:	2b01      	cmp	r3, #1
 80533bc:	f040 8488 	bne.w	8053cd0 <_svfprintf_r+0x1360>
 80533c0:	e097      	b.n	80534f2 <_svfprintf_r+0xb82>
 80533c2:	1d33      	adds	r3, r6, #4
 80533c4:	f018 0f10 	tst.w	r8, #16
 80533c8:	9306      	str	r3, [sp, #24]
 80533ca:	d001      	beq.n	80533d0 <_svfprintf_r+0xa60>
 80533cc:	6836      	ldr	r6, [r6, #0]
 80533ce:	e003      	b.n	80533d8 <_svfprintf_r+0xa68>
 80533d0:	f018 0f40 	tst.w	r8, #64	; 0x40
 80533d4:	d002      	beq.n	80533dc <_svfprintf_r+0xa6c>
 80533d6:	8836      	ldrh	r6, [r6, #0]
 80533d8:	2700      	movs	r7, #0
 80533da:	e7d9      	b.n	8053390 <_svfprintf_r+0xa20>
 80533dc:	f418 7f00 	tst.w	r8, #512	; 0x200
 80533e0:	d0f4      	beq.n	80533cc <_svfprintf_r+0xa5c>
 80533e2:	7836      	ldrb	r6, [r6, #0]
 80533e4:	e7f8      	b.n	80533d8 <_svfprintf_r+0xa68>
 80533e6:	4633      	mov	r3, r6
 80533e8:	2278      	movs	r2, #120	; 0x78
 80533ea:	f853 6b04 	ldr.w	r6, [r3], #4
 80533ee:	9306      	str	r3, [sp, #24]
 80533f0:	f647 0330 	movw	r3, #30768	; 0x7830
 80533f4:	f8ad 306c 	strh.w	r3, [sp, #108]	; 0x6c
 80533f8:	4ba1      	ldr	r3, [pc, #644]	; (8053680 <_svfprintf_r+0xd10>)
 80533fa:	9316      	str	r3, [sp, #88]	; 0x58
 80533fc:	2700      	movs	r7, #0
 80533fe:	f048 0802 	orr.w	r8, r8, #2
 8053402:	2302      	movs	r3, #2
 8053404:	9207      	str	r2, [sp, #28]
 8053406:	e7c6      	b.n	8053396 <_svfprintf_r+0xa26>
 8053408:	4633      	mov	r3, r6
 805340a:	2500      	movs	r5, #0
 805340c:	f853 bb04 	ldr.w	fp, [r3], #4
 8053410:	9306      	str	r3, [sp, #24]
 8053412:	9b04      	ldr	r3, [sp, #16]
 8053414:	f88d 506b 	strb.w	r5, [sp, #107]	; 0x6b
 8053418:	1c59      	adds	r1, r3, #1
 805341a:	d010      	beq.n	805343e <_svfprintf_r+0xace>
 805341c:	461a      	mov	r2, r3
 805341e:	4629      	mov	r1, r5
 8053420:	4658      	mov	r0, fp
 8053422:	f7ec fefd 	bl	8040220 <memchr>
 8053426:	9003      	str	r0, [sp, #12]
 8053428:	2800      	cmp	r0, #0
 805342a:	f000 80d2 	beq.w	80535d2 <_svfprintf_r+0xc62>
 805342e:	eba0 030b 	sub.w	r3, r0, fp
 8053432:	e9cd 5303 	strd	r5, r3, [sp, #12]
 8053436:	e9cd 5508 	strd	r5, r5, [sp, #32]
 805343a:	462e      	mov	r6, r5
 805343c:	e5c0      	b.n	8052fc0 <_svfprintf_r+0x650>
 805343e:	4658      	mov	r0, fp
 8053440:	f7ec fee0 	bl	8040204 <strlen>
 8053444:	e9cd 5003 	strd	r5, r0, [sp, #12]
 8053448:	e463      	b.n	8052d12 <_svfprintf_r+0x3a2>
 805344a:	f048 0810 	orr.w	r8, r8, #16
 805344e:	f018 0f20 	tst.w	r8, #32
 8053452:	d007      	beq.n	8053464 <_svfprintf_r+0xaf4>
 8053454:	3607      	adds	r6, #7
 8053456:	f026 0307 	bic.w	r3, r6, #7
 805345a:	e8f3 6702 	ldrd	r6, r7, [r3], #8
 805345e:	9306      	str	r3, [sp, #24]
 8053460:	2301      	movs	r3, #1
 8053462:	e798      	b.n	8053396 <_svfprintf_r+0xa26>
 8053464:	1d33      	adds	r3, r6, #4
 8053466:	f018 0f10 	tst.w	r8, #16
 805346a:	9306      	str	r3, [sp, #24]
 805346c:	d001      	beq.n	8053472 <_svfprintf_r+0xb02>
 805346e:	6836      	ldr	r6, [r6, #0]
 8053470:	e003      	b.n	805347a <_svfprintf_r+0xb0a>
 8053472:	f018 0f40 	tst.w	r8, #64	; 0x40
 8053476:	d002      	beq.n	805347e <_svfprintf_r+0xb0e>
 8053478:	8836      	ldrh	r6, [r6, #0]
 805347a:	2700      	movs	r7, #0
 805347c:	e7f0      	b.n	8053460 <_svfprintf_r+0xaf0>
 805347e:	f418 7f00 	tst.w	r8, #512	; 0x200
 8053482:	d0f4      	beq.n	805346e <_svfprintf_r+0xafe>
 8053484:	7836      	ldrb	r6, [r6, #0]
 8053486:	e7f8      	b.n	805347a <_svfprintf_r+0xb0a>
 8053488:	4b7e      	ldr	r3, [pc, #504]	; (8053684 <_svfprintf_r+0xd14>)
 805348a:	9316      	str	r3, [sp, #88]	; 0x58
 805348c:	f018 0f20 	tst.w	r8, #32
 8053490:	d019      	beq.n	80534c6 <_svfprintf_r+0xb56>
 8053492:	3607      	adds	r6, #7
 8053494:	f026 0307 	bic.w	r3, r6, #7
 8053498:	e8f3 6702 	ldrd	r6, r7, [r3], #8
 805349c:	9306      	str	r3, [sp, #24]
 805349e:	f018 0f01 	tst.w	r8, #1
 80534a2:	d00a      	beq.n	80534ba <_svfprintf_r+0xb4a>
 80534a4:	ea56 0307 	orrs.w	r3, r6, r7
 80534a8:	d007      	beq.n	80534ba <_svfprintf_r+0xb4a>
 80534aa:	2330      	movs	r3, #48	; 0x30
 80534ac:	f88d 306c 	strb.w	r3, [sp, #108]	; 0x6c
 80534b0:	9b07      	ldr	r3, [sp, #28]
 80534b2:	f88d 306d 	strb.w	r3, [sp, #109]	; 0x6d
 80534b6:	f048 0802 	orr.w	r8, r8, #2
 80534ba:	f428 6880 	bic.w	r8, r8, #1024	; 0x400
 80534be:	2302      	movs	r3, #2
 80534c0:	e769      	b.n	8053396 <_svfprintf_r+0xa26>
 80534c2:	4b6f      	ldr	r3, [pc, #444]	; (8053680 <_svfprintf_r+0xd10>)
 80534c4:	e7e1      	b.n	805348a <_svfprintf_r+0xb1a>
 80534c6:	1d33      	adds	r3, r6, #4
 80534c8:	f018 0f10 	tst.w	r8, #16
 80534cc:	9306      	str	r3, [sp, #24]
 80534ce:	d001      	beq.n	80534d4 <_svfprintf_r+0xb64>
 80534d0:	6836      	ldr	r6, [r6, #0]
 80534d2:	e003      	b.n	80534dc <_svfprintf_r+0xb6c>
 80534d4:	f018 0f40 	tst.w	r8, #64	; 0x40
 80534d8:	d002      	beq.n	80534e0 <_svfprintf_r+0xb70>
 80534da:	8836      	ldrh	r6, [r6, #0]
 80534dc:	2700      	movs	r7, #0
 80534de:	e7de      	b.n	805349e <_svfprintf_r+0xb2e>
 80534e0:	f418 7f00 	tst.w	r8, #512	; 0x200
 80534e4:	d0f4      	beq.n	80534d0 <_svfprintf_r+0xb60>
 80534e6:	7836      	ldrb	r6, [r6, #0]
 80534e8:	e7f8      	b.n	80534dc <_svfprintf_r+0xb6c>
 80534ea:	2f00      	cmp	r7, #0
 80534ec:	bf08      	it	eq
 80534ee:	2e0a      	cmpeq	r6, #10
 80534f0:	d206      	bcs.n	8053500 <_svfprintf_r+0xb90>
 80534f2:	3630      	adds	r6, #48	; 0x30
 80534f4:	f88d 6137 	strb.w	r6, [sp, #311]	; 0x137
 80534f8:	f20d 1b37 	addw	fp, sp, #311	; 0x137
 80534fc:	f000 bc06 	b.w	8053d0c <_svfprintf_r+0x139c>
 8053500:	2300      	movs	r3, #0
 8053502:	9305      	str	r3, [sp, #20]
 8053504:	9b03      	ldr	r3, [sp, #12]
 8053506:	ad4e      	add	r5, sp, #312	; 0x138
 8053508:	f403 6880 	and.w	r8, r3, #1024	; 0x400
 805350c:	220a      	movs	r2, #10
 805350e:	2300      	movs	r3, #0
 8053510:	4630      	mov	r0, r6
 8053512:	4639      	mov	r1, r7
 8053514:	f7ed fbd8 	bl	8040cc8 <__aeabi_uldivmod>
 8053518:	9b05      	ldr	r3, [sp, #20]
 805351a:	3230      	adds	r2, #48	; 0x30
 805351c:	3301      	adds	r3, #1
 805351e:	f105 3bff 	add.w	fp, r5, #4294967295
 8053522:	f805 2c01 	strb.w	r2, [r5, #-1]
 8053526:	9305      	str	r3, [sp, #20]
 8053528:	f1b8 0f00 	cmp.w	r8, #0
 805352c:	d019      	beq.n	8053562 <_svfprintf_r+0xbf2>
 805352e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8053530:	9a05      	ldr	r2, [sp, #20]
 8053532:	781b      	ldrb	r3, [r3, #0]
 8053534:	429a      	cmp	r2, r3
 8053536:	d114      	bne.n	8053562 <_svfprintf_r+0xbf2>
 8053538:	2aff      	cmp	r2, #255	; 0xff
 805353a:	d012      	beq.n	8053562 <_svfprintf_r+0xbf2>
 805353c:	2f00      	cmp	r7, #0
 805353e:	bf08      	it	eq
 8053540:	2e0a      	cmpeq	r6, #10
 8053542:	d30e      	bcc.n	8053562 <_svfprintf_r+0xbf2>
 8053544:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8053546:	9914      	ldr	r1, [sp, #80]	; 0x50
 8053548:	ebab 0b03 	sub.w	fp, fp, r3
 805354c:	461a      	mov	r2, r3
 805354e:	4658      	mov	r0, fp
 8053550:	f004 f8d9 	bl	8057706 <strncpy>
 8053554:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8053556:	785d      	ldrb	r5, [r3, #1]
 8053558:	b195      	cbz	r5, 8053580 <_svfprintf_r+0xc10>
 805355a:	3301      	adds	r3, #1
 805355c:	930a      	str	r3, [sp, #40]	; 0x28
 805355e:	2300      	movs	r3, #0
 8053560:	9305      	str	r3, [sp, #20]
 8053562:	220a      	movs	r2, #10
 8053564:	2300      	movs	r3, #0
 8053566:	4630      	mov	r0, r6
 8053568:	4639      	mov	r1, r7
 805356a:	f7ed fbad 	bl	8040cc8 <__aeabi_uldivmod>
 805356e:	2f00      	cmp	r7, #0
 8053570:	bf08      	it	eq
 8053572:	2e0a      	cmpeq	r6, #10
 8053574:	f0c0 83ca 	bcc.w	8053d0c <_svfprintf_r+0x139c>
 8053578:	4606      	mov	r6, r0
 805357a:	460f      	mov	r7, r1
 805357c:	465d      	mov	r5, fp
 805357e:	e7c5      	b.n	805350c <_svfprintf_r+0xb9c>
 8053580:	9505      	str	r5, [sp, #20]
 8053582:	e7ee      	b.n	8053562 <_svfprintf_r+0xbf2>
 8053584:	9a16      	ldr	r2, [sp, #88]	; 0x58
 8053586:	f006 030f 	and.w	r3, r6, #15
 805358a:	5cd3      	ldrb	r3, [r2, r3]
 805358c:	f80b 3d01 	strb.w	r3, [fp, #-1]!
 8053590:	0933      	lsrs	r3, r6, #4
 8053592:	ea43 7307 	orr.w	r3, r3, r7, lsl #28
 8053596:	093a      	lsrs	r2, r7, #4
 8053598:	461e      	mov	r6, r3
 805359a:	4617      	mov	r7, r2
 805359c:	ea56 0307 	orrs.w	r3, r6, r7
 80535a0:	d1f0      	bne.n	8053584 <_svfprintf_r+0xc14>
 80535a2:	e3b3      	b.n	8053d0c <_svfprintf_r+0x139c>
 80535a4:	b933      	cbnz	r3, 80535b4 <_svfprintf_r+0xc44>
 80535a6:	f018 0f01 	tst.w	r8, #1
 80535aa:	d003      	beq.n	80535b4 <_svfprintf_r+0xc44>
 80535ac:	2330      	movs	r3, #48	; 0x30
 80535ae:	f88d 3137 	strb.w	r3, [sp, #311]	; 0x137
 80535b2:	e7a1      	b.n	80534f8 <_svfprintf_r+0xb88>
 80535b4:	f50d 7b9c 	add.w	fp, sp, #312	; 0x138
 80535b8:	e3a8      	b.n	8053d0c <_svfprintf_r+0x139c>
 80535ba:	9b07      	ldr	r3, [sp, #28]
 80535bc:	2b00      	cmp	r3, #0
 80535be:	f000 8373 	beq.w	8053ca8 <_svfprintf_r+0x1338>
 80535c2:	2000      	movs	r0, #0
 80535c4:	f88d 30d4 	strb.w	r3, [sp, #212]	; 0xd4
 80535c8:	f88d 006b 	strb.w	r0, [sp, #107]	; 0x6b
 80535cc:	9606      	str	r6, [sp, #24]
 80535ce:	f7ff bb34 	b.w	8052c3a <_svfprintf_r+0x2ca>
 80535d2:	9e03      	ldr	r6, [sp, #12]
 80535d4:	f7ff bb9e 	b.w	8052d14 <_svfprintf_r+0x3a4>
 80535d8:	2010      	movs	r0, #16
 80535da:	4402      	add	r2, r0
 80535dc:	2b07      	cmp	r3, #7
 80535de:	e9cd 3223 	strd	r3, r2, [sp, #140]	; 0x8c
 80535e2:	6060      	str	r0, [r4, #4]
 80535e4:	dd08      	ble.n	80535f8 <_svfprintf_r+0xc88>
 80535e6:	aa22      	add	r2, sp, #136	; 0x88
 80535e8:	4649      	mov	r1, r9
 80535ea:	4650      	mov	r0, sl
 80535ec:	f004 f89e 	bl	805772c <__ssprint_r>
 80535f0:	2800      	cmp	r0, #0
 80535f2:	f040 8337 	bne.w	8053c64 <_svfprintf_r+0x12f4>
 80535f6:	a925      	add	r1, sp, #148	; 0x94
 80535f8:	3f10      	subs	r7, #16
 80535fa:	460c      	mov	r4, r1
 80535fc:	e4fb      	b.n	8052ff6 <_svfprintf_r+0x686>
 80535fe:	460c      	mov	r4, r1
 8053600:	e514      	b.n	805302c <_svfprintf_r+0x6bc>
 8053602:	aa22      	add	r2, sp, #136	; 0x88
 8053604:	4649      	mov	r1, r9
 8053606:	4650      	mov	r0, sl
 8053608:	f004 f890 	bl	805772c <__ssprint_r>
 805360c:	2800      	cmp	r0, #0
 805360e:	f040 8329 	bne.w	8053c64 <_svfprintf_r+0x12f4>
 8053612:	ac25      	add	r4, sp, #148	; 0x94
 8053614:	e51c      	b.n	8053050 <_svfprintf_r+0x6e0>
 8053616:	aa22      	add	r2, sp, #136	; 0x88
 8053618:	4649      	mov	r1, r9
 805361a:	4650      	mov	r0, sl
 805361c:	f004 f886 	bl	805772c <__ssprint_r>
 8053620:	2800      	cmp	r0, #0
 8053622:	f040 831f 	bne.w	8053c64 <_svfprintf_r+0x12f4>
 8053626:	ac25      	add	r4, sp, #148	; 0x94
 8053628:	e522      	b.n	8053070 <_svfprintf_r+0x700>
 805362a:	2010      	movs	r0, #16
 805362c:	4402      	add	r2, r0
 805362e:	2b07      	cmp	r3, #7
 8053630:	e9cd 3223 	strd	r3, r2, [sp, #140]	; 0x8c
 8053634:	6060      	str	r0, [r4, #4]
 8053636:	dd08      	ble.n	805364a <_svfprintf_r+0xcda>
 8053638:	aa22      	add	r2, sp, #136	; 0x88
 805363a:	4649      	mov	r1, r9
 805363c:	4650      	mov	r0, sl
 805363e:	f004 f875 	bl	805772c <__ssprint_r>
 8053642:	2800      	cmp	r0, #0
 8053644:	f040 830e 	bne.w	8053c64 <_svfprintf_r+0x12f4>
 8053648:	a925      	add	r1, sp, #148	; 0x94
 805364a:	3f10      	subs	r7, #16
 805364c:	460c      	mov	r4, r1
 805364e:	e517      	b.n	8053080 <_svfprintf_r+0x710>
 8053650:	460c      	mov	r4, r1
 8053652:	e530      	b.n	80530b6 <_svfprintf_r+0x746>
 8053654:	2010      	movs	r0, #16
 8053656:	4402      	add	r2, r0
 8053658:	2b07      	cmp	r3, #7
 805365a:	e9cd 3223 	strd	r3, r2, [sp, #140]	; 0x8c
 805365e:	6060      	str	r0, [r4, #4]
 8053660:	dd08      	ble.n	8053674 <_svfprintf_r+0xd04>
 8053662:	aa22      	add	r2, sp, #136	; 0x88
 8053664:	4649      	mov	r1, r9
 8053666:	4650      	mov	r0, sl
 8053668:	f004 f860 	bl	805772c <__ssprint_r>
 805366c:	2800      	cmp	r0, #0
 805366e:	f040 82f9 	bne.w	8053c64 <_svfprintf_r+0x12f4>
 8053672:	a925      	add	r1, sp, #148	; 0x94
 8053674:	3e10      	subs	r6, #16
 8053676:	460c      	mov	r4, r1
 8053678:	e522      	b.n	80530c0 <_svfprintf_r+0x750>
 805367a:	460c      	mov	r4, r1
 805367c:	e548      	b.n	8053110 <_svfprintf_r+0x7a0>
 805367e:	bf00      	nop
 8053680:	0805ab60 	.word	0x0805ab60
 8053684:	0805ab71 	.word	0x0805ab71
 8053688:	9b07      	ldr	r3, [sp, #28]
 805368a:	2b65      	cmp	r3, #101	; 0x65
 805368c:	f340 8232 	ble.w	8053af4 <_svfprintf_r+0x1184>
 8053690:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
 8053694:	2200      	movs	r2, #0
 8053696:	2300      	movs	r3, #0
 8053698:	f7ed fa36 	bl	8040b08 <__aeabi_dcmpeq>
 805369c:	2800      	cmp	r0, #0
 805369e:	d068      	beq.n	8053772 <_svfprintf_r+0xe02>
 80536a0:	4b6d      	ldr	r3, [pc, #436]	; (8053858 <_svfprintf_r+0xee8>)
 80536a2:	6023      	str	r3, [r4, #0]
 80536a4:	2301      	movs	r3, #1
 80536a6:	441e      	add	r6, r3
 80536a8:	6063      	str	r3, [r4, #4]
 80536aa:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 80536ac:	9624      	str	r6, [sp, #144]	; 0x90
 80536ae:	3301      	adds	r3, #1
 80536b0:	2b07      	cmp	r3, #7
 80536b2:	9323      	str	r3, [sp, #140]	; 0x8c
 80536b4:	dc37      	bgt.n	8053726 <_svfprintf_r+0xdb6>
 80536b6:	3408      	adds	r4, #8
 80536b8:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 80536ba:	9a05      	ldr	r2, [sp, #20]
 80536bc:	4293      	cmp	r3, r2
 80536be:	db03      	blt.n	80536c8 <_svfprintf_r+0xd58>
 80536c0:	f018 0f01 	tst.w	r8, #1
 80536c4:	f43f ad36 	beq.w	8053134 <_svfprintf_r+0x7c4>
 80536c8:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 80536ca:	6023      	str	r3, [r4, #0]
 80536cc:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80536ce:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 80536d0:	6063      	str	r3, [r4, #4]
 80536d2:	9b24      	ldr	r3, [sp, #144]	; 0x90
 80536d4:	4413      	add	r3, r2
 80536d6:	9324      	str	r3, [sp, #144]	; 0x90
 80536d8:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 80536da:	3301      	adds	r3, #1
 80536dc:	2b07      	cmp	r3, #7
 80536de:	9323      	str	r3, [sp, #140]	; 0x8c
 80536e0:	dc2b      	bgt.n	805373a <_svfprintf_r+0xdca>
 80536e2:	3408      	adds	r4, #8
 80536e4:	9b05      	ldr	r3, [sp, #20]
 80536e6:	1e5d      	subs	r5, r3, #1
 80536e8:	2d00      	cmp	r5, #0
 80536ea:	f77f ad23 	ble.w	8053134 <_svfprintf_r+0x7c4>
 80536ee:	4e5b      	ldr	r6, [pc, #364]	; (805385c <_svfprintf_r+0xeec>)
 80536f0:	2710      	movs	r7, #16
 80536f2:	e9dd 3223 	ldrd	r3, r2, [sp, #140]	; 0x8c
 80536f6:	2d10      	cmp	r5, #16
 80536f8:	f103 0301 	add.w	r3, r3, #1
 80536fc:	f104 0108 	add.w	r1, r4, #8
 8053700:	6026      	str	r6, [r4, #0]
 8053702:	dc24      	bgt.n	805374e <_svfprintf_r+0xdde>
 8053704:	6065      	str	r5, [r4, #4]
 8053706:	2b07      	cmp	r3, #7
 8053708:	4415      	add	r5, r2
 805370a:	e9cd 3523 	strd	r3, r5, [sp, #140]	; 0x8c
 805370e:	f340 8288 	ble.w	8053c22 <_svfprintf_r+0x12b2>
 8053712:	aa22      	add	r2, sp, #136	; 0x88
 8053714:	4649      	mov	r1, r9
 8053716:	4650      	mov	r0, sl
 8053718:	f004 f808 	bl	805772c <__ssprint_r>
 805371c:	2800      	cmp	r0, #0
 805371e:	f040 82a1 	bne.w	8053c64 <_svfprintf_r+0x12f4>
 8053722:	ac25      	add	r4, sp, #148	; 0x94
 8053724:	e506      	b.n	8053134 <_svfprintf_r+0x7c4>
 8053726:	aa22      	add	r2, sp, #136	; 0x88
 8053728:	4649      	mov	r1, r9
 805372a:	4650      	mov	r0, sl
 805372c:	f003 fffe 	bl	805772c <__ssprint_r>
 8053730:	2800      	cmp	r0, #0
 8053732:	f040 8297 	bne.w	8053c64 <_svfprintf_r+0x12f4>
 8053736:	ac25      	add	r4, sp, #148	; 0x94
 8053738:	e7be      	b.n	80536b8 <_svfprintf_r+0xd48>
 805373a:	aa22      	add	r2, sp, #136	; 0x88
 805373c:	4649      	mov	r1, r9
 805373e:	4650      	mov	r0, sl
 8053740:	f003 fff4 	bl	805772c <__ssprint_r>
 8053744:	2800      	cmp	r0, #0
 8053746:	f040 828d 	bne.w	8053c64 <_svfprintf_r+0x12f4>
 805374a:	ac25      	add	r4, sp, #148	; 0x94
 805374c:	e7ca      	b.n	80536e4 <_svfprintf_r+0xd74>
 805374e:	3210      	adds	r2, #16
 8053750:	2b07      	cmp	r3, #7
 8053752:	e9cd 3223 	strd	r3, r2, [sp, #140]	; 0x8c
 8053756:	6067      	str	r7, [r4, #4]
 8053758:	dd08      	ble.n	805376c <_svfprintf_r+0xdfc>
 805375a:	aa22      	add	r2, sp, #136	; 0x88
 805375c:	4649      	mov	r1, r9
 805375e:	4650      	mov	r0, sl
 8053760:	f003 ffe4 	bl	805772c <__ssprint_r>
 8053764:	2800      	cmp	r0, #0
 8053766:	f040 827d 	bne.w	8053c64 <_svfprintf_r+0x12f4>
 805376a:	a925      	add	r1, sp, #148	; 0x94
 805376c:	3d10      	subs	r5, #16
 805376e:	460c      	mov	r4, r1
 8053770:	e7bf      	b.n	80536f2 <_svfprintf_r+0xd82>
 8053772:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 8053774:	2b00      	cmp	r3, #0
 8053776:	dc73      	bgt.n	8053860 <_svfprintf_r+0xef0>
 8053778:	4b37      	ldr	r3, [pc, #220]	; (8053858 <_svfprintf_r+0xee8>)
 805377a:	6023      	str	r3, [r4, #0]
 805377c:	2301      	movs	r3, #1
 805377e:	441e      	add	r6, r3
 8053780:	6063      	str	r3, [r4, #4]
 8053782:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 8053784:	9624      	str	r6, [sp, #144]	; 0x90
 8053786:	3301      	adds	r3, #1
 8053788:	2b07      	cmp	r3, #7
 805378a:	9323      	str	r3, [sp, #140]	; 0x8c
 805378c:	dc3d      	bgt.n	805380a <_svfprintf_r+0xe9a>
 805378e:	3408      	adds	r4, #8
 8053790:	9905      	ldr	r1, [sp, #20]
 8053792:	9a1c      	ldr	r2, [sp, #112]	; 0x70
 8053794:	9b24      	ldr	r3, [sp, #144]	; 0x90
 8053796:	430a      	orrs	r2, r1
 8053798:	f008 0101 	and.w	r1, r8, #1
 805379c:	430a      	orrs	r2, r1
 805379e:	f43f acc9 	beq.w	8053134 <_svfprintf_r+0x7c4>
 80537a2:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 80537a4:	6022      	str	r2, [r4, #0]
 80537a6:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 80537a8:	6062      	str	r2, [r4, #4]
 80537aa:	4413      	add	r3, r2
 80537ac:	9324      	str	r3, [sp, #144]	; 0x90
 80537ae:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 80537b0:	3301      	adds	r3, #1
 80537b2:	2b07      	cmp	r3, #7
 80537b4:	9323      	str	r3, [sp, #140]	; 0x8c
 80537b6:	dc32      	bgt.n	805381e <_svfprintf_r+0xeae>
 80537b8:	3408      	adds	r4, #8
 80537ba:	9d1c      	ldr	r5, [sp, #112]	; 0x70
 80537bc:	2d00      	cmp	r5, #0
 80537be:	da1b      	bge.n	80537f8 <_svfprintf_r+0xe88>
 80537c0:	4e26      	ldr	r6, [pc, #152]	; (805385c <_svfprintf_r+0xeec>)
 80537c2:	426d      	negs	r5, r5
 80537c4:	4623      	mov	r3, r4
 80537c6:	2710      	movs	r7, #16
 80537c8:	e9dd 2123 	ldrd	r2, r1, [sp, #140]	; 0x8c
 80537cc:	2d10      	cmp	r5, #16
 80537ce:	f102 0201 	add.w	r2, r2, #1
 80537d2:	f104 0408 	add.w	r4, r4, #8
 80537d6:	601e      	str	r6, [r3, #0]
 80537d8:	dc2b      	bgt.n	8053832 <_svfprintf_r+0xec2>
 80537da:	605d      	str	r5, [r3, #4]
 80537dc:	2a07      	cmp	r2, #7
 80537de:	440d      	add	r5, r1
 80537e0:	e9cd 2523 	strd	r2, r5, [sp, #140]	; 0x8c
 80537e4:	dd08      	ble.n	80537f8 <_svfprintf_r+0xe88>
 80537e6:	aa22      	add	r2, sp, #136	; 0x88
 80537e8:	4649      	mov	r1, r9
 80537ea:	4650      	mov	r0, sl
 80537ec:	f003 ff9e 	bl	805772c <__ssprint_r>
 80537f0:	2800      	cmp	r0, #0
 80537f2:	f040 8237 	bne.w	8053c64 <_svfprintf_r+0x12f4>
 80537f6:	ac25      	add	r4, sp, #148	; 0x94
 80537f8:	9b05      	ldr	r3, [sp, #20]
 80537fa:	9a05      	ldr	r2, [sp, #20]
 80537fc:	6063      	str	r3, [r4, #4]
 80537fe:	9b24      	ldr	r3, [sp, #144]	; 0x90
 8053800:	f8c4 b000 	str.w	fp, [r4]
 8053804:	4413      	add	r3, r2
 8053806:	9324      	str	r3, [sp, #144]	; 0x90
 8053808:	e48d      	b.n	8053126 <_svfprintf_r+0x7b6>
 805380a:	aa22      	add	r2, sp, #136	; 0x88
 805380c:	4649      	mov	r1, r9
 805380e:	4650      	mov	r0, sl
 8053810:	f003 ff8c 	bl	805772c <__ssprint_r>
 8053814:	2800      	cmp	r0, #0
 8053816:	f040 8225 	bne.w	8053c64 <_svfprintf_r+0x12f4>
 805381a:	ac25      	add	r4, sp, #148	; 0x94
 805381c:	e7b8      	b.n	8053790 <_svfprintf_r+0xe20>
 805381e:	aa22      	add	r2, sp, #136	; 0x88
 8053820:	4649      	mov	r1, r9
 8053822:	4650      	mov	r0, sl
 8053824:	f003 ff82 	bl	805772c <__ssprint_r>
 8053828:	2800      	cmp	r0, #0
 805382a:	f040 821b 	bne.w	8053c64 <_svfprintf_r+0x12f4>
 805382e:	ac25      	add	r4, sp, #148	; 0x94
 8053830:	e7c3      	b.n	80537ba <_svfprintf_r+0xe4a>
 8053832:	3110      	adds	r1, #16
 8053834:	2a07      	cmp	r2, #7
 8053836:	e9cd 2123 	strd	r2, r1, [sp, #140]	; 0x8c
 805383a:	605f      	str	r7, [r3, #4]
 805383c:	dd08      	ble.n	8053850 <_svfprintf_r+0xee0>
 805383e:	aa22      	add	r2, sp, #136	; 0x88
 8053840:	4649      	mov	r1, r9
 8053842:	4650      	mov	r0, sl
 8053844:	f003 ff72 	bl	805772c <__ssprint_r>
 8053848:	2800      	cmp	r0, #0
 805384a:	f040 820b 	bne.w	8053c64 <_svfprintf_r+0x12f4>
 805384e:	ac25      	add	r4, sp, #148	; 0x94
 8053850:	3d10      	subs	r5, #16
 8053852:	4623      	mov	r3, r4
 8053854:	e7b8      	b.n	80537c8 <_svfprintf_r+0xe58>
 8053856:	bf00      	nop
 8053858:	0805ab82 	.word	0x0805ab82
 805385c:	0805ab94 	.word	0x0805ab94
 8053860:	9b05      	ldr	r3, [sp, #20]
 8053862:	42ab      	cmp	r3, r5
 8053864:	bfa8      	it	ge
 8053866:	462b      	movge	r3, r5
 8053868:	2b00      	cmp	r3, #0
 805386a:	461f      	mov	r7, r3
 805386c:	dd0a      	ble.n	8053884 <_svfprintf_r+0xf14>
 805386e:	441e      	add	r6, r3
 8053870:	e9c4 b300 	strd	fp, r3, [r4]
 8053874:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 8053876:	9624      	str	r6, [sp, #144]	; 0x90
 8053878:	3301      	adds	r3, #1
 805387a:	2b07      	cmp	r3, #7
 805387c:	9323      	str	r3, [sp, #140]	; 0x8c
 805387e:	f300 8086 	bgt.w	805398e <_svfprintf_r+0x101e>
 8053882:	3408      	adds	r4, #8
 8053884:	2f00      	cmp	r7, #0
 8053886:	bfac      	ite	ge
 8053888:	1bee      	subge	r6, r5, r7
 805388a:	462e      	movlt	r6, r5
 805388c:	2e00      	cmp	r6, #0
 805388e:	dd19      	ble.n	80538c4 <_svfprintf_r+0xf54>
 8053890:	4f97      	ldr	r7, [pc, #604]	; (8053af0 <_svfprintf_r+0x1180>)
 8053892:	6027      	str	r7, [r4, #0]
 8053894:	e9dd 3223 	ldrd	r3, r2, [sp, #140]	; 0x8c
 8053898:	2e10      	cmp	r6, #16
 805389a:	f103 0301 	add.w	r3, r3, #1
 805389e:	f104 0108 	add.w	r1, r4, #8
 80538a2:	dc7e      	bgt.n	80539a2 <_svfprintf_r+0x1032>
 80538a4:	6066      	str	r6, [r4, #4]
 80538a6:	2b07      	cmp	r3, #7
 80538a8:	4416      	add	r6, r2
 80538aa:	e9cd 3623 	strd	r3, r6, [sp, #140]	; 0x8c
 80538ae:	f340 808b 	ble.w	80539c8 <_svfprintf_r+0x1058>
 80538b2:	aa22      	add	r2, sp, #136	; 0x88
 80538b4:	4649      	mov	r1, r9
 80538b6:	4650      	mov	r0, sl
 80538b8:	f003 ff38 	bl	805772c <__ssprint_r>
 80538bc:	2800      	cmp	r0, #0
 80538be:	f040 81d1 	bne.w	8053c64 <_svfprintf_r+0x12f4>
 80538c2:	ac25      	add	r4, sp, #148	; 0x94
 80538c4:	f418 6f80 	tst.w	r8, #1024	; 0x400
 80538c8:	445d      	add	r5, fp
 80538ca:	d00b      	beq.n	80538e4 <_svfprintf_r+0xf74>
 80538cc:	4e88      	ldr	r6, [pc, #544]	; (8053af0 <_svfprintf_r+0x1180>)
 80538ce:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80538d0:	2b00      	cmp	r3, #0
 80538d2:	d17b      	bne.n	80539cc <_svfprintf_r+0x105c>
 80538d4:	9b08      	ldr	r3, [sp, #32]
 80538d6:	2b00      	cmp	r3, #0
 80538d8:	d17b      	bne.n	80539d2 <_svfprintf_r+0x1062>
 80538da:	9b05      	ldr	r3, [sp, #20]
 80538dc:	445b      	add	r3, fp
 80538de:	429d      	cmp	r5, r3
 80538e0:	bf28      	it	cs
 80538e2:	461d      	movcs	r5, r3
 80538e4:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 80538e6:	9a05      	ldr	r2, [sp, #20]
 80538e8:	4293      	cmp	r3, r2
 80538ea:	db02      	blt.n	80538f2 <_svfprintf_r+0xf82>
 80538ec:	f018 0f01 	tst.w	r8, #1
 80538f0:	d00e      	beq.n	8053910 <_svfprintf_r+0xfa0>
 80538f2:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 80538f4:	6023      	str	r3, [r4, #0]
 80538f6:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80538f8:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 80538fa:	6063      	str	r3, [r4, #4]
 80538fc:	9b24      	ldr	r3, [sp, #144]	; 0x90
 80538fe:	4413      	add	r3, r2
 8053900:	9324      	str	r3, [sp, #144]	; 0x90
 8053902:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 8053904:	3301      	adds	r3, #1
 8053906:	2b07      	cmp	r3, #7
 8053908:	9323      	str	r3, [sp, #140]	; 0x8c
 805390a:	f300 80dd 	bgt.w	8053ac8 <_svfprintf_r+0x1158>
 805390e:	3408      	adds	r4, #8
 8053910:	9b05      	ldr	r3, [sp, #20]
 8053912:	9e1c      	ldr	r6, [sp, #112]	; 0x70
 8053914:	eb0b 0203 	add.w	r2, fp, r3
 8053918:	1b9e      	subs	r6, r3, r6
 805391a:	1b52      	subs	r2, r2, r5
 805391c:	4296      	cmp	r6, r2
 805391e:	bfa8      	it	ge
 8053920:	4616      	movge	r6, r2
 8053922:	2e00      	cmp	r6, #0
 8053924:	dd0b      	ble.n	805393e <_svfprintf_r+0xfce>
 8053926:	9b24      	ldr	r3, [sp, #144]	; 0x90
 8053928:	4433      	add	r3, r6
 805392a:	9324      	str	r3, [sp, #144]	; 0x90
 805392c:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 805392e:	3301      	adds	r3, #1
 8053930:	2b07      	cmp	r3, #7
 8053932:	e9c4 5600 	strd	r5, r6, [r4]
 8053936:	9323      	str	r3, [sp, #140]	; 0x8c
 8053938:	f300 80d0 	bgt.w	8053adc <_svfprintf_r+0x116c>
 805393c:	3408      	adds	r4, #8
 805393e:	9d1c      	ldr	r5, [sp, #112]	; 0x70
 8053940:	9b05      	ldr	r3, [sp, #20]
 8053942:	2e00      	cmp	r6, #0
 8053944:	eba3 0505 	sub.w	r5, r3, r5
 8053948:	bfa8      	it	ge
 805394a:	1bad      	subge	r5, r5, r6
 805394c:	2d00      	cmp	r5, #0
 805394e:	f77f abf1 	ble.w	8053134 <_svfprintf_r+0x7c4>
 8053952:	4e67      	ldr	r6, [pc, #412]	; (8053af0 <_svfprintf_r+0x1180>)
 8053954:	2710      	movs	r7, #16
 8053956:	e9dd 3223 	ldrd	r3, r2, [sp, #140]	; 0x8c
 805395a:	2d10      	cmp	r5, #16
 805395c:	f103 0301 	add.w	r3, r3, #1
 8053960:	f104 0108 	add.w	r1, r4, #8
 8053964:	6026      	str	r6, [r4, #0]
 8053966:	f77f aecd 	ble.w	8053704 <_svfprintf_r+0xd94>
 805396a:	3210      	adds	r2, #16
 805396c:	2b07      	cmp	r3, #7
 805396e:	e9cd 3223 	strd	r3, r2, [sp, #140]	; 0x8c
 8053972:	6067      	str	r7, [r4, #4]
 8053974:	dd08      	ble.n	8053988 <_svfprintf_r+0x1018>
 8053976:	aa22      	add	r2, sp, #136	; 0x88
 8053978:	4649      	mov	r1, r9
 805397a:	4650      	mov	r0, sl
 805397c:	f003 fed6 	bl	805772c <__ssprint_r>
 8053980:	2800      	cmp	r0, #0
 8053982:	f040 816f 	bne.w	8053c64 <_svfprintf_r+0x12f4>
 8053986:	a925      	add	r1, sp, #148	; 0x94
 8053988:	3d10      	subs	r5, #16
 805398a:	460c      	mov	r4, r1
 805398c:	e7e3      	b.n	8053956 <_svfprintf_r+0xfe6>
 805398e:	aa22      	add	r2, sp, #136	; 0x88
 8053990:	4649      	mov	r1, r9
 8053992:	4650      	mov	r0, sl
 8053994:	f003 feca 	bl	805772c <__ssprint_r>
 8053998:	2800      	cmp	r0, #0
 805399a:	f040 8163 	bne.w	8053c64 <_svfprintf_r+0x12f4>
 805399e:	ac25      	add	r4, sp, #148	; 0x94
 80539a0:	e770      	b.n	8053884 <_svfprintf_r+0xf14>
 80539a2:	2010      	movs	r0, #16
 80539a4:	4402      	add	r2, r0
 80539a6:	2b07      	cmp	r3, #7
 80539a8:	e9cd 3223 	strd	r3, r2, [sp, #140]	; 0x8c
 80539ac:	6060      	str	r0, [r4, #4]
 80539ae:	dd08      	ble.n	80539c2 <_svfprintf_r+0x1052>
 80539b0:	aa22      	add	r2, sp, #136	; 0x88
 80539b2:	4649      	mov	r1, r9
 80539b4:	4650      	mov	r0, sl
 80539b6:	f003 feb9 	bl	805772c <__ssprint_r>
 80539ba:	2800      	cmp	r0, #0
 80539bc:	f040 8152 	bne.w	8053c64 <_svfprintf_r+0x12f4>
 80539c0:	a925      	add	r1, sp, #148	; 0x94
 80539c2:	3e10      	subs	r6, #16
 80539c4:	460c      	mov	r4, r1
 80539c6:	e764      	b.n	8053892 <_svfprintf_r+0xf22>
 80539c8:	460c      	mov	r4, r1
 80539ca:	e77b      	b.n	80538c4 <_svfprintf_r+0xf54>
 80539cc:	9b08      	ldr	r3, [sp, #32]
 80539ce:	2b00      	cmp	r3, #0
 80539d0:	d04a      	beq.n	8053a68 <_svfprintf_r+0x10f8>
 80539d2:	9b08      	ldr	r3, [sp, #32]
 80539d4:	3b01      	subs	r3, #1
 80539d6:	9308      	str	r3, [sp, #32]
 80539d8:	9b14      	ldr	r3, [sp, #80]	; 0x50
 80539da:	6023      	str	r3, [r4, #0]
 80539dc:	9b12      	ldr	r3, [sp, #72]	; 0x48
 80539de:	9a12      	ldr	r2, [sp, #72]	; 0x48
 80539e0:	6063      	str	r3, [r4, #4]
 80539e2:	9b24      	ldr	r3, [sp, #144]	; 0x90
 80539e4:	4413      	add	r3, r2
 80539e6:	9324      	str	r3, [sp, #144]	; 0x90
 80539e8:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 80539ea:	3301      	adds	r3, #1
 80539ec:	2b07      	cmp	r3, #7
 80539ee:	9323      	str	r3, [sp, #140]	; 0x8c
 80539f0:	dc41      	bgt.n	8053a76 <_svfprintf_r+0x1106>
 80539f2:	3408      	adds	r4, #8
 80539f4:	9b05      	ldr	r3, [sp, #20]
 80539f6:	445b      	add	r3, fp
 80539f8:	1b5a      	subs	r2, r3, r5
 80539fa:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80539fc:	781b      	ldrb	r3, [r3, #0]
 80539fe:	4293      	cmp	r3, r2
 8053a00:	bfa8      	it	ge
 8053a02:	4613      	movge	r3, r2
 8053a04:	2b00      	cmp	r3, #0
 8053a06:	461f      	mov	r7, r3
 8053a08:	dd0a      	ble.n	8053a20 <_svfprintf_r+0x10b0>
 8053a0a:	e9c4 5300 	strd	r5, r3, [r4]
 8053a0e:	9b24      	ldr	r3, [sp, #144]	; 0x90
 8053a10:	443b      	add	r3, r7
 8053a12:	9324      	str	r3, [sp, #144]	; 0x90
 8053a14:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 8053a16:	3301      	adds	r3, #1
 8053a18:	2b07      	cmp	r3, #7
 8053a1a:	9323      	str	r3, [sp, #140]	; 0x8c
 8053a1c:	dc35      	bgt.n	8053a8a <_svfprintf_r+0x111a>
 8053a1e:	3408      	adds	r4, #8
 8053a20:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8053a22:	781b      	ldrb	r3, [r3, #0]
 8053a24:	2f00      	cmp	r7, #0
 8053a26:	bfac      	ite	ge
 8053a28:	1bdf      	subge	r7, r3, r7
 8053a2a:	461f      	movlt	r7, r3
 8053a2c:	2f00      	cmp	r7, #0
 8053a2e:	dd17      	ble.n	8053a60 <_svfprintf_r+0x10f0>
 8053a30:	e9dd 2323 	ldrd	r2, r3, [sp, #140]	; 0x8c
 8053a34:	2f10      	cmp	r7, #16
 8053a36:	f102 0201 	add.w	r2, r2, #1
 8053a3a:	f104 0108 	add.w	r1, r4, #8
 8053a3e:	6026      	str	r6, [r4, #0]
 8053a40:	dc2d      	bgt.n	8053a9e <_svfprintf_r+0x112e>
 8053a42:	443b      	add	r3, r7
 8053a44:	2a07      	cmp	r2, #7
 8053a46:	e9cd 2323 	strd	r2, r3, [sp, #140]	; 0x8c
 8053a4a:	6067      	str	r7, [r4, #4]
 8053a4c:	dd3a      	ble.n	8053ac4 <_svfprintf_r+0x1154>
 8053a4e:	aa22      	add	r2, sp, #136	; 0x88
 8053a50:	4649      	mov	r1, r9
 8053a52:	4650      	mov	r0, sl
 8053a54:	f003 fe6a 	bl	805772c <__ssprint_r>
 8053a58:	2800      	cmp	r0, #0
 8053a5a:	f040 8103 	bne.w	8053c64 <_svfprintf_r+0x12f4>
 8053a5e:	ac25      	add	r4, sp, #148	; 0x94
 8053a60:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8053a62:	781b      	ldrb	r3, [r3, #0]
 8053a64:	441d      	add	r5, r3
 8053a66:	e732      	b.n	80538ce <_svfprintf_r+0xf5e>
 8053a68:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8053a6a:	3b01      	subs	r3, #1
 8053a6c:	930a      	str	r3, [sp, #40]	; 0x28
 8053a6e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8053a70:	3b01      	subs	r3, #1
 8053a72:	9309      	str	r3, [sp, #36]	; 0x24
 8053a74:	e7b0      	b.n	80539d8 <_svfprintf_r+0x1068>
 8053a76:	aa22      	add	r2, sp, #136	; 0x88
 8053a78:	4649      	mov	r1, r9
 8053a7a:	4650      	mov	r0, sl
 8053a7c:	f003 fe56 	bl	805772c <__ssprint_r>
 8053a80:	2800      	cmp	r0, #0
 8053a82:	f040 80ef 	bne.w	8053c64 <_svfprintf_r+0x12f4>
 8053a86:	ac25      	add	r4, sp, #148	; 0x94
 8053a88:	e7b4      	b.n	80539f4 <_svfprintf_r+0x1084>
 8053a8a:	aa22      	add	r2, sp, #136	; 0x88
 8053a8c:	4649      	mov	r1, r9
 8053a8e:	4650      	mov	r0, sl
 8053a90:	f003 fe4c 	bl	805772c <__ssprint_r>
 8053a94:	2800      	cmp	r0, #0
 8053a96:	f040 80e5 	bne.w	8053c64 <_svfprintf_r+0x12f4>
 8053a9a:	ac25      	add	r4, sp, #148	; 0x94
 8053a9c:	e7c0      	b.n	8053a20 <_svfprintf_r+0x10b0>
 8053a9e:	2010      	movs	r0, #16
 8053aa0:	4403      	add	r3, r0
 8053aa2:	2a07      	cmp	r2, #7
 8053aa4:	e9cd 2323 	strd	r2, r3, [sp, #140]	; 0x8c
 8053aa8:	6060      	str	r0, [r4, #4]
 8053aaa:	dd08      	ble.n	8053abe <_svfprintf_r+0x114e>
 8053aac:	aa22      	add	r2, sp, #136	; 0x88
 8053aae:	4649      	mov	r1, r9
 8053ab0:	4650      	mov	r0, sl
 8053ab2:	f003 fe3b 	bl	805772c <__ssprint_r>
 8053ab6:	2800      	cmp	r0, #0
 8053ab8:	f040 80d4 	bne.w	8053c64 <_svfprintf_r+0x12f4>
 8053abc:	a925      	add	r1, sp, #148	; 0x94
 8053abe:	3f10      	subs	r7, #16
 8053ac0:	460c      	mov	r4, r1
 8053ac2:	e7b5      	b.n	8053a30 <_svfprintf_r+0x10c0>
 8053ac4:	460c      	mov	r4, r1
 8053ac6:	e7cb      	b.n	8053a60 <_svfprintf_r+0x10f0>
 8053ac8:	aa22      	add	r2, sp, #136	; 0x88
 8053aca:	4649      	mov	r1, r9
 8053acc:	4650      	mov	r0, sl
 8053ace:	f003 fe2d 	bl	805772c <__ssprint_r>
 8053ad2:	2800      	cmp	r0, #0
 8053ad4:	f040 80c6 	bne.w	8053c64 <_svfprintf_r+0x12f4>
 8053ad8:	ac25      	add	r4, sp, #148	; 0x94
 8053ada:	e719      	b.n	8053910 <_svfprintf_r+0xfa0>
 8053adc:	aa22      	add	r2, sp, #136	; 0x88
 8053ade:	4649      	mov	r1, r9
 8053ae0:	4650      	mov	r0, sl
 8053ae2:	f003 fe23 	bl	805772c <__ssprint_r>
 8053ae6:	2800      	cmp	r0, #0
 8053ae8:	f040 80bc 	bne.w	8053c64 <_svfprintf_r+0x12f4>
 8053aec:	ac25      	add	r4, sp, #148	; 0x94
 8053aee:	e726      	b.n	805393e <_svfprintf_r+0xfce>
 8053af0:	0805ab94 	.word	0x0805ab94
 8053af4:	9a05      	ldr	r2, [sp, #20]
 8053af6:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 8053af8:	2a01      	cmp	r2, #1
 8053afa:	f106 0601 	add.w	r6, r6, #1
 8053afe:	f103 0301 	add.w	r3, r3, #1
 8053b02:	f104 0508 	add.w	r5, r4, #8
 8053b06:	dc02      	bgt.n	8053b0e <_svfprintf_r+0x119e>
 8053b08:	f018 0f01 	tst.w	r8, #1
 8053b0c:	d07e      	beq.n	8053c0c <_svfprintf_r+0x129c>
 8053b0e:	2201      	movs	r2, #1
 8053b10:	2b07      	cmp	r3, #7
 8053b12:	e9cd 3623 	strd	r3, r6, [sp, #140]	; 0x8c
 8053b16:	f8c4 b000 	str.w	fp, [r4]
 8053b1a:	6062      	str	r2, [r4, #4]
 8053b1c:	dd08      	ble.n	8053b30 <_svfprintf_r+0x11c0>
 8053b1e:	aa22      	add	r2, sp, #136	; 0x88
 8053b20:	4649      	mov	r1, r9
 8053b22:	4650      	mov	r0, sl
 8053b24:	f003 fe02 	bl	805772c <__ssprint_r>
 8053b28:	2800      	cmp	r0, #0
 8053b2a:	f040 809b 	bne.w	8053c64 <_svfprintf_r+0x12f4>
 8053b2e:	ad25      	add	r5, sp, #148	; 0x94
 8053b30:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8053b32:	602b      	str	r3, [r5, #0]
 8053b34:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8053b36:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 8053b38:	606b      	str	r3, [r5, #4]
 8053b3a:	9b24      	ldr	r3, [sp, #144]	; 0x90
 8053b3c:	4413      	add	r3, r2
 8053b3e:	9324      	str	r3, [sp, #144]	; 0x90
 8053b40:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 8053b42:	3301      	adds	r3, #1
 8053b44:	2b07      	cmp	r3, #7
 8053b46:	9323      	str	r3, [sp, #140]	; 0x8c
 8053b48:	dc32      	bgt.n	8053bb0 <_svfprintf_r+0x1240>
 8053b4a:	3508      	adds	r5, #8
 8053b4c:	9b05      	ldr	r3, [sp, #20]
 8053b4e:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
 8053b52:	1e5c      	subs	r4, r3, #1
 8053b54:	2200      	movs	r2, #0
 8053b56:	2300      	movs	r3, #0
 8053b58:	f7ec ffd6 	bl	8040b08 <__aeabi_dcmpeq>
 8053b5c:	2800      	cmp	r0, #0
 8053b5e:	d130      	bne.n	8053bc2 <_svfprintf_r+0x1252>
 8053b60:	9923      	ldr	r1, [sp, #140]	; 0x8c
 8053b62:	9b24      	ldr	r3, [sp, #144]	; 0x90
 8053b64:	9a05      	ldr	r2, [sp, #20]
 8053b66:	3101      	adds	r1, #1
 8053b68:	3b01      	subs	r3, #1
 8053b6a:	f10b 0001 	add.w	r0, fp, #1
 8053b6e:	4413      	add	r3, r2
 8053b70:	2907      	cmp	r1, #7
 8053b72:	e9c5 0400 	strd	r0, r4, [r5]
 8053b76:	e9cd 1323 	strd	r1, r3, [sp, #140]	; 0x8c
 8053b7a:	dd50      	ble.n	8053c1e <_svfprintf_r+0x12ae>
 8053b7c:	aa22      	add	r2, sp, #136	; 0x88
 8053b7e:	4649      	mov	r1, r9
 8053b80:	4650      	mov	r0, sl
 8053b82:	f003 fdd3 	bl	805772c <__ssprint_r>
 8053b86:	2800      	cmp	r0, #0
 8053b88:	d16c      	bne.n	8053c64 <_svfprintf_r+0x12f4>
 8053b8a:	ad25      	add	r5, sp, #148	; 0x94
 8053b8c:	ab1e      	add	r3, sp, #120	; 0x78
 8053b8e:	602b      	str	r3, [r5, #0]
 8053b90:	9b15      	ldr	r3, [sp, #84]	; 0x54
 8053b92:	9a15      	ldr	r2, [sp, #84]	; 0x54
 8053b94:	606b      	str	r3, [r5, #4]
 8053b96:	9b24      	ldr	r3, [sp, #144]	; 0x90
 8053b98:	4413      	add	r3, r2
 8053b9a:	9324      	str	r3, [sp, #144]	; 0x90
 8053b9c:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 8053b9e:	3301      	adds	r3, #1
 8053ba0:	2b07      	cmp	r3, #7
 8053ba2:	9323      	str	r3, [sp, #140]	; 0x8c
 8053ba4:	f73f adb5 	bgt.w	8053712 <_svfprintf_r+0xda2>
 8053ba8:	f105 0408 	add.w	r4, r5, #8
 8053bac:	f7ff bac2 	b.w	8053134 <_svfprintf_r+0x7c4>
 8053bb0:	aa22      	add	r2, sp, #136	; 0x88
 8053bb2:	4649      	mov	r1, r9
 8053bb4:	4650      	mov	r0, sl
 8053bb6:	f003 fdb9 	bl	805772c <__ssprint_r>
 8053bba:	2800      	cmp	r0, #0
 8053bbc:	d152      	bne.n	8053c64 <_svfprintf_r+0x12f4>
 8053bbe:	ad25      	add	r5, sp, #148	; 0x94
 8053bc0:	e7c4      	b.n	8053b4c <_svfprintf_r+0x11dc>
 8053bc2:	2c00      	cmp	r4, #0
 8053bc4:	dde2      	ble.n	8053b8c <_svfprintf_r+0x121c>
 8053bc6:	4e58      	ldr	r6, [pc, #352]	; (8053d28 <_svfprintf_r+0x13b8>)
 8053bc8:	2710      	movs	r7, #16
 8053bca:	e9dd 3223 	ldrd	r3, r2, [sp, #140]	; 0x8c
 8053bce:	2c10      	cmp	r4, #16
 8053bd0:	f103 0301 	add.w	r3, r3, #1
 8053bd4:	f105 0108 	add.w	r1, r5, #8
 8053bd8:	602e      	str	r6, [r5, #0]
 8053bda:	dc07      	bgt.n	8053bec <_svfprintf_r+0x127c>
 8053bdc:	606c      	str	r4, [r5, #4]
 8053bde:	2b07      	cmp	r3, #7
 8053be0:	4414      	add	r4, r2
 8053be2:	e9cd 3423 	strd	r3, r4, [sp, #140]	; 0x8c
 8053be6:	dcc9      	bgt.n	8053b7c <_svfprintf_r+0x120c>
 8053be8:	460d      	mov	r5, r1
 8053bea:	e7cf      	b.n	8053b8c <_svfprintf_r+0x121c>
 8053bec:	3210      	adds	r2, #16
 8053bee:	2b07      	cmp	r3, #7
 8053bf0:	e9cd 3223 	strd	r3, r2, [sp, #140]	; 0x8c
 8053bf4:	606f      	str	r7, [r5, #4]
 8053bf6:	dd06      	ble.n	8053c06 <_svfprintf_r+0x1296>
 8053bf8:	aa22      	add	r2, sp, #136	; 0x88
 8053bfa:	4649      	mov	r1, r9
 8053bfc:	4650      	mov	r0, sl
 8053bfe:	f003 fd95 	bl	805772c <__ssprint_r>
 8053c02:	bb78      	cbnz	r0, 8053c64 <_svfprintf_r+0x12f4>
 8053c04:	a925      	add	r1, sp, #148	; 0x94
 8053c06:	3c10      	subs	r4, #16
 8053c08:	460d      	mov	r5, r1
 8053c0a:	e7de      	b.n	8053bca <_svfprintf_r+0x125a>
 8053c0c:	2201      	movs	r2, #1
 8053c0e:	2b07      	cmp	r3, #7
 8053c10:	e9cd 3623 	strd	r3, r6, [sp, #140]	; 0x8c
 8053c14:	f8c4 b000 	str.w	fp, [r4]
 8053c18:	6062      	str	r2, [r4, #4]
 8053c1a:	ddb7      	ble.n	8053b8c <_svfprintf_r+0x121c>
 8053c1c:	e7ae      	b.n	8053b7c <_svfprintf_r+0x120c>
 8053c1e:	3508      	adds	r5, #8
 8053c20:	e7b4      	b.n	8053b8c <_svfprintf_r+0x121c>
 8053c22:	460c      	mov	r4, r1
 8053c24:	f7ff ba86 	b.w	8053134 <_svfprintf_r+0x7c4>
 8053c28:	e9dd 3210 	ldrd	r3, r2, [sp, #64]	; 0x40
 8053c2c:	1a9d      	subs	r5, r3, r2
 8053c2e:	2d00      	cmp	r5, #0
 8053c30:	f77f aa84 	ble.w	805313c <_svfprintf_r+0x7cc>
 8053c34:	4e3d      	ldr	r6, [pc, #244]	; (8053d2c <_svfprintf_r+0x13bc>)
 8053c36:	2710      	movs	r7, #16
 8053c38:	e9dd 3223 	ldrd	r3, r2, [sp, #140]	; 0x8c
 8053c3c:	2d10      	cmp	r5, #16
 8053c3e:	f103 0301 	add.w	r3, r3, #1
 8053c42:	6026      	str	r6, [r4, #0]
 8053c44:	dc18      	bgt.n	8053c78 <_svfprintf_r+0x1308>
 8053c46:	6065      	str	r5, [r4, #4]
 8053c48:	2b07      	cmp	r3, #7
 8053c4a:	4415      	add	r5, r2
 8053c4c:	e9cd 3523 	strd	r3, r5, [sp, #140]	; 0x8c
 8053c50:	f77f aa74 	ble.w	805313c <_svfprintf_r+0x7cc>
 8053c54:	aa22      	add	r2, sp, #136	; 0x88
 8053c56:	4649      	mov	r1, r9
 8053c58:	4650      	mov	r0, sl
 8053c5a:	f003 fd67 	bl	805772c <__ssprint_r>
 8053c5e:	2800      	cmp	r0, #0
 8053c60:	f43f aa6c 	beq.w	805313c <_svfprintf_r+0x7cc>
 8053c64:	9b03      	ldr	r3, [sp, #12]
 8053c66:	2b00      	cmp	r3, #0
 8053c68:	f43f a88a 	beq.w	8052d80 <_svfprintf_r+0x410>
 8053c6c:	4619      	mov	r1, r3
 8053c6e:	4650      	mov	r0, sl
 8053c70:	f002 fb7e 	bl	8056370 <_free_r>
 8053c74:	f7ff b884 	b.w	8052d80 <_svfprintf_r+0x410>
 8053c78:	3210      	adds	r2, #16
 8053c7a:	2b07      	cmp	r3, #7
 8053c7c:	e9cd 3223 	strd	r3, r2, [sp, #140]	; 0x8c
 8053c80:	6067      	str	r7, [r4, #4]
 8053c82:	dc02      	bgt.n	8053c8a <_svfprintf_r+0x131a>
 8053c84:	3408      	adds	r4, #8
 8053c86:	3d10      	subs	r5, #16
 8053c88:	e7d6      	b.n	8053c38 <_svfprintf_r+0x12c8>
 8053c8a:	aa22      	add	r2, sp, #136	; 0x88
 8053c8c:	4649      	mov	r1, r9
 8053c8e:	4650      	mov	r0, sl
 8053c90:	f003 fd4c 	bl	805772c <__ssprint_r>
 8053c94:	2800      	cmp	r0, #0
 8053c96:	d1e5      	bne.n	8053c64 <_svfprintf_r+0x12f4>
 8053c98:	ac25      	add	r4, sp, #148	; 0x94
 8053c9a:	e7f4      	b.n	8053c86 <_svfprintf_r+0x1316>
 8053c9c:	9903      	ldr	r1, [sp, #12]
 8053c9e:	4650      	mov	r0, sl
 8053ca0:	f002 fb66 	bl	8056370 <_free_r>
 8053ca4:	f7ff ba62 	b.w	805316c <_svfprintf_r+0x7fc>
 8053ca8:	9b24      	ldr	r3, [sp, #144]	; 0x90
 8053caa:	2b00      	cmp	r3, #0
 8053cac:	f43f a868 	beq.w	8052d80 <_svfprintf_r+0x410>
 8053cb0:	aa22      	add	r2, sp, #136	; 0x88
 8053cb2:	4649      	mov	r1, r9
 8053cb4:	4650      	mov	r0, sl
 8053cb6:	f003 fd39 	bl	805772c <__ssprint_r>
 8053cba:	f7ff b861 	b.w	8052d80 <_svfprintf_r+0x410>
 8053cbe:	ea56 0207 	orrs.w	r2, r6, r7
 8053cc2:	f8cd 800c 	str.w	r8, [sp, #12]
 8053cc6:	f43f ab78 	beq.w	80533ba <_svfprintf_r+0xa4a>
 8053cca:	2b01      	cmp	r3, #1
 8053ccc:	f43f ac0d 	beq.w	80534ea <_svfprintf_r+0xb7a>
 8053cd0:	2b02      	cmp	r3, #2
 8053cd2:	f50d 7b9c 	add.w	fp, sp, #312	; 0x138
 8053cd6:	f43f ac55 	beq.w	8053584 <_svfprintf_r+0xc14>
 8053cda:	08f2      	lsrs	r2, r6, #3
 8053cdc:	ea42 7247 	orr.w	r2, r2, r7, lsl #29
 8053ce0:	08f8      	lsrs	r0, r7, #3
 8053ce2:	f006 0307 	and.w	r3, r6, #7
 8053ce6:	4607      	mov	r7, r0
 8053ce8:	4616      	mov	r6, r2
 8053cea:	3330      	adds	r3, #48	; 0x30
 8053cec:	ea56 0207 	orrs.w	r2, r6, r7
 8053cf0:	4659      	mov	r1, fp
 8053cf2:	f80b 3d01 	strb.w	r3, [fp, #-1]!
 8053cf6:	d1f0      	bne.n	8053cda <_svfprintf_r+0x136a>
 8053cf8:	9a03      	ldr	r2, [sp, #12]
 8053cfa:	07d2      	lsls	r2, r2, #31
 8053cfc:	d506      	bpl.n	8053d0c <_svfprintf_r+0x139c>
 8053cfe:	2b30      	cmp	r3, #48	; 0x30
 8053d00:	d004      	beq.n	8053d0c <_svfprintf_r+0x139c>
 8053d02:	2330      	movs	r3, #48	; 0x30
 8053d04:	f80b 3c01 	strb.w	r3, [fp, #-1]
 8053d08:	f1a1 0b02 	sub.w	fp, r1, #2
 8053d0c:	ab4e      	add	r3, sp, #312	; 0x138
 8053d0e:	eba3 030b 	sub.w	r3, r3, fp
 8053d12:	9e04      	ldr	r6, [sp, #16]
 8053d14:	9304      	str	r3, [sp, #16]
 8053d16:	2300      	movs	r3, #0
 8053d18:	f8dd 800c 	ldr.w	r8, [sp, #12]
 8053d1c:	9303      	str	r3, [sp, #12]
 8053d1e:	e9cd 3308 	strd	r3, r3, [sp, #32]
 8053d22:	461d      	mov	r5, r3
 8053d24:	f7ff b94c 	b.w	8052fc0 <_svfprintf_r+0x650>
 8053d28:	0805ab94 	.word	0x0805ab94
 8053d2c:	0805ab84 	.word	0x0805ab84

08053d30 <sysconf>:
 8053d30:	2808      	cmp	r0, #8
 8053d32:	b508      	push	{r3, lr}
 8053d34:	d006      	beq.n	8053d44 <sysconf+0x14>
 8053d36:	f002 f98b 	bl	8056050 <__errno>
 8053d3a:	2316      	movs	r3, #22
 8053d3c:	6003      	str	r3, [r0, #0]
 8053d3e:	f04f 30ff 	mov.w	r0, #4294967295
 8053d42:	bd08      	pop	{r3, pc}
 8053d44:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 8053d48:	e7fb      	b.n	8053d42 <sysconf+0x12>
	...

08053d4c <__utoa>:
 8053d4c:	b5f0      	push	{r4, r5, r6, r7, lr}
 8053d4e:	4c1f      	ldr	r4, [pc, #124]	; (8053dcc <__utoa+0x80>)
 8053d50:	b08b      	sub	sp, #44	; 0x2c
 8053d52:	4605      	mov	r5, r0
 8053d54:	460b      	mov	r3, r1
 8053d56:	466e      	mov	r6, sp
 8053d58:	f104 0c20 	add.w	ip, r4, #32
 8053d5c:	6820      	ldr	r0, [r4, #0]
 8053d5e:	6861      	ldr	r1, [r4, #4]
 8053d60:	4637      	mov	r7, r6
 8053d62:	c703      	stmia	r7!, {r0, r1}
 8053d64:	3408      	adds	r4, #8
 8053d66:	4564      	cmp	r4, ip
 8053d68:	463e      	mov	r6, r7
 8053d6a:	d1f7      	bne.n	8053d5c <__utoa+0x10>
 8053d6c:	7921      	ldrb	r1, [r4, #4]
 8053d6e:	7139      	strb	r1, [r7, #4]
 8053d70:	1e91      	subs	r1, r2, #2
 8053d72:	6820      	ldr	r0, [r4, #0]
 8053d74:	6038      	str	r0, [r7, #0]
 8053d76:	2922      	cmp	r1, #34	; 0x22
 8053d78:	f04f 0100 	mov.w	r1, #0
 8053d7c:	d904      	bls.n	8053d88 <__utoa+0x3c>
 8053d7e:	7019      	strb	r1, [r3, #0]
 8053d80:	460b      	mov	r3, r1
 8053d82:	4618      	mov	r0, r3
 8053d84:	b00b      	add	sp, #44	; 0x2c
 8053d86:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8053d88:	1e58      	subs	r0, r3, #1
 8053d8a:	4684      	mov	ip, r0
 8053d8c:	fbb5 f7f2 	udiv	r7, r5, r2
 8053d90:	f10d 0e28 	add.w	lr, sp, #40	; 0x28
 8053d94:	fb02 5617 	mls	r6, r2, r7, r5
 8053d98:	4476      	add	r6, lr
 8053d9a:	460c      	mov	r4, r1
 8053d9c:	f816 6c28 	ldrb.w	r6, [r6, #-40]
 8053da0:	f80c 6f01 	strb.w	r6, [ip, #1]!
 8053da4:	462e      	mov	r6, r5
 8053da6:	42b2      	cmp	r2, r6
 8053da8:	f101 0101 	add.w	r1, r1, #1
 8053dac:	463d      	mov	r5, r7
 8053dae:	d9ed      	bls.n	8053d8c <__utoa+0x40>
 8053db0:	2200      	movs	r2, #0
 8053db2:	545a      	strb	r2, [r3, r1]
 8053db4:	1919      	adds	r1, r3, r4
 8053db6:	1aa5      	subs	r5, r4, r2
 8053db8:	42aa      	cmp	r2, r5
 8053dba:	dae2      	bge.n	8053d82 <__utoa+0x36>
 8053dbc:	f810 5f01 	ldrb.w	r5, [r0, #1]!
 8053dc0:	780e      	ldrb	r6, [r1, #0]
 8053dc2:	7006      	strb	r6, [r0, #0]
 8053dc4:	3201      	adds	r2, #1
 8053dc6:	f801 5901 	strb.w	r5, [r1], #-1
 8053dca:	e7f4      	b.n	8053db6 <__utoa+0x6a>
 8053dcc:	0805aba4 	.word	0x0805aba4

08053dd0 <_vfprintf_r>:
 8053dd0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8053dd4:	ed2d 8b04 	vpush	{d8-d9}
 8053dd8:	b0cf      	sub	sp, #316	; 0x13c
 8053dda:	4689      	mov	r9, r1
 8053ddc:	9203      	str	r2, [sp, #12]
 8053dde:	461c      	mov	r4, r3
 8053de0:	461e      	mov	r6, r3
 8053de2:	4682      	mov	sl, r0
 8053de4:	f002 ff18 	bl	8056c18 <_localeconv_r>
 8053de8:	6803      	ldr	r3, [r0, #0]
 8053dea:	9313      	str	r3, [sp, #76]	; 0x4c
 8053dec:	4618      	mov	r0, r3
 8053dee:	f7ec fa09 	bl	8040204 <strlen>
 8053df2:	900e      	str	r0, [sp, #56]	; 0x38
 8053df4:	f1ba 0f00 	cmp.w	sl, #0
 8053df8:	d005      	beq.n	8053e06 <_vfprintf_r+0x36>
 8053dfa:	f8da 3038 	ldr.w	r3, [sl, #56]	; 0x38
 8053dfe:	b913      	cbnz	r3, 8053e06 <_vfprintf_r+0x36>
 8053e00:	4650      	mov	r0, sl
 8053e02:	f002 fa25 	bl	8056250 <__sinit>
 8053e06:	f8d9 3064 	ldr.w	r3, [r9, #100]	; 0x64
 8053e0a:	07d8      	lsls	r0, r3, #31
 8053e0c:	d407      	bmi.n	8053e1e <_vfprintf_r+0x4e>
 8053e0e:	f8b9 300c 	ldrh.w	r3, [r9, #12]
 8053e12:	0599      	lsls	r1, r3, #22
 8053e14:	d403      	bmi.n	8053e1e <_vfprintf_r+0x4e>
 8053e16:	f8d9 0058 	ldr.w	r0, [r9, #88]	; 0x58
 8053e1a:	f002 ff03 	bl	8056c24 <__retarget_lock_acquire_recursive>
 8053e1e:	f9b9 300c 	ldrsh.w	r3, [r9, #12]
 8053e22:	049a      	lsls	r2, r3, #18
 8053e24:	d409      	bmi.n	8053e3a <_vfprintf_r+0x6a>
 8053e26:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8053e2a:	f8a9 300c 	strh.w	r3, [r9, #12]
 8053e2e:	f8d9 3064 	ldr.w	r3, [r9, #100]	; 0x64
 8053e32:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 8053e36:	f8c9 3064 	str.w	r3, [r9, #100]	; 0x64
 8053e3a:	f8b9 300c 	ldrh.w	r3, [r9, #12]
 8053e3e:	071f      	lsls	r7, r3, #28
 8053e40:	d502      	bpl.n	8053e48 <_vfprintf_r+0x78>
 8053e42:	f8d9 3010 	ldr.w	r3, [r9, #16]
 8053e46:	b9d3      	cbnz	r3, 8053e7e <_vfprintf_r+0xae>
 8053e48:	4649      	mov	r1, r9
 8053e4a:	4650      	mov	r0, sl
 8053e4c:	f001 fa36 	bl	80552bc <__swsetup_r>
 8053e50:	b1a8      	cbz	r0, 8053e7e <_vfprintf_r+0xae>
 8053e52:	f8d9 3064 	ldr.w	r3, [r9, #100]	; 0x64
 8053e56:	07dd      	lsls	r5, r3, #31
 8053e58:	d508      	bpl.n	8053e6c <_vfprintf_r+0x9c>
 8053e5a:	f04f 33ff 	mov.w	r3, #4294967295
 8053e5e:	930f      	str	r3, [sp, #60]	; 0x3c
 8053e60:	980f      	ldr	r0, [sp, #60]	; 0x3c
 8053e62:	b04f      	add	sp, #316	; 0x13c
 8053e64:	ecbd 8b04 	vpop	{d8-d9}
 8053e68:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8053e6c:	f8b9 300c 	ldrh.w	r3, [r9, #12]
 8053e70:	059c      	lsls	r4, r3, #22
 8053e72:	d4f2      	bmi.n	8053e5a <_vfprintf_r+0x8a>
 8053e74:	f8d9 0058 	ldr.w	r0, [r9, #88]	; 0x58
 8053e78:	f002 fed5 	bl	8056c26 <__retarget_lock_release_recursive>
 8053e7c:	e7ed      	b.n	8053e5a <_vfprintf_r+0x8a>
 8053e7e:	f8b9 300c 	ldrh.w	r3, [r9, #12]
 8053e82:	f003 021a 	and.w	r2, r3, #26
 8053e86:	2a0a      	cmp	r2, #10
 8053e88:	d115      	bne.n	8053eb6 <_vfprintf_r+0xe6>
 8053e8a:	f9b9 200e 	ldrsh.w	r2, [r9, #14]
 8053e8e:	2a00      	cmp	r2, #0
 8053e90:	db11      	blt.n	8053eb6 <_vfprintf_r+0xe6>
 8053e92:	f8d9 2064 	ldr.w	r2, [r9, #100]	; 0x64
 8053e96:	07d0      	lsls	r0, r2, #31
 8053e98:	d405      	bmi.n	8053ea6 <_vfprintf_r+0xd6>
 8053e9a:	0599      	lsls	r1, r3, #22
 8053e9c:	d403      	bmi.n	8053ea6 <_vfprintf_r+0xd6>
 8053e9e:	f8d9 0058 	ldr.w	r0, [r9, #88]	; 0x58
 8053ea2:	f002 fec0 	bl	8056c26 <__retarget_lock_release_recursive>
 8053ea6:	9a03      	ldr	r2, [sp, #12]
 8053ea8:	4623      	mov	r3, r4
 8053eaa:	4649      	mov	r1, r9
 8053eac:	4650      	mov	r0, sl
 8053eae:	f001 f9c5 	bl	805523c <__sbprintf>
 8053eb2:	900f      	str	r0, [sp, #60]	; 0x3c
 8053eb4:	e7d4      	b.n	8053e60 <_vfprintf_r+0x90>
 8053eb6:	ed9f 7b9a 	vldr	d7, [pc, #616]	; 8054120 <_vfprintf_r+0x350>
 8053eba:	2500      	movs	r5, #0
 8053ebc:	e9cd 5523 	strd	r5, r5, [sp, #140]	; 0x8c
 8053ec0:	ed8d 7b0c 	vstr	d7, [sp, #48]	; 0x30
 8053ec4:	e9cd 5515 	strd	r5, r5, [sp, #84]	; 0x54
 8053ec8:	ac25      	add	r4, sp, #148	; 0x94
 8053eca:	9422      	str	r4, [sp, #136]	; 0x88
 8053ecc:	9505      	str	r5, [sp, #20]
 8053ece:	950a      	str	r5, [sp, #40]	; 0x28
 8053ed0:	9512      	str	r5, [sp, #72]	; 0x48
 8053ed2:	9514      	str	r5, [sp, #80]	; 0x50
 8053ed4:	950f      	str	r5, [sp, #60]	; 0x3c
 8053ed6:	9b03      	ldr	r3, [sp, #12]
 8053ed8:	461d      	mov	r5, r3
 8053eda:	f813 2b01 	ldrb.w	r2, [r3], #1
 8053ede:	b10a      	cbz	r2, 8053ee4 <_vfprintf_r+0x114>
 8053ee0:	2a25      	cmp	r2, #37	; 0x25
 8053ee2:	d1f9      	bne.n	8053ed8 <_vfprintf_r+0x108>
 8053ee4:	9b03      	ldr	r3, [sp, #12]
 8053ee6:	1aef      	subs	r7, r5, r3
 8053ee8:	d00d      	beq.n	8053f06 <_vfprintf_r+0x136>
 8053eea:	e9c4 3700 	strd	r3, r7, [r4]
 8053eee:	9b24      	ldr	r3, [sp, #144]	; 0x90
 8053ef0:	443b      	add	r3, r7
 8053ef2:	9324      	str	r3, [sp, #144]	; 0x90
 8053ef4:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 8053ef6:	3301      	adds	r3, #1
 8053ef8:	2b07      	cmp	r3, #7
 8053efa:	9323      	str	r3, [sp, #140]	; 0x8c
 8053efc:	dc79      	bgt.n	8053ff2 <_vfprintf_r+0x222>
 8053efe:	3408      	adds	r4, #8
 8053f00:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8053f02:	443b      	add	r3, r7
 8053f04:	930f      	str	r3, [sp, #60]	; 0x3c
 8053f06:	782b      	ldrb	r3, [r5, #0]
 8053f08:	2b00      	cmp	r3, #0
 8053f0a:	f001 8156 	beq.w	80551ba <_vfprintf_r+0x13ea>
 8053f0e:	2300      	movs	r3, #0
 8053f10:	3501      	adds	r5, #1
 8053f12:	f88d 306b 	strb.w	r3, [sp, #107]	; 0x6b
 8053f16:	f04f 38ff 	mov.w	r8, #4294967295
 8053f1a:	9310      	str	r3, [sp, #64]	; 0x40
 8053f1c:	469b      	mov	fp, r3
 8053f1e:	270a      	movs	r7, #10
 8053f20:	212b      	movs	r1, #43	; 0x2b
 8053f22:	462a      	mov	r2, r5
 8053f24:	f812 3b01 	ldrb.w	r3, [r2], #1
 8053f28:	9307      	str	r3, [sp, #28]
 8053f2a:	4613      	mov	r3, r2
 8053f2c:	930b      	str	r3, [sp, #44]	; 0x2c
 8053f2e:	9b07      	ldr	r3, [sp, #28]
 8053f30:	3b20      	subs	r3, #32
 8053f32:	2b5a      	cmp	r3, #90	; 0x5a
 8053f34:	f200 85c0 	bhi.w	8054ab8 <_vfprintf_r+0xce8>
 8053f38:	e8df f013 	tbh	[pc, r3, lsl #1]
 8053f3c:	05be007e 	.word	0x05be007e
 8053f40:	008605be 	.word	0x008605be
 8053f44:	05be05be 	.word	0x05be05be
 8053f48:	006505be 	.word	0x006505be
 8053f4c:	05be05be 	.word	0x05be05be
 8053f50:	00930089 	.word	0x00930089
 8053f54:	009005be 	.word	0x009005be
 8053f58:	05be0096 	.word	0x05be0096
 8053f5c:	00b200af 	.word	0x00b200af
 8053f60:	00b200b2 	.word	0x00b200b2
 8053f64:	00b200b2 	.word	0x00b200b2
 8053f68:	00b200b2 	.word	0x00b200b2
 8053f6c:	00b200b2 	.word	0x00b200b2
 8053f70:	05be05be 	.word	0x05be05be
 8053f74:	05be05be 	.word	0x05be05be
 8053f78:	05be05be 	.word	0x05be05be
 8053f7c:	012105be 	.word	0x012105be
 8053f80:	00df05be 	.word	0x00df05be
 8053f84:	012100f6 	.word	0x012100f6
 8053f88:	01210121 	.word	0x01210121
 8053f8c:	05be05be 	.word	0x05be05be
 8053f90:	05be05be 	.word	0x05be05be
 8053f94:	05be00c2 	.word	0x05be00c2
 8053f98:	049005be 	.word	0x049005be
 8053f9c:	05be05be 	.word	0x05be05be
 8053fa0:	04d705be 	.word	0x04d705be
 8053fa4:	04fb05be 	.word	0x04fb05be
 8053fa8:	05be05be 	.word	0x05be05be
 8053fac:	05be051a 	.word	0x05be051a
 8053fb0:	05be05be 	.word	0x05be05be
 8053fb4:	05be05be 	.word	0x05be05be
 8053fb8:	05be05be 	.word	0x05be05be
 8053fbc:	012105be 	.word	0x012105be
 8053fc0:	00df05be 	.word	0x00df05be
 8053fc4:	012100f8 	.word	0x012100f8
 8053fc8:	01210121 	.word	0x01210121
 8053fcc:	00f800c5 	.word	0x00f800c5
 8053fd0:	05be00d9 	.word	0x05be00d9
 8053fd4:	05be00d2 	.word	0x05be00d2
 8053fd8:	0492046d 	.word	0x0492046d
 8053fdc:	00d904c6 	.word	0x00d904c6
 8053fe0:	04d705be 	.word	0x04d705be
 8053fe4:	04fd007c 	.word	0x04fd007c
 8053fe8:	05be05be 	.word	0x05be05be
 8053fec:	05be0537 	.word	0x05be0537
 8053ff0:	007c      	.short	0x007c
 8053ff2:	aa22      	add	r2, sp, #136	; 0x88
 8053ff4:	4649      	mov	r1, r9
 8053ff6:	4650      	mov	r0, sl
 8053ff8:	f003 fc13 	bl	8057822 <__sprint_r>
 8053ffc:	2800      	cmp	r0, #0
 8053ffe:	f040 8130 	bne.w	8054262 <_vfprintf_r+0x492>
 8054002:	ac25      	add	r4, sp, #148	; 0x94
 8054004:	e77c      	b.n	8053f00 <_vfprintf_r+0x130>
 8054006:	4650      	mov	r0, sl
 8054008:	f002 fe06 	bl	8056c18 <_localeconv_r>
 805400c:	6843      	ldr	r3, [r0, #4]
 805400e:	9314      	str	r3, [sp, #80]	; 0x50
 8054010:	4618      	mov	r0, r3
 8054012:	f7ec f8f7 	bl	8040204 <strlen>
 8054016:	9012      	str	r0, [sp, #72]	; 0x48
 8054018:	4650      	mov	r0, sl
 805401a:	f002 fdfd 	bl	8056c18 <_localeconv_r>
 805401e:	6883      	ldr	r3, [r0, #8]
 8054020:	930a      	str	r3, [sp, #40]	; 0x28
 8054022:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8054024:	212b      	movs	r1, #43	; 0x2b
 8054026:	b12b      	cbz	r3, 8054034 <_vfprintf_r+0x264>
 8054028:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 805402a:	b11b      	cbz	r3, 8054034 <_vfprintf_r+0x264>
 805402c:	781b      	ldrb	r3, [r3, #0]
 805402e:	b10b      	cbz	r3, 8054034 <_vfprintf_r+0x264>
 8054030:	f44b 6b80 	orr.w	fp, fp, #1024	; 0x400
 8054034:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
 8054036:	e774      	b.n	8053f22 <_vfprintf_r+0x152>
 8054038:	f89d 306b 	ldrb.w	r3, [sp, #107]	; 0x6b
 805403c:	2b00      	cmp	r3, #0
 805403e:	d1f9      	bne.n	8054034 <_vfprintf_r+0x264>
 8054040:	2320      	movs	r3, #32
 8054042:	f88d 306b 	strb.w	r3, [sp, #107]	; 0x6b
 8054046:	e7f5      	b.n	8054034 <_vfprintf_r+0x264>
 8054048:	f04b 0b01 	orr.w	fp, fp, #1
 805404c:	e7f2      	b.n	8054034 <_vfprintf_r+0x264>
 805404e:	f856 3b04 	ldr.w	r3, [r6], #4
 8054052:	9310      	str	r3, [sp, #64]	; 0x40
 8054054:	2b00      	cmp	r3, #0
 8054056:	daed      	bge.n	8054034 <_vfprintf_r+0x264>
 8054058:	425b      	negs	r3, r3
 805405a:	9310      	str	r3, [sp, #64]	; 0x40
 805405c:	f04b 0b04 	orr.w	fp, fp, #4
 8054060:	e7e8      	b.n	8054034 <_vfprintf_r+0x264>
 8054062:	f88d 106b 	strb.w	r1, [sp, #107]	; 0x6b
 8054066:	e7e5      	b.n	8054034 <_vfprintf_r+0x264>
 8054068:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 805406a:	f813 2b01 	ldrb.w	r2, [r3], #1
 805406e:	9207      	str	r2, [sp, #28]
 8054070:	2a2a      	cmp	r2, #42	; 0x2a
 8054072:	d10f      	bne.n	8054094 <_vfprintf_r+0x2c4>
 8054074:	f856 0b04 	ldr.w	r0, [r6], #4
 8054078:	930b      	str	r3, [sp, #44]	; 0x2c
 805407a:	ea40 78e0 	orr.w	r8, r0, r0, asr #31
 805407e:	e7d9      	b.n	8054034 <_vfprintf_r+0x264>
 8054080:	fb07 2808 	mla	r8, r7, r8, r2
 8054084:	f813 2b01 	ldrb.w	r2, [r3], #1
 8054088:	9207      	str	r2, [sp, #28]
 805408a:	9a07      	ldr	r2, [sp, #28]
 805408c:	3a30      	subs	r2, #48	; 0x30
 805408e:	2a09      	cmp	r2, #9
 8054090:	d9f6      	bls.n	8054080 <_vfprintf_r+0x2b0>
 8054092:	e74b      	b.n	8053f2c <_vfprintf_r+0x15c>
 8054094:	f04f 0800 	mov.w	r8, #0
 8054098:	e7f7      	b.n	805408a <_vfprintf_r+0x2ba>
 805409a:	f04b 0b80 	orr.w	fp, fp, #128	; 0x80
 805409e:	e7c9      	b.n	8054034 <_vfprintf_r+0x264>
 80540a0:	2200      	movs	r2, #0
 80540a2:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80540a4:	9210      	str	r2, [sp, #64]	; 0x40
 80540a6:	9a07      	ldr	r2, [sp, #28]
 80540a8:	9810      	ldr	r0, [sp, #64]	; 0x40
 80540aa:	3a30      	subs	r2, #48	; 0x30
 80540ac:	fb07 2200 	mla	r2, r7, r0, r2
 80540b0:	9210      	str	r2, [sp, #64]	; 0x40
 80540b2:	f813 2b01 	ldrb.w	r2, [r3], #1
 80540b6:	9207      	str	r2, [sp, #28]
 80540b8:	3a30      	subs	r2, #48	; 0x30
 80540ba:	2a09      	cmp	r2, #9
 80540bc:	d9f3      	bls.n	80540a6 <_vfprintf_r+0x2d6>
 80540be:	e735      	b.n	8053f2c <_vfprintf_r+0x15c>
 80540c0:	f04b 0b08 	orr.w	fp, fp, #8
 80540c4:	e7b6      	b.n	8054034 <_vfprintf_r+0x264>
 80540c6:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80540c8:	781b      	ldrb	r3, [r3, #0]
 80540ca:	2b68      	cmp	r3, #104	; 0x68
 80540cc:	bf01      	itttt	eq
 80540ce:	9b0b      	ldreq	r3, [sp, #44]	; 0x2c
 80540d0:	3301      	addeq	r3, #1
 80540d2:	930b      	streq	r3, [sp, #44]	; 0x2c
 80540d4:	f44b 7b00 	orreq.w	fp, fp, #512	; 0x200
 80540d8:	bf18      	it	ne
 80540da:	f04b 0b40 	orrne.w	fp, fp, #64	; 0x40
 80540de:	e7a9      	b.n	8054034 <_vfprintf_r+0x264>
 80540e0:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80540e2:	781b      	ldrb	r3, [r3, #0]
 80540e4:	2b6c      	cmp	r3, #108	; 0x6c
 80540e6:	d105      	bne.n	80540f4 <_vfprintf_r+0x324>
 80540e8:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80540ea:	3301      	adds	r3, #1
 80540ec:	930b      	str	r3, [sp, #44]	; 0x2c
 80540ee:	f04b 0b20 	orr.w	fp, fp, #32
 80540f2:	e79f      	b.n	8054034 <_vfprintf_r+0x264>
 80540f4:	f04b 0b10 	orr.w	fp, fp, #16
 80540f8:	e79c      	b.n	8054034 <_vfprintf_r+0x264>
 80540fa:	4632      	mov	r2, r6
 80540fc:	2000      	movs	r0, #0
 80540fe:	f852 3b04 	ldr.w	r3, [r2], #4
 8054102:	9206      	str	r2, [sp, #24]
 8054104:	f88d 30d4 	strb.w	r3, [sp, #212]	; 0xd4
 8054108:	f88d 006b 	strb.w	r0, [sp, #107]	; 0x6b
 805410c:	ab35      	add	r3, sp, #212	; 0xd4
 805410e:	e9cd 0008 	strd	r0, r0, [sp, #32]
 8054112:	9004      	str	r0, [sp, #16]
 8054114:	f04f 0801 	mov.w	r8, #1
 8054118:	4606      	mov	r6, r0
 805411a:	4605      	mov	r5, r0
 805411c:	9303      	str	r3, [sp, #12]
 805411e:	e1c3      	b.n	80544a8 <_vfprintf_r+0x6d8>
	...
 8054128:	f04b 0b10 	orr.w	fp, fp, #16
 805412c:	f01b 0f20 	tst.w	fp, #32
 8054130:	d012      	beq.n	8054158 <_vfprintf_r+0x388>
 8054132:	3607      	adds	r6, #7
 8054134:	f026 0307 	bic.w	r3, r6, #7
 8054138:	e8f3 6702 	ldrd	r6, r7, [r3], #8
 805413c:	9306      	str	r3, [sp, #24]
 805413e:	2e00      	cmp	r6, #0
 8054140:	f177 0300 	sbcs.w	r3, r7, #0
 8054144:	da06      	bge.n	8054154 <_vfprintf_r+0x384>
 8054146:	4276      	negs	r6, r6
 8054148:	f04f 032d 	mov.w	r3, #45	; 0x2d
 805414c:	eb67 0747 	sbc.w	r7, r7, r7, lsl #1
 8054150:	f88d 306b 	strb.w	r3, [sp, #107]	; 0x6b
 8054154:	2301      	movs	r3, #1
 8054156:	e392      	b.n	805487e <_vfprintf_r+0xaae>
 8054158:	1d33      	adds	r3, r6, #4
 805415a:	f01b 0f10 	tst.w	fp, #16
 805415e:	9306      	str	r3, [sp, #24]
 8054160:	d002      	beq.n	8054168 <_vfprintf_r+0x398>
 8054162:	6836      	ldr	r6, [r6, #0]
 8054164:	17f7      	asrs	r7, r6, #31
 8054166:	e7ea      	b.n	805413e <_vfprintf_r+0x36e>
 8054168:	f01b 0f40 	tst.w	fp, #64	; 0x40
 805416c:	6836      	ldr	r6, [r6, #0]
 805416e:	d001      	beq.n	8054174 <_vfprintf_r+0x3a4>
 8054170:	b236      	sxth	r6, r6
 8054172:	e7f7      	b.n	8054164 <_vfprintf_r+0x394>
 8054174:	f41b 7f00 	tst.w	fp, #512	; 0x200
 8054178:	bf18      	it	ne
 805417a:	b276      	sxtbne	r6, r6
 805417c:	e7f2      	b.n	8054164 <_vfprintf_r+0x394>
 805417e:	3607      	adds	r6, #7
 8054180:	f026 0307 	bic.w	r3, r6, #7
 8054184:	ecb3 7b02 	vldmia	r3!, {d7}
 8054188:	ed8d 7b0c 	vstr	d7, [sp, #48]	; 0x30
 805418c:	9306      	str	r3, [sp, #24]
 805418e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8054190:	ee09 3a10 	vmov	s18, r3
 8054194:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8054196:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 805419a:	ee09 3a90 	vmov	s19, r3
 805419e:	f04f 32ff 	mov.w	r2, #4294967295
 80541a2:	4b39      	ldr	r3, [pc, #228]	; (8054288 <_vfprintf_r+0x4b8>)
 80541a4:	ec51 0b19 	vmov	r0, r1, d9
 80541a8:	f7ec fce0 	bl	8040b6c <__aeabi_dcmpun>
 80541ac:	bb20      	cbnz	r0, 80541f8 <_vfprintf_r+0x428>
 80541ae:	4b36      	ldr	r3, [pc, #216]	; (8054288 <_vfprintf_r+0x4b8>)
 80541b0:	ec51 0b19 	vmov	r0, r1, d9
 80541b4:	f04f 32ff 	mov.w	r2, #4294967295
 80541b8:	f7ec fcba 	bl	8040b30 <__aeabi_dcmple>
 80541bc:	b9e0      	cbnz	r0, 80541f8 <_vfprintf_r+0x428>
 80541be:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
 80541c2:	2200      	movs	r2, #0
 80541c4:	2300      	movs	r3, #0
 80541c6:	f7ec fca9 	bl	8040b1c <__aeabi_dcmplt>
 80541ca:	b110      	cbz	r0, 80541d2 <_vfprintf_r+0x402>
 80541cc:	232d      	movs	r3, #45	; 0x2d
 80541ce:	f88d 306b 	strb.w	r3, [sp, #107]	; 0x6b
 80541d2:	4a2e      	ldr	r2, [pc, #184]	; (805428c <_vfprintf_r+0x4bc>)
 80541d4:	482e      	ldr	r0, [pc, #184]	; (8054290 <_vfprintf_r+0x4c0>)
 80541d6:	9907      	ldr	r1, [sp, #28]
 80541d8:	4613      	mov	r3, r2
 80541da:	2947      	cmp	r1, #71	; 0x47
 80541dc:	bfc8      	it	gt
 80541de:	4603      	movgt	r3, r0
 80541e0:	9303      	str	r3, [sp, #12]
 80541e2:	2300      	movs	r3, #0
 80541e4:	f02b 0b80 	bic.w	fp, fp, #128	; 0x80
 80541e8:	9304      	str	r3, [sp, #16]
 80541ea:	f04f 0803 	mov.w	r8, #3
 80541ee:	461e      	mov	r6, r3
 80541f0:	e9cd 3308 	strd	r3, r3, [sp, #32]
 80541f4:	461d      	mov	r5, r3
 80541f6:	e157      	b.n	80544a8 <_vfprintf_r+0x6d8>
 80541f8:	e9dd 230c 	ldrd	r2, r3, [sp, #48]	; 0x30
 80541fc:	4610      	mov	r0, r2
 80541fe:	4619      	mov	r1, r3
 8054200:	f7ec fcb4 	bl	8040b6c <__aeabi_dcmpun>
 8054204:	b140      	cbz	r0, 8054218 <_vfprintf_r+0x448>
 8054206:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8054208:	4a22      	ldr	r2, [pc, #136]	; (8054294 <_vfprintf_r+0x4c4>)
 805420a:	4823      	ldr	r0, [pc, #140]	; (8054298 <_vfprintf_r+0x4c8>)
 805420c:	2b00      	cmp	r3, #0
 805420e:	bfbc      	itt	lt
 8054210:	232d      	movlt	r3, #45	; 0x2d
 8054212:	f88d 306b 	strblt.w	r3, [sp, #107]	; 0x6b
 8054216:	e7de      	b.n	80541d6 <_vfprintf_r+0x406>
 8054218:	9b07      	ldr	r3, [sp, #28]
 805421a:	f023 0320 	bic.w	r3, r3, #32
 805421e:	2b41      	cmp	r3, #65	; 0x41
 8054220:	9308      	str	r3, [sp, #32]
 8054222:	d13b      	bne.n	805429c <_vfprintf_r+0x4cc>
 8054224:	2330      	movs	r3, #48	; 0x30
 8054226:	f88d 306c 	strb.w	r3, [sp, #108]	; 0x6c
 805422a:	9b07      	ldr	r3, [sp, #28]
 805422c:	2b61      	cmp	r3, #97	; 0x61
 805422e:	bf0c      	ite	eq
 8054230:	2378      	moveq	r3, #120	; 0x78
 8054232:	2358      	movne	r3, #88	; 0x58
 8054234:	f1b8 0f63 	cmp.w	r8, #99	; 0x63
 8054238:	f88d 306d 	strb.w	r3, [sp, #109]	; 0x6d
 805423c:	f04b 0b02 	orr.w	fp, fp, #2
 8054240:	f340 8209 	ble.w	8054656 <_vfprintf_r+0x886>
 8054244:	f108 0101 	add.w	r1, r8, #1
 8054248:	4650      	mov	r0, sl
 805424a:	f7fd f98b 	bl	8051564 <_malloc_r>
 805424e:	9003      	str	r0, [sp, #12]
 8054250:	2800      	cmp	r0, #0
 8054252:	f040 8204 	bne.w	805465e <_vfprintf_r+0x88e>
 8054256:	f8b9 300c 	ldrh.w	r3, [r9, #12]
 805425a:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 805425e:	f8a9 300c 	strh.w	r3, [r9, #12]
 8054262:	f8d9 3064 	ldr.w	r3, [r9, #100]	; 0x64
 8054266:	07d9      	lsls	r1, r3, #31
 8054268:	d407      	bmi.n	805427a <_vfprintf_r+0x4aa>
 805426a:	f8b9 300c 	ldrh.w	r3, [r9, #12]
 805426e:	059a      	lsls	r2, r3, #22
 8054270:	d403      	bmi.n	805427a <_vfprintf_r+0x4aa>
 8054272:	f8d9 0058 	ldr.w	r0, [r9, #88]	; 0x58
 8054276:	f002 fcd6 	bl	8056c26 <__retarget_lock_release_recursive>
 805427a:	f8b9 300c 	ldrh.w	r3, [r9, #12]
 805427e:	065b      	lsls	r3, r3, #25
 8054280:	f57f adee 	bpl.w	8053e60 <_vfprintf_r+0x90>
 8054284:	e5e9      	b.n	8053e5a <_vfprintf_r+0x8a>
 8054286:	bf00      	nop
 8054288:	7fefffff 	.word	0x7fefffff
 805428c:	0805ab50 	.word	0x0805ab50
 8054290:	0805ab54 	.word	0x0805ab54
 8054294:	0805ab58 	.word	0x0805ab58
 8054298:	0805ab5c 	.word	0x0805ab5c
 805429c:	f1b8 3fff 	cmp.w	r8, #4294967295
 80542a0:	f000 81e0 	beq.w	8054664 <_vfprintf_r+0x894>
 80542a4:	9b08      	ldr	r3, [sp, #32]
 80542a6:	2b47      	cmp	r3, #71	; 0x47
 80542a8:	f040 81e0 	bne.w	805466c <_vfprintf_r+0x89c>
 80542ac:	f1b8 0f00 	cmp.w	r8, #0
 80542b0:	f040 81dc 	bne.w	805466c <_vfprintf_r+0x89c>
 80542b4:	f8cd 8010 	str.w	r8, [sp, #16]
 80542b8:	f04f 0801 	mov.w	r8, #1
 80542bc:	f44b 7380 	orr.w	r3, fp, #256	; 0x100
 80542c0:	9311      	str	r3, [sp, #68]	; 0x44
 80542c2:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 80542c4:	2b00      	cmp	r3, #0
 80542c6:	f280 81d3 	bge.w	8054670 <_vfprintf_r+0x8a0>
 80542ca:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80542cc:	ee08 3a10 	vmov	s16, r3
 80542d0:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 80542d2:	f103 4300 	add.w	r3, r3, #2147483648	; 0x80000000
 80542d6:	ee08 3a90 	vmov	s17, r3
 80542da:	232d      	movs	r3, #45	; 0x2d
 80542dc:	9318      	str	r3, [sp, #96]	; 0x60
 80542de:	9b08      	ldr	r3, [sp, #32]
 80542e0:	2b41      	cmp	r3, #65	; 0x41
 80542e2:	f040 81e3 	bne.w	80546ac <_vfprintf_r+0x8dc>
 80542e6:	eeb0 0a48 	vmov.f32	s0, s16
 80542ea:	eef0 0a68 	vmov.f32	s1, s17
 80542ee:	a81c      	add	r0, sp, #112	; 0x70
 80542f0:	f003 f986 	bl	8057600 <frexp>
 80542f4:	2200      	movs	r2, #0
 80542f6:	f04f 537f 	mov.w	r3, #1069547520	; 0x3fc00000
 80542fa:	ec51 0b10 	vmov	r0, r1, d0
 80542fe:	f7ec f99b 	bl	8040638 <__aeabi_dmul>
 8054302:	2200      	movs	r2, #0
 8054304:	2300      	movs	r3, #0
 8054306:	4606      	mov	r6, r0
 8054308:	460f      	mov	r7, r1
 805430a:	f7ec fbfd 	bl	8040b08 <__aeabi_dcmpeq>
 805430e:	b108      	cbz	r0, 8054314 <_vfprintf_r+0x544>
 8054310:	2301      	movs	r3, #1
 8054312:	931c      	str	r3, [sp, #112]	; 0x70
 8054314:	4bb7      	ldr	r3, [pc, #732]	; (80545f4 <_vfprintf_r+0x824>)
 8054316:	4ab8      	ldr	r2, [pc, #736]	; (80545f8 <_vfprintf_r+0x828>)
 8054318:	9907      	ldr	r1, [sp, #28]
 805431a:	9d03      	ldr	r5, [sp, #12]
 805431c:	2961      	cmp	r1, #97	; 0x61
 805431e:	bf18      	it	ne
 8054320:	461a      	movne	r2, r3
 8054322:	f108 33ff 	add.w	r3, r8, #4294967295
 8054326:	9217      	str	r2, [sp, #92]	; 0x5c
 8054328:	9305      	str	r3, [sp, #20]
 805432a:	4bb4      	ldr	r3, [pc, #720]	; (80545fc <_vfprintf_r+0x82c>)
 805432c:	2200      	movs	r2, #0
 805432e:	4630      	mov	r0, r6
 8054330:	4639      	mov	r1, r7
 8054332:	f7ec f981 	bl	8040638 <__aeabi_dmul>
 8054336:	460f      	mov	r7, r1
 8054338:	4606      	mov	r6, r0
 805433a:	f7ec fc2d 	bl	8040b98 <__aeabi_d2iz>
 805433e:	9019      	str	r0, [sp, #100]	; 0x64
 8054340:	f7ec f910 	bl	8040564 <__aeabi_i2d>
 8054344:	4602      	mov	r2, r0
 8054346:	460b      	mov	r3, r1
 8054348:	4630      	mov	r0, r6
 805434a:	4639      	mov	r1, r7
 805434c:	f7eb ffbc 	bl	80402c8 <__aeabi_dsub>
 8054350:	9a19      	ldr	r2, [sp, #100]	; 0x64
 8054352:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 8054354:	5c9b      	ldrb	r3, [r3, r2]
 8054356:	f805 3b01 	strb.w	r3, [r5], #1
 805435a:	9b05      	ldr	r3, [sp, #20]
 805435c:	9309      	str	r3, [sp, #36]	; 0x24
 805435e:	1c5a      	adds	r2, r3, #1
 8054360:	4606      	mov	r6, r0
 8054362:	460f      	mov	r7, r1
 8054364:	d007      	beq.n	8054376 <_vfprintf_r+0x5a6>
 8054366:	3b01      	subs	r3, #1
 8054368:	9305      	str	r3, [sp, #20]
 805436a:	2200      	movs	r2, #0
 805436c:	2300      	movs	r3, #0
 805436e:	f7ec fbcb 	bl	8040b08 <__aeabi_dcmpeq>
 8054372:	2800      	cmp	r0, #0
 8054374:	d0d9      	beq.n	805432a <_vfprintf_r+0x55a>
 8054376:	4ba2      	ldr	r3, [pc, #648]	; (8054600 <_vfprintf_r+0x830>)
 8054378:	2200      	movs	r2, #0
 805437a:	4630      	mov	r0, r6
 805437c:	4639      	mov	r1, r7
 805437e:	f7ec fbeb 	bl	8040b58 <__aeabi_dcmpgt>
 8054382:	b960      	cbnz	r0, 805439e <_vfprintf_r+0x5ce>
 8054384:	4b9e      	ldr	r3, [pc, #632]	; (8054600 <_vfprintf_r+0x830>)
 8054386:	2200      	movs	r2, #0
 8054388:	4630      	mov	r0, r6
 805438a:	4639      	mov	r1, r7
 805438c:	f7ec fbbc 	bl	8040b08 <__aeabi_dcmpeq>
 8054390:	2800      	cmp	r0, #0
 8054392:	f000 8186 	beq.w	80546a2 <_vfprintf_r+0x8d2>
 8054396:	9b19      	ldr	r3, [sp, #100]	; 0x64
 8054398:	07df      	lsls	r7, r3, #31
 805439a:	f140 8182 	bpl.w	80546a2 <_vfprintf_r+0x8d2>
 805439e:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 80543a0:	9520      	str	r5, [sp, #128]	; 0x80
 80543a2:	7bd9      	ldrb	r1, [r3, #15]
 80543a4:	2030      	movs	r0, #48	; 0x30
 80543a6:	9a20      	ldr	r2, [sp, #128]	; 0x80
 80543a8:	1e53      	subs	r3, r2, #1
 80543aa:	9320      	str	r3, [sp, #128]	; 0x80
 80543ac:	f812 3c01 	ldrb.w	r3, [r2, #-1]
 80543b0:	428b      	cmp	r3, r1
 80543b2:	f000 8165 	beq.w	8054680 <_vfprintf_r+0x8b0>
 80543b6:	2b39      	cmp	r3, #57	; 0x39
 80543b8:	bf0b      	itete	eq
 80543ba:	9b17      	ldreq	r3, [sp, #92]	; 0x5c
 80543bc:	3301      	addne	r3, #1
 80543be:	7a9b      	ldrbeq	r3, [r3, #10]
 80543c0:	b2db      	uxtbne	r3, r3
 80543c2:	f802 3c01 	strb.w	r3, [r2, #-1]
 80543c6:	9b03      	ldr	r3, [sp, #12]
 80543c8:	1aeb      	subs	r3, r5, r3
 80543ca:	9305      	str	r3, [sp, #20]
 80543cc:	9b08      	ldr	r3, [sp, #32]
 80543ce:	9d1c      	ldr	r5, [sp, #112]	; 0x70
 80543d0:	2b47      	cmp	r3, #71	; 0x47
 80543d2:	f040 81b3 	bne.w	805473c <_vfprintf_r+0x96c>
 80543d6:	1cee      	adds	r6, r5, #3
 80543d8:	db02      	blt.n	80543e0 <_vfprintf_r+0x610>
 80543da:	4545      	cmp	r5, r8
 80543dc:	f340 81d5 	ble.w	805478a <_vfprintf_r+0x9ba>
 80543e0:	9b07      	ldr	r3, [sp, #28]
 80543e2:	3b02      	subs	r3, #2
 80543e4:	9307      	str	r3, [sp, #28]
 80543e6:	9907      	ldr	r1, [sp, #28]
 80543e8:	f89d 201c 	ldrb.w	r2, [sp, #28]
 80543ec:	f021 0120 	bic.w	r1, r1, #32
 80543f0:	2941      	cmp	r1, #65	; 0x41
 80543f2:	bf08      	it	eq
 80543f4:	320f      	addeq	r2, #15
 80543f6:	f105 33ff 	add.w	r3, r5, #4294967295
 80543fa:	bf06      	itte	eq
 80543fc:	b2d2      	uxtbeq	r2, r2
 80543fe:	2101      	moveq	r1, #1
 8054400:	2100      	movne	r1, #0
 8054402:	2b00      	cmp	r3, #0
 8054404:	931c      	str	r3, [sp, #112]	; 0x70
 8054406:	bfb8      	it	lt
 8054408:	f1c5 0301 	rsblt	r3, r5, #1
 805440c:	f88d 2078 	strb.w	r2, [sp, #120]	; 0x78
 8054410:	bfb4      	ite	lt
 8054412:	222d      	movlt	r2, #45	; 0x2d
 8054414:	222b      	movge	r2, #43	; 0x2b
 8054416:	2b09      	cmp	r3, #9
 8054418:	f88d 2079 	strb.w	r2, [sp, #121]	; 0x79
 805441c:	f340 81a4 	ble.w	8054768 <_vfprintf_r+0x998>
 8054420:	f10d 0287 	add.w	r2, sp, #135	; 0x87
 8054424:	260a      	movs	r6, #10
 8054426:	4611      	mov	r1, r2
 8054428:	fb93 f5f6 	sdiv	r5, r3, r6
 805442c:	fb06 3015 	mls	r0, r6, r5, r3
 8054430:	3030      	adds	r0, #48	; 0x30
 8054432:	f801 0c01 	strb.w	r0, [r1, #-1]
 8054436:	4618      	mov	r0, r3
 8054438:	2863      	cmp	r0, #99	; 0x63
 805443a:	f102 32ff 	add.w	r2, r2, #4294967295
 805443e:	462b      	mov	r3, r5
 8054440:	dcf1      	bgt.n	8054426 <_vfprintf_r+0x656>
 8054442:	3330      	adds	r3, #48	; 0x30
 8054444:	1e88      	subs	r0, r1, #2
 8054446:	f802 3c01 	strb.w	r3, [r2, #-1]
 805444a:	f10d 0587 	add.w	r5, sp, #135	; 0x87
 805444e:	f10d 027a 	add.w	r2, sp, #122	; 0x7a
 8054452:	4603      	mov	r3, r0
 8054454:	42ab      	cmp	r3, r5
 8054456:	f0c0 8182 	bcc.w	805475e <_vfprintf_r+0x98e>
 805445a:	f10d 0289 	add.w	r2, sp, #137	; 0x89
 805445e:	1a52      	subs	r2, r2, r1
 8054460:	42a8      	cmp	r0, r5
 8054462:	bf88      	it	hi
 8054464:	2200      	movhi	r2, #0
 8054466:	f10d 037a 	add.w	r3, sp, #122	; 0x7a
 805446a:	441a      	add	r2, r3
 805446c:	ab1e      	add	r3, sp, #120	; 0x78
 805446e:	1ad3      	subs	r3, r2, r3
 8054470:	9a05      	ldr	r2, [sp, #20]
 8054472:	9315      	str	r3, [sp, #84]	; 0x54
 8054474:	2a01      	cmp	r2, #1
 8054476:	eb03 0802 	add.w	r8, r3, r2
 805447a:	dc02      	bgt.n	8054482 <_vfprintf_r+0x6b2>
 805447c:	f01b 0f01 	tst.w	fp, #1
 8054480:	d001      	beq.n	8054486 <_vfprintf_r+0x6b6>
 8054482:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8054484:	4498      	add	r8, r3
 8054486:	f42b 6380 	bic.w	r3, fp, #1024	; 0x400
 805448a:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 805448e:	9311      	str	r3, [sp, #68]	; 0x44
 8054490:	2300      	movs	r3, #0
 8054492:	e9cd 3308 	strd	r3, r3, [sp, #32]
 8054496:	461d      	mov	r5, r3
 8054498:	9b18      	ldr	r3, [sp, #96]	; 0x60
 805449a:	b113      	cbz	r3, 80544a2 <_vfprintf_r+0x6d2>
 805449c:	232d      	movs	r3, #45	; 0x2d
 805449e:	f88d 306b 	strb.w	r3, [sp, #107]	; 0x6b
 80544a2:	f8dd b044 	ldr.w	fp, [sp, #68]	; 0x44
 80544a6:	2600      	movs	r6, #0
 80544a8:	4546      	cmp	r6, r8
 80544aa:	4633      	mov	r3, r6
 80544ac:	bfb8      	it	lt
 80544ae:	4643      	movlt	r3, r8
 80544b0:	9311      	str	r3, [sp, #68]	; 0x44
 80544b2:	f89d 306b 	ldrb.w	r3, [sp, #107]	; 0x6b
 80544b6:	b113      	cbz	r3, 80544be <_vfprintf_r+0x6ee>
 80544b8:	9b11      	ldr	r3, [sp, #68]	; 0x44
 80544ba:	3301      	adds	r3, #1
 80544bc:	9311      	str	r3, [sp, #68]	; 0x44
 80544be:	f01b 0302 	ands.w	r3, fp, #2
 80544c2:	9317      	str	r3, [sp, #92]	; 0x5c
 80544c4:	bf1e      	ittt	ne
 80544c6:	9b11      	ldrne	r3, [sp, #68]	; 0x44
 80544c8:	3302      	addne	r3, #2
 80544ca:	9311      	strne	r3, [sp, #68]	; 0x44
 80544cc:	f01b 0384 	ands.w	r3, fp, #132	; 0x84
 80544d0:	9318      	str	r3, [sp, #96]	; 0x60
 80544d2:	d11f      	bne.n	8054514 <_vfprintf_r+0x744>
 80544d4:	e9dd 3210 	ldrd	r3, r2, [sp, #64]	; 0x40
 80544d8:	1a9f      	subs	r7, r3, r2
 80544da:	2f00      	cmp	r7, #0
 80544dc:	dd1a      	ble.n	8054514 <_vfprintf_r+0x744>
 80544de:	e9dd 3223 	ldrd	r3, r2, [sp, #140]	; 0x8c
 80544e2:	4848      	ldr	r0, [pc, #288]	; (8054604 <_vfprintf_r+0x834>)
 80544e4:	6020      	str	r0, [r4, #0]
 80544e6:	2f10      	cmp	r7, #16
 80544e8:	f103 0301 	add.w	r3, r3, #1
 80544ec:	f104 0108 	add.w	r1, r4, #8
 80544f0:	f300 82f0 	bgt.w	8054ad4 <_vfprintf_r+0xd04>
 80544f4:	6067      	str	r7, [r4, #4]
 80544f6:	2b07      	cmp	r3, #7
 80544f8:	4417      	add	r7, r2
 80544fa:	e9cd 3723 	strd	r3, r7, [sp, #140]	; 0x8c
 80544fe:	f340 82fc 	ble.w	8054afa <_vfprintf_r+0xd2a>
 8054502:	aa22      	add	r2, sp, #136	; 0x88
 8054504:	4649      	mov	r1, r9
 8054506:	4650      	mov	r0, sl
 8054508:	f003 f98b 	bl	8057822 <__sprint_r>
 805450c:	2800      	cmp	r0, #0
 805450e:	f040 8632 	bne.w	8055176 <_vfprintf_r+0x13a6>
 8054512:	ac25      	add	r4, sp, #148	; 0x94
 8054514:	f89d 306b 	ldrb.w	r3, [sp, #107]	; 0x6b
 8054518:	b173      	cbz	r3, 8054538 <_vfprintf_r+0x768>
 805451a:	f10d 036b 	add.w	r3, sp, #107	; 0x6b
 805451e:	6023      	str	r3, [r4, #0]
 8054520:	2301      	movs	r3, #1
 8054522:	6063      	str	r3, [r4, #4]
 8054524:	9b24      	ldr	r3, [sp, #144]	; 0x90
 8054526:	3301      	adds	r3, #1
 8054528:	9324      	str	r3, [sp, #144]	; 0x90
 805452a:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 805452c:	3301      	adds	r3, #1
 805452e:	2b07      	cmp	r3, #7
 8054530:	9323      	str	r3, [sp, #140]	; 0x8c
 8054532:	f300 82e4 	bgt.w	8054afe <_vfprintf_r+0xd2e>
 8054536:	3408      	adds	r4, #8
 8054538:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 805453a:	b16b      	cbz	r3, 8054558 <_vfprintf_r+0x788>
 805453c:	ab1b      	add	r3, sp, #108	; 0x6c
 805453e:	6023      	str	r3, [r4, #0]
 8054540:	2302      	movs	r3, #2
 8054542:	6063      	str	r3, [r4, #4]
 8054544:	9b24      	ldr	r3, [sp, #144]	; 0x90
 8054546:	3302      	adds	r3, #2
 8054548:	9324      	str	r3, [sp, #144]	; 0x90
 805454a:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 805454c:	3301      	adds	r3, #1
 805454e:	2b07      	cmp	r3, #7
 8054550:	9323      	str	r3, [sp, #140]	; 0x8c
 8054552:	f300 82de 	bgt.w	8054b12 <_vfprintf_r+0xd42>
 8054556:	3408      	adds	r4, #8
 8054558:	9b18      	ldr	r3, [sp, #96]	; 0x60
 805455a:	2b80      	cmp	r3, #128	; 0x80
 805455c:	d11f      	bne.n	805459e <_vfprintf_r+0x7ce>
 805455e:	e9dd 3210 	ldrd	r3, r2, [sp, #64]	; 0x40
 8054562:	1a9f      	subs	r7, r3, r2
 8054564:	2f00      	cmp	r7, #0
 8054566:	dd1a      	ble.n	805459e <_vfprintf_r+0x7ce>
 8054568:	e9dd 3223 	ldrd	r3, r2, [sp, #140]	; 0x8c
 805456c:	4826      	ldr	r0, [pc, #152]	; (8054608 <_vfprintf_r+0x838>)
 805456e:	6020      	str	r0, [r4, #0]
 8054570:	2f10      	cmp	r7, #16
 8054572:	f103 0301 	add.w	r3, r3, #1
 8054576:	f104 0108 	add.w	r1, r4, #8
 805457a:	f300 82d4 	bgt.w	8054b26 <_vfprintf_r+0xd56>
 805457e:	6067      	str	r7, [r4, #4]
 8054580:	2b07      	cmp	r3, #7
 8054582:	4417      	add	r7, r2
 8054584:	e9cd 3723 	strd	r3, r7, [sp, #140]	; 0x8c
 8054588:	f340 82e0 	ble.w	8054b4c <_vfprintf_r+0xd7c>
 805458c:	aa22      	add	r2, sp, #136	; 0x88
 805458e:	4649      	mov	r1, r9
 8054590:	4650      	mov	r0, sl
 8054592:	f003 f946 	bl	8057822 <__sprint_r>
 8054596:	2800      	cmp	r0, #0
 8054598:	f040 85ed 	bne.w	8055176 <_vfprintf_r+0x13a6>
 805459c:	ac25      	add	r4, sp, #148	; 0x94
 805459e:	eba6 0608 	sub.w	r6, r6, r8
 80545a2:	2e00      	cmp	r6, #0
 80545a4:	dd1a      	ble.n	80545dc <_vfprintf_r+0x80c>
 80545a6:	4f18      	ldr	r7, [pc, #96]	; (8054608 <_vfprintf_r+0x838>)
 80545a8:	6027      	str	r7, [r4, #0]
 80545aa:	e9dd 3223 	ldrd	r3, r2, [sp, #140]	; 0x8c
 80545ae:	2e10      	cmp	r6, #16
 80545b0:	f103 0301 	add.w	r3, r3, #1
 80545b4:	f104 0108 	add.w	r1, r4, #8
 80545b8:	f300 82ca 	bgt.w	8054b50 <_vfprintf_r+0xd80>
 80545bc:	6066      	str	r6, [r4, #4]
 80545be:	2b07      	cmp	r3, #7
 80545c0:	4416      	add	r6, r2
 80545c2:	e9cd 3623 	strd	r3, r6, [sp, #140]	; 0x8c
 80545c6:	f340 82d6 	ble.w	8054b76 <_vfprintf_r+0xda6>
 80545ca:	aa22      	add	r2, sp, #136	; 0x88
 80545cc:	4649      	mov	r1, r9
 80545ce:	4650      	mov	r0, sl
 80545d0:	f003 f927 	bl	8057822 <__sprint_r>
 80545d4:	2800      	cmp	r0, #0
 80545d6:	f040 85ce 	bne.w	8055176 <_vfprintf_r+0x13a6>
 80545da:	ac25      	add	r4, sp, #148	; 0x94
 80545dc:	f41b 7f80 	tst.w	fp, #256	; 0x100
 80545e0:	9e24      	ldr	r6, [sp, #144]	; 0x90
 80545e2:	f040 82cf 	bne.w	8054b84 <_vfprintf_r+0xdb4>
 80545e6:	9b03      	ldr	r3, [sp, #12]
 80545e8:	e9c4 3800 	strd	r3, r8, [r4]
 80545ec:	4446      	add	r6, r8
 80545ee:	9624      	str	r6, [sp, #144]	; 0x90
 80545f0:	e00c      	b.n	805460c <_vfprintf_r+0x83c>
 80545f2:	bf00      	nop
 80545f4:	0805ab71 	.word	0x0805ab71
 80545f8:	0805ab60 	.word	0x0805ab60
 80545fc:	40300000 	.word	0x40300000
 8054600:	3fe00000 	.word	0x3fe00000
 8054604:	0805abc9 	.word	0x0805abc9
 8054608:	0805abd9 	.word	0x0805abd9
 805460c:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 805460e:	3301      	adds	r3, #1
 8054610:	2b07      	cmp	r3, #7
 8054612:	9323      	str	r3, [sp, #140]	; 0x8c
 8054614:	f300 82fb 	bgt.w	8054c0e <_vfprintf_r+0xe3e>
 8054618:	3408      	adds	r4, #8
 805461a:	f01b 0f04 	tst.w	fp, #4
 805461e:	f040 858c 	bne.w	805513a <_vfprintf_r+0x136a>
 8054622:	e9dd 320f 	ldrd	r3, r2, [sp, #60]	; 0x3c
 8054626:	9911      	ldr	r1, [sp, #68]	; 0x44
 8054628:	428a      	cmp	r2, r1
 805462a:	bfac      	ite	ge
 805462c:	189b      	addge	r3, r3, r2
 805462e:	185b      	addlt	r3, r3, r1
 8054630:	930f      	str	r3, [sp, #60]	; 0x3c
 8054632:	9b24      	ldr	r3, [sp, #144]	; 0x90
 8054634:	b13b      	cbz	r3, 8054646 <_vfprintf_r+0x876>
 8054636:	aa22      	add	r2, sp, #136	; 0x88
 8054638:	4649      	mov	r1, r9
 805463a:	4650      	mov	r0, sl
 805463c:	f003 f8f1 	bl	8057822 <__sprint_r>
 8054640:	2800      	cmp	r0, #0
 8054642:	f040 8598 	bne.w	8055176 <_vfprintf_r+0x13a6>
 8054646:	2300      	movs	r3, #0
 8054648:	9323      	str	r3, [sp, #140]	; 0x8c
 805464a:	9b04      	ldr	r3, [sp, #16]
 805464c:	2b00      	cmp	r3, #0
 805464e:	f040 85ae 	bne.w	80551ae <_vfprintf_r+0x13de>
 8054652:	ac25      	add	r4, sp, #148	; 0x94
 8054654:	e0eb      	b.n	805482e <_vfprintf_r+0xa5e>
 8054656:	ab35      	add	r3, sp, #212	; 0xd4
 8054658:	9004      	str	r0, [sp, #16]
 805465a:	9303      	str	r3, [sp, #12]
 805465c:	e62e      	b.n	80542bc <_vfprintf_r+0x4ec>
 805465e:	9b03      	ldr	r3, [sp, #12]
 8054660:	9304      	str	r3, [sp, #16]
 8054662:	e62b      	b.n	80542bc <_vfprintf_r+0x4ec>
 8054664:	9004      	str	r0, [sp, #16]
 8054666:	f04f 0806 	mov.w	r8, #6
 805466a:	e627      	b.n	80542bc <_vfprintf_r+0x4ec>
 805466c:	9004      	str	r0, [sp, #16]
 805466e:	e625      	b.n	80542bc <_vfprintf_r+0x4ec>
 8054670:	ed9d 7b0c 	vldr	d7, [sp, #48]	; 0x30
 8054674:	2300      	movs	r3, #0
 8054676:	eeb0 8a47 	vmov.f32	s16, s14
 805467a:	eef0 8a67 	vmov.f32	s17, s15
 805467e:	e62d      	b.n	80542dc <_vfprintf_r+0x50c>
 8054680:	f802 0c01 	strb.w	r0, [r2, #-1]
 8054684:	e68f      	b.n	80543a6 <_vfprintf_r+0x5d6>
 8054686:	f803 0b01 	strb.w	r0, [r3], #1
 805468a:	1aca      	subs	r2, r1, r3
 805468c:	2a00      	cmp	r2, #0
 805468e:	dafa      	bge.n	8054686 <_vfprintf_r+0x8b6>
 8054690:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8054692:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8054694:	3201      	adds	r2, #1
 8054696:	f103 0301 	add.w	r3, r3, #1
 805469a:	bfb8      	it	lt
 805469c:	2300      	movlt	r3, #0
 805469e:	441d      	add	r5, r3
 80546a0:	e691      	b.n	80543c6 <_vfprintf_r+0x5f6>
 80546a2:	9a09      	ldr	r2, [sp, #36]	; 0x24
 80546a4:	462b      	mov	r3, r5
 80546a6:	18a9      	adds	r1, r5, r2
 80546a8:	2030      	movs	r0, #48	; 0x30
 80546aa:	e7ee      	b.n	805468a <_vfprintf_r+0x8ba>
 80546ac:	9b08      	ldr	r3, [sp, #32]
 80546ae:	2b46      	cmp	r3, #70	; 0x46
 80546b0:	d005      	beq.n	80546be <_vfprintf_r+0x8ee>
 80546b2:	2b45      	cmp	r3, #69	; 0x45
 80546b4:	d11b      	bne.n	80546ee <_vfprintf_r+0x91e>
 80546b6:	f108 0501 	add.w	r5, r8, #1
 80546ba:	2102      	movs	r1, #2
 80546bc:	e001      	b.n	80546c2 <_vfprintf_r+0x8f2>
 80546be:	4645      	mov	r5, r8
 80546c0:	2103      	movs	r1, #3
 80546c2:	ab20      	add	r3, sp, #128	; 0x80
 80546c4:	9301      	str	r3, [sp, #4]
 80546c6:	ab1d      	add	r3, sp, #116	; 0x74
 80546c8:	9300      	str	r3, [sp, #0]
 80546ca:	462a      	mov	r2, r5
 80546cc:	ab1c      	add	r3, sp, #112	; 0x70
 80546ce:	4650      	mov	r0, sl
 80546d0:	eeb0 0a48 	vmov.f32	s0, s16
 80546d4:	eef0 0a68 	vmov.f32	s1, s17
 80546d8:	f000 fee6 	bl	80554a8 <_dtoa_r>
 80546dc:	9b08      	ldr	r3, [sp, #32]
 80546de:	9003      	str	r0, [sp, #12]
 80546e0:	2b47      	cmp	r3, #71	; 0x47
 80546e2:	d106      	bne.n	80546f2 <_vfprintf_r+0x922>
 80546e4:	f01b 0f01 	tst.w	fp, #1
 80546e8:	d103      	bne.n	80546f2 <_vfprintf_r+0x922>
 80546ea:	9d20      	ldr	r5, [sp, #128]	; 0x80
 80546ec:	e66b      	b.n	80543c6 <_vfprintf_r+0x5f6>
 80546ee:	4645      	mov	r5, r8
 80546f0:	e7e3      	b.n	80546ba <_vfprintf_r+0x8ea>
 80546f2:	9b03      	ldr	r3, [sp, #12]
 80546f4:	195e      	adds	r6, r3, r5
 80546f6:	9b08      	ldr	r3, [sp, #32]
 80546f8:	2b46      	cmp	r3, #70	; 0x46
 80546fa:	d10f      	bne.n	805471c <_vfprintf_r+0x94c>
 80546fc:	9b03      	ldr	r3, [sp, #12]
 80546fe:	781b      	ldrb	r3, [r3, #0]
 8054700:	2b30      	cmp	r3, #48	; 0x30
 8054702:	d109      	bne.n	8054718 <_vfprintf_r+0x948>
 8054704:	ec51 0b18 	vmov	r0, r1, d8
 8054708:	2200      	movs	r2, #0
 805470a:	2300      	movs	r3, #0
 805470c:	f7ec f9fc 	bl	8040b08 <__aeabi_dcmpeq>
 8054710:	b910      	cbnz	r0, 8054718 <_vfprintf_r+0x948>
 8054712:	f1c5 0501 	rsb	r5, r5, #1
 8054716:	951c      	str	r5, [sp, #112]	; 0x70
 8054718:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 805471a:	441e      	add	r6, r3
 805471c:	ec51 0b18 	vmov	r0, r1, d8
 8054720:	2200      	movs	r2, #0
 8054722:	2300      	movs	r3, #0
 8054724:	f7ec f9f0 	bl	8040b08 <__aeabi_dcmpeq>
 8054728:	b100      	cbz	r0, 805472c <_vfprintf_r+0x95c>
 805472a:	9620      	str	r6, [sp, #128]	; 0x80
 805472c:	2230      	movs	r2, #48	; 0x30
 805472e:	9b20      	ldr	r3, [sp, #128]	; 0x80
 8054730:	429e      	cmp	r6, r3
 8054732:	d9da      	bls.n	80546ea <_vfprintf_r+0x91a>
 8054734:	1c59      	adds	r1, r3, #1
 8054736:	9120      	str	r1, [sp, #128]	; 0x80
 8054738:	701a      	strb	r2, [r3, #0]
 805473a:	e7f8      	b.n	805472e <_vfprintf_r+0x95e>
 805473c:	9b08      	ldr	r3, [sp, #32]
 805473e:	2b46      	cmp	r3, #70	; 0x46
 8054740:	f47f ae51 	bne.w	80543e6 <_vfprintf_r+0x616>
 8054744:	f00b 0301 	and.w	r3, fp, #1
 8054748:	2d00      	cmp	r5, #0
 805474a:	ea43 0308 	orr.w	r3, r3, r8
 805474e:	dd18      	ble.n	8054782 <_vfprintf_r+0x9b2>
 8054750:	b383      	cbz	r3, 80547b4 <_vfprintf_r+0x9e4>
 8054752:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8054754:	18eb      	adds	r3, r5, r3
 8054756:	4498      	add	r8, r3
 8054758:	2366      	movs	r3, #102	; 0x66
 805475a:	9307      	str	r3, [sp, #28]
 805475c:	e030      	b.n	80547c0 <_vfprintf_r+0x9f0>
 805475e:	f813 6b01 	ldrb.w	r6, [r3], #1
 8054762:	f802 6b01 	strb.w	r6, [r2], #1
 8054766:	e675      	b.n	8054454 <_vfprintf_r+0x684>
 8054768:	b941      	cbnz	r1, 805477c <_vfprintf_r+0x9ac>
 805476a:	2230      	movs	r2, #48	; 0x30
 805476c:	f88d 207a 	strb.w	r2, [sp, #122]	; 0x7a
 8054770:	f10d 027b 	add.w	r2, sp, #123	; 0x7b
 8054774:	3330      	adds	r3, #48	; 0x30
 8054776:	f802 3b01 	strb.w	r3, [r2], #1
 805477a:	e677      	b.n	805446c <_vfprintf_r+0x69c>
 805477c:	f10d 027a 	add.w	r2, sp, #122	; 0x7a
 8054780:	e7f8      	b.n	8054774 <_vfprintf_r+0x9a4>
 8054782:	b1cb      	cbz	r3, 80547b8 <_vfprintf_r+0x9e8>
 8054784:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8054786:	3301      	adds	r3, #1
 8054788:	e7e5      	b.n	8054756 <_vfprintf_r+0x986>
 805478a:	9b05      	ldr	r3, [sp, #20]
 805478c:	429d      	cmp	r5, r3
 805478e:	db07      	blt.n	80547a0 <_vfprintf_r+0x9d0>
 8054790:	f01b 0f01 	tst.w	fp, #1
 8054794:	d029      	beq.n	80547ea <_vfprintf_r+0xa1a>
 8054796:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8054798:	eb05 0803 	add.w	r8, r5, r3
 805479c:	2367      	movs	r3, #103	; 0x67
 805479e:	e7dc      	b.n	805475a <_vfprintf_r+0x98a>
 80547a0:	9b05      	ldr	r3, [sp, #20]
 80547a2:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 80547a4:	2d00      	cmp	r5, #0
 80547a6:	eb03 0802 	add.w	r8, r3, r2
 80547aa:	dcf7      	bgt.n	805479c <_vfprintf_r+0x9cc>
 80547ac:	f1c5 0301 	rsb	r3, r5, #1
 80547b0:	4498      	add	r8, r3
 80547b2:	e7f3      	b.n	805479c <_vfprintf_r+0x9cc>
 80547b4:	46a8      	mov	r8, r5
 80547b6:	e7cf      	b.n	8054758 <_vfprintf_r+0x988>
 80547b8:	2366      	movs	r3, #102	; 0x66
 80547ba:	9307      	str	r3, [sp, #28]
 80547bc:	f04f 0801 	mov.w	r8, #1
 80547c0:	f41b 6380 	ands.w	r3, fp, #1024	; 0x400
 80547c4:	9309      	str	r3, [sp, #36]	; 0x24
 80547c6:	d023      	beq.n	8054810 <_vfprintf_r+0xa40>
 80547c8:	2300      	movs	r3, #0
 80547ca:	2d00      	cmp	r5, #0
 80547cc:	e9cd 3308 	strd	r3, r3, [sp, #32]
 80547d0:	f77f ae62 	ble.w	8054498 <_vfprintf_r+0x6c8>
 80547d4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80547d6:	781b      	ldrb	r3, [r3, #0]
 80547d8:	2bff      	cmp	r3, #255	; 0xff
 80547da:	d108      	bne.n	80547ee <_vfprintf_r+0xa1e>
 80547dc:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
 80547e0:	4413      	add	r3, r2
 80547e2:	9a12      	ldr	r2, [sp, #72]	; 0x48
 80547e4:	fb02 8803 	mla	r8, r2, r3, r8
 80547e8:	e656      	b.n	8054498 <_vfprintf_r+0x6c8>
 80547ea:	46a8      	mov	r8, r5
 80547ec:	e7d6      	b.n	805479c <_vfprintf_r+0x9cc>
 80547ee:	42ab      	cmp	r3, r5
 80547f0:	daf4      	bge.n	80547dc <_vfprintf_r+0xa0c>
 80547f2:	1aed      	subs	r5, r5, r3
 80547f4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80547f6:	785b      	ldrb	r3, [r3, #1]
 80547f8:	b133      	cbz	r3, 8054808 <_vfprintf_r+0xa38>
 80547fa:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80547fc:	3301      	adds	r3, #1
 80547fe:	9309      	str	r3, [sp, #36]	; 0x24
 8054800:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8054802:	3301      	adds	r3, #1
 8054804:	930a      	str	r3, [sp, #40]	; 0x28
 8054806:	e7e5      	b.n	80547d4 <_vfprintf_r+0xa04>
 8054808:	9b08      	ldr	r3, [sp, #32]
 805480a:	3301      	adds	r3, #1
 805480c:	9308      	str	r3, [sp, #32]
 805480e:	e7e1      	b.n	80547d4 <_vfprintf_r+0xa04>
 8054810:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8054812:	9308      	str	r3, [sp, #32]
 8054814:	e640      	b.n	8054498 <_vfprintf_r+0x6c8>
 8054816:	4632      	mov	r2, r6
 8054818:	f01b 0f20 	tst.w	fp, #32
 805481c:	f852 3b04 	ldr.w	r3, [r2], #4
 8054820:	9206      	str	r2, [sp, #24]
 8054822:	d009      	beq.n	8054838 <_vfprintf_r+0xa68>
 8054824:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8054826:	4610      	mov	r0, r2
 8054828:	17d1      	asrs	r1, r2, #31
 805482a:	e9c3 0100 	strd	r0, r1, [r3]
 805482e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8054830:	9e06      	ldr	r6, [sp, #24]
 8054832:	9303      	str	r3, [sp, #12]
 8054834:	f7ff bb4f 	b.w	8053ed6 <_vfprintf_r+0x106>
 8054838:	f01b 0f10 	tst.w	fp, #16
 805483c:	d002      	beq.n	8054844 <_vfprintf_r+0xa74>
 805483e:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8054840:	601a      	str	r2, [r3, #0]
 8054842:	e7f4      	b.n	805482e <_vfprintf_r+0xa5e>
 8054844:	f01b 0f40 	tst.w	fp, #64	; 0x40
 8054848:	d002      	beq.n	8054850 <_vfprintf_r+0xa80>
 805484a:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 805484c:	801a      	strh	r2, [r3, #0]
 805484e:	e7ee      	b.n	805482e <_vfprintf_r+0xa5e>
 8054850:	f41b 7f00 	tst.w	fp, #512	; 0x200
 8054854:	d0f3      	beq.n	805483e <_vfprintf_r+0xa6e>
 8054856:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8054858:	701a      	strb	r2, [r3, #0]
 805485a:	e7e8      	b.n	805482e <_vfprintf_r+0xa5e>
 805485c:	f04b 0b10 	orr.w	fp, fp, #16
 8054860:	f01b 0f20 	tst.w	fp, #32
 8054864:	d01e      	beq.n	80548a4 <_vfprintf_r+0xad4>
 8054866:	3607      	adds	r6, #7
 8054868:	f026 0307 	bic.w	r3, r6, #7
 805486c:	e8f3 6702 	ldrd	r6, r7, [r3], #8
 8054870:	9306      	str	r3, [sp, #24]
 8054872:	f42b 6b80 	bic.w	fp, fp, #1024	; 0x400
 8054876:	2300      	movs	r3, #0
 8054878:	2200      	movs	r2, #0
 805487a:	f88d 206b 	strb.w	r2, [sp, #107]	; 0x6b
 805487e:	f1b8 3fff 	cmp.w	r8, #4294967295
 8054882:	f000 84a9 	beq.w	80551d8 <_vfprintf_r+0x1408>
 8054886:	f02b 0280 	bic.w	r2, fp, #128	; 0x80
 805488a:	9204      	str	r2, [sp, #16]
 805488c:	ea56 0207 	orrs.w	r2, r6, r7
 8054890:	f040 84a8 	bne.w	80551e4 <_vfprintf_r+0x1414>
 8054894:	f1b8 0f00 	cmp.w	r8, #0
 8054898:	f000 8104 	beq.w	8054aa4 <_vfprintf_r+0xcd4>
 805489c:	2b01      	cmp	r3, #1
 805489e:	f040 84a4 	bne.w	80551ea <_vfprintf_r+0x141a>
 80548a2:	e09a      	b.n	80549da <_vfprintf_r+0xc0a>
 80548a4:	1d33      	adds	r3, r6, #4
 80548a6:	f01b 0f10 	tst.w	fp, #16
 80548aa:	9306      	str	r3, [sp, #24]
 80548ac:	d001      	beq.n	80548b2 <_vfprintf_r+0xae2>
 80548ae:	6836      	ldr	r6, [r6, #0]
 80548b0:	e003      	b.n	80548ba <_vfprintf_r+0xaea>
 80548b2:	f01b 0f40 	tst.w	fp, #64	; 0x40
 80548b6:	d002      	beq.n	80548be <_vfprintf_r+0xaee>
 80548b8:	8836      	ldrh	r6, [r6, #0]
 80548ba:	2700      	movs	r7, #0
 80548bc:	e7d9      	b.n	8054872 <_vfprintf_r+0xaa2>
 80548be:	f41b 7f00 	tst.w	fp, #512	; 0x200
 80548c2:	d0f4      	beq.n	80548ae <_vfprintf_r+0xade>
 80548c4:	7836      	ldrb	r6, [r6, #0]
 80548c6:	e7f8      	b.n	80548ba <_vfprintf_r+0xaea>
 80548c8:	4633      	mov	r3, r6
 80548ca:	2278      	movs	r2, #120	; 0x78
 80548cc:	f853 6b04 	ldr.w	r6, [r3], #4
 80548d0:	9306      	str	r3, [sp, #24]
 80548d2:	f647 0330 	movw	r3, #30768	; 0x7830
 80548d6:	f8ad 306c 	strh.w	r3, [sp, #108]	; 0x6c
 80548da:	4ba8      	ldr	r3, [pc, #672]	; (8054b7c <_vfprintf_r+0xdac>)
 80548dc:	9316      	str	r3, [sp, #88]	; 0x58
 80548de:	2700      	movs	r7, #0
 80548e0:	f04b 0b02 	orr.w	fp, fp, #2
 80548e4:	2302      	movs	r3, #2
 80548e6:	9207      	str	r2, [sp, #28]
 80548e8:	e7c6      	b.n	8054878 <_vfprintf_r+0xaa8>
 80548ea:	4632      	mov	r2, r6
 80548ec:	2500      	movs	r5, #0
 80548ee:	f852 3b04 	ldr.w	r3, [r2], #4
 80548f2:	9303      	str	r3, [sp, #12]
 80548f4:	f1b8 3fff 	cmp.w	r8, #4294967295
 80548f8:	9206      	str	r2, [sp, #24]
 80548fa:	f88d 506b 	strb.w	r5, [sp, #107]	; 0x6b
 80548fe:	d010      	beq.n	8054922 <_vfprintf_r+0xb52>
 8054900:	9803      	ldr	r0, [sp, #12]
 8054902:	4642      	mov	r2, r8
 8054904:	4629      	mov	r1, r5
 8054906:	f7eb fc8b 	bl	8040220 <memchr>
 805490a:	9004      	str	r0, [sp, #16]
 805490c:	2800      	cmp	r0, #0
 805490e:	f000 80df 	beq.w	8054ad0 <_vfprintf_r+0xd00>
 8054912:	9a03      	ldr	r2, [sp, #12]
 8054914:	9504      	str	r5, [sp, #16]
 8054916:	e9cd 5508 	strd	r5, r5, [sp, #32]
 805491a:	eba0 0802 	sub.w	r8, r0, r2
 805491e:	462e      	mov	r6, r5
 8054920:	e5c2      	b.n	80544a8 <_vfprintf_r+0x6d8>
 8054922:	9803      	ldr	r0, [sp, #12]
 8054924:	f7eb fc6e 	bl	8040204 <strlen>
 8054928:	462e      	mov	r6, r5
 805492a:	4680      	mov	r8, r0
 805492c:	9504      	str	r5, [sp, #16]
 805492e:	4633      	mov	r3, r6
 8054930:	e45e      	b.n	80541f0 <_vfprintf_r+0x420>
 8054932:	f04b 0b10 	orr.w	fp, fp, #16
 8054936:	f01b 0f20 	tst.w	fp, #32
 805493a:	d007      	beq.n	805494c <_vfprintf_r+0xb7c>
 805493c:	3607      	adds	r6, #7
 805493e:	f026 0307 	bic.w	r3, r6, #7
 8054942:	e8f3 6702 	ldrd	r6, r7, [r3], #8
 8054946:	9306      	str	r3, [sp, #24]
 8054948:	2301      	movs	r3, #1
 805494a:	e795      	b.n	8054878 <_vfprintf_r+0xaa8>
 805494c:	1d33      	adds	r3, r6, #4
 805494e:	f01b 0f10 	tst.w	fp, #16
 8054952:	9306      	str	r3, [sp, #24]
 8054954:	d001      	beq.n	805495a <_vfprintf_r+0xb8a>
 8054956:	6836      	ldr	r6, [r6, #0]
 8054958:	e003      	b.n	8054962 <_vfprintf_r+0xb92>
 805495a:	f01b 0f40 	tst.w	fp, #64	; 0x40
 805495e:	d002      	beq.n	8054966 <_vfprintf_r+0xb96>
 8054960:	8836      	ldrh	r6, [r6, #0]
 8054962:	2700      	movs	r7, #0
 8054964:	e7f0      	b.n	8054948 <_vfprintf_r+0xb78>
 8054966:	f41b 7f00 	tst.w	fp, #512	; 0x200
 805496a:	d0f4      	beq.n	8054956 <_vfprintf_r+0xb86>
 805496c:	7836      	ldrb	r6, [r6, #0]
 805496e:	e7f8      	b.n	8054962 <_vfprintf_r+0xb92>
 8054970:	4b83      	ldr	r3, [pc, #524]	; (8054b80 <_vfprintf_r+0xdb0>)
 8054972:	9316      	str	r3, [sp, #88]	; 0x58
 8054974:	f01b 0f20 	tst.w	fp, #32
 8054978:	d019      	beq.n	80549ae <_vfprintf_r+0xbde>
 805497a:	3607      	adds	r6, #7
 805497c:	f026 0307 	bic.w	r3, r6, #7
 8054980:	e8f3 6702 	ldrd	r6, r7, [r3], #8
 8054984:	9306      	str	r3, [sp, #24]
 8054986:	f01b 0f01 	tst.w	fp, #1
 805498a:	d00a      	beq.n	80549a2 <_vfprintf_r+0xbd2>
 805498c:	ea56 0307 	orrs.w	r3, r6, r7
 8054990:	d007      	beq.n	80549a2 <_vfprintf_r+0xbd2>
 8054992:	2330      	movs	r3, #48	; 0x30
 8054994:	f88d 306c 	strb.w	r3, [sp, #108]	; 0x6c
 8054998:	9b07      	ldr	r3, [sp, #28]
 805499a:	f88d 306d 	strb.w	r3, [sp, #109]	; 0x6d
 805499e:	f04b 0b02 	orr.w	fp, fp, #2
 80549a2:	f42b 6b80 	bic.w	fp, fp, #1024	; 0x400
 80549a6:	2302      	movs	r3, #2
 80549a8:	e766      	b.n	8054878 <_vfprintf_r+0xaa8>
 80549aa:	4b74      	ldr	r3, [pc, #464]	; (8054b7c <_vfprintf_r+0xdac>)
 80549ac:	e7e1      	b.n	8054972 <_vfprintf_r+0xba2>
 80549ae:	1d33      	adds	r3, r6, #4
 80549b0:	f01b 0f10 	tst.w	fp, #16
 80549b4:	9306      	str	r3, [sp, #24]
 80549b6:	d001      	beq.n	80549bc <_vfprintf_r+0xbec>
 80549b8:	6836      	ldr	r6, [r6, #0]
 80549ba:	e003      	b.n	80549c4 <_vfprintf_r+0xbf4>
 80549bc:	f01b 0f40 	tst.w	fp, #64	; 0x40
 80549c0:	d002      	beq.n	80549c8 <_vfprintf_r+0xbf8>
 80549c2:	8836      	ldrh	r6, [r6, #0]
 80549c4:	2700      	movs	r7, #0
 80549c6:	e7de      	b.n	8054986 <_vfprintf_r+0xbb6>
 80549c8:	f41b 7f00 	tst.w	fp, #512	; 0x200
 80549cc:	d0f4      	beq.n	80549b8 <_vfprintf_r+0xbe8>
 80549ce:	7836      	ldrb	r6, [r6, #0]
 80549d0:	e7f8      	b.n	80549c4 <_vfprintf_r+0xbf4>
 80549d2:	2f00      	cmp	r7, #0
 80549d4:	bf08      	it	eq
 80549d6:	2e0a      	cmpeq	r6, #10
 80549d8:	d206      	bcs.n	80549e8 <_vfprintf_r+0xc18>
 80549da:	3630      	adds	r6, #48	; 0x30
 80549dc:	f88d 6137 	strb.w	r6, [sp, #311]	; 0x137
 80549e0:	f20d 1337 	addw	r3, sp, #311	; 0x137
 80549e4:	f000 bc23 	b.w	805522e <_vfprintf_r+0x145e>
 80549e8:	2300      	movs	r3, #0
 80549ea:	9305      	str	r3, [sp, #20]
 80549ec:	9b04      	ldr	r3, [sp, #16]
 80549ee:	ad4e      	add	r5, sp, #312	; 0x138
 80549f0:	f403 6b80 	and.w	fp, r3, #1024	; 0x400
 80549f4:	1e6b      	subs	r3, r5, #1
 80549f6:	9303      	str	r3, [sp, #12]
 80549f8:	220a      	movs	r2, #10
 80549fa:	2300      	movs	r3, #0
 80549fc:	4630      	mov	r0, r6
 80549fe:	4639      	mov	r1, r7
 8054a00:	f7ec f962 	bl	8040cc8 <__aeabi_uldivmod>
 8054a04:	9b05      	ldr	r3, [sp, #20]
 8054a06:	3230      	adds	r2, #48	; 0x30
 8054a08:	3301      	adds	r3, #1
 8054a0a:	f805 2c01 	strb.w	r2, [r5, #-1]
 8054a0e:	9305      	str	r3, [sp, #20]
 8054a10:	f1bb 0f00 	cmp.w	fp, #0
 8054a14:	d019      	beq.n	8054a4a <_vfprintf_r+0xc7a>
 8054a16:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8054a18:	9a05      	ldr	r2, [sp, #20]
 8054a1a:	781b      	ldrb	r3, [r3, #0]
 8054a1c:	429a      	cmp	r2, r3
 8054a1e:	d114      	bne.n	8054a4a <_vfprintf_r+0xc7a>
 8054a20:	2aff      	cmp	r2, #255	; 0xff
 8054a22:	d012      	beq.n	8054a4a <_vfprintf_r+0xc7a>
 8054a24:	2f00      	cmp	r7, #0
 8054a26:	bf08      	it	eq
 8054a28:	2e0a      	cmpeq	r6, #10
 8054a2a:	d30e      	bcc.n	8054a4a <_vfprintf_r+0xc7a>
 8054a2c:	9b03      	ldr	r3, [sp, #12]
 8054a2e:	9a12      	ldr	r2, [sp, #72]	; 0x48
 8054a30:	9914      	ldr	r1, [sp, #80]	; 0x50
 8054a32:	1a9b      	subs	r3, r3, r2
 8054a34:	4618      	mov	r0, r3
 8054a36:	9303      	str	r3, [sp, #12]
 8054a38:	f002 fe65 	bl	8057706 <strncpy>
 8054a3c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8054a3e:	785d      	ldrb	r5, [r3, #1]
 8054a40:	b1e5      	cbz	r5, 8054a7c <_vfprintf_r+0xcac>
 8054a42:	3301      	adds	r3, #1
 8054a44:	930a      	str	r3, [sp, #40]	; 0x28
 8054a46:	2300      	movs	r3, #0
 8054a48:	9305      	str	r3, [sp, #20]
 8054a4a:	220a      	movs	r2, #10
 8054a4c:	2300      	movs	r3, #0
 8054a4e:	4630      	mov	r0, r6
 8054a50:	4639      	mov	r1, r7
 8054a52:	f7ec f939 	bl	8040cc8 <__aeabi_uldivmod>
 8054a56:	2f00      	cmp	r7, #0
 8054a58:	bf08      	it	eq
 8054a5a:	2e0a      	cmpeq	r6, #10
 8054a5c:	d20a      	bcs.n	8054a74 <_vfprintf_r+0xca4>
 8054a5e:	9b03      	ldr	r3, [sp, #12]
 8054a60:	f8dd b010 	ldr.w	fp, [sp, #16]
 8054a64:	aa4e      	add	r2, sp, #312	; 0x138
 8054a66:	4646      	mov	r6, r8
 8054a68:	eba2 0803 	sub.w	r8, r2, r3
 8054a6c:	2300      	movs	r3, #0
 8054a6e:	9304      	str	r3, [sp, #16]
 8054a70:	f7ff bbbe 	b.w	80541f0 <_vfprintf_r+0x420>
 8054a74:	9d03      	ldr	r5, [sp, #12]
 8054a76:	4606      	mov	r6, r0
 8054a78:	460f      	mov	r7, r1
 8054a7a:	e7bb      	b.n	80549f4 <_vfprintf_r+0xc24>
 8054a7c:	9505      	str	r5, [sp, #20]
 8054a7e:	e7e4      	b.n	8054a4a <_vfprintf_r+0xc7a>
 8054a80:	9a16      	ldr	r2, [sp, #88]	; 0x58
 8054a82:	f006 030f 	and.w	r3, r6, #15
 8054a86:	5cd3      	ldrb	r3, [r2, r3]
 8054a88:	9a03      	ldr	r2, [sp, #12]
 8054a8a:	f802 3d01 	strb.w	r3, [r2, #-1]!
 8054a8e:	0933      	lsrs	r3, r6, #4
 8054a90:	ea43 7307 	orr.w	r3, r3, r7, lsl #28
 8054a94:	9203      	str	r2, [sp, #12]
 8054a96:	093a      	lsrs	r2, r7, #4
 8054a98:	461e      	mov	r6, r3
 8054a9a:	4617      	mov	r7, r2
 8054a9c:	ea56 0307 	orrs.w	r3, r6, r7
 8054aa0:	d1ee      	bne.n	8054a80 <_vfprintf_r+0xcb0>
 8054aa2:	e7dc      	b.n	8054a5e <_vfprintf_r+0xc8e>
 8054aa4:	b933      	cbnz	r3, 8054ab4 <_vfprintf_r+0xce4>
 8054aa6:	f01b 0f01 	tst.w	fp, #1
 8054aaa:	d003      	beq.n	8054ab4 <_vfprintf_r+0xce4>
 8054aac:	2330      	movs	r3, #48	; 0x30
 8054aae:	f88d 3137 	strb.w	r3, [sp, #311]	; 0x137
 8054ab2:	e795      	b.n	80549e0 <_vfprintf_r+0xc10>
 8054ab4:	ab4e      	add	r3, sp, #312	; 0x138
 8054ab6:	e3ba      	b.n	805522e <_vfprintf_r+0x145e>
 8054ab8:	9b07      	ldr	r3, [sp, #28]
 8054aba:	2b00      	cmp	r3, #0
 8054abc:	f000 837d 	beq.w	80551ba <_vfprintf_r+0x13ea>
 8054ac0:	2000      	movs	r0, #0
 8054ac2:	f88d 30d4 	strb.w	r3, [sp, #212]	; 0xd4
 8054ac6:	f88d 006b 	strb.w	r0, [sp, #107]	; 0x6b
 8054aca:	9606      	str	r6, [sp, #24]
 8054acc:	f7ff bb1e 	b.w	805410c <_vfprintf_r+0x33c>
 8054ad0:	9e04      	ldr	r6, [sp, #16]
 8054ad2:	e72c      	b.n	805492e <_vfprintf_r+0xb5e>
 8054ad4:	2010      	movs	r0, #16
 8054ad6:	4402      	add	r2, r0
 8054ad8:	2b07      	cmp	r3, #7
 8054ada:	e9cd 3223 	strd	r3, r2, [sp, #140]	; 0x8c
 8054ade:	6060      	str	r0, [r4, #4]
 8054ae0:	dd08      	ble.n	8054af4 <_vfprintf_r+0xd24>
 8054ae2:	aa22      	add	r2, sp, #136	; 0x88
 8054ae4:	4649      	mov	r1, r9
 8054ae6:	4650      	mov	r0, sl
 8054ae8:	f002 fe9b 	bl	8057822 <__sprint_r>
 8054aec:	2800      	cmp	r0, #0
 8054aee:	f040 8342 	bne.w	8055176 <_vfprintf_r+0x13a6>
 8054af2:	a925      	add	r1, sp, #148	; 0x94
 8054af4:	3f10      	subs	r7, #16
 8054af6:	460c      	mov	r4, r1
 8054af8:	e4f1      	b.n	80544de <_vfprintf_r+0x70e>
 8054afa:	460c      	mov	r4, r1
 8054afc:	e50a      	b.n	8054514 <_vfprintf_r+0x744>
 8054afe:	aa22      	add	r2, sp, #136	; 0x88
 8054b00:	4649      	mov	r1, r9
 8054b02:	4650      	mov	r0, sl
 8054b04:	f002 fe8d 	bl	8057822 <__sprint_r>
 8054b08:	2800      	cmp	r0, #0
 8054b0a:	f040 8334 	bne.w	8055176 <_vfprintf_r+0x13a6>
 8054b0e:	ac25      	add	r4, sp, #148	; 0x94
 8054b10:	e512      	b.n	8054538 <_vfprintf_r+0x768>
 8054b12:	aa22      	add	r2, sp, #136	; 0x88
 8054b14:	4649      	mov	r1, r9
 8054b16:	4650      	mov	r0, sl
 8054b18:	f002 fe83 	bl	8057822 <__sprint_r>
 8054b1c:	2800      	cmp	r0, #0
 8054b1e:	f040 832a 	bne.w	8055176 <_vfprintf_r+0x13a6>
 8054b22:	ac25      	add	r4, sp, #148	; 0x94
 8054b24:	e518      	b.n	8054558 <_vfprintf_r+0x788>
 8054b26:	2010      	movs	r0, #16
 8054b28:	4402      	add	r2, r0
 8054b2a:	2b07      	cmp	r3, #7
 8054b2c:	e9cd 3223 	strd	r3, r2, [sp, #140]	; 0x8c
 8054b30:	6060      	str	r0, [r4, #4]
 8054b32:	dd08      	ble.n	8054b46 <_vfprintf_r+0xd76>
 8054b34:	aa22      	add	r2, sp, #136	; 0x88
 8054b36:	4649      	mov	r1, r9
 8054b38:	4650      	mov	r0, sl
 8054b3a:	f002 fe72 	bl	8057822 <__sprint_r>
 8054b3e:	2800      	cmp	r0, #0
 8054b40:	f040 8319 	bne.w	8055176 <_vfprintf_r+0x13a6>
 8054b44:	a925      	add	r1, sp, #148	; 0x94
 8054b46:	3f10      	subs	r7, #16
 8054b48:	460c      	mov	r4, r1
 8054b4a:	e50d      	b.n	8054568 <_vfprintf_r+0x798>
 8054b4c:	460c      	mov	r4, r1
 8054b4e:	e526      	b.n	805459e <_vfprintf_r+0x7ce>
 8054b50:	2010      	movs	r0, #16
 8054b52:	4402      	add	r2, r0
 8054b54:	2b07      	cmp	r3, #7
 8054b56:	e9cd 3223 	strd	r3, r2, [sp, #140]	; 0x8c
 8054b5a:	6060      	str	r0, [r4, #4]
 8054b5c:	dd08      	ble.n	8054b70 <_vfprintf_r+0xda0>
 8054b5e:	aa22      	add	r2, sp, #136	; 0x88
 8054b60:	4649      	mov	r1, r9
 8054b62:	4650      	mov	r0, sl
 8054b64:	f002 fe5d 	bl	8057822 <__sprint_r>
 8054b68:	2800      	cmp	r0, #0
 8054b6a:	f040 8304 	bne.w	8055176 <_vfprintf_r+0x13a6>
 8054b6e:	a925      	add	r1, sp, #148	; 0x94
 8054b70:	3e10      	subs	r6, #16
 8054b72:	460c      	mov	r4, r1
 8054b74:	e518      	b.n	80545a8 <_vfprintf_r+0x7d8>
 8054b76:	460c      	mov	r4, r1
 8054b78:	e530      	b.n	80545dc <_vfprintf_r+0x80c>
 8054b7a:	bf00      	nop
 8054b7c:	0805ab60 	.word	0x0805ab60
 8054b80:	0805ab71 	.word	0x0805ab71
 8054b84:	9b07      	ldr	r3, [sp, #28]
 8054b86:	2b65      	cmp	r3, #101	; 0x65
 8054b88:	f340 8242 	ble.w	8055010 <_vfprintf_r+0x1240>
 8054b8c:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
 8054b90:	2200      	movs	r2, #0
 8054b92:	2300      	movs	r3, #0
 8054b94:	f7eb ffb8 	bl	8040b08 <__aeabi_dcmpeq>
 8054b98:	2800      	cmp	r0, #0
 8054b9a:	d068      	beq.n	8054c6e <_vfprintf_r+0xe9e>
 8054b9c:	4b6d      	ldr	r3, [pc, #436]	; (8054d54 <_vfprintf_r+0xf84>)
 8054b9e:	6023      	str	r3, [r4, #0]
 8054ba0:	2301      	movs	r3, #1
 8054ba2:	441e      	add	r6, r3
 8054ba4:	6063      	str	r3, [r4, #4]
 8054ba6:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 8054ba8:	9624      	str	r6, [sp, #144]	; 0x90
 8054baa:	3301      	adds	r3, #1
 8054bac:	2b07      	cmp	r3, #7
 8054bae:	9323      	str	r3, [sp, #140]	; 0x8c
 8054bb0:	dc37      	bgt.n	8054c22 <_vfprintf_r+0xe52>
 8054bb2:	3408      	adds	r4, #8
 8054bb4:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 8054bb6:	9a05      	ldr	r2, [sp, #20]
 8054bb8:	4293      	cmp	r3, r2
 8054bba:	db03      	blt.n	8054bc4 <_vfprintf_r+0xdf4>
 8054bbc:	f01b 0f01 	tst.w	fp, #1
 8054bc0:	f43f ad2b 	beq.w	805461a <_vfprintf_r+0x84a>
 8054bc4:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8054bc6:	6023      	str	r3, [r4, #0]
 8054bc8:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8054bca:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 8054bcc:	6063      	str	r3, [r4, #4]
 8054bce:	9b24      	ldr	r3, [sp, #144]	; 0x90
 8054bd0:	4413      	add	r3, r2
 8054bd2:	9324      	str	r3, [sp, #144]	; 0x90
 8054bd4:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 8054bd6:	3301      	adds	r3, #1
 8054bd8:	2b07      	cmp	r3, #7
 8054bda:	9323      	str	r3, [sp, #140]	; 0x8c
 8054bdc:	dc2b      	bgt.n	8054c36 <_vfprintf_r+0xe66>
 8054bde:	3408      	adds	r4, #8
 8054be0:	9b05      	ldr	r3, [sp, #20]
 8054be2:	1e5d      	subs	r5, r3, #1
 8054be4:	2d00      	cmp	r5, #0
 8054be6:	f77f ad18 	ble.w	805461a <_vfprintf_r+0x84a>
 8054bea:	4e5b      	ldr	r6, [pc, #364]	; (8054d58 <_vfprintf_r+0xf88>)
 8054bec:	2710      	movs	r7, #16
 8054bee:	e9dd 3223 	ldrd	r3, r2, [sp, #140]	; 0x8c
 8054bf2:	2d10      	cmp	r5, #16
 8054bf4:	f103 0301 	add.w	r3, r3, #1
 8054bf8:	f104 0108 	add.w	r1, r4, #8
 8054bfc:	6026      	str	r6, [r4, #0]
 8054bfe:	dc24      	bgt.n	8054c4a <_vfprintf_r+0xe7a>
 8054c00:	6065      	str	r5, [r4, #4]
 8054c02:	2b07      	cmp	r3, #7
 8054c04:	4415      	add	r5, r2
 8054c06:	e9cd 3523 	strd	r3, r5, [sp, #140]	; 0x8c
 8054c0a:	f340 8293 	ble.w	8055134 <_vfprintf_r+0x1364>
 8054c0e:	aa22      	add	r2, sp, #136	; 0x88
 8054c10:	4649      	mov	r1, r9
 8054c12:	4650      	mov	r0, sl
 8054c14:	f002 fe05 	bl	8057822 <__sprint_r>
 8054c18:	2800      	cmp	r0, #0
 8054c1a:	f040 82ac 	bne.w	8055176 <_vfprintf_r+0x13a6>
 8054c1e:	ac25      	add	r4, sp, #148	; 0x94
 8054c20:	e4fb      	b.n	805461a <_vfprintf_r+0x84a>
 8054c22:	aa22      	add	r2, sp, #136	; 0x88
 8054c24:	4649      	mov	r1, r9
 8054c26:	4650      	mov	r0, sl
 8054c28:	f002 fdfb 	bl	8057822 <__sprint_r>
 8054c2c:	2800      	cmp	r0, #0
 8054c2e:	f040 82a2 	bne.w	8055176 <_vfprintf_r+0x13a6>
 8054c32:	ac25      	add	r4, sp, #148	; 0x94
 8054c34:	e7be      	b.n	8054bb4 <_vfprintf_r+0xde4>
 8054c36:	aa22      	add	r2, sp, #136	; 0x88
 8054c38:	4649      	mov	r1, r9
 8054c3a:	4650      	mov	r0, sl
 8054c3c:	f002 fdf1 	bl	8057822 <__sprint_r>
 8054c40:	2800      	cmp	r0, #0
 8054c42:	f040 8298 	bne.w	8055176 <_vfprintf_r+0x13a6>
 8054c46:	ac25      	add	r4, sp, #148	; 0x94
 8054c48:	e7ca      	b.n	8054be0 <_vfprintf_r+0xe10>
 8054c4a:	3210      	adds	r2, #16
 8054c4c:	2b07      	cmp	r3, #7
 8054c4e:	e9cd 3223 	strd	r3, r2, [sp, #140]	; 0x8c
 8054c52:	6067      	str	r7, [r4, #4]
 8054c54:	dd08      	ble.n	8054c68 <_vfprintf_r+0xe98>
 8054c56:	aa22      	add	r2, sp, #136	; 0x88
 8054c58:	4649      	mov	r1, r9
 8054c5a:	4650      	mov	r0, sl
 8054c5c:	f002 fde1 	bl	8057822 <__sprint_r>
 8054c60:	2800      	cmp	r0, #0
 8054c62:	f040 8288 	bne.w	8055176 <_vfprintf_r+0x13a6>
 8054c66:	a925      	add	r1, sp, #148	; 0x94
 8054c68:	3d10      	subs	r5, #16
 8054c6a:	460c      	mov	r4, r1
 8054c6c:	e7bf      	b.n	8054bee <_vfprintf_r+0xe1e>
 8054c6e:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 8054c70:	2b00      	cmp	r3, #0
 8054c72:	dc73      	bgt.n	8054d5c <_vfprintf_r+0xf8c>
 8054c74:	4b37      	ldr	r3, [pc, #220]	; (8054d54 <_vfprintf_r+0xf84>)
 8054c76:	6023      	str	r3, [r4, #0]
 8054c78:	2301      	movs	r3, #1
 8054c7a:	441e      	add	r6, r3
 8054c7c:	6063      	str	r3, [r4, #4]
 8054c7e:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 8054c80:	9624      	str	r6, [sp, #144]	; 0x90
 8054c82:	3301      	adds	r3, #1
 8054c84:	2b07      	cmp	r3, #7
 8054c86:	9323      	str	r3, [sp, #140]	; 0x8c
 8054c88:	dc3d      	bgt.n	8054d06 <_vfprintf_r+0xf36>
 8054c8a:	3408      	adds	r4, #8
 8054c8c:	9905      	ldr	r1, [sp, #20]
 8054c8e:	9a1c      	ldr	r2, [sp, #112]	; 0x70
 8054c90:	9b24      	ldr	r3, [sp, #144]	; 0x90
 8054c92:	430a      	orrs	r2, r1
 8054c94:	f00b 0101 	and.w	r1, fp, #1
 8054c98:	430a      	orrs	r2, r1
 8054c9a:	f43f acbe 	beq.w	805461a <_vfprintf_r+0x84a>
 8054c9e:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 8054ca0:	6022      	str	r2, [r4, #0]
 8054ca2:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 8054ca4:	6062      	str	r2, [r4, #4]
 8054ca6:	4413      	add	r3, r2
 8054ca8:	9324      	str	r3, [sp, #144]	; 0x90
 8054caa:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 8054cac:	3301      	adds	r3, #1
 8054cae:	2b07      	cmp	r3, #7
 8054cb0:	9323      	str	r3, [sp, #140]	; 0x8c
 8054cb2:	dc32      	bgt.n	8054d1a <_vfprintf_r+0xf4a>
 8054cb4:	3408      	adds	r4, #8
 8054cb6:	9d1c      	ldr	r5, [sp, #112]	; 0x70
 8054cb8:	2d00      	cmp	r5, #0
 8054cba:	da1b      	bge.n	8054cf4 <_vfprintf_r+0xf24>
 8054cbc:	4e26      	ldr	r6, [pc, #152]	; (8054d58 <_vfprintf_r+0xf88>)
 8054cbe:	426d      	negs	r5, r5
 8054cc0:	4623      	mov	r3, r4
 8054cc2:	2710      	movs	r7, #16
 8054cc4:	e9dd 2123 	ldrd	r2, r1, [sp, #140]	; 0x8c
 8054cc8:	2d10      	cmp	r5, #16
 8054cca:	f102 0201 	add.w	r2, r2, #1
 8054cce:	f104 0408 	add.w	r4, r4, #8
 8054cd2:	601e      	str	r6, [r3, #0]
 8054cd4:	dc2b      	bgt.n	8054d2e <_vfprintf_r+0xf5e>
 8054cd6:	605d      	str	r5, [r3, #4]
 8054cd8:	2a07      	cmp	r2, #7
 8054cda:	440d      	add	r5, r1
 8054cdc:	e9cd 2523 	strd	r2, r5, [sp, #140]	; 0x8c
 8054ce0:	dd08      	ble.n	8054cf4 <_vfprintf_r+0xf24>
 8054ce2:	aa22      	add	r2, sp, #136	; 0x88
 8054ce4:	4649      	mov	r1, r9
 8054ce6:	4650      	mov	r0, sl
 8054ce8:	f002 fd9b 	bl	8057822 <__sprint_r>
 8054cec:	2800      	cmp	r0, #0
 8054cee:	f040 8242 	bne.w	8055176 <_vfprintf_r+0x13a6>
 8054cf2:	ac25      	add	r4, sp, #148	; 0x94
 8054cf4:	9b03      	ldr	r3, [sp, #12]
 8054cf6:	6023      	str	r3, [r4, #0]
 8054cf8:	9b05      	ldr	r3, [sp, #20]
 8054cfa:	9a05      	ldr	r2, [sp, #20]
 8054cfc:	6063      	str	r3, [r4, #4]
 8054cfe:	9b24      	ldr	r3, [sp, #144]	; 0x90
 8054d00:	4413      	add	r3, r2
 8054d02:	9324      	str	r3, [sp, #144]	; 0x90
 8054d04:	e482      	b.n	805460c <_vfprintf_r+0x83c>
 8054d06:	aa22      	add	r2, sp, #136	; 0x88
 8054d08:	4649      	mov	r1, r9
 8054d0a:	4650      	mov	r0, sl
 8054d0c:	f002 fd89 	bl	8057822 <__sprint_r>
 8054d10:	2800      	cmp	r0, #0
 8054d12:	f040 8230 	bne.w	8055176 <_vfprintf_r+0x13a6>
 8054d16:	ac25      	add	r4, sp, #148	; 0x94
 8054d18:	e7b8      	b.n	8054c8c <_vfprintf_r+0xebc>
 8054d1a:	aa22      	add	r2, sp, #136	; 0x88
 8054d1c:	4649      	mov	r1, r9
 8054d1e:	4650      	mov	r0, sl
 8054d20:	f002 fd7f 	bl	8057822 <__sprint_r>
 8054d24:	2800      	cmp	r0, #0
 8054d26:	f040 8226 	bne.w	8055176 <_vfprintf_r+0x13a6>
 8054d2a:	ac25      	add	r4, sp, #148	; 0x94
 8054d2c:	e7c3      	b.n	8054cb6 <_vfprintf_r+0xee6>
 8054d2e:	3110      	adds	r1, #16
 8054d30:	2a07      	cmp	r2, #7
 8054d32:	e9cd 2123 	strd	r2, r1, [sp, #140]	; 0x8c
 8054d36:	605f      	str	r7, [r3, #4]
 8054d38:	dd08      	ble.n	8054d4c <_vfprintf_r+0xf7c>
 8054d3a:	aa22      	add	r2, sp, #136	; 0x88
 8054d3c:	4649      	mov	r1, r9
 8054d3e:	4650      	mov	r0, sl
 8054d40:	f002 fd6f 	bl	8057822 <__sprint_r>
 8054d44:	2800      	cmp	r0, #0
 8054d46:	f040 8216 	bne.w	8055176 <_vfprintf_r+0x13a6>
 8054d4a:	ac25      	add	r4, sp, #148	; 0x94
 8054d4c:	3d10      	subs	r5, #16
 8054d4e:	4623      	mov	r3, r4
 8054d50:	e7b8      	b.n	8054cc4 <_vfprintf_r+0xef4>
 8054d52:	bf00      	nop
 8054d54:	0805ab82 	.word	0x0805ab82
 8054d58:	0805abd9 	.word	0x0805abd9
 8054d5c:	9b05      	ldr	r3, [sp, #20]
 8054d5e:	42ab      	cmp	r3, r5
 8054d60:	bfa8      	it	ge
 8054d62:	462b      	movge	r3, r5
 8054d64:	2b00      	cmp	r3, #0
 8054d66:	461f      	mov	r7, r3
 8054d68:	dd0b      	ble.n	8054d82 <_vfprintf_r+0xfb2>
 8054d6a:	9b03      	ldr	r3, [sp, #12]
 8054d6c:	e9c4 3700 	strd	r3, r7, [r4]
 8054d70:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 8054d72:	3301      	adds	r3, #1
 8054d74:	443e      	add	r6, r7
 8054d76:	2b07      	cmp	r3, #7
 8054d78:	9624      	str	r6, [sp, #144]	; 0x90
 8054d7a:	9323      	str	r3, [sp, #140]	; 0x8c
 8054d7c:	f300 808c 	bgt.w	8054e98 <_vfprintf_r+0x10c8>
 8054d80:	3408      	adds	r4, #8
 8054d82:	2f00      	cmp	r7, #0
 8054d84:	bfac      	ite	ge
 8054d86:	1bee      	subge	r6, r5, r7
 8054d88:	462e      	movlt	r6, r5
 8054d8a:	2e00      	cmp	r6, #0
 8054d8c:	dd1c      	ble.n	8054dc8 <_vfprintf_r+0xff8>
 8054d8e:	4f9f      	ldr	r7, [pc, #636]	; (805500c <_vfprintf_r+0x123c>)
 8054d90:	f04f 0810 	mov.w	r8, #16
 8054d94:	e9dd 3223 	ldrd	r3, r2, [sp, #140]	; 0x8c
 8054d98:	2e10      	cmp	r6, #16
 8054d9a:	f103 0301 	add.w	r3, r3, #1
 8054d9e:	f104 0108 	add.w	r1, r4, #8
 8054da2:	6027      	str	r7, [r4, #0]
 8054da4:	f300 8082 	bgt.w	8054eac <_vfprintf_r+0x10dc>
 8054da8:	6066      	str	r6, [r4, #4]
 8054daa:	2b07      	cmp	r3, #7
 8054dac:	4416      	add	r6, r2
 8054dae:	e9cd 3623 	strd	r3, r6, [sp, #140]	; 0x8c
 8054db2:	f340 808e 	ble.w	8054ed2 <_vfprintf_r+0x1102>
 8054db6:	aa22      	add	r2, sp, #136	; 0x88
 8054db8:	4649      	mov	r1, r9
 8054dba:	4650      	mov	r0, sl
 8054dbc:	f002 fd31 	bl	8057822 <__sprint_r>
 8054dc0:	2800      	cmp	r0, #0
 8054dc2:	f040 81d8 	bne.w	8055176 <_vfprintf_r+0x13a6>
 8054dc6:	ac25      	add	r4, sp, #148	; 0x94
 8054dc8:	9b03      	ldr	r3, [sp, #12]
 8054dca:	f41b 6f80 	tst.w	fp, #1024	; 0x400
 8054dce:	441d      	add	r5, r3
 8054dd0:	d00d      	beq.n	8054dee <_vfprintf_r+0x101e>
 8054dd2:	4e8e      	ldr	r6, [pc, #568]	; (805500c <_vfprintf_r+0x123c>)
 8054dd4:	2710      	movs	r7, #16
 8054dd6:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8054dd8:	2b00      	cmp	r3, #0
 8054dda:	d17c      	bne.n	8054ed6 <_vfprintf_r+0x1106>
 8054ddc:	9b08      	ldr	r3, [sp, #32]
 8054dde:	2b00      	cmp	r3, #0
 8054de0:	d17c      	bne.n	8054edc <_vfprintf_r+0x110c>
 8054de2:	9b03      	ldr	r3, [sp, #12]
 8054de4:	9a05      	ldr	r2, [sp, #20]
 8054de6:	4413      	add	r3, r2
 8054de8:	429d      	cmp	r5, r3
 8054dea:	bf28      	it	cs
 8054dec:	461d      	movcs	r5, r3
 8054dee:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 8054df0:	9a05      	ldr	r2, [sp, #20]
 8054df2:	4293      	cmp	r3, r2
 8054df4:	db02      	blt.n	8054dfc <_vfprintf_r+0x102c>
 8054df6:	f01b 0f01 	tst.w	fp, #1
 8054dfa:	d00e      	beq.n	8054e1a <_vfprintf_r+0x104a>
 8054dfc:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8054dfe:	6023      	str	r3, [r4, #0]
 8054e00:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8054e02:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 8054e04:	6063      	str	r3, [r4, #4]
 8054e06:	9b24      	ldr	r3, [sp, #144]	; 0x90
 8054e08:	4413      	add	r3, r2
 8054e0a:	9324      	str	r3, [sp, #144]	; 0x90
 8054e0c:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 8054e0e:	3301      	adds	r3, #1
 8054e10:	2b07      	cmp	r3, #7
 8054e12:	9323      	str	r3, [sp, #140]	; 0x8c
 8054e14:	f300 80e5 	bgt.w	8054fe2 <_vfprintf_r+0x1212>
 8054e18:	3408      	adds	r4, #8
 8054e1a:	9905      	ldr	r1, [sp, #20]
 8054e1c:	9b03      	ldr	r3, [sp, #12]
 8054e1e:	9e1c      	ldr	r6, [sp, #112]	; 0x70
 8054e20:	440b      	add	r3, r1
 8054e22:	1b8e      	subs	r6, r1, r6
 8054e24:	1b5a      	subs	r2, r3, r5
 8054e26:	4296      	cmp	r6, r2
 8054e28:	bfa8      	it	ge
 8054e2a:	4616      	movge	r6, r2
 8054e2c:	2e00      	cmp	r6, #0
 8054e2e:	dd0b      	ble.n	8054e48 <_vfprintf_r+0x1078>
 8054e30:	9b24      	ldr	r3, [sp, #144]	; 0x90
 8054e32:	4433      	add	r3, r6
 8054e34:	9324      	str	r3, [sp, #144]	; 0x90
 8054e36:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 8054e38:	3301      	adds	r3, #1
 8054e3a:	2b07      	cmp	r3, #7
 8054e3c:	e9c4 5600 	strd	r5, r6, [r4]
 8054e40:	9323      	str	r3, [sp, #140]	; 0x8c
 8054e42:	f300 80d8 	bgt.w	8054ff6 <_vfprintf_r+0x1226>
 8054e46:	3408      	adds	r4, #8
 8054e48:	9d1c      	ldr	r5, [sp, #112]	; 0x70
 8054e4a:	9b05      	ldr	r3, [sp, #20]
 8054e4c:	2e00      	cmp	r6, #0
 8054e4e:	eba3 0505 	sub.w	r5, r3, r5
 8054e52:	bfa8      	it	ge
 8054e54:	1bad      	subge	r5, r5, r6
 8054e56:	2d00      	cmp	r5, #0
 8054e58:	f77f abdf 	ble.w	805461a <_vfprintf_r+0x84a>
 8054e5c:	4e6b      	ldr	r6, [pc, #428]	; (805500c <_vfprintf_r+0x123c>)
 8054e5e:	2710      	movs	r7, #16
 8054e60:	e9dd 3223 	ldrd	r3, r2, [sp, #140]	; 0x8c
 8054e64:	2d10      	cmp	r5, #16
 8054e66:	f103 0301 	add.w	r3, r3, #1
 8054e6a:	f104 0108 	add.w	r1, r4, #8
 8054e6e:	6026      	str	r6, [r4, #0]
 8054e70:	f77f aec6 	ble.w	8054c00 <_vfprintf_r+0xe30>
 8054e74:	3210      	adds	r2, #16
 8054e76:	2b07      	cmp	r3, #7
 8054e78:	e9cd 3223 	strd	r3, r2, [sp, #140]	; 0x8c
 8054e7c:	6067      	str	r7, [r4, #4]
 8054e7e:	dd08      	ble.n	8054e92 <_vfprintf_r+0x10c2>
 8054e80:	aa22      	add	r2, sp, #136	; 0x88
 8054e82:	4649      	mov	r1, r9
 8054e84:	4650      	mov	r0, sl
 8054e86:	f002 fccc 	bl	8057822 <__sprint_r>
 8054e8a:	2800      	cmp	r0, #0
 8054e8c:	f040 8173 	bne.w	8055176 <_vfprintf_r+0x13a6>
 8054e90:	a925      	add	r1, sp, #148	; 0x94
 8054e92:	3d10      	subs	r5, #16
 8054e94:	460c      	mov	r4, r1
 8054e96:	e7e3      	b.n	8054e60 <_vfprintf_r+0x1090>
 8054e98:	aa22      	add	r2, sp, #136	; 0x88
 8054e9a:	4649      	mov	r1, r9
 8054e9c:	4650      	mov	r0, sl
 8054e9e:	f002 fcc0 	bl	8057822 <__sprint_r>
 8054ea2:	2800      	cmp	r0, #0
 8054ea4:	f040 8167 	bne.w	8055176 <_vfprintf_r+0x13a6>
 8054ea8:	ac25      	add	r4, sp, #148	; 0x94
 8054eaa:	e76a      	b.n	8054d82 <_vfprintf_r+0xfb2>
 8054eac:	3210      	adds	r2, #16
 8054eae:	2b07      	cmp	r3, #7
 8054eb0:	e9cd 3223 	strd	r3, r2, [sp, #140]	; 0x8c
 8054eb4:	f8c4 8004 	str.w	r8, [r4, #4]
 8054eb8:	dd08      	ble.n	8054ecc <_vfprintf_r+0x10fc>
 8054eba:	aa22      	add	r2, sp, #136	; 0x88
 8054ebc:	4649      	mov	r1, r9
 8054ebe:	4650      	mov	r0, sl
 8054ec0:	f002 fcaf 	bl	8057822 <__sprint_r>
 8054ec4:	2800      	cmp	r0, #0
 8054ec6:	f040 8156 	bne.w	8055176 <_vfprintf_r+0x13a6>
 8054eca:	a925      	add	r1, sp, #148	; 0x94
 8054ecc:	3e10      	subs	r6, #16
 8054ece:	460c      	mov	r4, r1
 8054ed0:	e760      	b.n	8054d94 <_vfprintf_r+0xfc4>
 8054ed2:	460c      	mov	r4, r1
 8054ed4:	e778      	b.n	8054dc8 <_vfprintf_r+0xff8>
 8054ed6:	9b08      	ldr	r3, [sp, #32]
 8054ed8:	2b00      	cmp	r3, #0
 8054eda:	d052      	beq.n	8054f82 <_vfprintf_r+0x11b2>
 8054edc:	9b08      	ldr	r3, [sp, #32]
 8054ede:	3b01      	subs	r3, #1
 8054ee0:	9308      	str	r3, [sp, #32]
 8054ee2:	9b14      	ldr	r3, [sp, #80]	; 0x50
 8054ee4:	6023      	str	r3, [r4, #0]
 8054ee6:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8054ee8:	9a12      	ldr	r2, [sp, #72]	; 0x48
 8054eea:	6063      	str	r3, [r4, #4]
 8054eec:	9b24      	ldr	r3, [sp, #144]	; 0x90
 8054eee:	4413      	add	r3, r2
 8054ef0:	9324      	str	r3, [sp, #144]	; 0x90
 8054ef2:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 8054ef4:	3301      	adds	r3, #1
 8054ef6:	2b07      	cmp	r3, #7
 8054ef8:	9323      	str	r3, [sp, #140]	; 0x8c
 8054efa:	dc49      	bgt.n	8054f90 <_vfprintf_r+0x11c0>
 8054efc:	3408      	adds	r4, #8
 8054efe:	9b03      	ldr	r3, [sp, #12]
 8054f00:	9a05      	ldr	r2, [sp, #20]
 8054f02:	eb03 0802 	add.w	r8, r3, r2
 8054f06:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8054f08:	781b      	ldrb	r3, [r3, #0]
 8054f0a:	eba8 0805 	sub.w	r8, r8, r5
 8054f0e:	4598      	cmp	r8, r3
 8054f10:	bfa8      	it	ge
 8054f12:	4698      	movge	r8, r3
 8054f14:	f1b8 0f00 	cmp.w	r8, #0
 8054f18:	dd0a      	ble.n	8054f30 <_vfprintf_r+0x1160>
 8054f1a:	9b24      	ldr	r3, [sp, #144]	; 0x90
 8054f1c:	4443      	add	r3, r8
 8054f1e:	9324      	str	r3, [sp, #144]	; 0x90
 8054f20:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 8054f22:	3301      	adds	r3, #1
 8054f24:	2b07      	cmp	r3, #7
 8054f26:	e9c4 5800 	strd	r5, r8, [r4]
 8054f2a:	9323      	str	r3, [sp, #140]	; 0x8c
 8054f2c:	dc3a      	bgt.n	8054fa4 <_vfprintf_r+0x11d4>
 8054f2e:	3408      	adds	r4, #8
 8054f30:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8054f32:	781b      	ldrb	r3, [r3, #0]
 8054f34:	f1b8 0f00 	cmp.w	r8, #0
 8054f38:	bfac      	ite	ge
 8054f3a:	eba3 0808 	subge.w	r8, r3, r8
 8054f3e:	4698      	movlt	r8, r3
 8054f40:	f1b8 0f00 	cmp.w	r8, #0
 8054f44:	dd19      	ble.n	8054f7a <_vfprintf_r+0x11aa>
 8054f46:	e9dd 2323 	ldrd	r2, r3, [sp, #140]	; 0x8c
 8054f4a:	f1b8 0f10 	cmp.w	r8, #16
 8054f4e:	f102 0201 	add.w	r2, r2, #1
 8054f52:	f104 0108 	add.w	r1, r4, #8
 8054f56:	6026      	str	r6, [r4, #0]
 8054f58:	dc2e      	bgt.n	8054fb8 <_vfprintf_r+0x11e8>
 8054f5a:	4443      	add	r3, r8
 8054f5c:	2a07      	cmp	r2, #7
 8054f5e:	e9cd 2323 	strd	r2, r3, [sp, #140]	; 0x8c
 8054f62:	f8c4 8004 	str.w	r8, [r4, #4]
 8054f66:	dd3a      	ble.n	8054fde <_vfprintf_r+0x120e>
 8054f68:	aa22      	add	r2, sp, #136	; 0x88
 8054f6a:	4649      	mov	r1, r9
 8054f6c:	4650      	mov	r0, sl
 8054f6e:	f002 fc58 	bl	8057822 <__sprint_r>
 8054f72:	2800      	cmp	r0, #0
 8054f74:	f040 80ff 	bne.w	8055176 <_vfprintf_r+0x13a6>
 8054f78:	ac25      	add	r4, sp, #148	; 0x94
 8054f7a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8054f7c:	781b      	ldrb	r3, [r3, #0]
 8054f7e:	441d      	add	r5, r3
 8054f80:	e729      	b.n	8054dd6 <_vfprintf_r+0x1006>
 8054f82:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8054f84:	3b01      	subs	r3, #1
 8054f86:	930a      	str	r3, [sp, #40]	; 0x28
 8054f88:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8054f8a:	3b01      	subs	r3, #1
 8054f8c:	9309      	str	r3, [sp, #36]	; 0x24
 8054f8e:	e7a8      	b.n	8054ee2 <_vfprintf_r+0x1112>
 8054f90:	aa22      	add	r2, sp, #136	; 0x88
 8054f92:	4649      	mov	r1, r9
 8054f94:	4650      	mov	r0, sl
 8054f96:	f002 fc44 	bl	8057822 <__sprint_r>
 8054f9a:	2800      	cmp	r0, #0
 8054f9c:	f040 80eb 	bne.w	8055176 <_vfprintf_r+0x13a6>
 8054fa0:	ac25      	add	r4, sp, #148	; 0x94
 8054fa2:	e7ac      	b.n	8054efe <_vfprintf_r+0x112e>
 8054fa4:	aa22      	add	r2, sp, #136	; 0x88
 8054fa6:	4649      	mov	r1, r9
 8054fa8:	4650      	mov	r0, sl
 8054faa:	f002 fc3a 	bl	8057822 <__sprint_r>
 8054fae:	2800      	cmp	r0, #0
 8054fb0:	f040 80e1 	bne.w	8055176 <_vfprintf_r+0x13a6>
 8054fb4:	ac25      	add	r4, sp, #148	; 0x94
 8054fb6:	e7bb      	b.n	8054f30 <_vfprintf_r+0x1160>
 8054fb8:	3310      	adds	r3, #16
 8054fba:	2a07      	cmp	r2, #7
 8054fbc:	e9cd 2323 	strd	r2, r3, [sp, #140]	; 0x8c
 8054fc0:	6067      	str	r7, [r4, #4]
 8054fc2:	dd08      	ble.n	8054fd6 <_vfprintf_r+0x1206>
 8054fc4:	aa22      	add	r2, sp, #136	; 0x88
 8054fc6:	4649      	mov	r1, r9
 8054fc8:	4650      	mov	r0, sl
 8054fca:	f002 fc2a 	bl	8057822 <__sprint_r>
 8054fce:	2800      	cmp	r0, #0
 8054fd0:	f040 80d1 	bne.w	8055176 <_vfprintf_r+0x13a6>
 8054fd4:	a925      	add	r1, sp, #148	; 0x94
 8054fd6:	f1a8 0810 	sub.w	r8, r8, #16
 8054fda:	460c      	mov	r4, r1
 8054fdc:	e7b3      	b.n	8054f46 <_vfprintf_r+0x1176>
 8054fde:	460c      	mov	r4, r1
 8054fe0:	e7cb      	b.n	8054f7a <_vfprintf_r+0x11aa>
 8054fe2:	aa22      	add	r2, sp, #136	; 0x88
 8054fe4:	4649      	mov	r1, r9
 8054fe6:	4650      	mov	r0, sl
 8054fe8:	f002 fc1b 	bl	8057822 <__sprint_r>
 8054fec:	2800      	cmp	r0, #0
 8054fee:	f040 80c2 	bne.w	8055176 <_vfprintf_r+0x13a6>
 8054ff2:	ac25      	add	r4, sp, #148	; 0x94
 8054ff4:	e711      	b.n	8054e1a <_vfprintf_r+0x104a>
 8054ff6:	aa22      	add	r2, sp, #136	; 0x88
 8054ff8:	4649      	mov	r1, r9
 8054ffa:	4650      	mov	r0, sl
 8054ffc:	f002 fc11 	bl	8057822 <__sprint_r>
 8055000:	2800      	cmp	r0, #0
 8055002:	f040 80b8 	bne.w	8055176 <_vfprintf_r+0x13a6>
 8055006:	ac25      	add	r4, sp, #148	; 0x94
 8055008:	e71e      	b.n	8054e48 <_vfprintf_r+0x1078>
 805500a:	bf00      	nop
 805500c:	0805abd9 	.word	0x0805abd9
 8055010:	9a05      	ldr	r2, [sp, #20]
 8055012:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 8055014:	2a01      	cmp	r2, #1
 8055016:	9a03      	ldr	r2, [sp, #12]
 8055018:	6022      	str	r2, [r4, #0]
 805501a:	f106 0601 	add.w	r6, r6, #1
 805501e:	f103 0301 	add.w	r3, r3, #1
 8055022:	f04f 0201 	mov.w	r2, #1
 8055026:	e9cd 3623 	strd	r3, r6, [sp, #140]	; 0x8c
 805502a:	f104 0508 	add.w	r5, r4, #8
 805502e:	6062      	str	r2, [r4, #4]
 8055030:	dc02      	bgt.n	8055038 <_vfprintf_r+0x1268>
 8055032:	f01b 0f01 	tst.w	fp, #1
 8055036:	d078      	beq.n	805512a <_vfprintf_r+0x135a>
 8055038:	2b07      	cmp	r3, #7
 805503a:	dd08      	ble.n	805504e <_vfprintf_r+0x127e>
 805503c:	aa22      	add	r2, sp, #136	; 0x88
 805503e:	4649      	mov	r1, r9
 8055040:	4650      	mov	r0, sl
 8055042:	f002 fbee 	bl	8057822 <__sprint_r>
 8055046:	2800      	cmp	r0, #0
 8055048:	f040 8095 	bne.w	8055176 <_vfprintf_r+0x13a6>
 805504c:	ad25      	add	r5, sp, #148	; 0x94
 805504e:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8055050:	602b      	str	r3, [r5, #0]
 8055052:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8055054:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 8055056:	606b      	str	r3, [r5, #4]
 8055058:	9b24      	ldr	r3, [sp, #144]	; 0x90
 805505a:	4413      	add	r3, r2
 805505c:	9324      	str	r3, [sp, #144]	; 0x90
 805505e:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 8055060:	3301      	adds	r3, #1
 8055062:	2b07      	cmp	r3, #7
 8055064:	9323      	str	r3, [sp, #140]	; 0x8c
 8055066:	dc32      	bgt.n	80550ce <_vfprintf_r+0x12fe>
 8055068:	3508      	adds	r5, #8
 805506a:	9b05      	ldr	r3, [sp, #20]
 805506c:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
 8055070:	1e5c      	subs	r4, r3, #1
 8055072:	2200      	movs	r2, #0
 8055074:	2300      	movs	r3, #0
 8055076:	f7eb fd47 	bl	8040b08 <__aeabi_dcmpeq>
 805507a:	2800      	cmp	r0, #0
 805507c:	d130      	bne.n	80550e0 <_vfprintf_r+0x1310>
 805507e:	9923      	ldr	r1, [sp, #140]	; 0x8c
 8055080:	9b24      	ldr	r3, [sp, #144]	; 0x90
 8055082:	9803      	ldr	r0, [sp, #12]
 8055084:	9a05      	ldr	r2, [sp, #20]
 8055086:	3101      	adds	r1, #1
 8055088:	3b01      	subs	r3, #1
 805508a:	3001      	adds	r0, #1
 805508c:	4413      	add	r3, r2
 805508e:	2907      	cmp	r1, #7
 8055090:	e9c5 0400 	strd	r0, r4, [r5]
 8055094:	e9cd 1323 	strd	r1, r3, [sp, #140]	; 0x8c
 8055098:	dd4a      	ble.n	8055130 <_vfprintf_r+0x1360>
 805509a:	aa22      	add	r2, sp, #136	; 0x88
 805509c:	4649      	mov	r1, r9
 805509e:	4650      	mov	r0, sl
 80550a0:	f002 fbbf 	bl	8057822 <__sprint_r>
 80550a4:	2800      	cmp	r0, #0
 80550a6:	d166      	bne.n	8055176 <_vfprintf_r+0x13a6>
 80550a8:	ad25      	add	r5, sp, #148	; 0x94
 80550aa:	ab1e      	add	r3, sp, #120	; 0x78
 80550ac:	602b      	str	r3, [r5, #0]
 80550ae:	9b15      	ldr	r3, [sp, #84]	; 0x54
 80550b0:	9a15      	ldr	r2, [sp, #84]	; 0x54
 80550b2:	606b      	str	r3, [r5, #4]
 80550b4:	9b24      	ldr	r3, [sp, #144]	; 0x90
 80550b6:	4413      	add	r3, r2
 80550b8:	9324      	str	r3, [sp, #144]	; 0x90
 80550ba:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 80550bc:	3301      	adds	r3, #1
 80550be:	2b07      	cmp	r3, #7
 80550c0:	9323      	str	r3, [sp, #140]	; 0x8c
 80550c2:	f73f ada4 	bgt.w	8054c0e <_vfprintf_r+0xe3e>
 80550c6:	f105 0408 	add.w	r4, r5, #8
 80550ca:	f7ff baa6 	b.w	805461a <_vfprintf_r+0x84a>
 80550ce:	aa22      	add	r2, sp, #136	; 0x88
 80550d0:	4649      	mov	r1, r9
 80550d2:	4650      	mov	r0, sl
 80550d4:	f002 fba5 	bl	8057822 <__sprint_r>
 80550d8:	2800      	cmp	r0, #0
 80550da:	d14c      	bne.n	8055176 <_vfprintf_r+0x13a6>
 80550dc:	ad25      	add	r5, sp, #148	; 0x94
 80550de:	e7c4      	b.n	805506a <_vfprintf_r+0x129a>
 80550e0:	2c00      	cmp	r4, #0
 80550e2:	dde2      	ble.n	80550aa <_vfprintf_r+0x12da>
 80550e4:	4e53      	ldr	r6, [pc, #332]	; (8055234 <_vfprintf_r+0x1464>)
 80550e6:	2710      	movs	r7, #16
 80550e8:	e9dd 3223 	ldrd	r3, r2, [sp, #140]	; 0x8c
 80550ec:	2c10      	cmp	r4, #16
 80550ee:	f103 0301 	add.w	r3, r3, #1
 80550f2:	f105 0108 	add.w	r1, r5, #8
 80550f6:	602e      	str	r6, [r5, #0]
 80550f8:	dc07      	bgt.n	805510a <_vfprintf_r+0x133a>
 80550fa:	606c      	str	r4, [r5, #4]
 80550fc:	2b07      	cmp	r3, #7
 80550fe:	4414      	add	r4, r2
 8055100:	e9cd 3423 	strd	r3, r4, [sp, #140]	; 0x8c
 8055104:	dcc9      	bgt.n	805509a <_vfprintf_r+0x12ca>
 8055106:	460d      	mov	r5, r1
 8055108:	e7cf      	b.n	80550aa <_vfprintf_r+0x12da>
 805510a:	3210      	adds	r2, #16
 805510c:	2b07      	cmp	r3, #7
 805510e:	e9cd 3223 	strd	r3, r2, [sp, #140]	; 0x8c
 8055112:	606f      	str	r7, [r5, #4]
 8055114:	dd06      	ble.n	8055124 <_vfprintf_r+0x1354>
 8055116:	aa22      	add	r2, sp, #136	; 0x88
 8055118:	4649      	mov	r1, r9
 805511a:	4650      	mov	r0, sl
 805511c:	f002 fb81 	bl	8057822 <__sprint_r>
 8055120:	bb48      	cbnz	r0, 8055176 <_vfprintf_r+0x13a6>
 8055122:	a925      	add	r1, sp, #148	; 0x94
 8055124:	3c10      	subs	r4, #16
 8055126:	460d      	mov	r5, r1
 8055128:	e7de      	b.n	80550e8 <_vfprintf_r+0x1318>
 805512a:	2b07      	cmp	r3, #7
 805512c:	ddbd      	ble.n	80550aa <_vfprintf_r+0x12da>
 805512e:	e7b4      	b.n	805509a <_vfprintf_r+0x12ca>
 8055130:	3508      	adds	r5, #8
 8055132:	e7ba      	b.n	80550aa <_vfprintf_r+0x12da>
 8055134:	460c      	mov	r4, r1
 8055136:	f7ff ba70 	b.w	805461a <_vfprintf_r+0x84a>
 805513a:	e9dd 3210 	ldrd	r3, r2, [sp, #64]	; 0x40
 805513e:	1a9d      	subs	r5, r3, r2
 8055140:	2d00      	cmp	r5, #0
 8055142:	f77f aa6e 	ble.w	8054622 <_vfprintf_r+0x852>
 8055146:	4e3c      	ldr	r6, [pc, #240]	; (8055238 <_vfprintf_r+0x1468>)
 8055148:	2710      	movs	r7, #16
 805514a:	e9dd 3223 	ldrd	r3, r2, [sp, #140]	; 0x8c
 805514e:	2d10      	cmp	r5, #16
 8055150:	f103 0301 	add.w	r3, r3, #1
 8055154:	6026      	str	r6, [r4, #0]
 8055156:	dc18      	bgt.n	805518a <_vfprintf_r+0x13ba>
 8055158:	6065      	str	r5, [r4, #4]
 805515a:	2b07      	cmp	r3, #7
 805515c:	4415      	add	r5, r2
 805515e:	e9cd 3523 	strd	r3, r5, [sp, #140]	; 0x8c
 8055162:	f77f aa5e 	ble.w	8054622 <_vfprintf_r+0x852>
 8055166:	aa22      	add	r2, sp, #136	; 0x88
 8055168:	4649      	mov	r1, r9
 805516a:	4650      	mov	r0, sl
 805516c:	f002 fb59 	bl	8057822 <__sprint_r>
 8055170:	2800      	cmp	r0, #0
 8055172:	f43f aa56 	beq.w	8054622 <_vfprintf_r+0x852>
 8055176:	9b04      	ldr	r3, [sp, #16]
 8055178:	2b00      	cmp	r3, #0
 805517a:	f43f a872 	beq.w	8054262 <_vfprintf_r+0x492>
 805517e:	4619      	mov	r1, r3
 8055180:	4650      	mov	r0, sl
 8055182:	f001 f8f5 	bl	8056370 <_free_r>
 8055186:	f7ff b86c 	b.w	8054262 <_vfprintf_r+0x492>
 805518a:	3210      	adds	r2, #16
 805518c:	2b07      	cmp	r3, #7
 805518e:	e9cd 3223 	strd	r3, r2, [sp, #140]	; 0x8c
 8055192:	6067      	str	r7, [r4, #4]
 8055194:	dc02      	bgt.n	805519c <_vfprintf_r+0x13cc>
 8055196:	3408      	adds	r4, #8
 8055198:	3d10      	subs	r5, #16
 805519a:	e7d6      	b.n	805514a <_vfprintf_r+0x137a>
 805519c:	aa22      	add	r2, sp, #136	; 0x88
 805519e:	4649      	mov	r1, r9
 80551a0:	4650      	mov	r0, sl
 80551a2:	f002 fb3e 	bl	8057822 <__sprint_r>
 80551a6:	2800      	cmp	r0, #0
 80551a8:	d1e5      	bne.n	8055176 <_vfprintf_r+0x13a6>
 80551aa:	ac25      	add	r4, sp, #148	; 0x94
 80551ac:	e7f4      	b.n	8055198 <_vfprintf_r+0x13c8>
 80551ae:	9904      	ldr	r1, [sp, #16]
 80551b0:	4650      	mov	r0, sl
 80551b2:	f001 f8dd 	bl	8056370 <_free_r>
 80551b6:	f7ff ba4c 	b.w	8054652 <_vfprintf_r+0x882>
 80551ba:	9b24      	ldr	r3, [sp, #144]	; 0x90
 80551bc:	b91b      	cbnz	r3, 80551c6 <_vfprintf_r+0x13f6>
 80551be:	2300      	movs	r3, #0
 80551c0:	9323      	str	r3, [sp, #140]	; 0x8c
 80551c2:	f7ff b84e 	b.w	8054262 <_vfprintf_r+0x492>
 80551c6:	aa22      	add	r2, sp, #136	; 0x88
 80551c8:	4649      	mov	r1, r9
 80551ca:	4650      	mov	r0, sl
 80551cc:	f002 fb29 	bl	8057822 <__sprint_r>
 80551d0:	2800      	cmp	r0, #0
 80551d2:	d0f4      	beq.n	80551be <_vfprintf_r+0x13ee>
 80551d4:	f7ff b845 	b.w	8054262 <_vfprintf_r+0x492>
 80551d8:	ea56 0207 	orrs.w	r2, r6, r7
 80551dc:	f8cd b010 	str.w	fp, [sp, #16]
 80551e0:	f43f ab5c 	beq.w	805489c <_vfprintf_r+0xacc>
 80551e4:	2b01      	cmp	r3, #1
 80551e6:	f43f abf4 	beq.w	80549d2 <_vfprintf_r+0xc02>
 80551ea:	2b02      	cmp	r3, #2
 80551ec:	ab4e      	add	r3, sp, #312	; 0x138
 80551ee:	9303      	str	r3, [sp, #12]
 80551f0:	f43f ac46 	beq.w	8054a80 <_vfprintf_r+0xcb0>
 80551f4:	9903      	ldr	r1, [sp, #12]
 80551f6:	f006 0307 	and.w	r3, r6, #7
 80551fa:	460a      	mov	r2, r1
 80551fc:	3330      	adds	r3, #48	; 0x30
 80551fe:	f802 3d01 	strb.w	r3, [r2, #-1]!
 8055202:	9203      	str	r2, [sp, #12]
 8055204:	08f2      	lsrs	r2, r6, #3
 8055206:	ea42 7247 	orr.w	r2, r2, r7, lsl #29
 805520a:	08f8      	lsrs	r0, r7, #3
 805520c:	4616      	mov	r6, r2
 805520e:	4607      	mov	r7, r0
 8055210:	ea56 0207 	orrs.w	r2, r6, r7
 8055214:	d1ee      	bne.n	80551f4 <_vfprintf_r+0x1424>
 8055216:	9a04      	ldr	r2, [sp, #16]
 8055218:	07d0      	lsls	r0, r2, #31
 805521a:	f57f ac20 	bpl.w	8054a5e <_vfprintf_r+0xc8e>
 805521e:	2b30      	cmp	r3, #48	; 0x30
 8055220:	f43f ac1d 	beq.w	8054a5e <_vfprintf_r+0xc8e>
 8055224:	9a03      	ldr	r2, [sp, #12]
 8055226:	2330      	movs	r3, #48	; 0x30
 8055228:	f802 3c01 	strb.w	r3, [r2, #-1]
 805522c:	1e8b      	subs	r3, r1, #2
 805522e:	9303      	str	r3, [sp, #12]
 8055230:	e415      	b.n	8054a5e <_vfprintf_r+0xc8e>
 8055232:	bf00      	nop
 8055234:	0805abd9 	.word	0x0805abd9
 8055238:	0805abc9 	.word	0x0805abc9

0805523c <__sbprintf>:
 805523c:	b570      	push	{r4, r5, r6, lr}
 805523e:	460c      	mov	r4, r1
 8055240:	8989      	ldrh	r1, [r1, #12]
 8055242:	f5ad 6d8e 	sub.w	sp, sp, #1136	; 0x470
 8055246:	f021 0102 	bic.w	r1, r1, #2
 805524a:	f8ad 1014 	strh.w	r1, [sp, #20]
 805524e:	6e61      	ldr	r1, [r4, #100]	; 0x64
 8055250:	911b      	str	r1, [sp, #108]	; 0x6c
 8055252:	89e1      	ldrh	r1, [r4, #14]
 8055254:	f8ad 1016 	strh.w	r1, [sp, #22]
 8055258:	69e1      	ldr	r1, [r4, #28]
 805525a:	9109      	str	r1, [sp, #36]	; 0x24
 805525c:	6a61      	ldr	r1, [r4, #36]	; 0x24
 805525e:	910b      	str	r1, [sp, #44]	; 0x2c
 8055260:	a91c      	add	r1, sp, #112	; 0x70
 8055262:	9102      	str	r1, [sp, #8]
 8055264:	9106      	str	r1, [sp, #24]
 8055266:	f44f 6180 	mov.w	r1, #1024	; 0x400
 805526a:	4606      	mov	r6, r0
 805526c:	9104      	str	r1, [sp, #16]
 805526e:	9107      	str	r1, [sp, #28]
 8055270:	a818      	add	r0, sp, #96	; 0x60
 8055272:	2100      	movs	r1, #0
 8055274:	e9cd 3200 	strd	r3, r2, [sp]
 8055278:	9108      	str	r1, [sp, #32]
 805527a:	f001 fcd1 	bl	8056c20 <__retarget_lock_init_recursive>
 805527e:	e9dd 3200 	ldrd	r3, r2, [sp]
 8055282:	a902      	add	r1, sp, #8
 8055284:	4630      	mov	r0, r6
 8055286:	f7fe fda3 	bl	8053dd0 <_vfprintf_r>
 805528a:	1e05      	subs	r5, r0, #0
 805528c:	db07      	blt.n	805529e <__sbprintf+0x62>
 805528e:	a902      	add	r1, sp, #8
 8055290:	4630      	mov	r0, r6
 8055292:	f000 ff71 	bl	8056178 <_fflush_r>
 8055296:	2800      	cmp	r0, #0
 8055298:	bf18      	it	ne
 805529a:	f04f 35ff 	movne.w	r5, #4294967295
 805529e:	f8bd 3014 	ldrh.w	r3, [sp, #20]
 80552a2:	9818      	ldr	r0, [sp, #96]	; 0x60
 80552a4:	065b      	lsls	r3, r3, #25
 80552a6:	bf42      	ittt	mi
 80552a8:	89a3      	ldrhmi	r3, [r4, #12]
 80552aa:	f043 0340 	orrmi.w	r3, r3, #64	; 0x40
 80552ae:	81a3      	strhmi	r3, [r4, #12]
 80552b0:	f001 fcb7 	bl	8056c22 <__retarget_lock_close_recursive>
 80552b4:	4628      	mov	r0, r5
 80552b6:	f50d 6d8e 	add.w	sp, sp, #1136	; 0x470
 80552ba:	bd70      	pop	{r4, r5, r6, pc}

080552bc <__swsetup_r>:
 80552bc:	b538      	push	{r3, r4, r5, lr}
 80552be:	4b2a      	ldr	r3, [pc, #168]	; (8055368 <__swsetup_r+0xac>)
 80552c0:	4605      	mov	r5, r0
 80552c2:	6818      	ldr	r0, [r3, #0]
 80552c4:	460c      	mov	r4, r1
 80552c6:	b118      	cbz	r0, 80552d0 <__swsetup_r+0x14>
 80552c8:	6b83      	ldr	r3, [r0, #56]	; 0x38
 80552ca:	b90b      	cbnz	r3, 80552d0 <__swsetup_r+0x14>
 80552cc:	f000 ffc0 	bl	8056250 <__sinit>
 80552d0:	89a3      	ldrh	r3, [r4, #12]
 80552d2:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
 80552d6:	0718      	lsls	r0, r3, #28
 80552d8:	d422      	bmi.n	8055320 <__swsetup_r+0x64>
 80552da:	06d9      	lsls	r1, r3, #27
 80552dc:	d407      	bmi.n	80552ee <__swsetup_r+0x32>
 80552de:	2309      	movs	r3, #9
 80552e0:	602b      	str	r3, [r5, #0]
 80552e2:	f042 0340 	orr.w	r3, r2, #64	; 0x40
 80552e6:	81a3      	strh	r3, [r4, #12]
 80552e8:	f04f 30ff 	mov.w	r0, #4294967295
 80552ec:	e034      	b.n	8055358 <__swsetup_r+0x9c>
 80552ee:	0758      	lsls	r0, r3, #29
 80552f0:	d512      	bpl.n	8055318 <__swsetup_r+0x5c>
 80552f2:	6b21      	ldr	r1, [r4, #48]	; 0x30
 80552f4:	b141      	cbz	r1, 8055308 <__swsetup_r+0x4c>
 80552f6:	f104 0340 	add.w	r3, r4, #64	; 0x40
 80552fa:	4299      	cmp	r1, r3
 80552fc:	d002      	beq.n	8055304 <__swsetup_r+0x48>
 80552fe:	4628      	mov	r0, r5
 8055300:	f001 f836 	bl	8056370 <_free_r>
 8055304:	2300      	movs	r3, #0
 8055306:	6323      	str	r3, [r4, #48]	; 0x30
 8055308:	89a3      	ldrh	r3, [r4, #12]
 805530a:	f023 0324 	bic.w	r3, r3, #36	; 0x24
 805530e:	81a3      	strh	r3, [r4, #12]
 8055310:	2300      	movs	r3, #0
 8055312:	6063      	str	r3, [r4, #4]
 8055314:	6923      	ldr	r3, [r4, #16]
 8055316:	6023      	str	r3, [r4, #0]
 8055318:	89a3      	ldrh	r3, [r4, #12]
 805531a:	f043 0308 	orr.w	r3, r3, #8
 805531e:	81a3      	strh	r3, [r4, #12]
 8055320:	6923      	ldr	r3, [r4, #16]
 8055322:	b94b      	cbnz	r3, 8055338 <__swsetup_r+0x7c>
 8055324:	89a3      	ldrh	r3, [r4, #12]
 8055326:	f403 7320 	and.w	r3, r3, #640	; 0x280
 805532a:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 805532e:	d003      	beq.n	8055338 <__swsetup_r+0x7c>
 8055330:	4621      	mov	r1, r4
 8055332:	4628      	mov	r0, r5
 8055334:	f001 fca4 	bl	8056c80 <__smakebuf_r>
 8055338:	89a0      	ldrh	r0, [r4, #12]
 805533a:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
 805533e:	f010 0301 	ands.w	r3, r0, #1
 8055342:	d00a      	beq.n	805535a <__swsetup_r+0x9e>
 8055344:	2300      	movs	r3, #0
 8055346:	60a3      	str	r3, [r4, #8]
 8055348:	6963      	ldr	r3, [r4, #20]
 805534a:	425b      	negs	r3, r3
 805534c:	61a3      	str	r3, [r4, #24]
 805534e:	6923      	ldr	r3, [r4, #16]
 8055350:	b943      	cbnz	r3, 8055364 <__swsetup_r+0xa8>
 8055352:	f010 0080 	ands.w	r0, r0, #128	; 0x80
 8055356:	d1c4      	bne.n	80552e2 <__swsetup_r+0x26>
 8055358:	bd38      	pop	{r3, r4, r5, pc}
 805535a:	0781      	lsls	r1, r0, #30
 805535c:	bf58      	it	pl
 805535e:	6963      	ldrpl	r3, [r4, #20]
 8055360:	60a3      	str	r3, [r4, #8]
 8055362:	e7f4      	b.n	805534e <__swsetup_r+0x92>
 8055364:	2000      	movs	r0, #0
 8055366:	e7f7      	b.n	8055358 <__swsetup_r+0x9c>
 8055368:	200036d0 	.word	0x200036d0

0805536c <register_fini>:
 805536c:	4b02      	ldr	r3, [pc, #8]	; (8055378 <register_fini+0xc>)
 805536e:	b113      	cbz	r3, 8055376 <register_fini+0xa>
 8055370:	4802      	ldr	r0, [pc, #8]	; (805537c <register_fini+0x10>)
 8055372:	f000 b805 	b.w	8055380 <atexit>
 8055376:	4770      	bx	lr
 8055378:	00000000 	.word	0x00000000
 805537c:	080562a1 	.word	0x080562a1

08055380 <atexit>:
 8055380:	2300      	movs	r3, #0
 8055382:	4601      	mov	r1, r0
 8055384:	461a      	mov	r2, r3
 8055386:	4618      	mov	r0, r3
 8055388:	f002 bf66 	b.w	8058258 <__register_exitproc>

0805538c <quorem>:
 805538c:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8055390:	6903      	ldr	r3, [r0, #16]
 8055392:	690c      	ldr	r4, [r1, #16]
 8055394:	42a3      	cmp	r3, r4
 8055396:	4607      	mov	r7, r0
 8055398:	f2c0 8081 	blt.w	805549e <quorem+0x112>
 805539c:	3c01      	subs	r4, #1
 805539e:	f101 0814 	add.w	r8, r1, #20
 80553a2:	f100 0514 	add.w	r5, r0, #20
 80553a6:	eb05 0384 	add.w	r3, r5, r4, lsl #2
 80553aa:	9301      	str	r3, [sp, #4]
 80553ac:	f858 3024 	ldr.w	r3, [r8, r4, lsl #2]
 80553b0:	f855 2024 	ldr.w	r2, [r5, r4, lsl #2]
 80553b4:	3301      	adds	r3, #1
 80553b6:	429a      	cmp	r2, r3
 80553b8:	ea4f 0b84 	mov.w	fp, r4, lsl #2
 80553bc:	eb08 0984 	add.w	r9, r8, r4, lsl #2
 80553c0:	fbb2 f6f3 	udiv	r6, r2, r3
 80553c4:	d331      	bcc.n	805542a <quorem+0x9e>
 80553c6:	f04f 0e00 	mov.w	lr, #0
 80553ca:	4640      	mov	r0, r8
 80553cc:	46ac      	mov	ip, r5
 80553ce:	46f2      	mov	sl, lr
 80553d0:	f850 2b04 	ldr.w	r2, [r0], #4
 80553d4:	b293      	uxth	r3, r2
 80553d6:	fb06 e303 	mla	r3, r6, r3, lr
 80553da:	ea4f 4e13 	mov.w	lr, r3, lsr #16
 80553de:	b29b      	uxth	r3, r3
 80553e0:	ebaa 0303 	sub.w	r3, sl, r3
 80553e4:	0c12      	lsrs	r2, r2, #16
 80553e6:	f8dc a000 	ldr.w	sl, [ip]
 80553ea:	fb06 e202 	mla	r2, r6, r2, lr
 80553ee:	fa13 f38a 	uxtah	r3, r3, sl
 80553f2:	ea4f 4e12 	mov.w	lr, r2, lsr #16
 80553f6:	fa1f fa82 	uxth.w	sl, r2
 80553fa:	f8dc 2000 	ldr.w	r2, [ip]
 80553fe:	ebca 4212 	rsb	r2, sl, r2, lsr #16
 8055402:	eb02 4223 	add.w	r2, r2, r3, asr #16
 8055406:	b29b      	uxth	r3, r3
 8055408:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 805540c:	4581      	cmp	r9, r0
 805540e:	f84c 3b04 	str.w	r3, [ip], #4
 8055412:	ea4f 4a22 	mov.w	sl, r2, asr #16
 8055416:	d2db      	bcs.n	80553d0 <quorem+0x44>
 8055418:	f855 300b 	ldr.w	r3, [r5, fp]
 805541c:	b92b      	cbnz	r3, 805542a <quorem+0x9e>
 805541e:	9b01      	ldr	r3, [sp, #4]
 8055420:	3b04      	subs	r3, #4
 8055422:	429d      	cmp	r5, r3
 8055424:	461a      	mov	r2, r3
 8055426:	d32e      	bcc.n	8055486 <quorem+0xfa>
 8055428:	613c      	str	r4, [r7, #16]
 805542a:	4638      	mov	r0, r7
 805542c:	f001 fef4 	bl	8057218 <__mcmp>
 8055430:	2800      	cmp	r0, #0
 8055432:	db24      	blt.n	805547e <quorem+0xf2>
 8055434:	3601      	adds	r6, #1
 8055436:	4628      	mov	r0, r5
 8055438:	f04f 0c00 	mov.w	ip, #0
 805543c:	f858 2b04 	ldr.w	r2, [r8], #4
 8055440:	f8d0 e000 	ldr.w	lr, [r0]
 8055444:	b293      	uxth	r3, r2
 8055446:	ebac 0303 	sub.w	r3, ip, r3
 805544a:	0c12      	lsrs	r2, r2, #16
 805544c:	fa13 f38e 	uxtah	r3, r3, lr
 8055450:	ebc2 421e 	rsb	r2, r2, lr, lsr #16
 8055454:	eb02 4223 	add.w	r2, r2, r3, asr #16
 8055458:	b29b      	uxth	r3, r3
 805545a:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 805545e:	45c1      	cmp	r9, r8
 8055460:	f840 3b04 	str.w	r3, [r0], #4
 8055464:	ea4f 4c22 	mov.w	ip, r2, asr #16
 8055468:	d2e8      	bcs.n	805543c <quorem+0xb0>
 805546a:	f855 2024 	ldr.w	r2, [r5, r4, lsl #2]
 805546e:	eb05 0384 	add.w	r3, r5, r4, lsl #2
 8055472:	b922      	cbnz	r2, 805547e <quorem+0xf2>
 8055474:	3b04      	subs	r3, #4
 8055476:	429d      	cmp	r5, r3
 8055478:	461a      	mov	r2, r3
 805547a:	d30a      	bcc.n	8055492 <quorem+0x106>
 805547c:	613c      	str	r4, [r7, #16]
 805547e:	4630      	mov	r0, r6
 8055480:	b003      	add	sp, #12
 8055482:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8055486:	6812      	ldr	r2, [r2, #0]
 8055488:	3b04      	subs	r3, #4
 805548a:	2a00      	cmp	r2, #0
 805548c:	d1cc      	bne.n	8055428 <quorem+0x9c>
 805548e:	3c01      	subs	r4, #1
 8055490:	e7c7      	b.n	8055422 <quorem+0x96>
 8055492:	6812      	ldr	r2, [r2, #0]
 8055494:	3b04      	subs	r3, #4
 8055496:	2a00      	cmp	r2, #0
 8055498:	d1f0      	bne.n	805547c <quorem+0xf0>
 805549a:	3c01      	subs	r4, #1
 805549c:	e7eb      	b.n	8055476 <quorem+0xea>
 805549e:	2000      	movs	r0, #0
 80554a0:	e7ee      	b.n	8055480 <quorem+0xf4>
 80554a2:	0000      	movs	r0, r0
 80554a4:	0000      	movs	r0, r0
	...

080554a8 <_dtoa_r>:
 80554a8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80554ac:	ed2d 8b02 	vpush	{d8}
 80554b0:	b095      	sub	sp, #84	; 0x54
 80554b2:	ec57 6b10 	vmov	r6, r7, d0
 80554b6:	9105      	str	r1, [sp, #20]
 80554b8:	6c01      	ldr	r1, [r0, #64]	; 0x40
 80554ba:	9d20      	ldr	r5, [sp, #128]	; 0x80
 80554bc:	9209      	str	r2, [sp, #36]	; 0x24
 80554be:	e9cd 6702 	strd	r6, r7, [sp, #8]
 80554c2:	4604      	mov	r4, r0
 80554c4:	930f      	str	r3, [sp, #60]	; 0x3c
 80554c6:	b141      	cbz	r1, 80554da <_dtoa_r+0x32>
 80554c8:	6c42      	ldr	r2, [r0, #68]	; 0x44
 80554ca:	604a      	str	r2, [r1, #4]
 80554cc:	2301      	movs	r3, #1
 80554ce:	4093      	lsls	r3, r2
 80554d0:	608b      	str	r3, [r1, #8]
 80554d2:	f001 fc4c 	bl	8056d6e <_Bfree>
 80554d6:	2300      	movs	r3, #0
 80554d8:	6423      	str	r3, [r4, #64]	; 0x40
 80554da:	1e3b      	subs	r3, r7, #0
 80554dc:	bfb9      	ittee	lt
 80554de:	f023 4300 	biclt.w	r3, r3, #2147483648	; 0x80000000
 80554e2:	9303      	strlt	r3, [sp, #12]
 80554e4:	2300      	movge	r3, #0
 80554e6:	602b      	strge	r3, [r5, #0]
 80554e8:	f8dd 900c 	ldr.w	r9, [sp, #12]
 80554ec:	4ba2      	ldr	r3, [pc, #648]	; (8055778 <_dtoa_r+0x2d0>)
 80554ee:	bfbc      	itt	lt
 80554f0:	2201      	movlt	r2, #1
 80554f2:	602a      	strlt	r2, [r5, #0]
 80554f4:	ea33 0309 	bics.w	r3, r3, r9
 80554f8:	d11b      	bne.n	8055532 <_dtoa_r+0x8a>
 80554fa:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 80554fc:	f242 730f 	movw	r3, #9999	; 0x270f
 8055500:	6013      	str	r3, [r2, #0]
 8055502:	f3c9 0313 	ubfx	r3, r9, #0, #20
 8055506:	4333      	orrs	r3, r6
 8055508:	f000 8578 	beq.w	8055ffc <_dtoa_r+0xb54>
 805550c:	9b21      	ldr	r3, [sp, #132]	; 0x84
 805550e:	b90b      	cbnz	r3, 8055514 <_dtoa_r+0x6c>
 8055510:	4b9a      	ldr	r3, [pc, #616]	; (805577c <_dtoa_r+0x2d4>)
 8055512:	e024      	b.n	805555e <_dtoa_r+0xb6>
 8055514:	4b99      	ldr	r3, [pc, #612]	; (805577c <_dtoa_r+0x2d4>)
 8055516:	9300      	str	r3, [sp, #0]
 8055518:	3303      	adds	r3, #3
 805551a:	9a21      	ldr	r2, [sp, #132]	; 0x84
 805551c:	6013      	str	r3, [r2, #0]
 805551e:	9800      	ldr	r0, [sp, #0]
 8055520:	b015      	add	sp, #84	; 0x54
 8055522:	ecbd 8b02 	vpop	{d8}
 8055526:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 805552a:	4b95      	ldr	r3, [pc, #596]	; (8055780 <_dtoa_r+0x2d8>)
 805552c:	9300      	str	r3, [sp, #0]
 805552e:	3308      	adds	r3, #8
 8055530:	e7f3      	b.n	805551a <_dtoa_r+0x72>
 8055532:	ed9d 7b02 	vldr	d7, [sp, #8]
 8055536:	2200      	movs	r2, #0
 8055538:	ec51 0b17 	vmov	r0, r1, d7
 805553c:	2300      	movs	r3, #0
 805553e:	ed8d 7b0a 	vstr	d7, [sp, #40]	; 0x28
 8055542:	f7eb fae1 	bl	8040b08 <__aeabi_dcmpeq>
 8055546:	4680      	mov	r8, r0
 8055548:	b158      	cbz	r0, 8055562 <_dtoa_r+0xba>
 805554a:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 805554c:	2301      	movs	r3, #1
 805554e:	6013      	str	r3, [r2, #0]
 8055550:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8055552:	2b00      	cmp	r3, #0
 8055554:	f000 854f 	beq.w	8055ff6 <_dtoa_r+0xb4e>
 8055558:	488a      	ldr	r0, [pc, #552]	; (8055784 <_dtoa_r+0x2dc>)
 805555a:	6018      	str	r0, [r3, #0]
 805555c:	1e43      	subs	r3, r0, #1
 805555e:	9300      	str	r3, [sp, #0]
 8055560:	e7dd      	b.n	805551e <_dtoa_r+0x76>
 8055562:	ed9d 0b0a 	vldr	d0, [sp, #40]	; 0x28
 8055566:	aa12      	add	r2, sp, #72	; 0x48
 8055568:	a913      	add	r1, sp, #76	; 0x4c
 805556a:	4620      	mov	r0, r4
 805556c:	f001 ff74 	bl	8057458 <__d2b>
 8055570:	f3c9 550a 	ubfx	r5, r9, #20, #11
 8055574:	4683      	mov	fp, r0
 8055576:	2d00      	cmp	r5, #0
 8055578:	d07c      	beq.n	8055674 <_dtoa_r+0x1cc>
 805557a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 805557c:	f8cd 8040 	str.w	r8, [sp, #64]	; 0x40
 8055580:	f3c3 0313 	ubfx	r3, r3, #0, #20
 8055584:	e9dd 670a 	ldrd	r6, r7, [sp, #40]	; 0x28
 8055588:	f043 577f 	orr.w	r7, r3, #1069547520	; 0x3fc00000
 805558c:	f447 1740 	orr.w	r7, r7, #3145728	; 0x300000
 8055590:	f2a5 35ff 	subw	r5, r5, #1023	; 0x3ff
 8055594:	4b7c      	ldr	r3, [pc, #496]	; (8055788 <_dtoa_r+0x2e0>)
 8055596:	2200      	movs	r2, #0
 8055598:	4630      	mov	r0, r6
 805559a:	4639      	mov	r1, r7
 805559c:	f7ea fe94 	bl	80402c8 <__aeabi_dsub>
 80555a0:	a36f      	add	r3, pc, #444	; (adr r3, 8055760 <_dtoa_r+0x2b8>)
 80555a2:	e9d3 2300 	ldrd	r2, r3, [r3]
 80555a6:	f7eb f847 	bl	8040638 <__aeabi_dmul>
 80555aa:	a36f      	add	r3, pc, #444	; (adr r3, 8055768 <_dtoa_r+0x2c0>)
 80555ac:	e9d3 2300 	ldrd	r2, r3, [r3]
 80555b0:	f7ea fe8c 	bl	80402cc <__adddf3>
 80555b4:	4606      	mov	r6, r0
 80555b6:	4628      	mov	r0, r5
 80555b8:	460f      	mov	r7, r1
 80555ba:	f7ea ffd3 	bl	8040564 <__aeabi_i2d>
 80555be:	a36c      	add	r3, pc, #432	; (adr r3, 8055770 <_dtoa_r+0x2c8>)
 80555c0:	e9d3 2300 	ldrd	r2, r3, [r3]
 80555c4:	f7eb f838 	bl	8040638 <__aeabi_dmul>
 80555c8:	4602      	mov	r2, r0
 80555ca:	460b      	mov	r3, r1
 80555cc:	4630      	mov	r0, r6
 80555ce:	4639      	mov	r1, r7
 80555d0:	f7ea fe7c 	bl	80402cc <__adddf3>
 80555d4:	4606      	mov	r6, r0
 80555d6:	460f      	mov	r7, r1
 80555d8:	f7eb fade 	bl	8040b98 <__aeabi_d2iz>
 80555dc:	2200      	movs	r2, #0
 80555de:	4682      	mov	sl, r0
 80555e0:	2300      	movs	r3, #0
 80555e2:	4630      	mov	r0, r6
 80555e4:	4639      	mov	r1, r7
 80555e6:	f7eb fa99 	bl	8040b1c <__aeabi_dcmplt>
 80555ea:	b148      	cbz	r0, 8055600 <_dtoa_r+0x158>
 80555ec:	4650      	mov	r0, sl
 80555ee:	f7ea ffb9 	bl	8040564 <__aeabi_i2d>
 80555f2:	4632      	mov	r2, r6
 80555f4:	463b      	mov	r3, r7
 80555f6:	f7eb fa87 	bl	8040b08 <__aeabi_dcmpeq>
 80555fa:	b908      	cbnz	r0, 8055600 <_dtoa_r+0x158>
 80555fc:	f10a 3aff 	add.w	sl, sl, #4294967295
 8055600:	f1ba 0f16 	cmp.w	sl, #22
 8055604:	d854      	bhi.n	80556b0 <_dtoa_r+0x208>
 8055606:	4b61      	ldr	r3, [pc, #388]	; (805578c <_dtoa_r+0x2e4>)
 8055608:	eb03 03ca 	add.w	r3, r3, sl, lsl #3
 805560c:	e9d3 2300 	ldrd	r2, r3, [r3]
 8055610:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
 8055614:	f7eb fa82 	bl	8040b1c <__aeabi_dcmplt>
 8055618:	2800      	cmp	r0, #0
 805561a:	d04b      	beq.n	80556b4 <_dtoa_r+0x20c>
 805561c:	f10a 3aff 	add.w	sl, sl, #4294967295
 8055620:	2300      	movs	r3, #0
 8055622:	930e      	str	r3, [sp, #56]	; 0x38
 8055624:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8055626:	1b5d      	subs	r5, r3, r5
 8055628:	1e6b      	subs	r3, r5, #1
 805562a:	9304      	str	r3, [sp, #16]
 805562c:	bf43      	ittte	mi
 805562e:	2300      	movmi	r3, #0
 8055630:	f1c5 0801 	rsbmi	r8, r5, #1
 8055634:	9304      	strmi	r3, [sp, #16]
 8055636:	f04f 0800 	movpl.w	r8, #0
 805563a:	f1ba 0f00 	cmp.w	sl, #0
 805563e:	db3b      	blt.n	80556b8 <_dtoa_r+0x210>
 8055640:	9b04      	ldr	r3, [sp, #16]
 8055642:	f8cd a034 	str.w	sl, [sp, #52]	; 0x34
 8055646:	4453      	add	r3, sl
 8055648:	9304      	str	r3, [sp, #16]
 805564a:	2300      	movs	r3, #0
 805564c:	9306      	str	r3, [sp, #24]
 805564e:	9b05      	ldr	r3, [sp, #20]
 8055650:	2b09      	cmp	r3, #9
 8055652:	d86a      	bhi.n	805572a <_dtoa_r+0x282>
 8055654:	2b05      	cmp	r3, #5
 8055656:	bfc4      	itt	gt
 8055658:	3b04      	subgt	r3, #4
 805565a:	9305      	strgt	r3, [sp, #20]
 805565c:	9b05      	ldr	r3, [sp, #20]
 805565e:	f1a3 0302 	sub.w	r3, r3, #2
 8055662:	bfcc      	ite	gt
 8055664:	2500      	movgt	r5, #0
 8055666:	2501      	movle	r5, #1
 8055668:	2b03      	cmp	r3, #3
 805566a:	d86a      	bhi.n	8055742 <_dtoa_r+0x29a>
 805566c:	e8df f003 	tbb	[pc, r3]
 8055670:	5b4d4f2c 	.word	0x5b4d4f2c
 8055674:	e9dd 5312 	ldrd	r5, r3, [sp, #72]	; 0x48
 8055678:	441d      	add	r5, r3
 805567a:	f205 4332 	addw	r3, r5, #1074	; 0x432
 805567e:	2b20      	cmp	r3, #32
 8055680:	bfc1      	itttt	gt
 8055682:	f1c3 0340 	rsbgt	r3, r3, #64	; 0x40
 8055686:	f205 4012 	addwgt	r0, r5, #1042	; 0x412
 805568a:	fa09 f303 	lslgt.w	r3, r9, r3
 805568e:	fa26 f000 	lsrgt.w	r0, r6, r0
 8055692:	bfda      	itte	le
 8055694:	f1c3 0320 	rsble	r3, r3, #32
 8055698:	fa06 f003 	lslle.w	r0, r6, r3
 805569c:	4318      	orrgt	r0, r3
 805569e:	f7ea ff51 	bl	8040544 <__aeabi_ui2d>
 80556a2:	2301      	movs	r3, #1
 80556a4:	4606      	mov	r6, r0
 80556a6:	f1a1 77f8 	sub.w	r7, r1, #32505856	; 0x1f00000
 80556aa:	3d01      	subs	r5, #1
 80556ac:	9310      	str	r3, [sp, #64]	; 0x40
 80556ae:	e771      	b.n	8055594 <_dtoa_r+0xec>
 80556b0:	2301      	movs	r3, #1
 80556b2:	e7b6      	b.n	8055622 <_dtoa_r+0x17a>
 80556b4:	900e      	str	r0, [sp, #56]	; 0x38
 80556b6:	e7b5      	b.n	8055624 <_dtoa_r+0x17c>
 80556b8:	f1ca 0300 	rsb	r3, sl, #0
 80556bc:	9306      	str	r3, [sp, #24]
 80556be:	2300      	movs	r3, #0
 80556c0:	eba8 080a 	sub.w	r8, r8, sl
 80556c4:	930d      	str	r3, [sp, #52]	; 0x34
 80556c6:	e7c2      	b.n	805564e <_dtoa_r+0x1a6>
 80556c8:	2300      	movs	r3, #0
 80556ca:	9308      	str	r3, [sp, #32]
 80556cc:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80556ce:	2b00      	cmp	r3, #0
 80556d0:	dc3a      	bgt.n	8055748 <_dtoa_r+0x2a0>
 80556d2:	f04f 0901 	mov.w	r9, #1
 80556d6:	f8cd 9004 	str.w	r9, [sp, #4]
 80556da:	464b      	mov	r3, r9
 80556dc:	f8cd 9024 	str.w	r9, [sp, #36]	; 0x24
 80556e0:	2200      	movs	r2, #0
 80556e2:	6462      	str	r2, [r4, #68]	; 0x44
 80556e4:	2204      	movs	r2, #4
 80556e6:	f102 0014 	add.w	r0, r2, #20
 80556ea:	4298      	cmp	r0, r3
 80556ec:	6c61      	ldr	r1, [r4, #68]	; 0x44
 80556ee:	d931      	bls.n	8055754 <_dtoa_r+0x2ac>
 80556f0:	4620      	mov	r0, r4
 80556f2:	f001 fb17 	bl	8056d24 <_Balloc>
 80556f6:	9000      	str	r0, [sp, #0]
 80556f8:	2800      	cmp	r0, #0
 80556fa:	d14d      	bne.n	8055798 <_dtoa_r+0x2f0>
 80556fc:	4b24      	ldr	r3, [pc, #144]	; (8055790 <_dtoa_r+0x2e8>)
 80556fe:	4602      	mov	r2, r0
 8055700:	f44f 71d5 	mov.w	r1, #426	; 0x1aa
 8055704:	4823      	ldr	r0, [pc, #140]	; (8055794 <_dtoa_r+0x2ec>)
 8055706:	f002 fde7 	bl	80582d8 <__assert_func>
 805570a:	2301      	movs	r3, #1
 805570c:	e7dd      	b.n	80556ca <_dtoa_r+0x222>
 805570e:	2300      	movs	r3, #0
 8055710:	9308      	str	r3, [sp, #32]
 8055712:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8055714:	eb0a 0903 	add.w	r9, sl, r3
 8055718:	f109 0301 	add.w	r3, r9, #1
 805571c:	2b01      	cmp	r3, #1
 805571e:	9301      	str	r3, [sp, #4]
 8055720:	bfb8      	it	lt
 8055722:	2301      	movlt	r3, #1
 8055724:	e7dc      	b.n	80556e0 <_dtoa_r+0x238>
 8055726:	2301      	movs	r3, #1
 8055728:	e7f2      	b.n	8055710 <_dtoa_r+0x268>
 805572a:	2501      	movs	r5, #1
 805572c:	2300      	movs	r3, #0
 805572e:	9305      	str	r3, [sp, #20]
 8055730:	9508      	str	r5, [sp, #32]
 8055732:	f04f 39ff 	mov.w	r9, #4294967295
 8055736:	2200      	movs	r2, #0
 8055738:	f8cd 9004 	str.w	r9, [sp, #4]
 805573c:	2312      	movs	r3, #18
 805573e:	9209      	str	r2, [sp, #36]	; 0x24
 8055740:	e7ce      	b.n	80556e0 <_dtoa_r+0x238>
 8055742:	2301      	movs	r3, #1
 8055744:	9308      	str	r3, [sp, #32]
 8055746:	e7f4      	b.n	8055732 <_dtoa_r+0x28a>
 8055748:	f8dd 9024 	ldr.w	r9, [sp, #36]	; 0x24
 805574c:	f8cd 9004 	str.w	r9, [sp, #4]
 8055750:	464b      	mov	r3, r9
 8055752:	e7c5      	b.n	80556e0 <_dtoa_r+0x238>
 8055754:	3101      	adds	r1, #1
 8055756:	6461      	str	r1, [r4, #68]	; 0x44
 8055758:	0052      	lsls	r2, r2, #1
 805575a:	e7c4      	b.n	80556e6 <_dtoa_r+0x23e>
 805575c:	f3af 8000 	nop.w
 8055760:	636f4361 	.word	0x636f4361
 8055764:	3fd287a7 	.word	0x3fd287a7
 8055768:	8b60c8b3 	.word	0x8b60c8b3
 805576c:	3fc68a28 	.word	0x3fc68a28
 8055770:	509f79fb 	.word	0x509f79fb
 8055774:	3fd34413 	.word	0x3fd34413
 8055778:	7ff00000 	.word	0x7ff00000
 805577c:	0805acea 	.word	0x0805acea
 8055780:	0805acee 	.word	0x0805acee
 8055784:	0805ab83 	.word	0x0805ab83
 8055788:	3ff80000 	.word	0x3ff80000
 805578c:	0805ae70 	.word	0x0805ae70
 8055790:	0805acf7 	.word	0x0805acf7
 8055794:	0805ad08 	.word	0x0805ad08
 8055798:	9b00      	ldr	r3, [sp, #0]
 805579a:	6423      	str	r3, [r4, #64]	; 0x40
 805579c:	9b01      	ldr	r3, [sp, #4]
 805579e:	2b0e      	cmp	r3, #14
 80557a0:	f200 80ad 	bhi.w	80558fe <_dtoa_r+0x456>
 80557a4:	2d00      	cmp	r5, #0
 80557a6:	f000 80aa 	beq.w	80558fe <_dtoa_r+0x456>
 80557aa:	f1ba 0f00 	cmp.w	sl, #0
 80557ae:	dd36      	ble.n	805581e <_dtoa_r+0x376>
 80557b0:	4ac2      	ldr	r2, [pc, #776]	; (8055abc <_dtoa_r+0x614>)
 80557b2:	f00a 030f 	and.w	r3, sl, #15
 80557b6:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 80557ba:	ed93 7b00 	vldr	d7, [r3]
 80557be:	f41a 7f80 	tst.w	sl, #256	; 0x100
 80557c2:	ea4f 172a 	mov.w	r7, sl, asr #4
 80557c6:	eeb0 8a47 	vmov.f32	s16, s14
 80557ca:	eef0 8a67 	vmov.f32	s17, s15
 80557ce:	d016      	beq.n	80557fe <_dtoa_r+0x356>
 80557d0:	4bbb      	ldr	r3, [pc, #748]	; (8055ac0 <_dtoa_r+0x618>)
 80557d2:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
 80557d6:	e9d3 2308 	ldrd	r2, r3, [r3, #32]
 80557da:	f7eb f857 	bl	804088c <__aeabi_ddiv>
 80557de:	e9cd 0102 	strd	r0, r1, [sp, #8]
 80557e2:	f007 070f 	and.w	r7, r7, #15
 80557e6:	2503      	movs	r5, #3
 80557e8:	4eb5      	ldr	r6, [pc, #724]	; (8055ac0 <_dtoa_r+0x618>)
 80557ea:	b957      	cbnz	r7, 8055802 <_dtoa_r+0x35a>
 80557ec:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 80557f0:	ec53 2b18 	vmov	r2, r3, d8
 80557f4:	f7eb f84a 	bl	804088c <__aeabi_ddiv>
 80557f8:	e9cd 0102 	strd	r0, r1, [sp, #8]
 80557fc:	e029      	b.n	8055852 <_dtoa_r+0x3aa>
 80557fe:	2502      	movs	r5, #2
 8055800:	e7f2      	b.n	80557e8 <_dtoa_r+0x340>
 8055802:	07f9      	lsls	r1, r7, #31
 8055804:	d508      	bpl.n	8055818 <_dtoa_r+0x370>
 8055806:	ec51 0b18 	vmov	r0, r1, d8
 805580a:	e9d6 2300 	ldrd	r2, r3, [r6]
 805580e:	f7ea ff13 	bl	8040638 <__aeabi_dmul>
 8055812:	ec41 0b18 	vmov	d8, r0, r1
 8055816:	3501      	adds	r5, #1
 8055818:	107f      	asrs	r7, r7, #1
 805581a:	3608      	adds	r6, #8
 805581c:	e7e5      	b.n	80557ea <_dtoa_r+0x342>
 805581e:	f000 80a6 	beq.w	805596e <_dtoa_r+0x4c6>
 8055822:	f1ca 0600 	rsb	r6, sl, #0
 8055826:	4ba5      	ldr	r3, [pc, #660]	; (8055abc <_dtoa_r+0x614>)
 8055828:	4fa5      	ldr	r7, [pc, #660]	; (8055ac0 <_dtoa_r+0x618>)
 805582a:	f006 020f 	and.w	r2, r6, #15
 805582e:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 8055832:	e9d3 2300 	ldrd	r2, r3, [r3]
 8055836:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
 805583a:	f7ea fefd 	bl	8040638 <__aeabi_dmul>
 805583e:	e9cd 0102 	strd	r0, r1, [sp, #8]
 8055842:	1136      	asrs	r6, r6, #4
 8055844:	2300      	movs	r3, #0
 8055846:	2502      	movs	r5, #2
 8055848:	2e00      	cmp	r6, #0
 805584a:	f040 8085 	bne.w	8055958 <_dtoa_r+0x4b0>
 805584e:	2b00      	cmp	r3, #0
 8055850:	d1d2      	bne.n	80557f8 <_dtoa_r+0x350>
 8055852:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8055854:	2b00      	cmp	r3, #0
 8055856:	f000 808c 	beq.w	8055972 <_dtoa_r+0x4ca>
 805585a:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
 805585e:	4b99      	ldr	r3, [pc, #612]	; (8055ac4 <_dtoa_r+0x61c>)
 8055860:	2200      	movs	r2, #0
 8055862:	4630      	mov	r0, r6
 8055864:	4639      	mov	r1, r7
 8055866:	f7eb f959 	bl	8040b1c <__aeabi_dcmplt>
 805586a:	2800      	cmp	r0, #0
 805586c:	f000 8081 	beq.w	8055972 <_dtoa_r+0x4ca>
 8055870:	9b01      	ldr	r3, [sp, #4]
 8055872:	2b00      	cmp	r3, #0
 8055874:	d07d      	beq.n	8055972 <_dtoa_r+0x4ca>
 8055876:	f1b9 0f00 	cmp.w	r9, #0
 805587a:	dd3c      	ble.n	80558f6 <_dtoa_r+0x44e>
 805587c:	f10a 33ff 	add.w	r3, sl, #4294967295
 8055880:	9307      	str	r3, [sp, #28]
 8055882:	2200      	movs	r2, #0
 8055884:	4b90      	ldr	r3, [pc, #576]	; (8055ac8 <_dtoa_r+0x620>)
 8055886:	4630      	mov	r0, r6
 8055888:	4639      	mov	r1, r7
 805588a:	f7ea fed5 	bl	8040638 <__aeabi_dmul>
 805588e:	e9cd 0102 	strd	r0, r1, [sp, #8]
 8055892:	3501      	adds	r5, #1
 8055894:	f8cd 9030 	str.w	r9, [sp, #48]	; 0x30
 8055898:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
 805589c:	4628      	mov	r0, r5
 805589e:	f7ea fe61 	bl	8040564 <__aeabi_i2d>
 80558a2:	4632      	mov	r2, r6
 80558a4:	463b      	mov	r3, r7
 80558a6:	f7ea fec7 	bl	8040638 <__aeabi_dmul>
 80558aa:	4b88      	ldr	r3, [pc, #544]	; (8055acc <_dtoa_r+0x624>)
 80558ac:	2200      	movs	r2, #0
 80558ae:	f7ea fd0d 	bl	80402cc <__adddf3>
 80558b2:	f1a1 7350 	sub.w	r3, r1, #54525952	; 0x3400000
 80558b6:	e9cd 0102 	strd	r0, r1, [sp, #8]
 80558ba:	9303      	str	r3, [sp, #12]
 80558bc:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80558be:	2b00      	cmp	r3, #0
 80558c0:	d15c      	bne.n	805597c <_dtoa_r+0x4d4>
 80558c2:	4b83      	ldr	r3, [pc, #524]	; (8055ad0 <_dtoa_r+0x628>)
 80558c4:	2200      	movs	r2, #0
 80558c6:	4630      	mov	r0, r6
 80558c8:	4639      	mov	r1, r7
 80558ca:	f7ea fcfd 	bl	80402c8 <__aeabi_dsub>
 80558ce:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 80558d2:	4606      	mov	r6, r0
 80558d4:	460f      	mov	r7, r1
 80558d6:	f7eb f93f 	bl	8040b58 <__aeabi_dcmpgt>
 80558da:	2800      	cmp	r0, #0
 80558dc:	f040 8295 	bne.w	8055e0a <_dtoa_r+0x962>
 80558e0:	e9dd 2102 	ldrd	r2, r1, [sp, #8]
 80558e4:	4630      	mov	r0, r6
 80558e6:	f101 4300 	add.w	r3, r1, #2147483648	; 0x80000000
 80558ea:	4639      	mov	r1, r7
 80558ec:	f7eb f916 	bl	8040b1c <__aeabi_dcmplt>
 80558f0:	2800      	cmp	r0, #0
 80558f2:	f040 8287 	bne.w	8055e04 <_dtoa_r+0x95c>
 80558f6:	e9dd 230a 	ldrd	r2, r3, [sp, #40]	; 0x28
 80558fa:	e9cd 2302 	strd	r2, r3, [sp, #8]
 80558fe:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8055900:	2b00      	cmp	r3, #0
 8055902:	f2c0 8157 	blt.w	8055bb4 <_dtoa_r+0x70c>
 8055906:	f1ba 0f0e 	cmp.w	sl, #14
 805590a:	f300 8153 	bgt.w	8055bb4 <_dtoa_r+0x70c>
 805590e:	4b6b      	ldr	r3, [pc, #428]	; (8055abc <_dtoa_r+0x614>)
 8055910:	eb03 03ca 	add.w	r3, r3, sl, lsl #3
 8055914:	e9d3 8900 	ldrd	r8, r9, [r3]
 8055918:	9b09      	ldr	r3, [sp, #36]	; 0x24
 805591a:	2b00      	cmp	r3, #0
 805591c:	f280 80e2 	bge.w	8055ae4 <_dtoa_r+0x63c>
 8055920:	9b01      	ldr	r3, [sp, #4]
 8055922:	2b00      	cmp	r3, #0
 8055924:	f300 80de 	bgt.w	8055ae4 <_dtoa_r+0x63c>
 8055928:	f040 826c 	bne.w	8055e04 <_dtoa_r+0x95c>
 805592c:	4b68      	ldr	r3, [pc, #416]	; (8055ad0 <_dtoa_r+0x628>)
 805592e:	2200      	movs	r2, #0
 8055930:	4640      	mov	r0, r8
 8055932:	4649      	mov	r1, r9
 8055934:	f7ea fe80 	bl	8040638 <__aeabi_dmul>
 8055938:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 805593c:	f7eb f902 	bl	8040b44 <__aeabi_dcmpge>
 8055940:	9e01      	ldr	r6, [sp, #4]
 8055942:	4637      	mov	r7, r6
 8055944:	2800      	cmp	r0, #0
 8055946:	f040 8242 	bne.w	8055dce <_dtoa_r+0x926>
 805594a:	9d00      	ldr	r5, [sp, #0]
 805594c:	2331      	movs	r3, #49	; 0x31
 805594e:	f805 3b01 	strb.w	r3, [r5], #1
 8055952:	f10a 0a01 	add.w	sl, sl, #1
 8055956:	e23e      	b.n	8055dd6 <_dtoa_r+0x92e>
 8055958:	07f2      	lsls	r2, r6, #31
 805595a:	d505      	bpl.n	8055968 <_dtoa_r+0x4c0>
 805595c:	e9d7 2300 	ldrd	r2, r3, [r7]
 8055960:	f7ea fe6a 	bl	8040638 <__aeabi_dmul>
 8055964:	3501      	adds	r5, #1
 8055966:	2301      	movs	r3, #1
 8055968:	1076      	asrs	r6, r6, #1
 805596a:	3708      	adds	r7, #8
 805596c:	e76c      	b.n	8055848 <_dtoa_r+0x3a0>
 805596e:	2502      	movs	r5, #2
 8055970:	e76f      	b.n	8055852 <_dtoa_r+0x3aa>
 8055972:	9b01      	ldr	r3, [sp, #4]
 8055974:	f8cd a01c 	str.w	sl, [sp, #28]
 8055978:	930c      	str	r3, [sp, #48]	; 0x30
 805597a:	e78d      	b.n	8055898 <_dtoa_r+0x3f0>
 805597c:	9900      	ldr	r1, [sp, #0]
 805597e:	980c      	ldr	r0, [sp, #48]	; 0x30
 8055980:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8055982:	4b4e      	ldr	r3, [pc, #312]	; (8055abc <_dtoa_r+0x614>)
 8055984:	ed9d 7b02 	vldr	d7, [sp, #8]
 8055988:	4401      	add	r1, r0
 805598a:	9102      	str	r1, [sp, #8]
 805598c:	9908      	ldr	r1, [sp, #32]
 805598e:	eeb0 8a47 	vmov.f32	s16, s14
 8055992:	eef0 8a67 	vmov.f32	s17, s15
 8055996:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 805599a:	e953 2302 	ldrd	r2, r3, [r3, #-8]
 805599e:	2900      	cmp	r1, #0
 80559a0:	d045      	beq.n	8055a2e <_dtoa_r+0x586>
 80559a2:	494c      	ldr	r1, [pc, #304]	; (8055ad4 <_dtoa_r+0x62c>)
 80559a4:	2000      	movs	r0, #0
 80559a6:	f7ea ff71 	bl	804088c <__aeabi_ddiv>
 80559aa:	ec53 2b18 	vmov	r2, r3, d8
 80559ae:	f7ea fc8b 	bl	80402c8 <__aeabi_dsub>
 80559b2:	9d00      	ldr	r5, [sp, #0]
 80559b4:	ec41 0b18 	vmov	d8, r0, r1
 80559b8:	4639      	mov	r1, r7
 80559ba:	4630      	mov	r0, r6
 80559bc:	f7eb f8ec 	bl	8040b98 <__aeabi_d2iz>
 80559c0:	900c      	str	r0, [sp, #48]	; 0x30
 80559c2:	f7ea fdcf 	bl	8040564 <__aeabi_i2d>
 80559c6:	4602      	mov	r2, r0
 80559c8:	460b      	mov	r3, r1
 80559ca:	4630      	mov	r0, r6
 80559cc:	4639      	mov	r1, r7
 80559ce:	f7ea fc7b 	bl	80402c8 <__aeabi_dsub>
 80559d2:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80559d4:	3330      	adds	r3, #48	; 0x30
 80559d6:	f805 3b01 	strb.w	r3, [r5], #1
 80559da:	ec53 2b18 	vmov	r2, r3, d8
 80559de:	4606      	mov	r6, r0
 80559e0:	460f      	mov	r7, r1
 80559e2:	f7eb f89b 	bl	8040b1c <__aeabi_dcmplt>
 80559e6:	2800      	cmp	r0, #0
 80559e8:	d165      	bne.n	8055ab6 <_dtoa_r+0x60e>
 80559ea:	4632      	mov	r2, r6
 80559ec:	463b      	mov	r3, r7
 80559ee:	4935      	ldr	r1, [pc, #212]	; (8055ac4 <_dtoa_r+0x61c>)
 80559f0:	2000      	movs	r0, #0
 80559f2:	f7ea fc69 	bl	80402c8 <__aeabi_dsub>
 80559f6:	ec53 2b18 	vmov	r2, r3, d8
 80559fa:	f7eb f88f 	bl	8040b1c <__aeabi_dcmplt>
 80559fe:	2800      	cmp	r0, #0
 8055a00:	f040 80b8 	bne.w	8055b74 <_dtoa_r+0x6cc>
 8055a04:	9b02      	ldr	r3, [sp, #8]
 8055a06:	429d      	cmp	r5, r3
 8055a08:	f43f af75 	beq.w	80558f6 <_dtoa_r+0x44e>
 8055a0c:	4b2e      	ldr	r3, [pc, #184]	; (8055ac8 <_dtoa_r+0x620>)
 8055a0e:	ec51 0b18 	vmov	r0, r1, d8
 8055a12:	2200      	movs	r2, #0
 8055a14:	f7ea fe10 	bl	8040638 <__aeabi_dmul>
 8055a18:	4b2b      	ldr	r3, [pc, #172]	; (8055ac8 <_dtoa_r+0x620>)
 8055a1a:	ec41 0b18 	vmov	d8, r0, r1
 8055a1e:	2200      	movs	r2, #0
 8055a20:	4630      	mov	r0, r6
 8055a22:	4639      	mov	r1, r7
 8055a24:	f7ea fe08 	bl	8040638 <__aeabi_dmul>
 8055a28:	4606      	mov	r6, r0
 8055a2a:	460f      	mov	r7, r1
 8055a2c:	e7c4      	b.n	80559b8 <_dtoa_r+0x510>
 8055a2e:	ec51 0b17 	vmov	r0, r1, d7
 8055a32:	f7ea fe01 	bl	8040638 <__aeabi_dmul>
 8055a36:	9b02      	ldr	r3, [sp, #8]
 8055a38:	9d00      	ldr	r5, [sp, #0]
 8055a3a:	930c      	str	r3, [sp, #48]	; 0x30
 8055a3c:	ec41 0b18 	vmov	d8, r0, r1
 8055a40:	4639      	mov	r1, r7
 8055a42:	4630      	mov	r0, r6
 8055a44:	f7eb f8a8 	bl	8040b98 <__aeabi_d2iz>
 8055a48:	9011      	str	r0, [sp, #68]	; 0x44
 8055a4a:	f7ea fd8b 	bl	8040564 <__aeabi_i2d>
 8055a4e:	4602      	mov	r2, r0
 8055a50:	460b      	mov	r3, r1
 8055a52:	4630      	mov	r0, r6
 8055a54:	4639      	mov	r1, r7
 8055a56:	f7ea fc37 	bl	80402c8 <__aeabi_dsub>
 8055a5a:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8055a5c:	3330      	adds	r3, #48	; 0x30
 8055a5e:	f805 3b01 	strb.w	r3, [r5], #1
 8055a62:	9b02      	ldr	r3, [sp, #8]
 8055a64:	429d      	cmp	r5, r3
 8055a66:	4606      	mov	r6, r0
 8055a68:	460f      	mov	r7, r1
 8055a6a:	f04f 0200 	mov.w	r2, #0
 8055a6e:	d133      	bne.n	8055ad8 <_dtoa_r+0x630>
 8055a70:	4b18      	ldr	r3, [pc, #96]	; (8055ad4 <_dtoa_r+0x62c>)
 8055a72:	ec51 0b18 	vmov	r0, r1, d8
 8055a76:	f7ea fc29 	bl	80402cc <__adddf3>
 8055a7a:	4602      	mov	r2, r0
 8055a7c:	460b      	mov	r3, r1
 8055a7e:	4630      	mov	r0, r6
 8055a80:	4639      	mov	r1, r7
 8055a82:	f7eb f869 	bl	8040b58 <__aeabi_dcmpgt>
 8055a86:	2800      	cmp	r0, #0
 8055a88:	d174      	bne.n	8055b74 <_dtoa_r+0x6cc>
 8055a8a:	ec53 2b18 	vmov	r2, r3, d8
 8055a8e:	4911      	ldr	r1, [pc, #68]	; (8055ad4 <_dtoa_r+0x62c>)
 8055a90:	2000      	movs	r0, #0
 8055a92:	f7ea fc19 	bl	80402c8 <__aeabi_dsub>
 8055a96:	4602      	mov	r2, r0
 8055a98:	460b      	mov	r3, r1
 8055a9a:	4630      	mov	r0, r6
 8055a9c:	4639      	mov	r1, r7
 8055a9e:	f7eb f83d 	bl	8040b1c <__aeabi_dcmplt>
 8055aa2:	2800      	cmp	r0, #0
 8055aa4:	f43f af27 	beq.w	80558f6 <_dtoa_r+0x44e>
 8055aa8:	9d0c      	ldr	r5, [sp, #48]	; 0x30
 8055aaa:	1e6b      	subs	r3, r5, #1
 8055aac:	930c      	str	r3, [sp, #48]	; 0x30
 8055aae:	f815 3c01 	ldrb.w	r3, [r5, #-1]
 8055ab2:	2b30      	cmp	r3, #48	; 0x30
 8055ab4:	d0f8      	beq.n	8055aa8 <_dtoa_r+0x600>
 8055ab6:	f8dd a01c 	ldr.w	sl, [sp, #28]
 8055aba:	e049      	b.n	8055b50 <_dtoa_r+0x6a8>
 8055abc:	0805ae70 	.word	0x0805ae70
 8055ac0:	0805ae48 	.word	0x0805ae48
 8055ac4:	3ff00000 	.word	0x3ff00000
 8055ac8:	40240000 	.word	0x40240000
 8055acc:	401c0000 	.word	0x401c0000
 8055ad0:	40140000 	.word	0x40140000
 8055ad4:	3fe00000 	.word	0x3fe00000
 8055ad8:	4baf      	ldr	r3, [pc, #700]	; (8055d98 <_dtoa_r+0x8f0>)
 8055ada:	f7ea fdad 	bl	8040638 <__aeabi_dmul>
 8055ade:	4606      	mov	r6, r0
 8055ae0:	460f      	mov	r7, r1
 8055ae2:	e7ad      	b.n	8055a40 <_dtoa_r+0x598>
 8055ae4:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
 8055ae8:	9d00      	ldr	r5, [sp, #0]
 8055aea:	4642      	mov	r2, r8
 8055aec:	464b      	mov	r3, r9
 8055aee:	4630      	mov	r0, r6
 8055af0:	4639      	mov	r1, r7
 8055af2:	f7ea fecb 	bl	804088c <__aeabi_ddiv>
 8055af6:	f7eb f84f 	bl	8040b98 <__aeabi_d2iz>
 8055afa:	9002      	str	r0, [sp, #8]
 8055afc:	f7ea fd32 	bl	8040564 <__aeabi_i2d>
 8055b00:	4642      	mov	r2, r8
 8055b02:	464b      	mov	r3, r9
 8055b04:	f7ea fd98 	bl	8040638 <__aeabi_dmul>
 8055b08:	4602      	mov	r2, r0
 8055b0a:	460b      	mov	r3, r1
 8055b0c:	4630      	mov	r0, r6
 8055b0e:	4639      	mov	r1, r7
 8055b10:	f7ea fbda 	bl	80402c8 <__aeabi_dsub>
 8055b14:	9e02      	ldr	r6, [sp, #8]
 8055b16:	9f01      	ldr	r7, [sp, #4]
 8055b18:	3630      	adds	r6, #48	; 0x30
 8055b1a:	f805 6b01 	strb.w	r6, [r5], #1
 8055b1e:	9e00      	ldr	r6, [sp, #0]
 8055b20:	1bae      	subs	r6, r5, r6
 8055b22:	42b7      	cmp	r7, r6
 8055b24:	4602      	mov	r2, r0
 8055b26:	460b      	mov	r3, r1
 8055b28:	d137      	bne.n	8055b9a <_dtoa_r+0x6f2>
 8055b2a:	f7ea fbcf 	bl	80402cc <__adddf3>
 8055b2e:	4642      	mov	r2, r8
 8055b30:	464b      	mov	r3, r9
 8055b32:	4606      	mov	r6, r0
 8055b34:	460f      	mov	r7, r1
 8055b36:	f7eb f80f 	bl	8040b58 <__aeabi_dcmpgt>
 8055b3a:	b9c8      	cbnz	r0, 8055b70 <_dtoa_r+0x6c8>
 8055b3c:	4642      	mov	r2, r8
 8055b3e:	464b      	mov	r3, r9
 8055b40:	4630      	mov	r0, r6
 8055b42:	4639      	mov	r1, r7
 8055b44:	f7ea ffe0 	bl	8040b08 <__aeabi_dcmpeq>
 8055b48:	b110      	cbz	r0, 8055b50 <_dtoa_r+0x6a8>
 8055b4a:	9b02      	ldr	r3, [sp, #8]
 8055b4c:	07d9      	lsls	r1, r3, #31
 8055b4e:	d40f      	bmi.n	8055b70 <_dtoa_r+0x6c8>
 8055b50:	4620      	mov	r0, r4
 8055b52:	4659      	mov	r1, fp
 8055b54:	f001 f90b 	bl	8056d6e <_Bfree>
 8055b58:	2300      	movs	r3, #0
 8055b5a:	702b      	strb	r3, [r5, #0]
 8055b5c:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8055b5e:	f10a 0001 	add.w	r0, sl, #1
 8055b62:	6018      	str	r0, [r3, #0]
 8055b64:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8055b66:	2b00      	cmp	r3, #0
 8055b68:	f43f acd9 	beq.w	805551e <_dtoa_r+0x76>
 8055b6c:	601d      	str	r5, [r3, #0]
 8055b6e:	e4d6      	b.n	805551e <_dtoa_r+0x76>
 8055b70:	f8cd a01c 	str.w	sl, [sp, #28]
 8055b74:	462b      	mov	r3, r5
 8055b76:	461d      	mov	r5, r3
 8055b78:	f813 2d01 	ldrb.w	r2, [r3, #-1]!
 8055b7c:	2a39      	cmp	r2, #57	; 0x39
 8055b7e:	d108      	bne.n	8055b92 <_dtoa_r+0x6ea>
 8055b80:	9a00      	ldr	r2, [sp, #0]
 8055b82:	429a      	cmp	r2, r3
 8055b84:	d1f7      	bne.n	8055b76 <_dtoa_r+0x6ce>
 8055b86:	9a07      	ldr	r2, [sp, #28]
 8055b88:	9900      	ldr	r1, [sp, #0]
 8055b8a:	3201      	adds	r2, #1
 8055b8c:	9207      	str	r2, [sp, #28]
 8055b8e:	2230      	movs	r2, #48	; 0x30
 8055b90:	700a      	strb	r2, [r1, #0]
 8055b92:	781a      	ldrb	r2, [r3, #0]
 8055b94:	3201      	adds	r2, #1
 8055b96:	701a      	strb	r2, [r3, #0]
 8055b98:	e78d      	b.n	8055ab6 <_dtoa_r+0x60e>
 8055b9a:	4b7f      	ldr	r3, [pc, #508]	; (8055d98 <_dtoa_r+0x8f0>)
 8055b9c:	2200      	movs	r2, #0
 8055b9e:	f7ea fd4b 	bl	8040638 <__aeabi_dmul>
 8055ba2:	2200      	movs	r2, #0
 8055ba4:	2300      	movs	r3, #0
 8055ba6:	4606      	mov	r6, r0
 8055ba8:	460f      	mov	r7, r1
 8055baa:	f7ea ffad 	bl	8040b08 <__aeabi_dcmpeq>
 8055bae:	2800      	cmp	r0, #0
 8055bb0:	d09b      	beq.n	8055aea <_dtoa_r+0x642>
 8055bb2:	e7cd      	b.n	8055b50 <_dtoa_r+0x6a8>
 8055bb4:	9a08      	ldr	r2, [sp, #32]
 8055bb6:	2a00      	cmp	r2, #0
 8055bb8:	f000 80c4 	beq.w	8055d44 <_dtoa_r+0x89c>
 8055bbc:	9a05      	ldr	r2, [sp, #20]
 8055bbe:	2a01      	cmp	r2, #1
 8055bc0:	f300 80a8 	bgt.w	8055d14 <_dtoa_r+0x86c>
 8055bc4:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8055bc6:	2a00      	cmp	r2, #0
 8055bc8:	f000 80a0 	beq.w	8055d0c <_dtoa_r+0x864>
 8055bcc:	f203 4333 	addw	r3, r3, #1075	; 0x433
 8055bd0:	9e06      	ldr	r6, [sp, #24]
 8055bd2:	4645      	mov	r5, r8
 8055bd4:	9a04      	ldr	r2, [sp, #16]
 8055bd6:	2101      	movs	r1, #1
 8055bd8:	441a      	add	r2, r3
 8055bda:	4620      	mov	r0, r4
 8055bdc:	4498      	add	r8, r3
 8055bde:	9204      	str	r2, [sp, #16]
 8055be0:	f001 f9b2 	bl	8056f48 <__i2b>
 8055be4:	4607      	mov	r7, r0
 8055be6:	2d00      	cmp	r5, #0
 8055be8:	dd0b      	ble.n	8055c02 <_dtoa_r+0x75a>
 8055bea:	9b04      	ldr	r3, [sp, #16]
 8055bec:	2b00      	cmp	r3, #0
 8055bee:	dd08      	ble.n	8055c02 <_dtoa_r+0x75a>
 8055bf0:	42ab      	cmp	r3, r5
 8055bf2:	9a04      	ldr	r2, [sp, #16]
 8055bf4:	bfa8      	it	ge
 8055bf6:	462b      	movge	r3, r5
 8055bf8:	eba8 0803 	sub.w	r8, r8, r3
 8055bfc:	1aed      	subs	r5, r5, r3
 8055bfe:	1ad3      	subs	r3, r2, r3
 8055c00:	9304      	str	r3, [sp, #16]
 8055c02:	9b06      	ldr	r3, [sp, #24]
 8055c04:	b1fb      	cbz	r3, 8055c46 <_dtoa_r+0x79e>
 8055c06:	9b08      	ldr	r3, [sp, #32]
 8055c08:	2b00      	cmp	r3, #0
 8055c0a:	f000 809f 	beq.w	8055d4c <_dtoa_r+0x8a4>
 8055c0e:	2e00      	cmp	r6, #0
 8055c10:	dd11      	ble.n	8055c36 <_dtoa_r+0x78e>
 8055c12:	4639      	mov	r1, r7
 8055c14:	4632      	mov	r2, r6
 8055c16:	4620      	mov	r0, r4
 8055c18:	f001 fa52 	bl	80570c0 <__pow5mult>
 8055c1c:	465a      	mov	r2, fp
 8055c1e:	4601      	mov	r1, r0
 8055c20:	4607      	mov	r7, r0
 8055c22:	4620      	mov	r0, r4
 8055c24:	f001 f9a6 	bl	8056f74 <__multiply>
 8055c28:	4659      	mov	r1, fp
 8055c2a:	9007      	str	r0, [sp, #28]
 8055c2c:	4620      	mov	r0, r4
 8055c2e:	f001 f89e 	bl	8056d6e <_Bfree>
 8055c32:	9b07      	ldr	r3, [sp, #28]
 8055c34:	469b      	mov	fp, r3
 8055c36:	9b06      	ldr	r3, [sp, #24]
 8055c38:	1b9a      	subs	r2, r3, r6
 8055c3a:	d004      	beq.n	8055c46 <_dtoa_r+0x79e>
 8055c3c:	4659      	mov	r1, fp
 8055c3e:	4620      	mov	r0, r4
 8055c40:	f001 fa3e 	bl	80570c0 <__pow5mult>
 8055c44:	4683      	mov	fp, r0
 8055c46:	2101      	movs	r1, #1
 8055c48:	4620      	mov	r0, r4
 8055c4a:	f001 f97d 	bl	8056f48 <__i2b>
 8055c4e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8055c50:	2b00      	cmp	r3, #0
 8055c52:	4606      	mov	r6, r0
 8055c54:	dd7c      	ble.n	8055d50 <_dtoa_r+0x8a8>
 8055c56:	461a      	mov	r2, r3
 8055c58:	4601      	mov	r1, r0
 8055c5a:	4620      	mov	r0, r4
 8055c5c:	f001 fa30 	bl	80570c0 <__pow5mult>
 8055c60:	9b05      	ldr	r3, [sp, #20]
 8055c62:	2b01      	cmp	r3, #1
 8055c64:	4606      	mov	r6, r0
 8055c66:	dd76      	ble.n	8055d56 <_dtoa_r+0x8ae>
 8055c68:	2300      	movs	r3, #0
 8055c6a:	9306      	str	r3, [sp, #24]
 8055c6c:	6933      	ldr	r3, [r6, #16]
 8055c6e:	eb06 0383 	add.w	r3, r6, r3, lsl #2
 8055c72:	6918      	ldr	r0, [r3, #16]
 8055c74:	f001 f918 	bl	8056ea8 <__hi0bits>
 8055c78:	f1c0 0020 	rsb	r0, r0, #32
 8055c7c:	9b04      	ldr	r3, [sp, #16]
 8055c7e:	4418      	add	r0, r3
 8055c80:	f010 001f 	ands.w	r0, r0, #31
 8055c84:	f000 8086 	beq.w	8055d94 <_dtoa_r+0x8ec>
 8055c88:	f1c0 0320 	rsb	r3, r0, #32
 8055c8c:	2b04      	cmp	r3, #4
 8055c8e:	dd7f      	ble.n	8055d90 <_dtoa_r+0x8e8>
 8055c90:	f1c0 001c 	rsb	r0, r0, #28
 8055c94:	9b04      	ldr	r3, [sp, #16]
 8055c96:	4403      	add	r3, r0
 8055c98:	4480      	add	r8, r0
 8055c9a:	4405      	add	r5, r0
 8055c9c:	9304      	str	r3, [sp, #16]
 8055c9e:	f1b8 0f00 	cmp.w	r8, #0
 8055ca2:	dd05      	ble.n	8055cb0 <_dtoa_r+0x808>
 8055ca4:	4659      	mov	r1, fp
 8055ca6:	4642      	mov	r2, r8
 8055ca8:	4620      	mov	r0, r4
 8055caa:	f001 fa49 	bl	8057140 <__lshift>
 8055cae:	4683      	mov	fp, r0
 8055cb0:	9b04      	ldr	r3, [sp, #16]
 8055cb2:	2b00      	cmp	r3, #0
 8055cb4:	dd05      	ble.n	8055cc2 <_dtoa_r+0x81a>
 8055cb6:	4631      	mov	r1, r6
 8055cb8:	461a      	mov	r2, r3
 8055cba:	4620      	mov	r0, r4
 8055cbc:	f001 fa40 	bl	8057140 <__lshift>
 8055cc0:	4606      	mov	r6, r0
 8055cc2:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8055cc4:	2b00      	cmp	r3, #0
 8055cc6:	d069      	beq.n	8055d9c <_dtoa_r+0x8f4>
 8055cc8:	4631      	mov	r1, r6
 8055cca:	4658      	mov	r0, fp
 8055ccc:	f001 faa4 	bl	8057218 <__mcmp>
 8055cd0:	2800      	cmp	r0, #0
 8055cd2:	da63      	bge.n	8055d9c <_dtoa_r+0x8f4>
 8055cd4:	2300      	movs	r3, #0
 8055cd6:	4659      	mov	r1, fp
 8055cd8:	220a      	movs	r2, #10
 8055cda:	4620      	mov	r0, r4
 8055cdc:	f001 f850 	bl	8056d80 <__multadd>
 8055ce0:	9b08      	ldr	r3, [sp, #32]
 8055ce2:	f10a 3aff 	add.w	sl, sl, #4294967295
 8055ce6:	4683      	mov	fp, r0
 8055ce8:	2b00      	cmp	r3, #0
 8055cea:	f000 818e 	beq.w	805600a <_dtoa_r+0xb62>
 8055cee:	4639      	mov	r1, r7
 8055cf0:	2300      	movs	r3, #0
 8055cf2:	220a      	movs	r2, #10
 8055cf4:	4620      	mov	r0, r4
 8055cf6:	f001 f843 	bl	8056d80 <__multadd>
 8055cfa:	f1b9 0f00 	cmp.w	r9, #0
 8055cfe:	4607      	mov	r7, r0
 8055d00:	f300 808e 	bgt.w	8055e20 <_dtoa_r+0x978>
 8055d04:	9b05      	ldr	r3, [sp, #20]
 8055d06:	2b02      	cmp	r3, #2
 8055d08:	dc50      	bgt.n	8055dac <_dtoa_r+0x904>
 8055d0a:	e089      	b.n	8055e20 <_dtoa_r+0x978>
 8055d0c:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8055d0e:	f1c3 0336 	rsb	r3, r3, #54	; 0x36
 8055d12:	e75d      	b.n	8055bd0 <_dtoa_r+0x728>
 8055d14:	9b01      	ldr	r3, [sp, #4]
 8055d16:	1e5e      	subs	r6, r3, #1
 8055d18:	9b06      	ldr	r3, [sp, #24]
 8055d1a:	42b3      	cmp	r3, r6
 8055d1c:	bfbf      	itttt	lt
 8055d1e:	9b06      	ldrlt	r3, [sp, #24]
 8055d20:	9606      	strlt	r6, [sp, #24]
 8055d22:	1af2      	sublt	r2, r6, r3
 8055d24:	9b0d      	ldrlt	r3, [sp, #52]	; 0x34
 8055d26:	bfb6      	itet	lt
 8055d28:	189b      	addlt	r3, r3, r2
 8055d2a:	1b9e      	subge	r6, r3, r6
 8055d2c:	930d      	strlt	r3, [sp, #52]	; 0x34
 8055d2e:	9b01      	ldr	r3, [sp, #4]
 8055d30:	bfb8      	it	lt
 8055d32:	2600      	movlt	r6, #0
 8055d34:	2b00      	cmp	r3, #0
 8055d36:	bfb5      	itete	lt
 8055d38:	eba8 0503 	sublt.w	r5, r8, r3
 8055d3c:	9b01      	ldrge	r3, [sp, #4]
 8055d3e:	2300      	movlt	r3, #0
 8055d40:	4645      	movge	r5, r8
 8055d42:	e747      	b.n	8055bd4 <_dtoa_r+0x72c>
 8055d44:	9e06      	ldr	r6, [sp, #24]
 8055d46:	9f08      	ldr	r7, [sp, #32]
 8055d48:	4645      	mov	r5, r8
 8055d4a:	e74c      	b.n	8055be6 <_dtoa_r+0x73e>
 8055d4c:	9a06      	ldr	r2, [sp, #24]
 8055d4e:	e775      	b.n	8055c3c <_dtoa_r+0x794>
 8055d50:	9b05      	ldr	r3, [sp, #20]
 8055d52:	2b01      	cmp	r3, #1
 8055d54:	dc18      	bgt.n	8055d88 <_dtoa_r+0x8e0>
 8055d56:	9b02      	ldr	r3, [sp, #8]
 8055d58:	b9b3      	cbnz	r3, 8055d88 <_dtoa_r+0x8e0>
 8055d5a:	9b03      	ldr	r3, [sp, #12]
 8055d5c:	f3c3 0313 	ubfx	r3, r3, #0, #20
 8055d60:	b9a3      	cbnz	r3, 8055d8c <_dtoa_r+0x8e4>
 8055d62:	9b03      	ldr	r3, [sp, #12]
 8055d64:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 8055d68:	0d1b      	lsrs	r3, r3, #20
 8055d6a:	051b      	lsls	r3, r3, #20
 8055d6c:	b12b      	cbz	r3, 8055d7a <_dtoa_r+0x8d2>
 8055d6e:	9b04      	ldr	r3, [sp, #16]
 8055d70:	3301      	adds	r3, #1
 8055d72:	9304      	str	r3, [sp, #16]
 8055d74:	f108 0801 	add.w	r8, r8, #1
 8055d78:	2301      	movs	r3, #1
 8055d7a:	9306      	str	r3, [sp, #24]
 8055d7c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8055d7e:	2b00      	cmp	r3, #0
 8055d80:	f47f af74 	bne.w	8055c6c <_dtoa_r+0x7c4>
 8055d84:	2001      	movs	r0, #1
 8055d86:	e779      	b.n	8055c7c <_dtoa_r+0x7d4>
 8055d88:	2300      	movs	r3, #0
 8055d8a:	e7f6      	b.n	8055d7a <_dtoa_r+0x8d2>
 8055d8c:	9b02      	ldr	r3, [sp, #8]
 8055d8e:	e7f4      	b.n	8055d7a <_dtoa_r+0x8d2>
 8055d90:	d085      	beq.n	8055c9e <_dtoa_r+0x7f6>
 8055d92:	4618      	mov	r0, r3
 8055d94:	301c      	adds	r0, #28
 8055d96:	e77d      	b.n	8055c94 <_dtoa_r+0x7ec>
 8055d98:	40240000 	.word	0x40240000
 8055d9c:	9b01      	ldr	r3, [sp, #4]
 8055d9e:	2b00      	cmp	r3, #0
 8055da0:	dc38      	bgt.n	8055e14 <_dtoa_r+0x96c>
 8055da2:	9b05      	ldr	r3, [sp, #20]
 8055da4:	2b02      	cmp	r3, #2
 8055da6:	dd35      	ble.n	8055e14 <_dtoa_r+0x96c>
 8055da8:	f8dd 9004 	ldr.w	r9, [sp, #4]
 8055dac:	f1b9 0f00 	cmp.w	r9, #0
 8055db0:	d10d      	bne.n	8055dce <_dtoa_r+0x926>
 8055db2:	4631      	mov	r1, r6
 8055db4:	464b      	mov	r3, r9
 8055db6:	2205      	movs	r2, #5
 8055db8:	4620      	mov	r0, r4
 8055dba:	f000 ffe1 	bl	8056d80 <__multadd>
 8055dbe:	4601      	mov	r1, r0
 8055dc0:	4606      	mov	r6, r0
 8055dc2:	4658      	mov	r0, fp
 8055dc4:	f001 fa28 	bl	8057218 <__mcmp>
 8055dc8:	2800      	cmp	r0, #0
 8055dca:	f73f adbe 	bgt.w	805594a <_dtoa_r+0x4a2>
 8055dce:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8055dd0:	9d00      	ldr	r5, [sp, #0]
 8055dd2:	ea6f 0a03 	mvn.w	sl, r3
 8055dd6:	f04f 0800 	mov.w	r8, #0
 8055dda:	4631      	mov	r1, r6
 8055ddc:	4620      	mov	r0, r4
 8055dde:	f000 ffc6 	bl	8056d6e <_Bfree>
 8055de2:	2f00      	cmp	r7, #0
 8055de4:	f43f aeb4 	beq.w	8055b50 <_dtoa_r+0x6a8>
 8055de8:	f1b8 0f00 	cmp.w	r8, #0
 8055dec:	d005      	beq.n	8055dfa <_dtoa_r+0x952>
 8055dee:	45b8      	cmp	r8, r7
 8055df0:	d003      	beq.n	8055dfa <_dtoa_r+0x952>
 8055df2:	4641      	mov	r1, r8
 8055df4:	4620      	mov	r0, r4
 8055df6:	f000 ffba 	bl	8056d6e <_Bfree>
 8055dfa:	4639      	mov	r1, r7
 8055dfc:	4620      	mov	r0, r4
 8055dfe:	f000 ffb6 	bl	8056d6e <_Bfree>
 8055e02:	e6a5      	b.n	8055b50 <_dtoa_r+0x6a8>
 8055e04:	2600      	movs	r6, #0
 8055e06:	4637      	mov	r7, r6
 8055e08:	e7e1      	b.n	8055dce <_dtoa_r+0x926>
 8055e0a:	9e0c      	ldr	r6, [sp, #48]	; 0x30
 8055e0c:	f8dd a01c 	ldr.w	sl, [sp, #28]
 8055e10:	4637      	mov	r7, r6
 8055e12:	e59a      	b.n	805594a <_dtoa_r+0x4a2>
 8055e14:	9b08      	ldr	r3, [sp, #32]
 8055e16:	f8dd 9004 	ldr.w	r9, [sp, #4]
 8055e1a:	2b00      	cmp	r3, #0
 8055e1c:	f000 80fc 	beq.w	8056018 <_dtoa_r+0xb70>
 8055e20:	2d00      	cmp	r5, #0
 8055e22:	dd05      	ble.n	8055e30 <_dtoa_r+0x988>
 8055e24:	4639      	mov	r1, r7
 8055e26:	462a      	mov	r2, r5
 8055e28:	4620      	mov	r0, r4
 8055e2a:	f001 f989 	bl	8057140 <__lshift>
 8055e2e:	4607      	mov	r7, r0
 8055e30:	9b06      	ldr	r3, [sp, #24]
 8055e32:	2b00      	cmp	r3, #0
 8055e34:	d05b      	beq.n	8055eee <_dtoa_r+0xa46>
 8055e36:	6879      	ldr	r1, [r7, #4]
 8055e38:	4620      	mov	r0, r4
 8055e3a:	f000 ff73 	bl	8056d24 <_Balloc>
 8055e3e:	4605      	mov	r5, r0
 8055e40:	b920      	cbnz	r0, 8055e4c <_dtoa_r+0x9a4>
 8055e42:	4b80      	ldr	r3, [pc, #512]	; (8056044 <_dtoa_r+0xb9c>)
 8055e44:	4602      	mov	r2, r0
 8055e46:	f240 21ea 	movw	r1, #746	; 0x2ea
 8055e4a:	e45b      	b.n	8055704 <_dtoa_r+0x25c>
 8055e4c:	693a      	ldr	r2, [r7, #16]
 8055e4e:	3202      	adds	r2, #2
 8055e50:	0092      	lsls	r2, r2, #2
 8055e52:	f107 010c 	add.w	r1, r7, #12
 8055e56:	300c      	adds	r0, #12
 8055e58:	f7fb fdd4 	bl	8051a04 <memcpy>
 8055e5c:	2201      	movs	r2, #1
 8055e5e:	4629      	mov	r1, r5
 8055e60:	4620      	mov	r0, r4
 8055e62:	f001 f96d 	bl	8057140 <__lshift>
 8055e66:	9b00      	ldr	r3, [sp, #0]
 8055e68:	3301      	adds	r3, #1
 8055e6a:	9301      	str	r3, [sp, #4]
 8055e6c:	9b00      	ldr	r3, [sp, #0]
 8055e6e:	444b      	add	r3, r9
 8055e70:	9307      	str	r3, [sp, #28]
 8055e72:	9b02      	ldr	r3, [sp, #8]
 8055e74:	f003 0301 	and.w	r3, r3, #1
 8055e78:	46b8      	mov	r8, r7
 8055e7a:	9306      	str	r3, [sp, #24]
 8055e7c:	4607      	mov	r7, r0
 8055e7e:	9b01      	ldr	r3, [sp, #4]
 8055e80:	4631      	mov	r1, r6
 8055e82:	3b01      	subs	r3, #1
 8055e84:	4658      	mov	r0, fp
 8055e86:	9302      	str	r3, [sp, #8]
 8055e88:	f7ff fa80 	bl	805538c <quorem>
 8055e8c:	4603      	mov	r3, r0
 8055e8e:	3330      	adds	r3, #48	; 0x30
 8055e90:	9004      	str	r0, [sp, #16]
 8055e92:	4641      	mov	r1, r8
 8055e94:	4658      	mov	r0, fp
 8055e96:	9308      	str	r3, [sp, #32]
 8055e98:	f001 f9be 	bl	8057218 <__mcmp>
 8055e9c:	463a      	mov	r2, r7
 8055e9e:	4681      	mov	r9, r0
 8055ea0:	4631      	mov	r1, r6
 8055ea2:	4620      	mov	r0, r4
 8055ea4:	f001 f9d4 	bl	8057250 <__mdiff>
 8055ea8:	68c2      	ldr	r2, [r0, #12]
 8055eaa:	9b08      	ldr	r3, [sp, #32]
 8055eac:	4605      	mov	r5, r0
 8055eae:	bb02      	cbnz	r2, 8055ef2 <_dtoa_r+0xa4a>
 8055eb0:	4601      	mov	r1, r0
 8055eb2:	4658      	mov	r0, fp
 8055eb4:	f001 f9b0 	bl	8057218 <__mcmp>
 8055eb8:	9b08      	ldr	r3, [sp, #32]
 8055eba:	4602      	mov	r2, r0
 8055ebc:	4629      	mov	r1, r5
 8055ebe:	4620      	mov	r0, r4
 8055ec0:	e9cd 3208 	strd	r3, r2, [sp, #32]
 8055ec4:	f000 ff53 	bl	8056d6e <_Bfree>
 8055ec8:	9b05      	ldr	r3, [sp, #20]
 8055eca:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8055ecc:	9d01      	ldr	r5, [sp, #4]
 8055ece:	ea43 0102 	orr.w	r1, r3, r2
 8055ed2:	9b06      	ldr	r3, [sp, #24]
 8055ed4:	430b      	orrs	r3, r1
 8055ed6:	9b08      	ldr	r3, [sp, #32]
 8055ed8:	d10d      	bne.n	8055ef6 <_dtoa_r+0xa4e>
 8055eda:	2b39      	cmp	r3, #57	; 0x39
 8055edc:	d029      	beq.n	8055f32 <_dtoa_r+0xa8a>
 8055ede:	f1b9 0f00 	cmp.w	r9, #0
 8055ee2:	dd01      	ble.n	8055ee8 <_dtoa_r+0xa40>
 8055ee4:	9b04      	ldr	r3, [sp, #16]
 8055ee6:	3331      	adds	r3, #49	; 0x31
 8055ee8:	9a02      	ldr	r2, [sp, #8]
 8055eea:	7013      	strb	r3, [r2, #0]
 8055eec:	e775      	b.n	8055dda <_dtoa_r+0x932>
 8055eee:	4638      	mov	r0, r7
 8055ef0:	e7b9      	b.n	8055e66 <_dtoa_r+0x9be>
 8055ef2:	2201      	movs	r2, #1
 8055ef4:	e7e2      	b.n	8055ebc <_dtoa_r+0xa14>
 8055ef6:	f1b9 0f00 	cmp.w	r9, #0
 8055efa:	db06      	blt.n	8055f0a <_dtoa_r+0xa62>
 8055efc:	9905      	ldr	r1, [sp, #20]
 8055efe:	ea41 0909 	orr.w	r9, r1, r9
 8055f02:	9906      	ldr	r1, [sp, #24]
 8055f04:	ea59 0101 	orrs.w	r1, r9, r1
 8055f08:	d120      	bne.n	8055f4c <_dtoa_r+0xaa4>
 8055f0a:	2a00      	cmp	r2, #0
 8055f0c:	ddec      	ble.n	8055ee8 <_dtoa_r+0xa40>
 8055f0e:	4659      	mov	r1, fp
 8055f10:	2201      	movs	r2, #1
 8055f12:	4620      	mov	r0, r4
 8055f14:	9301      	str	r3, [sp, #4]
 8055f16:	f001 f913 	bl	8057140 <__lshift>
 8055f1a:	4631      	mov	r1, r6
 8055f1c:	4683      	mov	fp, r0
 8055f1e:	f001 f97b 	bl	8057218 <__mcmp>
 8055f22:	2800      	cmp	r0, #0
 8055f24:	9b01      	ldr	r3, [sp, #4]
 8055f26:	dc02      	bgt.n	8055f2e <_dtoa_r+0xa86>
 8055f28:	d1de      	bne.n	8055ee8 <_dtoa_r+0xa40>
 8055f2a:	07da      	lsls	r2, r3, #31
 8055f2c:	d5dc      	bpl.n	8055ee8 <_dtoa_r+0xa40>
 8055f2e:	2b39      	cmp	r3, #57	; 0x39
 8055f30:	d1d8      	bne.n	8055ee4 <_dtoa_r+0xa3c>
 8055f32:	9a02      	ldr	r2, [sp, #8]
 8055f34:	2339      	movs	r3, #57	; 0x39
 8055f36:	7013      	strb	r3, [r2, #0]
 8055f38:	462b      	mov	r3, r5
 8055f3a:	461d      	mov	r5, r3
 8055f3c:	3b01      	subs	r3, #1
 8055f3e:	f815 2c01 	ldrb.w	r2, [r5, #-1]
 8055f42:	2a39      	cmp	r2, #57	; 0x39
 8055f44:	d050      	beq.n	8055fe8 <_dtoa_r+0xb40>
 8055f46:	3201      	adds	r2, #1
 8055f48:	701a      	strb	r2, [r3, #0]
 8055f4a:	e746      	b.n	8055dda <_dtoa_r+0x932>
 8055f4c:	2a00      	cmp	r2, #0
 8055f4e:	dd03      	ble.n	8055f58 <_dtoa_r+0xab0>
 8055f50:	2b39      	cmp	r3, #57	; 0x39
 8055f52:	d0ee      	beq.n	8055f32 <_dtoa_r+0xa8a>
 8055f54:	3301      	adds	r3, #1
 8055f56:	e7c7      	b.n	8055ee8 <_dtoa_r+0xa40>
 8055f58:	9a01      	ldr	r2, [sp, #4]
 8055f5a:	9907      	ldr	r1, [sp, #28]
 8055f5c:	f802 3c01 	strb.w	r3, [r2, #-1]
 8055f60:	428a      	cmp	r2, r1
 8055f62:	d02a      	beq.n	8055fba <_dtoa_r+0xb12>
 8055f64:	4659      	mov	r1, fp
 8055f66:	2300      	movs	r3, #0
 8055f68:	220a      	movs	r2, #10
 8055f6a:	4620      	mov	r0, r4
 8055f6c:	f000 ff08 	bl	8056d80 <__multadd>
 8055f70:	45b8      	cmp	r8, r7
 8055f72:	4683      	mov	fp, r0
 8055f74:	f04f 0300 	mov.w	r3, #0
 8055f78:	f04f 020a 	mov.w	r2, #10
 8055f7c:	4641      	mov	r1, r8
 8055f7e:	4620      	mov	r0, r4
 8055f80:	d107      	bne.n	8055f92 <_dtoa_r+0xaea>
 8055f82:	f000 fefd 	bl	8056d80 <__multadd>
 8055f86:	4680      	mov	r8, r0
 8055f88:	4607      	mov	r7, r0
 8055f8a:	9b01      	ldr	r3, [sp, #4]
 8055f8c:	3301      	adds	r3, #1
 8055f8e:	9301      	str	r3, [sp, #4]
 8055f90:	e775      	b.n	8055e7e <_dtoa_r+0x9d6>
 8055f92:	f000 fef5 	bl	8056d80 <__multadd>
 8055f96:	4639      	mov	r1, r7
 8055f98:	4680      	mov	r8, r0
 8055f9a:	2300      	movs	r3, #0
 8055f9c:	220a      	movs	r2, #10
 8055f9e:	4620      	mov	r0, r4
 8055fa0:	f000 feee 	bl	8056d80 <__multadd>
 8055fa4:	4607      	mov	r7, r0
 8055fa6:	e7f0      	b.n	8055f8a <_dtoa_r+0xae2>
 8055fa8:	f1b9 0f00 	cmp.w	r9, #0
 8055fac:	9a00      	ldr	r2, [sp, #0]
 8055fae:	bfcc      	ite	gt
 8055fb0:	464d      	movgt	r5, r9
 8055fb2:	2501      	movle	r5, #1
 8055fb4:	4415      	add	r5, r2
 8055fb6:	f04f 0800 	mov.w	r8, #0
 8055fba:	4659      	mov	r1, fp
 8055fbc:	2201      	movs	r2, #1
 8055fbe:	4620      	mov	r0, r4
 8055fc0:	9301      	str	r3, [sp, #4]
 8055fc2:	f001 f8bd 	bl	8057140 <__lshift>
 8055fc6:	4631      	mov	r1, r6
 8055fc8:	4683      	mov	fp, r0
 8055fca:	f001 f925 	bl	8057218 <__mcmp>
 8055fce:	2800      	cmp	r0, #0
 8055fd0:	dcb2      	bgt.n	8055f38 <_dtoa_r+0xa90>
 8055fd2:	d102      	bne.n	8055fda <_dtoa_r+0xb32>
 8055fd4:	9b01      	ldr	r3, [sp, #4]
 8055fd6:	07db      	lsls	r3, r3, #31
 8055fd8:	d4ae      	bmi.n	8055f38 <_dtoa_r+0xa90>
 8055fda:	462b      	mov	r3, r5
 8055fdc:	461d      	mov	r5, r3
 8055fde:	f813 2d01 	ldrb.w	r2, [r3, #-1]!
 8055fe2:	2a30      	cmp	r2, #48	; 0x30
 8055fe4:	d0fa      	beq.n	8055fdc <_dtoa_r+0xb34>
 8055fe6:	e6f8      	b.n	8055dda <_dtoa_r+0x932>
 8055fe8:	9a00      	ldr	r2, [sp, #0]
 8055fea:	429a      	cmp	r2, r3
 8055fec:	d1a5      	bne.n	8055f3a <_dtoa_r+0xa92>
 8055fee:	f10a 0a01 	add.w	sl, sl, #1
 8055ff2:	2331      	movs	r3, #49	; 0x31
 8055ff4:	e779      	b.n	8055eea <_dtoa_r+0xa42>
 8055ff6:	4b14      	ldr	r3, [pc, #80]	; (8056048 <_dtoa_r+0xba0>)
 8055ff8:	f7ff bab1 	b.w	805555e <_dtoa_r+0xb6>
 8055ffc:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8055ffe:	2b00      	cmp	r3, #0
 8056000:	f47f aa93 	bne.w	805552a <_dtoa_r+0x82>
 8056004:	4b11      	ldr	r3, [pc, #68]	; (805604c <_dtoa_r+0xba4>)
 8056006:	f7ff baaa 	b.w	805555e <_dtoa_r+0xb6>
 805600a:	f1b9 0f00 	cmp.w	r9, #0
 805600e:	dc03      	bgt.n	8056018 <_dtoa_r+0xb70>
 8056010:	9b05      	ldr	r3, [sp, #20]
 8056012:	2b02      	cmp	r3, #2
 8056014:	f73f aeca 	bgt.w	8055dac <_dtoa_r+0x904>
 8056018:	9d00      	ldr	r5, [sp, #0]
 805601a:	4631      	mov	r1, r6
 805601c:	4658      	mov	r0, fp
 805601e:	f7ff f9b5 	bl	805538c <quorem>
 8056022:	f100 0330 	add.w	r3, r0, #48	; 0x30
 8056026:	f805 3b01 	strb.w	r3, [r5], #1
 805602a:	9a00      	ldr	r2, [sp, #0]
 805602c:	1aaa      	subs	r2, r5, r2
 805602e:	4591      	cmp	r9, r2
 8056030:	ddba      	ble.n	8055fa8 <_dtoa_r+0xb00>
 8056032:	4659      	mov	r1, fp
 8056034:	2300      	movs	r3, #0
 8056036:	220a      	movs	r2, #10
 8056038:	4620      	mov	r0, r4
 805603a:	f000 fea1 	bl	8056d80 <__multadd>
 805603e:	4683      	mov	fp, r0
 8056040:	e7eb      	b.n	805601a <_dtoa_r+0xb72>
 8056042:	bf00      	nop
 8056044:	0805acf7 	.word	0x0805acf7
 8056048:	0805ab82 	.word	0x0805ab82
 805604c:	0805acee 	.word	0x0805acee

08056050 <__errno>:
 8056050:	4b01      	ldr	r3, [pc, #4]	; (8056058 <__errno+0x8>)
 8056052:	6818      	ldr	r0, [r3, #0]
 8056054:	4770      	bx	lr
 8056056:	bf00      	nop
 8056058:	200036d0 	.word	0x200036d0

0805605c <__sflush_r>:
 805605c:	898b      	ldrh	r3, [r1, #12]
 805605e:	f9b1 200c 	ldrsh.w	r2, [r1, #12]
 8056062:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8056066:	4605      	mov	r5, r0
 8056068:	0718      	lsls	r0, r3, #28
 805606a:	460c      	mov	r4, r1
 805606c:	d45f      	bmi.n	805612e <__sflush_r+0xd2>
 805606e:	684b      	ldr	r3, [r1, #4]
 8056070:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 8056074:	2b00      	cmp	r3, #0
 8056076:	818a      	strh	r2, [r1, #12]
 8056078:	dc05      	bgt.n	8056086 <__sflush_r+0x2a>
 805607a:	6bcb      	ldr	r3, [r1, #60]	; 0x3c
 805607c:	2b00      	cmp	r3, #0
 805607e:	dc02      	bgt.n	8056086 <__sflush_r+0x2a>
 8056080:	2000      	movs	r0, #0
 8056082:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8056086:	6aa6      	ldr	r6, [r4, #40]	; 0x28
 8056088:	2e00      	cmp	r6, #0
 805608a:	d0f9      	beq.n	8056080 <__sflush_r+0x24>
 805608c:	2300      	movs	r3, #0
 805608e:	f412 5280 	ands.w	r2, r2, #4096	; 0x1000
 8056092:	682f      	ldr	r7, [r5, #0]
 8056094:	602b      	str	r3, [r5, #0]
 8056096:	d036      	beq.n	8056106 <__sflush_r+0xaa>
 8056098:	6d20      	ldr	r0, [r4, #80]	; 0x50
 805609a:	89a3      	ldrh	r3, [r4, #12]
 805609c:	075a      	lsls	r2, r3, #29
 805609e:	d505      	bpl.n	80560ac <__sflush_r+0x50>
 80560a0:	6863      	ldr	r3, [r4, #4]
 80560a2:	1ac0      	subs	r0, r0, r3
 80560a4:	6b23      	ldr	r3, [r4, #48]	; 0x30
 80560a6:	b10b      	cbz	r3, 80560ac <__sflush_r+0x50>
 80560a8:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 80560aa:	1ac0      	subs	r0, r0, r3
 80560ac:	2300      	movs	r3, #0
 80560ae:	4602      	mov	r2, r0
 80560b0:	6aa6      	ldr	r6, [r4, #40]	; 0x28
 80560b2:	69e1      	ldr	r1, [r4, #28]
 80560b4:	4628      	mov	r0, r5
 80560b6:	47b0      	blx	r6
 80560b8:	1c43      	adds	r3, r0, #1
 80560ba:	89a3      	ldrh	r3, [r4, #12]
 80560bc:	d106      	bne.n	80560cc <__sflush_r+0x70>
 80560be:	6829      	ldr	r1, [r5, #0]
 80560c0:	291d      	cmp	r1, #29
 80560c2:	d830      	bhi.n	8056126 <__sflush_r+0xca>
 80560c4:	4a2b      	ldr	r2, [pc, #172]	; (8056174 <__sflush_r+0x118>)
 80560c6:	40ca      	lsrs	r2, r1
 80560c8:	07d6      	lsls	r6, r2, #31
 80560ca:	d52c      	bpl.n	8056126 <__sflush_r+0xca>
 80560cc:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 80560d0:	b21b      	sxth	r3, r3
 80560d2:	2200      	movs	r2, #0
 80560d4:	6062      	str	r2, [r4, #4]
 80560d6:	04d9      	lsls	r1, r3, #19
 80560d8:	6922      	ldr	r2, [r4, #16]
 80560da:	81a3      	strh	r3, [r4, #12]
 80560dc:	6022      	str	r2, [r4, #0]
 80560de:	d504      	bpl.n	80560ea <__sflush_r+0x8e>
 80560e0:	1c42      	adds	r2, r0, #1
 80560e2:	d101      	bne.n	80560e8 <__sflush_r+0x8c>
 80560e4:	682b      	ldr	r3, [r5, #0]
 80560e6:	b903      	cbnz	r3, 80560ea <__sflush_r+0x8e>
 80560e8:	6520      	str	r0, [r4, #80]	; 0x50
 80560ea:	6b21      	ldr	r1, [r4, #48]	; 0x30
 80560ec:	602f      	str	r7, [r5, #0]
 80560ee:	2900      	cmp	r1, #0
 80560f0:	d0c6      	beq.n	8056080 <__sflush_r+0x24>
 80560f2:	f104 0340 	add.w	r3, r4, #64	; 0x40
 80560f6:	4299      	cmp	r1, r3
 80560f8:	d002      	beq.n	8056100 <__sflush_r+0xa4>
 80560fa:	4628      	mov	r0, r5
 80560fc:	f000 f938 	bl	8056370 <_free_r>
 8056100:	2000      	movs	r0, #0
 8056102:	6320      	str	r0, [r4, #48]	; 0x30
 8056104:	e7bd      	b.n	8056082 <__sflush_r+0x26>
 8056106:	69e1      	ldr	r1, [r4, #28]
 8056108:	2301      	movs	r3, #1
 805610a:	4628      	mov	r0, r5
 805610c:	47b0      	blx	r6
 805610e:	1c41      	adds	r1, r0, #1
 8056110:	d1c3      	bne.n	805609a <__sflush_r+0x3e>
 8056112:	682b      	ldr	r3, [r5, #0]
 8056114:	2b00      	cmp	r3, #0
 8056116:	d0c0      	beq.n	805609a <__sflush_r+0x3e>
 8056118:	2b1d      	cmp	r3, #29
 805611a:	d001      	beq.n	8056120 <__sflush_r+0xc4>
 805611c:	2b16      	cmp	r3, #22
 805611e:	d101      	bne.n	8056124 <__sflush_r+0xc8>
 8056120:	602f      	str	r7, [r5, #0]
 8056122:	e7ad      	b.n	8056080 <__sflush_r+0x24>
 8056124:	89a3      	ldrh	r3, [r4, #12]
 8056126:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 805612a:	81a3      	strh	r3, [r4, #12]
 805612c:	e7a9      	b.n	8056082 <__sflush_r+0x26>
 805612e:	690f      	ldr	r7, [r1, #16]
 8056130:	2f00      	cmp	r7, #0
 8056132:	d0a5      	beq.n	8056080 <__sflush_r+0x24>
 8056134:	079b      	lsls	r3, r3, #30
 8056136:	680e      	ldr	r6, [r1, #0]
 8056138:	bf08      	it	eq
 805613a:	694b      	ldreq	r3, [r1, #20]
 805613c:	600f      	str	r7, [r1, #0]
 805613e:	bf18      	it	ne
 8056140:	2300      	movne	r3, #0
 8056142:	eba6 0807 	sub.w	r8, r6, r7
 8056146:	608b      	str	r3, [r1, #8]
 8056148:	f1b8 0f00 	cmp.w	r8, #0
 805614c:	dd98      	ble.n	8056080 <__sflush_r+0x24>
 805614e:	69e1      	ldr	r1, [r4, #28]
 8056150:	6a66      	ldr	r6, [r4, #36]	; 0x24
 8056152:	4643      	mov	r3, r8
 8056154:	463a      	mov	r2, r7
 8056156:	4628      	mov	r0, r5
 8056158:	47b0      	blx	r6
 805615a:	2800      	cmp	r0, #0
 805615c:	dc06      	bgt.n	805616c <__sflush_r+0x110>
 805615e:	89a3      	ldrh	r3, [r4, #12]
 8056160:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8056164:	81a3      	strh	r3, [r4, #12]
 8056166:	f04f 30ff 	mov.w	r0, #4294967295
 805616a:	e78a      	b.n	8056082 <__sflush_r+0x26>
 805616c:	4407      	add	r7, r0
 805616e:	eba8 0800 	sub.w	r8, r8, r0
 8056172:	e7e9      	b.n	8056148 <__sflush_r+0xec>
 8056174:	20400001 	.word	0x20400001

08056178 <_fflush_r>:
 8056178:	b538      	push	{r3, r4, r5, lr}
 805617a:	460c      	mov	r4, r1
 805617c:	4605      	mov	r5, r0
 805617e:	b118      	cbz	r0, 8056188 <_fflush_r+0x10>
 8056180:	6b83      	ldr	r3, [r0, #56]	; 0x38
 8056182:	b90b      	cbnz	r3, 8056188 <_fflush_r+0x10>
 8056184:	f000 f864 	bl	8056250 <__sinit>
 8056188:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 805618c:	b1bb      	cbz	r3, 80561be <_fflush_r+0x46>
 805618e:	6e62      	ldr	r2, [r4, #100]	; 0x64
 8056190:	07d0      	lsls	r0, r2, #31
 8056192:	d404      	bmi.n	805619e <_fflush_r+0x26>
 8056194:	0599      	lsls	r1, r3, #22
 8056196:	d402      	bmi.n	805619e <_fflush_r+0x26>
 8056198:	6da0      	ldr	r0, [r4, #88]	; 0x58
 805619a:	f000 fd43 	bl	8056c24 <__retarget_lock_acquire_recursive>
 805619e:	4628      	mov	r0, r5
 80561a0:	4621      	mov	r1, r4
 80561a2:	f7ff ff5b 	bl	805605c <__sflush_r>
 80561a6:	6e63      	ldr	r3, [r4, #100]	; 0x64
 80561a8:	07da      	lsls	r2, r3, #31
 80561aa:	4605      	mov	r5, r0
 80561ac:	d405      	bmi.n	80561ba <_fflush_r+0x42>
 80561ae:	89a3      	ldrh	r3, [r4, #12]
 80561b0:	059b      	lsls	r3, r3, #22
 80561b2:	d402      	bmi.n	80561ba <_fflush_r+0x42>
 80561b4:	6da0      	ldr	r0, [r4, #88]	; 0x58
 80561b6:	f000 fd36 	bl	8056c26 <__retarget_lock_release_recursive>
 80561ba:	4628      	mov	r0, r5
 80561bc:	bd38      	pop	{r3, r4, r5, pc}
 80561be:	461d      	mov	r5, r3
 80561c0:	e7fb      	b.n	80561ba <_fflush_r+0x42>
	...

080561c4 <std>:
 80561c4:	2300      	movs	r3, #0
 80561c6:	b510      	push	{r4, lr}
 80561c8:	4604      	mov	r4, r0
 80561ca:	e9c0 3300 	strd	r3, r3, [r0]
 80561ce:	e9c0 3304 	strd	r3, r3, [r0, #16]
 80561d2:	6083      	str	r3, [r0, #8]
 80561d4:	8181      	strh	r1, [r0, #12]
 80561d6:	6643      	str	r3, [r0, #100]	; 0x64
 80561d8:	81c2      	strh	r2, [r0, #14]
 80561da:	6183      	str	r3, [r0, #24]
 80561dc:	4619      	mov	r1, r3
 80561de:	2208      	movs	r2, #8
 80561e0:	305c      	adds	r0, #92	; 0x5c
 80561e2:	f7fb fc1d 	bl	8051a20 <memset>
 80561e6:	4b07      	ldr	r3, [pc, #28]	; (8056204 <std+0x40>)
 80561e8:	6223      	str	r3, [r4, #32]
 80561ea:	4b07      	ldr	r3, [pc, #28]	; (8056208 <std+0x44>)
 80561ec:	6263      	str	r3, [r4, #36]	; 0x24
 80561ee:	4b07      	ldr	r3, [pc, #28]	; (805620c <std+0x48>)
 80561f0:	62a3      	str	r3, [r4, #40]	; 0x28
 80561f2:	4b07      	ldr	r3, [pc, #28]	; (8056210 <std+0x4c>)
 80561f4:	61e4      	str	r4, [r4, #28]
 80561f6:	62e3      	str	r3, [r4, #44]	; 0x2c
 80561f8:	f104 0058 	add.w	r0, r4, #88	; 0x58
 80561fc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8056200:	f000 bd0e 	b.w	8056c20 <__retarget_lock_init_recursive>
 8056204:	08057681 	.word	0x08057681
 8056208:	080576a3 	.word	0x080576a3
 805620c:	080576db 	.word	0x080576db
 8056210:	080576ff 	.word	0x080576ff

08056214 <_cleanup_r>:
 8056214:	4901      	ldr	r1, [pc, #4]	; (805621c <_cleanup_r+0x8>)
 8056216:	f000 b96b 	b.w	80564f0 <_fwalk_reent>
 805621a:	bf00      	nop
 805621c:	08058391 	.word	0x08058391

08056220 <__sfp_lock_acquire>:
 8056220:	4801      	ldr	r0, [pc, #4]	; (8056228 <__sfp_lock_acquire+0x8>)
 8056222:	f000 bcff 	b.w	8056c24 <__retarget_lock_acquire_recursive>
 8056226:	bf00      	nop
 8056228:	200100b4 	.word	0x200100b4

0805622c <__sfp_lock_release>:
 805622c:	4801      	ldr	r0, [pc, #4]	; (8056234 <__sfp_lock_release+0x8>)
 805622e:	f000 bcfa 	b.w	8056c26 <__retarget_lock_release_recursive>
 8056232:	bf00      	nop
 8056234:	200100b4 	.word	0x200100b4

08056238 <__sinit_lock_acquire>:
 8056238:	4801      	ldr	r0, [pc, #4]	; (8056240 <__sinit_lock_acquire+0x8>)
 805623a:	f000 bcf3 	b.w	8056c24 <__retarget_lock_acquire_recursive>
 805623e:	bf00      	nop
 8056240:	200100af 	.word	0x200100af

08056244 <__sinit_lock_release>:
 8056244:	4801      	ldr	r0, [pc, #4]	; (805624c <__sinit_lock_release+0x8>)
 8056246:	f000 bcee 	b.w	8056c26 <__retarget_lock_release_recursive>
 805624a:	bf00      	nop
 805624c:	200100af 	.word	0x200100af

08056250 <__sinit>:
 8056250:	b510      	push	{r4, lr}
 8056252:	4604      	mov	r4, r0
 8056254:	f7ff fff0 	bl	8056238 <__sinit_lock_acquire>
 8056258:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 805625a:	b11a      	cbz	r2, 8056264 <__sinit+0x14>
 805625c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8056260:	f7ff bff0 	b.w	8056244 <__sinit_lock_release>
 8056264:	4b0d      	ldr	r3, [pc, #52]	; (805629c <__sinit+0x4c>)
 8056266:	63e3      	str	r3, [r4, #60]	; 0x3c
 8056268:	2303      	movs	r3, #3
 805626a:	f8c4 32e4 	str.w	r3, [r4, #740]	; 0x2e4
 805626e:	f504 733b 	add.w	r3, r4, #748	; 0x2ec
 8056272:	f8c4 32e8 	str.w	r3, [r4, #744]	; 0x2e8
 8056276:	6860      	ldr	r0, [r4, #4]
 8056278:	f8c4 22e0 	str.w	r2, [r4, #736]	; 0x2e0
 805627c:	2104      	movs	r1, #4
 805627e:	f7ff ffa1 	bl	80561c4 <std>
 8056282:	68a0      	ldr	r0, [r4, #8]
 8056284:	2201      	movs	r2, #1
 8056286:	2109      	movs	r1, #9
 8056288:	f7ff ff9c 	bl	80561c4 <std>
 805628c:	68e0      	ldr	r0, [r4, #12]
 805628e:	2202      	movs	r2, #2
 8056290:	2112      	movs	r1, #18
 8056292:	f7ff ff97 	bl	80561c4 <std>
 8056296:	2301      	movs	r3, #1
 8056298:	63a3      	str	r3, [r4, #56]	; 0x38
 805629a:	e7df      	b.n	805625c <__sinit+0xc>
 805629c:	08056215 	.word	0x08056215

080562a0 <__libc_fini_array>:
 80562a0:	b538      	push	{r3, r4, r5, lr}
 80562a2:	4d07      	ldr	r5, [pc, #28]	; (80562c0 <__libc_fini_array+0x20>)
 80562a4:	4c07      	ldr	r4, [pc, #28]	; (80562c4 <__libc_fini_array+0x24>)
 80562a6:	1b64      	subs	r4, r4, r5
 80562a8:	10a4      	asrs	r4, r4, #2
 80562aa:	b91c      	cbnz	r4, 80562b4 <__libc_fini_array+0x14>
 80562ac:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 80562b0:	f002 bd46 	b.w	8058d40 <_fini>
 80562b4:	3c01      	subs	r4, #1
 80562b6:	f855 3024 	ldr.w	r3, [r5, r4, lsl #2]
 80562ba:	4798      	blx	r3
 80562bc:	e7f5      	b.n	80562aa <__libc_fini_array+0xa>
 80562be:	bf00      	nop
 80562c0:	0805afb0 	.word	0x0805afb0
 80562c4:	0805afb4 	.word	0x0805afb4

080562c8 <_malloc_trim_r>:
 80562c8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80562cc:	4606      	mov	r6, r0
 80562ce:	2008      	movs	r0, #8
 80562d0:	460c      	mov	r4, r1
 80562d2:	f7fd fd2d 	bl	8053d30 <sysconf>
 80562d6:	4f23      	ldr	r7, [pc, #140]	; (8056364 <_malloc_trim_r+0x9c>)
 80562d8:	4680      	mov	r8, r0
 80562da:	4630      	mov	r0, r6
 80562dc:	f7fb fba8 	bl	8051a30 <__malloc_lock>
 80562e0:	68bb      	ldr	r3, [r7, #8]
 80562e2:	685d      	ldr	r5, [r3, #4]
 80562e4:	f025 0503 	bic.w	r5, r5, #3
 80562e8:	1b2c      	subs	r4, r5, r4
 80562ea:	3c11      	subs	r4, #17
 80562ec:	4444      	add	r4, r8
 80562ee:	fbb4 f4f8 	udiv	r4, r4, r8
 80562f2:	3c01      	subs	r4, #1
 80562f4:	fb08 f404 	mul.w	r4, r8, r4
 80562f8:	45a0      	cmp	r8, r4
 80562fa:	dd05      	ble.n	8056308 <_malloc_trim_r+0x40>
 80562fc:	4630      	mov	r0, r6
 80562fe:	f7fb fb9d 	bl	8051a3c <__malloc_unlock>
 8056302:	2000      	movs	r0, #0
 8056304:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8056308:	2100      	movs	r1, #0
 805630a:	4630      	mov	r0, r6
 805630c:	f7fb fbae 	bl	8051a6c <_sbrk_r>
 8056310:	68bb      	ldr	r3, [r7, #8]
 8056312:	442b      	add	r3, r5
 8056314:	4298      	cmp	r0, r3
 8056316:	d1f1      	bne.n	80562fc <_malloc_trim_r+0x34>
 8056318:	4261      	negs	r1, r4
 805631a:	4630      	mov	r0, r6
 805631c:	f7fb fba6 	bl	8051a6c <_sbrk_r>
 8056320:	3001      	adds	r0, #1
 8056322:	d110      	bne.n	8056346 <_malloc_trim_r+0x7e>
 8056324:	2100      	movs	r1, #0
 8056326:	4630      	mov	r0, r6
 8056328:	f7fb fba0 	bl	8051a6c <_sbrk_r>
 805632c:	68ba      	ldr	r2, [r7, #8]
 805632e:	1a83      	subs	r3, r0, r2
 8056330:	2b0f      	cmp	r3, #15
 8056332:	dde3      	ble.n	80562fc <_malloc_trim_r+0x34>
 8056334:	490c      	ldr	r1, [pc, #48]	; (8056368 <_malloc_trim_r+0xa0>)
 8056336:	6809      	ldr	r1, [r1, #0]
 8056338:	1a40      	subs	r0, r0, r1
 805633a:	490c      	ldr	r1, [pc, #48]	; (805636c <_malloc_trim_r+0xa4>)
 805633c:	f043 0301 	orr.w	r3, r3, #1
 8056340:	6008      	str	r0, [r1, #0]
 8056342:	6053      	str	r3, [r2, #4]
 8056344:	e7da      	b.n	80562fc <_malloc_trim_r+0x34>
 8056346:	68bb      	ldr	r3, [r7, #8]
 8056348:	4a08      	ldr	r2, [pc, #32]	; (805636c <_malloc_trim_r+0xa4>)
 805634a:	1b2d      	subs	r5, r5, r4
 805634c:	f045 0501 	orr.w	r5, r5, #1
 8056350:	605d      	str	r5, [r3, #4]
 8056352:	6813      	ldr	r3, [r2, #0]
 8056354:	4630      	mov	r0, r6
 8056356:	1b1c      	subs	r4, r3, r4
 8056358:	6014      	str	r4, [r2, #0]
 805635a:	f7fb fb6f 	bl	8051a3c <__malloc_unlock>
 805635e:	2001      	movs	r0, #1
 8056360:	e7d0      	b.n	8056304 <_malloc_trim_r+0x3c>
 8056362:	bf00      	nop
 8056364:	20003b00 	.word	0x20003b00
 8056368:	20003f08 	.word	0x20003f08
 805636c:	20005198 	.word	0x20005198

08056370 <_free_r>:
 8056370:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8056372:	4605      	mov	r5, r0
 8056374:	460f      	mov	r7, r1
 8056376:	2900      	cmp	r1, #0
 8056378:	f000 80b1 	beq.w	80564de <_free_r+0x16e>
 805637c:	f7fb fb58 	bl	8051a30 <__malloc_lock>
 8056380:	f857 2c04 	ldr.w	r2, [r7, #-4]
 8056384:	4856      	ldr	r0, [pc, #344]	; (80564e0 <_free_r+0x170>)
 8056386:	f022 0401 	bic.w	r4, r2, #1
 805638a:	f1a7 0308 	sub.w	r3, r7, #8
 805638e:	eb03 0c04 	add.w	ip, r3, r4
 8056392:	6881      	ldr	r1, [r0, #8]
 8056394:	f8dc 6004 	ldr.w	r6, [ip, #4]
 8056398:	4561      	cmp	r1, ip
 805639a:	f026 0603 	bic.w	r6, r6, #3
 805639e:	f002 0201 	and.w	r2, r2, #1
 80563a2:	d11b      	bne.n	80563dc <_free_r+0x6c>
 80563a4:	4434      	add	r4, r6
 80563a6:	b93a      	cbnz	r2, 80563b8 <_free_r+0x48>
 80563a8:	f857 2c08 	ldr.w	r2, [r7, #-8]
 80563ac:	1a9b      	subs	r3, r3, r2
 80563ae:	4414      	add	r4, r2
 80563b0:	e9d3 1202 	ldrd	r1, r2, [r3, #8]
 80563b4:	60ca      	str	r2, [r1, #12]
 80563b6:	6091      	str	r1, [r2, #8]
 80563b8:	f044 0201 	orr.w	r2, r4, #1
 80563bc:	605a      	str	r2, [r3, #4]
 80563be:	6083      	str	r3, [r0, #8]
 80563c0:	4b48      	ldr	r3, [pc, #288]	; (80564e4 <_free_r+0x174>)
 80563c2:	681b      	ldr	r3, [r3, #0]
 80563c4:	42a3      	cmp	r3, r4
 80563c6:	d804      	bhi.n	80563d2 <_free_r+0x62>
 80563c8:	4b47      	ldr	r3, [pc, #284]	; (80564e8 <_free_r+0x178>)
 80563ca:	4628      	mov	r0, r5
 80563cc:	6819      	ldr	r1, [r3, #0]
 80563ce:	f7ff ff7b 	bl	80562c8 <_malloc_trim_r>
 80563d2:	4628      	mov	r0, r5
 80563d4:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
 80563d8:	f7fb bb30 	b.w	8051a3c <__malloc_unlock>
 80563dc:	f8cc 6004 	str.w	r6, [ip, #4]
 80563e0:	2a00      	cmp	r2, #0
 80563e2:	d138      	bne.n	8056456 <_free_r+0xe6>
 80563e4:	f857 1c08 	ldr.w	r1, [r7, #-8]
 80563e8:	1a5b      	subs	r3, r3, r1
 80563ea:	440c      	add	r4, r1
 80563ec:	6899      	ldr	r1, [r3, #8]
 80563ee:	f100 0708 	add.w	r7, r0, #8
 80563f2:	42b9      	cmp	r1, r7
 80563f4:	d031      	beq.n	805645a <_free_r+0xea>
 80563f6:	68df      	ldr	r7, [r3, #12]
 80563f8:	60cf      	str	r7, [r1, #12]
 80563fa:	60b9      	str	r1, [r7, #8]
 80563fc:	eb0c 0106 	add.w	r1, ip, r6
 8056400:	6849      	ldr	r1, [r1, #4]
 8056402:	07c9      	lsls	r1, r1, #31
 8056404:	d40b      	bmi.n	805641e <_free_r+0xae>
 8056406:	f8dc 1008 	ldr.w	r1, [ip, #8]
 805640a:	4434      	add	r4, r6
 805640c:	bb3a      	cbnz	r2, 805645e <_free_r+0xee>
 805640e:	4e37      	ldr	r6, [pc, #220]	; (80564ec <_free_r+0x17c>)
 8056410:	42b1      	cmp	r1, r6
 8056412:	d124      	bne.n	805645e <_free_r+0xee>
 8056414:	e9c0 3304 	strd	r3, r3, [r0, #16]
 8056418:	e9c3 1102 	strd	r1, r1, [r3, #8]
 805641c:	2201      	movs	r2, #1
 805641e:	f044 0101 	orr.w	r1, r4, #1
 8056422:	6059      	str	r1, [r3, #4]
 8056424:	511c      	str	r4, [r3, r4]
 8056426:	2a00      	cmp	r2, #0
 8056428:	d1d3      	bne.n	80563d2 <_free_r+0x62>
 805642a:	f5b4 7f00 	cmp.w	r4, #512	; 0x200
 805642e:	d21b      	bcs.n	8056468 <_free_r+0xf8>
 8056430:	0961      	lsrs	r1, r4, #5
 8056432:	08e2      	lsrs	r2, r4, #3
 8056434:	2401      	movs	r4, #1
 8056436:	408c      	lsls	r4, r1
 8056438:	6841      	ldr	r1, [r0, #4]
 805643a:	3201      	adds	r2, #1
 805643c:	430c      	orrs	r4, r1
 805643e:	6044      	str	r4, [r0, #4]
 8056440:	eb00 01c2 	add.w	r1, r0, r2, lsl #3
 8056444:	f850 4032 	ldr.w	r4, [r0, r2, lsl #3]
 8056448:	3908      	subs	r1, #8
 805644a:	e9c3 4102 	strd	r4, r1, [r3, #8]
 805644e:	f840 3032 	str.w	r3, [r0, r2, lsl #3]
 8056452:	60e3      	str	r3, [r4, #12]
 8056454:	e7bd      	b.n	80563d2 <_free_r+0x62>
 8056456:	2200      	movs	r2, #0
 8056458:	e7d0      	b.n	80563fc <_free_r+0x8c>
 805645a:	2201      	movs	r2, #1
 805645c:	e7ce      	b.n	80563fc <_free_r+0x8c>
 805645e:	f8dc 600c 	ldr.w	r6, [ip, #12]
 8056462:	60ce      	str	r6, [r1, #12]
 8056464:	60b1      	str	r1, [r6, #8]
 8056466:	e7da      	b.n	805641e <_free_r+0xae>
 8056468:	f5b4 6f20 	cmp.w	r4, #2560	; 0xa00
 805646c:	ea4f 2254 	mov.w	r2, r4, lsr #9
 8056470:	d214      	bcs.n	805649c <_free_r+0x12c>
 8056472:	09a2      	lsrs	r2, r4, #6
 8056474:	3238      	adds	r2, #56	; 0x38
 8056476:	1c51      	adds	r1, r2, #1
 8056478:	eb00 06c2 	add.w	r6, r0, r2, lsl #3
 805647c:	f850 1031 	ldr.w	r1, [r0, r1, lsl #3]
 8056480:	428e      	cmp	r6, r1
 8056482:	d125      	bne.n	80564d0 <_free_r+0x160>
 8056484:	2401      	movs	r4, #1
 8056486:	1092      	asrs	r2, r2, #2
 8056488:	fa04 f202 	lsl.w	r2, r4, r2
 805648c:	6844      	ldr	r4, [r0, #4]
 805648e:	4322      	orrs	r2, r4
 8056490:	6042      	str	r2, [r0, #4]
 8056492:	e9c3 1602 	strd	r1, r6, [r3, #8]
 8056496:	60b3      	str	r3, [r6, #8]
 8056498:	60cb      	str	r3, [r1, #12]
 805649a:	e79a      	b.n	80563d2 <_free_r+0x62>
 805649c:	2a14      	cmp	r2, #20
 805649e:	d801      	bhi.n	80564a4 <_free_r+0x134>
 80564a0:	325b      	adds	r2, #91	; 0x5b
 80564a2:	e7e8      	b.n	8056476 <_free_r+0x106>
 80564a4:	2a54      	cmp	r2, #84	; 0x54
 80564a6:	d802      	bhi.n	80564ae <_free_r+0x13e>
 80564a8:	0b22      	lsrs	r2, r4, #12
 80564aa:	326e      	adds	r2, #110	; 0x6e
 80564ac:	e7e3      	b.n	8056476 <_free_r+0x106>
 80564ae:	f5b2 7faa 	cmp.w	r2, #340	; 0x154
 80564b2:	d802      	bhi.n	80564ba <_free_r+0x14a>
 80564b4:	0be2      	lsrs	r2, r4, #15
 80564b6:	3277      	adds	r2, #119	; 0x77
 80564b8:	e7dd      	b.n	8056476 <_free_r+0x106>
 80564ba:	f240 5154 	movw	r1, #1364	; 0x554
 80564be:	428a      	cmp	r2, r1
 80564c0:	bf9a      	itte	ls
 80564c2:	0ca2      	lsrls	r2, r4, #18
 80564c4:	327c      	addls	r2, #124	; 0x7c
 80564c6:	227e      	movhi	r2, #126	; 0x7e
 80564c8:	e7d5      	b.n	8056476 <_free_r+0x106>
 80564ca:	6889      	ldr	r1, [r1, #8]
 80564cc:	428e      	cmp	r6, r1
 80564ce:	d004      	beq.n	80564da <_free_r+0x16a>
 80564d0:	684a      	ldr	r2, [r1, #4]
 80564d2:	f022 0203 	bic.w	r2, r2, #3
 80564d6:	42a2      	cmp	r2, r4
 80564d8:	d8f7      	bhi.n	80564ca <_free_r+0x15a>
 80564da:	68ce      	ldr	r6, [r1, #12]
 80564dc:	e7d9      	b.n	8056492 <_free_r+0x122>
 80564de:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80564e0:	20003b00 	.word	0x20003b00
 80564e4:	20003f0c 	.word	0x20003f0c
 80564e8:	200051c8 	.word	0x200051c8
 80564ec:	20003b08 	.word	0x20003b08

080564f0 <_fwalk_reent>:
 80564f0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80564f4:	4606      	mov	r6, r0
 80564f6:	4688      	mov	r8, r1
 80564f8:	f500 7438 	add.w	r4, r0, #736	; 0x2e0
 80564fc:	2700      	movs	r7, #0
 80564fe:	e9d4 9501 	ldrd	r9, r5, [r4, #4]
 8056502:	f1b9 0901 	subs.w	r9, r9, #1
 8056506:	d505      	bpl.n	8056514 <_fwalk_reent+0x24>
 8056508:	6824      	ldr	r4, [r4, #0]
 805650a:	2c00      	cmp	r4, #0
 805650c:	d1f7      	bne.n	80564fe <_fwalk_reent+0xe>
 805650e:	4638      	mov	r0, r7
 8056510:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8056514:	89ab      	ldrh	r3, [r5, #12]
 8056516:	2b01      	cmp	r3, #1
 8056518:	d907      	bls.n	805652a <_fwalk_reent+0x3a>
 805651a:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
 805651e:	3301      	adds	r3, #1
 8056520:	d003      	beq.n	805652a <_fwalk_reent+0x3a>
 8056522:	4629      	mov	r1, r5
 8056524:	4630      	mov	r0, r6
 8056526:	47c0      	blx	r8
 8056528:	4307      	orrs	r7, r0
 805652a:	3568      	adds	r5, #104	; 0x68
 805652c:	e7e9      	b.n	8056502 <_fwalk_reent+0x12>

0805652e <rshift>:
 805652e:	6903      	ldr	r3, [r0, #16]
 8056530:	ebb3 1f61 	cmp.w	r3, r1, asr #5
 8056534:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8056538:	ea4f 1261 	mov.w	r2, r1, asr #5
 805653c:	f100 0414 	add.w	r4, r0, #20
 8056540:	dd45      	ble.n	80565ce <rshift+0xa0>
 8056542:	f011 011f 	ands.w	r1, r1, #31
 8056546:	eb04 0683 	add.w	r6, r4, r3, lsl #2
 805654a:	eb04 0582 	add.w	r5, r4, r2, lsl #2
 805654e:	d10c      	bne.n	805656a <rshift+0x3c>
 8056550:	f100 0710 	add.w	r7, r0, #16
 8056554:	4629      	mov	r1, r5
 8056556:	42b1      	cmp	r1, r6
 8056558:	d334      	bcc.n	80565c4 <rshift+0x96>
 805655a:	1a9b      	subs	r3, r3, r2
 805655c:	009b      	lsls	r3, r3, #2
 805655e:	1eea      	subs	r2, r5, #3
 8056560:	4296      	cmp	r6, r2
 8056562:	bf38      	it	cc
 8056564:	2300      	movcc	r3, #0
 8056566:	4423      	add	r3, r4
 8056568:	e015      	b.n	8056596 <rshift+0x68>
 805656a:	f854 7022 	ldr.w	r7, [r4, r2, lsl #2]
 805656e:	f1c1 0820 	rsb	r8, r1, #32
 8056572:	40cf      	lsrs	r7, r1
 8056574:	f105 0e04 	add.w	lr, r5, #4
 8056578:	46a1      	mov	r9, r4
 805657a:	4576      	cmp	r6, lr
 805657c:	46f4      	mov	ip, lr
 805657e:	d815      	bhi.n	80565ac <rshift+0x7e>
 8056580:	1a9b      	subs	r3, r3, r2
 8056582:	009a      	lsls	r2, r3, #2
 8056584:	3a04      	subs	r2, #4
 8056586:	3501      	adds	r5, #1
 8056588:	42ae      	cmp	r6, r5
 805658a:	bf38      	it	cc
 805658c:	2200      	movcc	r2, #0
 805658e:	18a3      	adds	r3, r4, r2
 8056590:	50a7      	str	r7, [r4, r2]
 8056592:	b107      	cbz	r7, 8056596 <rshift+0x68>
 8056594:	3304      	adds	r3, #4
 8056596:	1b1a      	subs	r2, r3, r4
 8056598:	42a3      	cmp	r3, r4
 805659a:	ea4f 02a2 	mov.w	r2, r2, asr #2
 805659e:	bf08      	it	eq
 80565a0:	2300      	moveq	r3, #0
 80565a2:	6102      	str	r2, [r0, #16]
 80565a4:	bf08      	it	eq
 80565a6:	6143      	streq	r3, [r0, #20]
 80565a8:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 80565ac:	f8dc c000 	ldr.w	ip, [ip]
 80565b0:	fa0c fc08 	lsl.w	ip, ip, r8
 80565b4:	ea4c 0707 	orr.w	r7, ip, r7
 80565b8:	f849 7b04 	str.w	r7, [r9], #4
 80565bc:	f85e 7b04 	ldr.w	r7, [lr], #4
 80565c0:	40cf      	lsrs	r7, r1
 80565c2:	e7da      	b.n	805657a <rshift+0x4c>
 80565c4:	f851 cb04 	ldr.w	ip, [r1], #4
 80565c8:	f847 cf04 	str.w	ip, [r7, #4]!
 80565cc:	e7c3      	b.n	8056556 <rshift+0x28>
 80565ce:	4623      	mov	r3, r4
 80565d0:	e7e1      	b.n	8056596 <rshift+0x68>

080565d2 <__hexdig_fun>:
 80565d2:	f1a0 0330 	sub.w	r3, r0, #48	; 0x30
 80565d6:	2b09      	cmp	r3, #9
 80565d8:	d802      	bhi.n	80565e0 <__hexdig_fun+0xe>
 80565da:	3820      	subs	r0, #32
 80565dc:	b2c0      	uxtb	r0, r0
 80565de:	4770      	bx	lr
 80565e0:	f1a0 0361 	sub.w	r3, r0, #97	; 0x61
 80565e4:	2b05      	cmp	r3, #5
 80565e6:	d801      	bhi.n	80565ec <__hexdig_fun+0x1a>
 80565e8:	3847      	subs	r0, #71	; 0x47
 80565ea:	e7f7      	b.n	80565dc <__hexdig_fun+0xa>
 80565ec:	f1a0 0341 	sub.w	r3, r0, #65	; 0x41
 80565f0:	2b05      	cmp	r3, #5
 80565f2:	d801      	bhi.n	80565f8 <__hexdig_fun+0x26>
 80565f4:	3827      	subs	r0, #39	; 0x27
 80565f6:	e7f1      	b.n	80565dc <__hexdig_fun+0xa>
 80565f8:	2000      	movs	r0, #0
 80565fa:	4770      	bx	lr

080565fc <__gethex>:
 80565fc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8056600:	ed2d 8b02 	vpush	{d8}
 8056604:	b089      	sub	sp, #36	; 0x24
 8056606:	ee08 0a10 	vmov	s16, r0
 805660a:	9304      	str	r3, [sp, #16]
 805660c:	4bbc      	ldr	r3, [pc, #752]	; (8056900 <__gethex+0x304>)
 805660e:	681b      	ldr	r3, [r3, #0]
 8056610:	9301      	str	r3, [sp, #4]
 8056612:	4618      	mov	r0, r3
 8056614:	468b      	mov	fp, r1
 8056616:	4690      	mov	r8, r2
 8056618:	f7e9 fdf4 	bl	8040204 <strlen>
 805661c:	9b01      	ldr	r3, [sp, #4]
 805661e:	f8db 2000 	ldr.w	r2, [fp]
 8056622:	4403      	add	r3, r0
 8056624:	4682      	mov	sl, r0
 8056626:	f813 3c01 	ldrb.w	r3, [r3, #-1]
 805662a:	9305      	str	r3, [sp, #20]
 805662c:	1c93      	adds	r3, r2, #2
 805662e:	f1c2 22ff 	rsb	r2, r2, #4278255360	; 0xff00ff00
 8056632:	f502 027f 	add.w	r2, r2, #16711680	; 0xff0000
 8056636:	32fe      	adds	r2, #254	; 0xfe
 8056638:	18d1      	adds	r1, r2, r3
 805663a:	461f      	mov	r7, r3
 805663c:	f813 0b01 	ldrb.w	r0, [r3], #1
 8056640:	9100      	str	r1, [sp, #0]
 8056642:	2830      	cmp	r0, #48	; 0x30
 8056644:	d0f8      	beq.n	8056638 <__gethex+0x3c>
 8056646:	f7ff ffc4 	bl	80565d2 <__hexdig_fun>
 805664a:	4604      	mov	r4, r0
 805664c:	2800      	cmp	r0, #0
 805664e:	d13a      	bne.n	80566c6 <__gethex+0xca>
 8056650:	9901      	ldr	r1, [sp, #4]
 8056652:	4652      	mov	r2, sl
 8056654:	4638      	mov	r0, r7
 8056656:	f7fb fa70 	bl	8051b3a <strncmp>
 805665a:	4605      	mov	r5, r0
 805665c:	2800      	cmp	r0, #0
 805665e:	d168      	bne.n	8056732 <__gethex+0x136>
 8056660:	f817 000a 	ldrb.w	r0, [r7, sl]
 8056664:	eb07 060a 	add.w	r6, r7, sl
 8056668:	f7ff ffb3 	bl	80565d2 <__hexdig_fun>
 805666c:	2800      	cmp	r0, #0
 805666e:	d062      	beq.n	8056736 <__gethex+0x13a>
 8056670:	4633      	mov	r3, r6
 8056672:	7818      	ldrb	r0, [r3, #0]
 8056674:	2830      	cmp	r0, #48	; 0x30
 8056676:	461f      	mov	r7, r3
 8056678:	f103 0301 	add.w	r3, r3, #1
 805667c:	d0f9      	beq.n	8056672 <__gethex+0x76>
 805667e:	f7ff ffa8 	bl	80565d2 <__hexdig_fun>
 8056682:	2301      	movs	r3, #1
 8056684:	fab0 f480 	clz	r4, r0
 8056688:	0964      	lsrs	r4, r4, #5
 805668a:	4635      	mov	r5, r6
 805668c:	9300      	str	r3, [sp, #0]
 805668e:	463a      	mov	r2, r7
 8056690:	4616      	mov	r6, r2
 8056692:	3201      	adds	r2, #1
 8056694:	7830      	ldrb	r0, [r6, #0]
 8056696:	f7ff ff9c 	bl	80565d2 <__hexdig_fun>
 805669a:	2800      	cmp	r0, #0
 805669c:	d1f8      	bne.n	8056690 <__gethex+0x94>
 805669e:	9901      	ldr	r1, [sp, #4]
 80566a0:	4652      	mov	r2, sl
 80566a2:	4630      	mov	r0, r6
 80566a4:	f7fb fa49 	bl	8051b3a <strncmp>
 80566a8:	b980      	cbnz	r0, 80566cc <__gethex+0xd0>
 80566aa:	b94d      	cbnz	r5, 80566c0 <__gethex+0xc4>
 80566ac:	eb06 050a 	add.w	r5, r6, sl
 80566b0:	462a      	mov	r2, r5
 80566b2:	4616      	mov	r6, r2
 80566b4:	3201      	adds	r2, #1
 80566b6:	7830      	ldrb	r0, [r6, #0]
 80566b8:	f7ff ff8b 	bl	80565d2 <__hexdig_fun>
 80566bc:	2800      	cmp	r0, #0
 80566be:	d1f8      	bne.n	80566b2 <__gethex+0xb6>
 80566c0:	1bad      	subs	r5, r5, r6
 80566c2:	00ad      	lsls	r5, r5, #2
 80566c4:	e004      	b.n	80566d0 <__gethex+0xd4>
 80566c6:	2400      	movs	r4, #0
 80566c8:	4625      	mov	r5, r4
 80566ca:	e7e0      	b.n	805668e <__gethex+0x92>
 80566cc:	2d00      	cmp	r5, #0
 80566ce:	d1f7      	bne.n	80566c0 <__gethex+0xc4>
 80566d0:	7833      	ldrb	r3, [r6, #0]
 80566d2:	f003 03df 	and.w	r3, r3, #223	; 0xdf
 80566d6:	2b50      	cmp	r3, #80	; 0x50
 80566d8:	d13b      	bne.n	8056752 <__gethex+0x156>
 80566da:	7873      	ldrb	r3, [r6, #1]
 80566dc:	2b2b      	cmp	r3, #43	; 0x2b
 80566de:	d02c      	beq.n	805673a <__gethex+0x13e>
 80566e0:	2b2d      	cmp	r3, #45	; 0x2d
 80566e2:	d02e      	beq.n	8056742 <__gethex+0x146>
 80566e4:	1c71      	adds	r1, r6, #1
 80566e6:	f04f 0900 	mov.w	r9, #0
 80566ea:	7808      	ldrb	r0, [r1, #0]
 80566ec:	f7ff ff71 	bl	80565d2 <__hexdig_fun>
 80566f0:	1e43      	subs	r3, r0, #1
 80566f2:	b2db      	uxtb	r3, r3
 80566f4:	2b18      	cmp	r3, #24
 80566f6:	d82c      	bhi.n	8056752 <__gethex+0x156>
 80566f8:	f1a0 0210 	sub.w	r2, r0, #16
 80566fc:	f811 0f01 	ldrb.w	r0, [r1, #1]!
 8056700:	f7ff ff67 	bl	80565d2 <__hexdig_fun>
 8056704:	1e43      	subs	r3, r0, #1
 8056706:	b2db      	uxtb	r3, r3
 8056708:	2b18      	cmp	r3, #24
 805670a:	d91d      	bls.n	8056748 <__gethex+0x14c>
 805670c:	f1b9 0f00 	cmp.w	r9, #0
 8056710:	d000      	beq.n	8056714 <__gethex+0x118>
 8056712:	4252      	negs	r2, r2
 8056714:	4415      	add	r5, r2
 8056716:	f8cb 1000 	str.w	r1, [fp]
 805671a:	b1e4      	cbz	r4, 8056756 <__gethex+0x15a>
 805671c:	9b00      	ldr	r3, [sp, #0]
 805671e:	2b00      	cmp	r3, #0
 8056720:	bf14      	ite	ne
 8056722:	2700      	movne	r7, #0
 8056724:	2706      	moveq	r7, #6
 8056726:	4638      	mov	r0, r7
 8056728:	b009      	add	sp, #36	; 0x24
 805672a:	ecbd 8b02 	vpop	{d8}
 805672e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8056732:	463e      	mov	r6, r7
 8056734:	4625      	mov	r5, r4
 8056736:	2401      	movs	r4, #1
 8056738:	e7ca      	b.n	80566d0 <__gethex+0xd4>
 805673a:	f04f 0900 	mov.w	r9, #0
 805673e:	1cb1      	adds	r1, r6, #2
 8056740:	e7d3      	b.n	80566ea <__gethex+0xee>
 8056742:	f04f 0901 	mov.w	r9, #1
 8056746:	e7fa      	b.n	805673e <__gethex+0x142>
 8056748:	230a      	movs	r3, #10
 805674a:	fb03 0202 	mla	r2, r3, r2, r0
 805674e:	3a10      	subs	r2, #16
 8056750:	e7d4      	b.n	80566fc <__gethex+0x100>
 8056752:	4631      	mov	r1, r6
 8056754:	e7df      	b.n	8056716 <__gethex+0x11a>
 8056756:	1bf3      	subs	r3, r6, r7
 8056758:	3b01      	subs	r3, #1
 805675a:	4621      	mov	r1, r4
 805675c:	2b07      	cmp	r3, #7
 805675e:	dc0b      	bgt.n	8056778 <__gethex+0x17c>
 8056760:	ee18 0a10 	vmov	r0, s16
 8056764:	f000 fade 	bl	8056d24 <_Balloc>
 8056768:	4604      	mov	r4, r0
 805676a:	b940      	cbnz	r0, 805677e <__gethex+0x182>
 805676c:	4b65      	ldr	r3, [pc, #404]	; (8056904 <__gethex+0x308>)
 805676e:	4602      	mov	r2, r0
 8056770:	21de      	movs	r1, #222	; 0xde
 8056772:	4865      	ldr	r0, [pc, #404]	; (8056908 <__gethex+0x30c>)
 8056774:	f001 fdb0 	bl	80582d8 <__assert_func>
 8056778:	3101      	adds	r1, #1
 805677a:	105b      	asrs	r3, r3, #1
 805677c:	e7ee      	b.n	805675c <__gethex+0x160>
 805677e:	f100 0914 	add.w	r9, r0, #20
 8056782:	f04f 0b00 	mov.w	fp, #0
 8056786:	f1ca 0301 	rsb	r3, sl, #1
 805678a:	f8cd 9008 	str.w	r9, [sp, #8]
 805678e:	f8cd b000 	str.w	fp, [sp]
 8056792:	9306      	str	r3, [sp, #24]
 8056794:	42b7      	cmp	r7, r6
 8056796:	d340      	bcc.n	805681a <__gethex+0x21e>
 8056798:	9802      	ldr	r0, [sp, #8]
 805679a:	9b00      	ldr	r3, [sp, #0]
 805679c:	f840 3b04 	str.w	r3, [r0], #4
 80567a0:	eba0 0009 	sub.w	r0, r0, r9
 80567a4:	1080      	asrs	r0, r0, #2
 80567a6:	0146      	lsls	r6, r0, #5
 80567a8:	6120      	str	r0, [r4, #16]
 80567aa:	4618      	mov	r0, r3
 80567ac:	f000 fb7c 	bl	8056ea8 <__hi0bits>
 80567b0:	1a30      	subs	r0, r6, r0
 80567b2:	f8d8 6000 	ldr.w	r6, [r8]
 80567b6:	42b0      	cmp	r0, r6
 80567b8:	dd63      	ble.n	8056882 <__gethex+0x286>
 80567ba:	1b87      	subs	r7, r0, r6
 80567bc:	4639      	mov	r1, r7
 80567be:	4620      	mov	r0, r4
 80567c0:	f000 fefc 	bl	80575bc <__any_on>
 80567c4:	4682      	mov	sl, r0
 80567c6:	b1a8      	cbz	r0, 80567f4 <__gethex+0x1f8>
 80567c8:	1e7b      	subs	r3, r7, #1
 80567ca:	1159      	asrs	r1, r3, #5
 80567cc:	f003 021f 	and.w	r2, r3, #31
 80567d0:	f859 1021 	ldr.w	r1, [r9, r1, lsl #2]
 80567d4:	f04f 0a01 	mov.w	sl, #1
 80567d8:	fa0a f202 	lsl.w	r2, sl, r2
 80567dc:	420a      	tst	r2, r1
 80567de:	d009      	beq.n	80567f4 <__gethex+0x1f8>
 80567e0:	4553      	cmp	r3, sl
 80567e2:	dd05      	ble.n	80567f0 <__gethex+0x1f4>
 80567e4:	1eb9      	subs	r1, r7, #2
 80567e6:	4620      	mov	r0, r4
 80567e8:	f000 fee8 	bl	80575bc <__any_on>
 80567ec:	2800      	cmp	r0, #0
 80567ee:	d145      	bne.n	805687c <__gethex+0x280>
 80567f0:	f04f 0a02 	mov.w	sl, #2
 80567f4:	4639      	mov	r1, r7
 80567f6:	4620      	mov	r0, r4
 80567f8:	f7ff fe99 	bl	805652e <rshift>
 80567fc:	443d      	add	r5, r7
 80567fe:	f8d8 3008 	ldr.w	r3, [r8, #8]
 8056802:	42ab      	cmp	r3, r5
 8056804:	da4c      	bge.n	80568a0 <__gethex+0x2a4>
 8056806:	ee18 0a10 	vmov	r0, s16
 805680a:	4621      	mov	r1, r4
 805680c:	f000 faaf 	bl	8056d6e <_Bfree>
 8056810:	9a14      	ldr	r2, [sp, #80]	; 0x50
 8056812:	2300      	movs	r3, #0
 8056814:	6013      	str	r3, [r2, #0]
 8056816:	27a3      	movs	r7, #163	; 0xa3
 8056818:	e785      	b.n	8056726 <__gethex+0x12a>
 805681a:	1e73      	subs	r3, r6, #1
 805681c:	9a05      	ldr	r2, [sp, #20]
 805681e:	9303      	str	r3, [sp, #12]
 8056820:	f816 3c01 	ldrb.w	r3, [r6, #-1]
 8056824:	4293      	cmp	r3, r2
 8056826:	d019      	beq.n	805685c <__gethex+0x260>
 8056828:	f1bb 0f20 	cmp.w	fp, #32
 805682c:	d107      	bne.n	805683e <__gethex+0x242>
 805682e:	9b02      	ldr	r3, [sp, #8]
 8056830:	9a00      	ldr	r2, [sp, #0]
 8056832:	f843 2b04 	str.w	r2, [r3], #4
 8056836:	9302      	str	r3, [sp, #8]
 8056838:	2300      	movs	r3, #0
 805683a:	9300      	str	r3, [sp, #0]
 805683c:	469b      	mov	fp, r3
 805683e:	f816 0c01 	ldrb.w	r0, [r6, #-1]
 8056842:	f7ff fec6 	bl	80565d2 <__hexdig_fun>
 8056846:	9b00      	ldr	r3, [sp, #0]
 8056848:	f000 000f 	and.w	r0, r0, #15
 805684c:	fa00 f00b 	lsl.w	r0, r0, fp
 8056850:	4303      	orrs	r3, r0
 8056852:	9300      	str	r3, [sp, #0]
 8056854:	f10b 0b04 	add.w	fp, fp, #4
 8056858:	9b03      	ldr	r3, [sp, #12]
 805685a:	e00d      	b.n	8056878 <__gethex+0x27c>
 805685c:	9b03      	ldr	r3, [sp, #12]
 805685e:	9a06      	ldr	r2, [sp, #24]
 8056860:	4413      	add	r3, r2
 8056862:	42bb      	cmp	r3, r7
 8056864:	d3e0      	bcc.n	8056828 <__gethex+0x22c>
 8056866:	4618      	mov	r0, r3
 8056868:	9901      	ldr	r1, [sp, #4]
 805686a:	9307      	str	r3, [sp, #28]
 805686c:	4652      	mov	r2, sl
 805686e:	f7fb f964 	bl	8051b3a <strncmp>
 8056872:	9b07      	ldr	r3, [sp, #28]
 8056874:	2800      	cmp	r0, #0
 8056876:	d1d7      	bne.n	8056828 <__gethex+0x22c>
 8056878:	461e      	mov	r6, r3
 805687a:	e78b      	b.n	8056794 <__gethex+0x198>
 805687c:	f04f 0a03 	mov.w	sl, #3
 8056880:	e7b8      	b.n	80567f4 <__gethex+0x1f8>
 8056882:	da0a      	bge.n	805689a <__gethex+0x29e>
 8056884:	1a37      	subs	r7, r6, r0
 8056886:	4621      	mov	r1, r4
 8056888:	ee18 0a10 	vmov	r0, s16
 805688c:	463a      	mov	r2, r7
 805688e:	f000 fc57 	bl	8057140 <__lshift>
 8056892:	1bed      	subs	r5, r5, r7
 8056894:	4604      	mov	r4, r0
 8056896:	f100 0914 	add.w	r9, r0, #20
 805689a:	f04f 0a00 	mov.w	sl, #0
 805689e:	e7ae      	b.n	80567fe <__gethex+0x202>
 80568a0:	f8d8 0004 	ldr.w	r0, [r8, #4]
 80568a4:	42a8      	cmp	r0, r5
 80568a6:	dd72      	ble.n	805698e <__gethex+0x392>
 80568a8:	1b45      	subs	r5, r0, r5
 80568aa:	42ae      	cmp	r6, r5
 80568ac:	dc36      	bgt.n	805691c <__gethex+0x320>
 80568ae:	f8d8 300c 	ldr.w	r3, [r8, #12]
 80568b2:	2b02      	cmp	r3, #2
 80568b4:	d02a      	beq.n	805690c <__gethex+0x310>
 80568b6:	2b03      	cmp	r3, #3
 80568b8:	d02c      	beq.n	8056914 <__gethex+0x318>
 80568ba:	2b01      	cmp	r3, #1
 80568bc:	d115      	bne.n	80568ea <__gethex+0x2ee>
 80568be:	42ae      	cmp	r6, r5
 80568c0:	d113      	bne.n	80568ea <__gethex+0x2ee>
 80568c2:	2e01      	cmp	r6, #1
 80568c4:	d10b      	bne.n	80568de <__gethex+0x2e2>
 80568c6:	9a04      	ldr	r2, [sp, #16]
 80568c8:	f8d8 3004 	ldr.w	r3, [r8, #4]
 80568cc:	6013      	str	r3, [r2, #0]
 80568ce:	2301      	movs	r3, #1
 80568d0:	6123      	str	r3, [r4, #16]
 80568d2:	f8c9 3000 	str.w	r3, [r9]
 80568d6:	9b14      	ldr	r3, [sp, #80]	; 0x50
 80568d8:	2762      	movs	r7, #98	; 0x62
 80568da:	601c      	str	r4, [r3, #0]
 80568dc:	e723      	b.n	8056726 <__gethex+0x12a>
 80568de:	1e71      	subs	r1, r6, #1
 80568e0:	4620      	mov	r0, r4
 80568e2:	f000 fe6b 	bl	80575bc <__any_on>
 80568e6:	2800      	cmp	r0, #0
 80568e8:	d1ed      	bne.n	80568c6 <__gethex+0x2ca>
 80568ea:	ee18 0a10 	vmov	r0, s16
 80568ee:	4621      	mov	r1, r4
 80568f0:	f000 fa3d 	bl	8056d6e <_Bfree>
 80568f4:	9a14      	ldr	r2, [sp, #80]	; 0x50
 80568f6:	2300      	movs	r3, #0
 80568f8:	6013      	str	r3, [r2, #0]
 80568fa:	2750      	movs	r7, #80	; 0x50
 80568fc:	e713      	b.n	8056726 <__gethex+0x12a>
 80568fe:	bf00      	nop
 8056900:	0805add0 	.word	0x0805add0
 8056904:	0805acf7 	.word	0x0805acf7
 8056908:	0805ad67 	.word	0x0805ad67
 805690c:	9b15      	ldr	r3, [sp, #84]	; 0x54
 805690e:	2b00      	cmp	r3, #0
 8056910:	d1eb      	bne.n	80568ea <__gethex+0x2ee>
 8056912:	e7d8      	b.n	80568c6 <__gethex+0x2ca>
 8056914:	9b15      	ldr	r3, [sp, #84]	; 0x54
 8056916:	2b00      	cmp	r3, #0
 8056918:	d1d5      	bne.n	80568c6 <__gethex+0x2ca>
 805691a:	e7e6      	b.n	80568ea <__gethex+0x2ee>
 805691c:	1e6f      	subs	r7, r5, #1
 805691e:	f1ba 0f00 	cmp.w	sl, #0
 8056922:	d131      	bne.n	8056988 <__gethex+0x38c>
 8056924:	b127      	cbz	r7, 8056930 <__gethex+0x334>
 8056926:	4639      	mov	r1, r7
 8056928:	4620      	mov	r0, r4
 805692a:	f000 fe47 	bl	80575bc <__any_on>
 805692e:	4682      	mov	sl, r0
 8056930:	117b      	asrs	r3, r7, #5
 8056932:	2101      	movs	r1, #1
 8056934:	f859 3023 	ldr.w	r3, [r9, r3, lsl #2]
 8056938:	f007 071f 	and.w	r7, r7, #31
 805693c:	fa01 f707 	lsl.w	r7, r1, r7
 8056940:	421f      	tst	r7, r3
 8056942:	4629      	mov	r1, r5
 8056944:	4620      	mov	r0, r4
 8056946:	bf18      	it	ne
 8056948:	f04a 0a02 	orrne.w	sl, sl, #2
 805694c:	1b76      	subs	r6, r6, r5
 805694e:	f7ff fdee 	bl	805652e <rshift>
 8056952:	f8d8 5004 	ldr.w	r5, [r8, #4]
 8056956:	2702      	movs	r7, #2
 8056958:	f1ba 0f00 	cmp.w	sl, #0
 805695c:	d048      	beq.n	80569f0 <__gethex+0x3f4>
 805695e:	f8d8 300c 	ldr.w	r3, [r8, #12]
 8056962:	2b02      	cmp	r3, #2
 8056964:	d015      	beq.n	8056992 <__gethex+0x396>
 8056966:	2b03      	cmp	r3, #3
 8056968:	d017      	beq.n	805699a <__gethex+0x39e>
 805696a:	2b01      	cmp	r3, #1
 805696c:	d109      	bne.n	8056982 <__gethex+0x386>
 805696e:	f01a 0f02 	tst.w	sl, #2
 8056972:	d006      	beq.n	8056982 <__gethex+0x386>
 8056974:	f8d9 0000 	ldr.w	r0, [r9]
 8056978:	ea4a 0a00 	orr.w	sl, sl, r0
 805697c:	f01a 0f01 	tst.w	sl, #1
 8056980:	d10e      	bne.n	80569a0 <__gethex+0x3a4>
 8056982:	f047 0710 	orr.w	r7, r7, #16
 8056986:	e033      	b.n	80569f0 <__gethex+0x3f4>
 8056988:	f04f 0a01 	mov.w	sl, #1
 805698c:	e7d0      	b.n	8056930 <__gethex+0x334>
 805698e:	2701      	movs	r7, #1
 8056990:	e7e2      	b.n	8056958 <__gethex+0x35c>
 8056992:	9b15      	ldr	r3, [sp, #84]	; 0x54
 8056994:	f1c3 0301 	rsb	r3, r3, #1
 8056998:	9315      	str	r3, [sp, #84]	; 0x54
 805699a:	9b15      	ldr	r3, [sp, #84]	; 0x54
 805699c:	2b00      	cmp	r3, #0
 805699e:	d0f0      	beq.n	8056982 <__gethex+0x386>
 80569a0:	f8d4 b010 	ldr.w	fp, [r4, #16]
 80569a4:	f104 0314 	add.w	r3, r4, #20
 80569a8:	ea4f 0a8b 	mov.w	sl, fp, lsl #2
 80569ac:	eb03 018b 	add.w	r1, r3, fp, lsl #2
 80569b0:	f04f 0c00 	mov.w	ip, #0
 80569b4:	4618      	mov	r0, r3
 80569b6:	f853 2b04 	ldr.w	r2, [r3], #4
 80569ba:	f1b2 3fff 	cmp.w	r2, #4294967295
 80569be:	d01c      	beq.n	80569fa <__gethex+0x3fe>
 80569c0:	3201      	adds	r2, #1
 80569c2:	6002      	str	r2, [r0, #0]
 80569c4:	2f02      	cmp	r7, #2
 80569c6:	f104 0314 	add.w	r3, r4, #20
 80569ca:	d13f      	bne.n	8056a4c <__gethex+0x450>
 80569cc:	f8d8 2000 	ldr.w	r2, [r8]
 80569d0:	3a01      	subs	r2, #1
 80569d2:	42b2      	cmp	r2, r6
 80569d4:	d10a      	bne.n	80569ec <__gethex+0x3f0>
 80569d6:	1171      	asrs	r1, r6, #5
 80569d8:	2201      	movs	r2, #1
 80569da:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 80569de:	f006 061f 	and.w	r6, r6, #31
 80569e2:	fa02 f606 	lsl.w	r6, r2, r6
 80569e6:	421e      	tst	r6, r3
 80569e8:	bf18      	it	ne
 80569ea:	4617      	movne	r7, r2
 80569ec:	f047 0720 	orr.w	r7, r7, #32
 80569f0:	9b14      	ldr	r3, [sp, #80]	; 0x50
 80569f2:	601c      	str	r4, [r3, #0]
 80569f4:	9b04      	ldr	r3, [sp, #16]
 80569f6:	601d      	str	r5, [r3, #0]
 80569f8:	e695      	b.n	8056726 <__gethex+0x12a>
 80569fa:	4299      	cmp	r1, r3
 80569fc:	f843 cc04 	str.w	ip, [r3, #-4]
 8056a00:	d8d8      	bhi.n	80569b4 <__gethex+0x3b8>
 8056a02:	68a3      	ldr	r3, [r4, #8]
 8056a04:	459b      	cmp	fp, r3
 8056a06:	db19      	blt.n	8056a3c <__gethex+0x440>
 8056a08:	6861      	ldr	r1, [r4, #4]
 8056a0a:	ee18 0a10 	vmov	r0, s16
 8056a0e:	3101      	adds	r1, #1
 8056a10:	f000 f988 	bl	8056d24 <_Balloc>
 8056a14:	4681      	mov	r9, r0
 8056a16:	b918      	cbnz	r0, 8056a20 <__gethex+0x424>
 8056a18:	4b1a      	ldr	r3, [pc, #104]	; (8056a84 <__gethex+0x488>)
 8056a1a:	4602      	mov	r2, r0
 8056a1c:	2184      	movs	r1, #132	; 0x84
 8056a1e:	e6a8      	b.n	8056772 <__gethex+0x176>
 8056a20:	6922      	ldr	r2, [r4, #16]
 8056a22:	3202      	adds	r2, #2
 8056a24:	f104 010c 	add.w	r1, r4, #12
 8056a28:	0092      	lsls	r2, r2, #2
 8056a2a:	300c      	adds	r0, #12
 8056a2c:	f7fa ffea 	bl	8051a04 <memcpy>
 8056a30:	4621      	mov	r1, r4
 8056a32:	ee18 0a10 	vmov	r0, s16
 8056a36:	f000 f99a 	bl	8056d6e <_Bfree>
 8056a3a:	464c      	mov	r4, r9
 8056a3c:	6923      	ldr	r3, [r4, #16]
 8056a3e:	1c5a      	adds	r2, r3, #1
 8056a40:	eb04 0383 	add.w	r3, r4, r3, lsl #2
 8056a44:	6122      	str	r2, [r4, #16]
 8056a46:	2201      	movs	r2, #1
 8056a48:	615a      	str	r2, [r3, #20]
 8056a4a:	e7bb      	b.n	80569c4 <__gethex+0x3c8>
 8056a4c:	6922      	ldr	r2, [r4, #16]
 8056a4e:	455a      	cmp	r2, fp
 8056a50:	dd0b      	ble.n	8056a6a <__gethex+0x46e>
 8056a52:	2101      	movs	r1, #1
 8056a54:	4620      	mov	r0, r4
 8056a56:	f7ff fd6a 	bl	805652e <rshift>
 8056a5a:	f8d8 3008 	ldr.w	r3, [r8, #8]
 8056a5e:	3501      	adds	r5, #1
 8056a60:	42ab      	cmp	r3, r5
 8056a62:	f6ff aed0 	blt.w	8056806 <__gethex+0x20a>
 8056a66:	2701      	movs	r7, #1
 8056a68:	e7c0      	b.n	80569ec <__gethex+0x3f0>
 8056a6a:	f016 061f 	ands.w	r6, r6, #31
 8056a6e:	d0fa      	beq.n	8056a66 <__gethex+0x46a>
 8056a70:	449a      	add	sl, r3
 8056a72:	f1c6 0620 	rsb	r6, r6, #32
 8056a76:	f85a 0c04 	ldr.w	r0, [sl, #-4]
 8056a7a:	f000 fa15 	bl	8056ea8 <__hi0bits>
 8056a7e:	42b0      	cmp	r0, r6
 8056a80:	dbe7      	blt.n	8056a52 <__gethex+0x456>
 8056a82:	e7f0      	b.n	8056a66 <__gethex+0x46a>
 8056a84:	0805acf7 	.word	0x0805acf7

08056a88 <L_shift>:
 8056a88:	f1c2 0208 	rsb	r2, r2, #8
 8056a8c:	0092      	lsls	r2, r2, #2
 8056a8e:	b570      	push	{r4, r5, r6, lr}
 8056a90:	f1c2 0620 	rsb	r6, r2, #32
 8056a94:	6843      	ldr	r3, [r0, #4]
 8056a96:	6804      	ldr	r4, [r0, #0]
 8056a98:	fa03 f506 	lsl.w	r5, r3, r6
 8056a9c:	432c      	orrs	r4, r5
 8056a9e:	40d3      	lsrs	r3, r2
 8056aa0:	6004      	str	r4, [r0, #0]
 8056aa2:	f840 3f04 	str.w	r3, [r0, #4]!
 8056aa6:	4288      	cmp	r0, r1
 8056aa8:	d3f4      	bcc.n	8056a94 <L_shift+0xc>
 8056aaa:	bd70      	pop	{r4, r5, r6, pc}

08056aac <__match>:
 8056aac:	b530      	push	{r4, r5, lr}
 8056aae:	6803      	ldr	r3, [r0, #0]
 8056ab0:	3301      	adds	r3, #1
 8056ab2:	f811 4b01 	ldrb.w	r4, [r1], #1
 8056ab6:	b914      	cbnz	r4, 8056abe <__match+0x12>
 8056ab8:	6003      	str	r3, [r0, #0]
 8056aba:	2001      	movs	r0, #1
 8056abc:	bd30      	pop	{r4, r5, pc}
 8056abe:	f813 2b01 	ldrb.w	r2, [r3], #1
 8056ac2:	f1a2 0541 	sub.w	r5, r2, #65	; 0x41
 8056ac6:	2d19      	cmp	r5, #25
 8056ac8:	bf98      	it	ls
 8056aca:	3220      	addls	r2, #32
 8056acc:	42a2      	cmp	r2, r4
 8056ace:	d0f0      	beq.n	8056ab2 <__match+0x6>
 8056ad0:	2000      	movs	r0, #0
 8056ad2:	e7f3      	b.n	8056abc <__match+0x10>

08056ad4 <__hexnan>:
 8056ad4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8056ad8:	680b      	ldr	r3, [r1, #0]
 8056ada:	6801      	ldr	r1, [r0, #0]
 8056adc:	115e      	asrs	r6, r3, #5
 8056ade:	eb02 0686 	add.w	r6, r2, r6, lsl #2
 8056ae2:	f013 031f 	ands.w	r3, r3, #31
 8056ae6:	b087      	sub	sp, #28
 8056ae8:	bf18      	it	ne
 8056aea:	3604      	addne	r6, #4
 8056aec:	2500      	movs	r5, #0
 8056aee:	1f37      	subs	r7, r6, #4
 8056af0:	4682      	mov	sl, r0
 8056af2:	4690      	mov	r8, r2
 8056af4:	9301      	str	r3, [sp, #4]
 8056af6:	f846 5c04 	str.w	r5, [r6, #-4]
 8056afa:	46b9      	mov	r9, r7
 8056afc:	463c      	mov	r4, r7
 8056afe:	9502      	str	r5, [sp, #8]
 8056b00:	46ab      	mov	fp, r5
 8056b02:	784a      	ldrb	r2, [r1, #1]
 8056b04:	1c4b      	adds	r3, r1, #1
 8056b06:	9303      	str	r3, [sp, #12]
 8056b08:	b342      	cbz	r2, 8056b5c <__hexnan+0x88>
 8056b0a:	4610      	mov	r0, r2
 8056b0c:	9105      	str	r1, [sp, #20]
 8056b0e:	9204      	str	r2, [sp, #16]
 8056b10:	f7ff fd5f 	bl	80565d2 <__hexdig_fun>
 8056b14:	2800      	cmp	r0, #0
 8056b16:	d14f      	bne.n	8056bb8 <__hexnan+0xe4>
 8056b18:	9a04      	ldr	r2, [sp, #16]
 8056b1a:	9905      	ldr	r1, [sp, #20]
 8056b1c:	2a20      	cmp	r2, #32
 8056b1e:	d818      	bhi.n	8056b52 <__hexnan+0x7e>
 8056b20:	9b02      	ldr	r3, [sp, #8]
 8056b22:	459b      	cmp	fp, r3
 8056b24:	dd13      	ble.n	8056b4e <__hexnan+0x7a>
 8056b26:	454c      	cmp	r4, r9
 8056b28:	d206      	bcs.n	8056b38 <__hexnan+0x64>
 8056b2a:	2d07      	cmp	r5, #7
 8056b2c:	dc04      	bgt.n	8056b38 <__hexnan+0x64>
 8056b2e:	462a      	mov	r2, r5
 8056b30:	4649      	mov	r1, r9
 8056b32:	4620      	mov	r0, r4
 8056b34:	f7ff ffa8 	bl	8056a88 <L_shift>
 8056b38:	4544      	cmp	r4, r8
 8056b3a:	d950      	bls.n	8056bde <__hexnan+0x10a>
 8056b3c:	2300      	movs	r3, #0
 8056b3e:	f1a4 0904 	sub.w	r9, r4, #4
 8056b42:	f844 3c04 	str.w	r3, [r4, #-4]
 8056b46:	f8cd b008 	str.w	fp, [sp, #8]
 8056b4a:	464c      	mov	r4, r9
 8056b4c:	461d      	mov	r5, r3
 8056b4e:	9903      	ldr	r1, [sp, #12]
 8056b50:	e7d7      	b.n	8056b02 <__hexnan+0x2e>
 8056b52:	2a29      	cmp	r2, #41	; 0x29
 8056b54:	d156      	bne.n	8056c04 <__hexnan+0x130>
 8056b56:	3102      	adds	r1, #2
 8056b58:	f8ca 1000 	str.w	r1, [sl]
 8056b5c:	f1bb 0f00 	cmp.w	fp, #0
 8056b60:	d050      	beq.n	8056c04 <__hexnan+0x130>
 8056b62:	454c      	cmp	r4, r9
 8056b64:	d206      	bcs.n	8056b74 <__hexnan+0xa0>
 8056b66:	2d07      	cmp	r5, #7
 8056b68:	dc04      	bgt.n	8056b74 <__hexnan+0xa0>
 8056b6a:	462a      	mov	r2, r5
 8056b6c:	4649      	mov	r1, r9
 8056b6e:	4620      	mov	r0, r4
 8056b70:	f7ff ff8a 	bl	8056a88 <L_shift>
 8056b74:	4544      	cmp	r4, r8
 8056b76:	d934      	bls.n	8056be2 <__hexnan+0x10e>
 8056b78:	f1a8 0204 	sub.w	r2, r8, #4
 8056b7c:	4623      	mov	r3, r4
 8056b7e:	f853 1b04 	ldr.w	r1, [r3], #4
 8056b82:	f842 1f04 	str.w	r1, [r2, #4]!
 8056b86:	429f      	cmp	r7, r3
 8056b88:	d2f9      	bcs.n	8056b7e <__hexnan+0xaa>
 8056b8a:	1b3b      	subs	r3, r7, r4
 8056b8c:	f023 0303 	bic.w	r3, r3, #3
 8056b90:	3304      	adds	r3, #4
 8056b92:	3401      	adds	r4, #1
 8056b94:	3e03      	subs	r6, #3
 8056b96:	42b4      	cmp	r4, r6
 8056b98:	bf88      	it	hi
 8056b9a:	2304      	movhi	r3, #4
 8056b9c:	4443      	add	r3, r8
 8056b9e:	2200      	movs	r2, #0
 8056ba0:	f843 2b04 	str.w	r2, [r3], #4
 8056ba4:	429f      	cmp	r7, r3
 8056ba6:	d2fb      	bcs.n	8056ba0 <__hexnan+0xcc>
 8056ba8:	683b      	ldr	r3, [r7, #0]
 8056baa:	b91b      	cbnz	r3, 8056bb4 <__hexnan+0xe0>
 8056bac:	4547      	cmp	r7, r8
 8056bae:	d127      	bne.n	8056c00 <__hexnan+0x12c>
 8056bb0:	2301      	movs	r3, #1
 8056bb2:	603b      	str	r3, [r7, #0]
 8056bb4:	2005      	movs	r0, #5
 8056bb6:	e026      	b.n	8056c06 <__hexnan+0x132>
 8056bb8:	3501      	adds	r5, #1
 8056bba:	2d08      	cmp	r5, #8
 8056bbc:	f10b 0b01 	add.w	fp, fp, #1
 8056bc0:	dd06      	ble.n	8056bd0 <__hexnan+0xfc>
 8056bc2:	4544      	cmp	r4, r8
 8056bc4:	d9c3      	bls.n	8056b4e <__hexnan+0x7a>
 8056bc6:	2300      	movs	r3, #0
 8056bc8:	f844 3c04 	str.w	r3, [r4, #-4]
 8056bcc:	2501      	movs	r5, #1
 8056bce:	3c04      	subs	r4, #4
 8056bd0:	6822      	ldr	r2, [r4, #0]
 8056bd2:	f000 000f 	and.w	r0, r0, #15
 8056bd6:	ea40 1202 	orr.w	r2, r0, r2, lsl #4
 8056bda:	6022      	str	r2, [r4, #0]
 8056bdc:	e7b7      	b.n	8056b4e <__hexnan+0x7a>
 8056bde:	2508      	movs	r5, #8
 8056be0:	e7b5      	b.n	8056b4e <__hexnan+0x7a>
 8056be2:	9b01      	ldr	r3, [sp, #4]
 8056be4:	2b00      	cmp	r3, #0
 8056be6:	d0df      	beq.n	8056ba8 <__hexnan+0xd4>
 8056be8:	f04f 32ff 	mov.w	r2, #4294967295
 8056bec:	f1c3 0320 	rsb	r3, r3, #32
 8056bf0:	fa22 f303 	lsr.w	r3, r2, r3
 8056bf4:	f856 2c04 	ldr.w	r2, [r6, #-4]
 8056bf8:	401a      	ands	r2, r3
 8056bfa:	f846 2c04 	str.w	r2, [r6, #-4]
 8056bfe:	e7d3      	b.n	8056ba8 <__hexnan+0xd4>
 8056c00:	3f04      	subs	r7, #4
 8056c02:	e7d1      	b.n	8056ba8 <__hexnan+0xd4>
 8056c04:	2004      	movs	r0, #4
 8056c06:	b007      	add	sp, #28
 8056c08:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08056c0c <__locale_mb_cur_max>:
 8056c0c:	4b01      	ldr	r3, [pc, #4]	; (8056c14 <__locale_mb_cur_max+0x8>)
 8056c0e:	f893 0128 	ldrb.w	r0, [r3, #296]	; 0x128
 8056c12:	4770      	bx	lr
 8056c14:	20003f18 	.word	0x20003f18

08056c18 <_localeconv_r>:
 8056c18:	4800      	ldr	r0, [pc, #0]	; (8056c1c <_localeconv_r+0x4>)
 8056c1a:	4770      	bx	lr
 8056c1c:	20004008 	.word	0x20004008

08056c20 <__retarget_lock_init_recursive>:
 8056c20:	4770      	bx	lr

08056c22 <__retarget_lock_close_recursive>:
 8056c22:	4770      	bx	lr

08056c24 <__retarget_lock_acquire_recursive>:
 8056c24:	4770      	bx	lr

08056c26 <__retarget_lock_release_recursive>:
 8056c26:	4770      	bx	lr

08056c28 <__swhatbuf_r>:
 8056c28:	b570      	push	{r4, r5, r6, lr}
 8056c2a:	460e      	mov	r6, r1
 8056c2c:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8056c30:	2900      	cmp	r1, #0
 8056c32:	b096      	sub	sp, #88	; 0x58
 8056c34:	4614      	mov	r4, r2
 8056c36:	461d      	mov	r5, r3
 8056c38:	da09      	bge.n	8056c4e <__swhatbuf_r+0x26>
 8056c3a:	89b3      	ldrh	r3, [r6, #12]
 8056c3c:	2200      	movs	r2, #0
 8056c3e:	f013 0080 	ands.w	r0, r3, #128	; 0x80
 8056c42:	602a      	str	r2, [r5, #0]
 8056c44:	d116      	bne.n	8056c74 <__swhatbuf_r+0x4c>
 8056c46:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8056c4a:	6023      	str	r3, [r4, #0]
 8056c4c:	e015      	b.n	8056c7a <__swhatbuf_r+0x52>
 8056c4e:	466a      	mov	r2, sp
 8056c50:	f001 fc74 	bl	805853c <_fstat_r>
 8056c54:	2800      	cmp	r0, #0
 8056c56:	dbf0      	blt.n	8056c3a <__swhatbuf_r+0x12>
 8056c58:	9a01      	ldr	r2, [sp, #4]
 8056c5a:	f402 4270 	and.w	r2, r2, #61440	; 0xf000
 8056c5e:	f5a2 5300 	sub.w	r3, r2, #8192	; 0x2000
 8056c62:	425a      	negs	r2, r3
 8056c64:	415a      	adcs	r2, r3
 8056c66:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8056c6a:	602a      	str	r2, [r5, #0]
 8056c6c:	f44f 6000 	mov.w	r0, #2048	; 0x800
 8056c70:	6023      	str	r3, [r4, #0]
 8056c72:	e002      	b.n	8056c7a <__swhatbuf_r+0x52>
 8056c74:	2340      	movs	r3, #64	; 0x40
 8056c76:	6023      	str	r3, [r4, #0]
 8056c78:	4610      	mov	r0, r2
 8056c7a:	b016      	add	sp, #88	; 0x58
 8056c7c:	bd70      	pop	{r4, r5, r6, pc}
	...

08056c80 <__smakebuf_r>:
 8056c80:	898b      	ldrh	r3, [r1, #12]
 8056c82:	b573      	push	{r0, r1, r4, r5, r6, lr}
 8056c84:	079d      	lsls	r5, r3, #30
 8056c86:	4606      	mov	r6, r0
 8056c88:	460c      	mov	r4, r1
 8056c8a:	d507      	bpl.n	8056c9c <__smakebuf_r+0x1c>
 8056c8c:	f104 0343 	add.w	r3, r4, #67	; 0x43
 8056c90:	6023      	str	r3, [r4, #0]
 8056c92:	6123      	str	r3, [r4, #16]
 8056c94:	2301      	movs	r3, #1
 8056c96:	6163      	str	r3, [r4, #20]
 8056c98:	b002      	add	sp, #8
 8056c9a:	bd70      	pop	{r4, r5, r6, pc}
 8056c9c:	ab01      	add	r3, sp, #4
 8056c9e:	466a      	mov	r2, sp
 8056ca0:	f7ff ffc2 	bl	8056c28 <__swhatbuf_r>
 8056ca4:	9900      	ldr	r1, [sp, #0]
 8056ca6:	4605      	mov	r5, r0
 8056ca8:	4630      	mov	r0, r6
 8056caa:	f7fa fc5b 	bl	8051564 <_malloc_r>
 8056cae:	b948      	cbnz	r0, 8056cc4 <__smakebuf_r+0x44>
 8056cb0:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8056cb4:	059a      	lsls	r2, r3, #22
 8056cb6:	d4ef      	bmi.n	8056c98 <__smakebuf_r+0x18>
 8056cb8:	f023 0303 	bic.w	r3, r3, #3
 8056cbc:	f043 0302 	orr.w	r3, r3, #2
 8056cc0:	81a3      	strh	r3, [r4, #12]
 8056cc2:	e7e3      	b.n	8056c8c <__smakebuf_r+0xc>
 8056cc4:	4b0d      	ldr	r3, [pc, #52]	; (8056cfc <__smakebuf_r+0x7c>)
 8056cc6:	63f3      	str	r3, [r6, #60]	; 0x3c
 8056cc8:	89a3      	ldrh	r3, [r4, #12]
 8056cca:	6020      	str	r0, [r4, #0]
 8056ccc:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8056cd0:	81a3      	strh	r3, [r4, #12]
 8056cd2:	9b00      	ldr	r3, [sp, #0]
 8056cd4:	6163      	str	r3, [r4, #20]
 8056cd6:	9b01      	ldr	r3, [sp, #4]
 8056cd8:	6120      	str	r0, [r4, #16]
 8056cda:	b15b      	cbz	r3, 8056cf4 <__smakebuf_r+0x74>
 8056cdc:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 8056ce0:	4630      	mov	r0, r6
 8056ce2:	f001 fd87 	bl	80587f4 <_isatty_r>
 8056ce6:	b128      	cbz	r0, 8056cf4 <__smakebuf_r+0x74>
 8056ce8:	89a3      	ldrh	r3, [r4, #12]
 8056cea:	f023 0303 	bic.w	r3, r3, #3
 8056cee:	f043 0301 	orr.w	r3, r3, #1
 8056cf2:	81a3      	strh	r3, [r4, #12]
 8056cf4:	89a0      	ldrh	r0, [r4, #12]
 8056cf6:	4305      	orrs	r5, r0
 8056cf8:	81a5      	strh	r5, [r4, #12]
 8056cfa:	e7cd      	b.n	8056c98 <__smakebuf_r+0x18>
 8056cfc:	08056215 	.word	0x08056215

08056d00 <__ascii_mbtowc>:
 8056d00:	b082      	sub	sp, #8
 8056d02:	b901      	cbnz	r1, 8056d06 <__ascii_mbtowc+0x6>
 8056d04:	a901      	add	r1, sp, #4
 8056d06:	b142      	cbz	r2, 8056d1a <__ascii_mbtowc+0x1a>
 8056d08:	b14b      	cbz	r3, 8056d1e <__ascii_mbtowc+0x1e>
 8056d0a:	7813      	ldrb	r3, [r2, #0]
 8056d0c:	600b      	str	r3, [r1, #0]
 8056d0e:	7812      	ldrb	r2, [r2, #0]
 8056d10:	1e10      	subs	r0, r2, #0
 8056d12:	bf18      	it	ne
 8056d14:	2001      	movne	r0, #1
 8056d16:	b002      	add	sp, #8
 8056d18:	4770      	bx	lr
 8056d1a:	4610      	mov	r0, r2
 8056d1c:	e7fb      	b.n	8056d16 <__ascii_mbtowc+0x16>
 8056d1e:	f06f 0001 	mvn.w	r0, #1
 8056d22:	e7f8      	b.n	8056d16 <__ascii_mbtowc+0x16>

08056d24 <_Balloc>:
 8056d24:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
 8056d26:	b570      	push	{r4, r5, r6, lr}
 8056d28:	4605      	mov	r5, r0
 8056d2a:	460c      	mov	r4, r1
 8056d2c:	b17b      	cbz	r3, 8056d4e <_Balloc+0x2a>
 8056d2e:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
 8056d30:	f853 0024 	ldr.w	r0, [r3, r4, lsl #2]
 8056d34:	b9a0      	cbnz	r0, 8056d60 <_Balloc+0x3c>
 8056d36:	2101      	movs	r1, #1
 8056d38:	fa01 f604 	lsl.w	r6, r1, r4
 8056d3c:	1d72      	adds	r2, r6, #5
 8056d3e:	0092      	lsls	r2, r2, #2
 8056d40:	4628      	mov	r0, r5
 8056d42:	f001 fae7 	bl	8058314 <_calloc_r>
 8056d46:	b148      	cbz	r0, 8056d5c <_Balloc+0x38>
 8056d48:	e9c0 4601 	strd	r4, r6, [r0, #4]
 8056d4c:	e00b      	b.n	8056d66 <_Balloc+0x42>
 8056d4e:	2221      	movs	r2, #33	; 0x21
 8056d50:	2104      	movs	r1, #4
 8056d52:	f001 fadf 	bl	8058314 <_calloc_r>
 8056d56:	64e8      	str	r0, [r5, #76]	; 0x4c
 8056d58:	2800      	cmp	r0, #0
 8056d5a:	d1e8      	bne.n	8056d2e <_Balloc+0xa>
 8056d5c:	2000      	movs	r0, #0
 8056d5e:	bd70      	pop	{r4, r5, r6, pc}
 8056d60:	6802      	ldr	r2, [r0, #0]
 8056d62:	f843 2024 	str.w	r2, [r3, r4, lsl #2]
 8056d66:	2300      	movs	r3, #0
 8056d68:	e9c0 3303 	strd	r3, r3, [r0, #12]
 8056d6c:	e7f7      	b.n	8056d5e <_Balloc+0x3a>

08056d6e <_Bfree>:
 8056d6e:	b131      	cbz	r1, 8056d7e <_Bfree+0x10>
 8056d70:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
 8056d72:	684a      	ldr	r2, [r1, #4]
 8056d74:	f853 0022 	ldr.w	r0, [r3, r2, lsl #2]
 8056d78:	6008      	str	r0, [r1, #0]
 8056d7a:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
 8056d7e:	4770      	bx	lr

08056d80 <__multadd>:
 8056d80:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8056d84:	690e      	ldr	r6, [r1, #16]
 8056d86:	4607      	mov	r7, r0
 8056d88:	4698      	mov	r8, r3
 8056d8a:	460c      	mov	r4, r1
 8056d8c:	f101 0014 	add.w	r0, r1, #20
 8056d90:	2300      	movs	r3, #0
 8056d92:	6805      	ldr	r5, [r0, #0]
 8056d94:	b2a9      	uxth	r1, r5
 8056d96:	fb02 8101 	mla	r1, r2, r1, r8
 8056d9a:	ea4f 4c11 	mov.w	ip, r1, lsr #16
 8056d9e:	0c2d      	lsrs	r5, r5, #16
 8056da0:	fb02 c505 	mla	r5, r2, r5, ip
 8056da4:	b289      	uxth	r1, r1
 8056da6:	3301      	adds	r3, #1
 8056da8:	eb01 4105 	add.w	r1, r1, r5, lsl #16
 8056dac:	429e      	cmp	r6, r3
 8056dae:	f840 1b04 	str.w	r1, [r0], #4
 8056db2:	ea4f 4815 	mov.w	r8, r5, lsr #16
 8056db6:	dcec      	bgt.n	8056d92 <__multadd+0x12>
 8056db8:	f1b8 0f00 	cmp.w	r8, #0
 8056dbc:	d022      	beq.n	8056e04 <__multadd+0x84>
 8056dbe:	68a3      	ldr	r3, [r4, #8]
 8056dc0:	42b3      	cmp	r3, r6
 8056dc2:	dc19      	bgt.n	8056df8 <__multadd+0x78>
 8056dc4:	6861      	ldr	r1, [r4, #4]
 8056dc6:	4638      	mov	r0, r7
 8056dc8:	3101      	adds	r1, #1
 8056dca:	f7ff ffab 	bl	8056d24 <_Balloc>
 8056dce:	4605      	mov	r5, r0
 8056dd0:	b928      	cbnz	r0, 8056dde <__multadd+0x5e>
 8056dd2:	4602      	mov	r2, r0
 8056dd4:	4b0d      	ldr	r3, [pc, #52]	; (8056e0c <__multadd+0x8c>)
 8056dd6:	480e      	ldr	r0, [pc, #56]	; (8056e10 <__multadd+0x90>)
 8056dd8:	21b5      	movs	r1, #181	; 0xb5
 8056dda:	f001 fa7d 	bl	80582d8 <__assert_func>
 8056dde:	6922      	ldr	r2, [r4, #16]
 8056de0:	3202      	adds	r2, #2
 8056de2:	f104 010c 	add.w	r1, r4, #12
 8056de6:	0092      	lsls	r2, r2, #2
 8056de8:	300c      	adds	r0, #12
 8056dea:	f7fa fe0b 	bl	8051a04 <memcpy>
 8056dee:	4621      	mov	r1, r4
 8056df0:	4638      	mov	r0, r7
 8056df2:	f7ff ffbc 	bl	8056d6e <_Bfree>
 8056df6:	462c      	mov	r4, r5
 8056df8:	eb04 0386 	add.w	r3, r4, r6, lsl #2
 8056dfc:	3601      	adds	r6, #1
 8056dfe:	f8c3 8014 	str.w	r8, [r3, #20]
 8056e02:	6126      	str	r6, [r4, #16]
 8056e04:	4620      	mov	r0, r4
 8056e06:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8056e0a:	bf00      	nop
 8056e0c:	0805acf7 	.word	0x0805acf7
 8056e10:	0805ade4 	.word	0x0805ade4

08056e14 <__s2b>:
 8056e14:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8056e18:	460c      	mov	r4, r1
 8056e1a:	4615      	mov	r5, r2
 8056e1c:	461f      	mov	r7, r3
 8056e1e:	2209      	movs	r2, #9
 8056e20:	3308      	adds	r3, #8
 8056e22:	4606      	mov	r6, r0
 8056e24:	fb93 f3f2 	sdiv	r3, r3, r2
 8056e28:	2100      	movs	r1, #0
 8056e2a:	2201      	movs	r2, #1
 8056e2c:	429a      	cmp	r2, r3
 8056e2e:	db09      	blt.n	8056e44 <__s2b+0x30>
 8056e30:	4630      	mov	r0, r6
 8056e32:	f7ff ff77 	bl	8056d24 <_Balloc>
 8056e36:	b940      	cbnz	r0, 8056e4a <__s2b+0x36>
 8056e38:	4602      	mov	r2, r0
 8056e3a:	4b19      	ldr	r3, [pc, #100]	; (8056ea0 <__s2b+0x8c>)
 8056e3c:	4819      	ldr	r0, [pc, #100]	; (8056ea4 <__s2b+0x90>)
 8056e3e:	21ce      	movs	r1, #206	; 0xce
 8056e40:	f001 fa4a 	bl	80582d8 <__assert_func>
 8056e44:	0052      	lsls	r2, r2, #1
 8056e46:	3101      	adds	r1, #1
 8056e48:	e7f0      	b.n	8056e2c <__s2b+0x18>
 8056e4a:	9b08      	ldr	r3, [sp, #32]
 8056e4c:	6143      	str	r3, [r0, #20]
 8056e4e:	2d09      	cmp	r5, #9
 8056e50:	f04f 0301 	mov.w	r3, #1
 8056e54:	6103      	str	r3, [r0, #16]
 8056e56:	dd16      	ble.n	8056e86 <__s2b+0x72>
 8056e58:	f104 0909 	add.w	r9, r4, #9
 8056e5c:	46c8      	mov	r8, r9
 8056e5e:	442c      	add	r4, r5
 8056e60:	f818 3b01 	ldrb.w	r3, [r8], #1
 8056e64:	4601      	mov	r1, r0
 8056e66:	3b30      	subs	r3, #48	; 0x30
 8056e68:	220a      	movs	r2, #10
 8056e6a:	4630      	mov	r0, r6
 8056e6c:	f7ff ff88 	bl	8056d80 <__multadd>
 8056e70:	45a0      	cmp	r8, r4
 8056e72:	d1f5      	bne.n	8056e60 <__s2b+0x4c>
 8056e74:	f1a5 0408 	sub.w	r4, r5, #8
 8056e78:	444c      	add	r4, r9
 8056e7a:	1b2d      	subs	r5, r5, r4
 8056e7c:	1963      	adds	r3, r4, r5
 8056e7e:	42bb      	cmp	r3, r7
 8056e80:	db04      	blt.n	8056e8c <__s2b+0x78>
 8056e82:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8056e86:	340a      	adds	r4, #10
 8056e88:	2509      	movs	r5, #9
 8056e8a:	e7f6      	b.n	8056e7a <__s2b+0x66>
 8056e8c:	f814 3b01 	ldrb.w	r3, [r4], #1
 8056e90:	4601      	mov	r1, r0
 8056e92:	3b30      	subs	r3, #48	; 0x30
 8056e94:	220a      	movs	r2, #10
 8056e96:	4630      	mov	r0, r6
 8056e98:	f7ff ff72 	bl	8056d80 <__multadd>
 8056e9c:	e7ee      	b.n	8056e7c <__s2b+0x68>
 8056e9e:	bf00      	nop
 8056ea0:	0805acf7 	.word	0x0805acf7
 8056ea4:	0805ade4 	.word	0x0805ade4

08056ea8 <__hi0bits>:
 8056ea8:	0c03      	lsrs	r3, r0, #16
 8056eaa:	041b      	lsls	r3, r3, #16
 8056eac:	b9d3      	cbnz	r3, 8056ee4 <__hi0bits+0x3c>
 8056eae:	0400      	lsls	r0, r0, #16
 8056eb0:	2310      	movs	r3, #16
 8056eb2:	f010 4f7f 	tst.w	r0, #4278190080	; 0xff000000
 8056eb6:	bf04      	itt	eq
 8056eb8:	0200      	lsleq	r0, r0, #8
 8056eba:	3308      	addeq	r3, #8
 8056ebc:	f010 4f70 	tst.w	r0, #4026531840	; 0xf0000000
 8056ec0:	bf04      	itt	eq
 8056ec2:	0100      	lsleq	r0, r0, #4
 8056ec4:	3304      	addeq	r3, #4
 8056ec6:	f010 4f40 	tst.w	r0, #3221225472	; 0xc0000000
 8056eca:	bf04      	itt	eq
 8056ecc:	0080      	lsleq	r0, r0, #2
 8056ece:	3302      	addeq	r3, #2
 8056ed0:	2800      	cmp	r0, #0
 8056ed2:	db05      	blt.n	8056ee0 <__hi0bits+0x38>
 8056ed4:	f010 4f80 	tst.w	r0, #1073741824	; 0x40000000
 8056ed8:	f103 0301 	add.w	r3, r3, #1
 8056edc:	bf08      	it	eq
 8056ede:	2320      	moveq	r3, #32
 8056ee0:	4618      	mov	r0, r3
 8056ee2:	4770      	bx	lr
 8056ee4:	2300      	movs	r3, #0
 8056ee6:	e7e4      	b.n	8056eb2 <__hi0bits+0xa>

08056ee8 <__lo0bits>:
 8056ee8:	6803      	ldr	r3, [r0, #0]
 8056eea:	f013 0207 	ands.w	r2, r3, #7
 8056eee:	4601      	mov	r1, r0
 8056ef0:	d00b      	beq.n	8056f0a <__lo0bits+0x22>
 8056ef2:	07da      	lsls	r2, r3, #31
 8056ef4:	d424      	bmi.n	8056f40 <__lo0bits+0x58>
 8056ef6:	0798      	lsls	r0, r3, #30
 8056ef8:	bf49      	itett	mi
 8056efa:	085b      	lsrmi	r3, r3, #1
 8056efc:	089b      	lsrpl	r3, r3, #2
 8056efe:	2001      	movmi	r0, #1
 8056f00:	600b      	strmi	r3, [r1, #0]
 8056f02:	bf5c      	itt	pl
 8056f04:	600b      	strpl	r3, [r1, #0]
 8056f06:	2002      	movpl	r0, #2
 8056f08:	4770      	bx	lr
 8056f0a:	b298      	uxth	r0, r3
 8056f0c:	b9b0      	cbnz	r0, 8056f3c <__lo0bits+0x54>
 8056f0e:	0c1b      	lsrs	r3, r3, #16
 8056f10:	2010      	movs	r0, #16
 8056f12:	f013 0fff 	tst.w	r3, #255	; 0xff
 8056f16:	bf04      	itt	eq
 8056f18:	0a1b      	lsreq	r3, r3, #8
 8056f1a:	3008      	addeq	r0, #8
 8056f1c:	071a      	lsls	r2, r3, #28
 8056f1e:	bf04      	itt	eq
 8056f20:	091b      	lsreq	r3, r3, #4
 8056f22:	3004      	addeq	r0, #4
 8056f24:	079a      	lsls	r2, r3, #30
 8056f26:	bf04      	itt	eq
 8056f28:	089b      	lsreq	r3, r3, #2
 8056f2a:	3002      	addeq	r0, #2
 8056f2c:	07da      	lsls	r2, r3, #31
 8056f2e:	d403      	bmi.n	8056f38 <__lo0bits+0x50>
 8056f30:	085b      	lsrs	r3, r3, #1
 8056f32:	f100 0001 	add.w	r0, r0, #1
 8056f36:	d005      	beq.n	8056f44 <__lo0bits+0x5c>
 8056f38:	600b      	str	r3, [r1, #0]
 8056f3a:	4770      	bx	lr
 8056f3c:	4610      	mov	r0, r2
 8056f3e:	e7e8      	b.n	8056f12 <__lo0bits+0x2a>
 8056f40:	2000      	movs	r0, #0
 8056f42:	4770      	bx	lr
 8056f44:	2020      	movs	r0, #32
 8056f46:	4770      	bx	lr

08056f48 <__i2b>:
 8056f48:	b510      	push	{r4, lr}
 8056f4a:	460c      	mov	r4, r1
 8056f4c:	2101      	movs	r1, #1
 8056f4e:	f7ff fee9 	bl	8056d24 <_Balloc>
 8056f52:	4602      	mov	r2, r0
 8056f54:	b928      	cbnz	r0, 8056f62 <__i2b+0x1a>
 8056f56:	4b05      	ldr	r3, [pc, #20]	; (8056f6c <__i2b+0x24>)
 8056f58:	4805      	ldr	r0, [pc, #20]	; (8056f70 <__i2b+0x28>)
 8056f5a:	f44f 71a0 	mov.w	r1, #320	; 0x140
 8056f5e:	f001 f9bb 	bl	80582d8 <__assert_func>
 8056f62:	2301      	movs	r3, #1
 8056f64:	6144      	str	r4, [r0, #20]
 8056f66:	6103      	str	r3, [r0, #16]
 8056f68:	bd10      	pop	{r4, pc}
 8056f6a:	bf00      	nop
 8056f6c:	0805acf7 	.word	0x0805acf7
 8056f70:	0805ade4 	.word	0x0805ade4

08056f74 <__multiply>:
 8056f74:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8056f78:	4614      	mov	r4, r2
 8056f7a:	690a      	ldr	r2, [r1, #16]
 8056f7c:	6923      	ldr	r3, [r4, #16]
 8056f7e:	429a      	cmp	r2, r3
 8056f80:	bfb8      	it	lt
 8056f82:	460b      	movlt	r3, r1
 8056f84:	460d      	mov	r5, r1
 8056f86:	bfbc      	itt	lt
 8056f88:	4625      	movlt	r5, r4
 8056f8a:	461c      	movlt	r4, r3
 8056f8c:	f8d5 a010 	ldr.w	sl, [r5, #16]
 8056f90:	f8d4 9010 	ldr.w	r9, [r4, #16]
 8056f94:	68ab      	ldr	r3, [r5, #8]
 8056f96:	6869      	ldr	r1, [r5, #4]
 8056f98:	eb0a 0709 	add.w	r7, sl, r9
 8056f9c:	42bb      	cmp	r3, r7
 8056f9e:	b085      	sub	sp, #20
 8056fa0:	bfb8      	it	lt
 8056fa2:	3101      	addlt	r1, #1
 8056fa4:	f7ff febe 	bl	8056d24 <_Balloc>
 8056fa8:	b930      	cbnz	r0, 8056fb8 <__multiply+0x44>
 8056faa:	4602      	mov	r2, r0
 8056fac:	4b42      	ldr	r3, [pc, #264]	; (80570b8 <__multiply+0x144>)
 8056fae:	4843      	ldr	r0, [pc, #268]	; (80570bc <__multiply+0x148>)
 8056fb0:	f240 115d 	movw	r1, #349	; 0x15d
 8056fb4:	f001 f990 	bl	80582d8 <__assert_func>
 8056fb8:	f100 0614 	add.w	r6, r0, #20
 8056fbc:	eb06 0887 	add.w	r8, r6, r7, lsl #2
 8056fc0:	4633      	mov	r3, r6
 8056fc2:	2200      	movs	r2, #0
 8056fc4:	4543      	cmp	r3, r8
 8056fc6:	d31e      	bcc.n	8057006 <__multiply+0x92>
 8056fc8:	f105 0c14 	add.w	ip, r5, #20
 8056fcc:	f104 0314 	add.w	r3, r4, #20
 8056fd0:	eb0c 0c8a 	add.w	ip, ip, sl, lsl #2
 8056fd4:	eb03 0289 	add.w	r2, r3, r9, lsl #2
 8056fd8:	9202      	str	r2, [sp, #8]
 8056fda:	ebac 0205 	sub.w	r2, ip, r5
 8056fde:	3a15      	subs	r2, #21
 8056fe0:	f022 0203 	bic.w	r2, r2, #3
 8056fe4:	3204      	adds	r2, #4
 8056fe6:	f105 0115 	add.w	r1, r5, #21
 8056fea:	458c      	cmp	ip, r1
 8056fec:	bf38      	it	cc
 8056fee:	2204      	movcc	r2, #4
 8056ff0:	9201      	str	r2, [sp, #4]
 8056ff2:	9a02      	ldr	r2, [sp, #8]
 8056ff4:	9303      	str	r3, [sp, #12]
 8056ff6:	429a      	cmp	r2, r3
 8056ff8:	d808      	bhi.n	805700c <__multiply+0x98>
 8056ffa:	2f00      	cmp	r7, #0
 8056ffc:	dc55      	bgt.n	80570aa <__multiply+0x136>
 8056ffe:	6107      	str	r7, [r0, #16]
 8057000:	b005      	add	sp, #20
 8057002:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8057006:	f843 2b04 	str.w	r2, [r3], #4
 805700a:	e7db      	b.n	8056fc4 <__multiply+0x50>
 805700c:	f8b3 a000 	ldrh.w	sl, [r3]
 8057010:	f1ba 0f00 	cmp.w	sl, #0
 8057014:	d020      	beq.n	8057058 <__multiply+0xe4>
 8057016:	f105 0e14 	add.w	lr, r5, #20
 805701a:	46b1      	mov	r9, r6
 805701c:	2200      	movs	r2, #0
 805701e:	f85e 4b04 	ldr.w	r4, [lr], #4
 8057022:	f8d9 b000 	ldr.w	fp, [r9]
 8057026:	b2a1      	uxth	r1, r4
 8057028:	fa1f fb8b 	uxth.w	fp, fp
 805702c:	fb0a b101 	mla	r1, sl, r1, fp
 8057030:	4411      	add	r1, r2
 8057032:	f8d9 2000 	ldr.w	r2, [r9]
 8057036:	0c24      	lsrs	r4, r4, #16
 8057038:	0c12      	lsrs	r2, r2, #16
 805703a:	fb0a 2404 	mla	r4, sl, r4, r2
 805703e:	eb04 4411 	add.w	r4, r4, r1, lsr #16
 8057042:	b289      	uxth	r1, r1
 8057044:	ea41 4104 	orr.w	r1, r1, r4, lsl #16
 8057048:	45f4      	cmp	ip, lr
 805704a:	f849 1b04 	str.w	r1, [r9], #4
 805704e:	ea4f 4214 	mov.w	r2, r4, lsr #16
 8057052:	d8e4      	bhi.n	805701e <__multiply+0xaa>
 8057054:	9901      	ldr	r1, [sp, #4]
 8057056:	5072      	str	r2, [r6, r1]
 8057058:	9a03      	ldr	r2, [sp, #12]
 805705a:	f8b2 9002 	ldrh.w	r9, [r2, #2]
 805705e:	3304      	adds	r3, #4
 8057060:	f1b9 0f00 	cmp.w	r9, #0
 8057064:	d01f      	beq.n	80570a6 <__multiply+0x132>
 8057066:	6834      	ldr	r4, [r6, #0]
 8057068:	f105 0114 	add.w	r1, r5, #20
 805706c:	46b6      	mov	lr, r6
 805706e:	f04f 0a00 	mov.w	sl, #0
 8057072:	880a      	ldrh	r2, [r1, #0]
 8057074:	f8be b002 	ldrh.w	fp, [lr, #2]
 8057078:	fb09 b202 	mla	r2, r9, r2, fp
 805707c:	4492      	add	sl, r2
 805707e:	b2a4      	uxth	r4, r4
 8057080:	ea44 440a 	orr.w	r4, r4, sl, lsl #16
 8057084:	f84e 4b04 	str.w	r4, [lr], #4
 8057088:	f851 4b04 	ldr.w	r4, [r1], #4
 805708c:	f8be 2000 	ldrh.w	r2, [lr]
 8057090:	0c24      	lsrs	r4, r4, #16
 8057092:	fb09 2404 	mla	r4, r9, r4, r2
 8057096:	eb04 441a 	add.w	r4, r4, sl, lsr #16
 805709a:	458c      	cmp	ip, r1
 805709c:	ea4f 4a14 	mov.w	sl, r4, lsr #16
 80570a0:	d8e7      	bhi.n	8057072 <__multiply+0xfe>
 80570a2:	9a01      	ldr	r2, [sp, #4]
 80570a4:	50b4      	str	r4, [r6, r2]
 80570a6:	3604      	adds	r6, #4
 80570a8:	e7a3      	b.n	8056ff2 <__multiply+0x7e>
 80570aa:	f858 3d04 	ldr.w	r3, [r8, #-4]!
 80570ae:	2b00      	cmp	r3, #0
 80570b0:	d1a5      	bne.n	8056ffe <__multiply+0x8a>
 80570b2:	3f01      	subs	r7, #1
 80570b4:	e7a1      	b.n	8056ffa <__multiply+0x86>
 80570b6:	bf00      	nop
 80570b8:	0805acf7 	.word	0x0805acf7
 80570bc:	0805ade4 	.word	0x0805ade4

080570c0 <__pow5mult>:
 80570c0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80570c4:	4615      	mov	r5, r2
 80570c6:	f012 0203 	ands.w	r2, r2, #3
 80570ca:	4606      	mov	r6, r0
 80570cc:	460f      	mov	r7, r1
 80570ce:	d007      	beq.n	80570e0 <__pow5mult+0x20>
 80570d0:	4c1a      	ldr	r4, [pc, #104]	; (805713c <__pow5mult+0x7c>)
 80570d2:	3a01      	subs	r2, #1
 80570d4:	2300      	movs	r3, #0
 80570d6:	f854 2022 	ldr.w	r2, [r4, r2, lsl #2]
 80570da:	f7ff fe51 	bl	8056d80 <__multadd>
 80570de:	4607      	mov	r7, r0
 80570e0:	10ad      	asrs	r5, r5, #2
 80570e2:	d027      	beq.n	8057134 <__pow5mult+0x74>
 80570e4:	6cb4      	ldr	r4, [r6, #72]	; 0x48
 80570e6:	b944      	cbnz	r4, 80570fa <__pow5mult+0x3a>
 80570e8:	f240 2171 	movw	r1, #625	; 0x271
 80570ec:	4630      	mov	r0, r6
 80570ee:	f7ff ff2b 	bl	8056f48 <__i2b>
 80570f2:	2300      	movs	r3, #0
 80570f4:	64b0      	str	r0, [r6, #72]	; 0x48
 80570f6:	4604      	mov	r4, r0
 80570f8:	6003      	str	r3, [r0, #0]
 80570fa:	f04f 0900 	mov.w	r9, #0
 80570fe:	07eb      	lsls	r3, r5, #31
 8057100:	d50a      	bpl.n	8057118 <__pow5mult+0x58>
 8057102:	4639      	mov	r1, r7
 8057104:	4622      	mov	r2, r4
 8057106:	4630      	mov	r0, r6
 8057108:	f7ff ff34 	bl	8056f74 <__multiply>
 805710c:	4639      	mov	r1, r7
 805710e:	4680      	mov	r8, r0
 8057110:	4630      	mov	r0, r6
 8057112:	f7ff fe2c 	bl	8056d6e <_Bfree>
 8057116:	4647      	mov	r7, r8
 8057118:	106d      	asrs	r5, r5, #1
 805711a:	d00b      	beq.n	8057134 <__pow5mult+0x74>
 805711c:	6820      	ldr	r0, [r4, #0]
 805711e:	b938      	cbnz	r0, 8057130 <__pow5mult+0x70>
 8057120:	4622      	mov	r2, r4
 8057122:	4621      	mov	r1, r4
 8057124:	4630      	mov	r0, r6
 8057126:	f7ff ff25 	bl	8056f74 <__multiply>
 805712a:	6020      	str	r0, [r4, #0]
 805712c:	f8c0 9000 	str.w	r9, [r0]
 8057130:	4604      	mov	r4, r0
 8057132:	e7e4      	b.n	80570fe <__pow5mult+0x3e>
 8057134:	4638      	mov	r0, r7
 8057136:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 805713a:	bf00      	nop
 805713c:	0805af38 	.word	0x0805af38

08057140 <__lshift>:
 8057140:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8057144:	460c      	mov	r4, r1
 8057146:	6849      	ldr	r1, [r1, #4]
 8057148:	6923      	ldr	r3, [r4, #16]
 805714a:	eb03 1862 	add.w	r8, r3, r2, asr #5
 805714e:	68a3      	ldr	r3, [r4, #8]
 8057150:	4607      	mov	r7, r0
 8057152:	4691      	mov	r9, r2
 8057154:	ea4f 1a62 	mov.w	sl, r2, asr #5
 8057158:	f108 0601 	add.w	r6, r8, #1
 805715c:	42b3      	cmp	r3, r6
 805715e:	db0b      	blt.n	8057178 <__lshift+0x38>
 8057160:	4638      	mov	r0, r7
 8057162:	f7ff fddf 	bl	8056d24 <_Balloc>
 8057166:	4605      	mov	r5, r0
 8057168:	b948      	cbnz	r0, 805717e <__lshift+0x3e>
 805716a:	4602      	mov	r2, r0
 805716c:	4b28      	ldr	r3, [pc, #160]	; (8057210 <__lshift+0xd0>)
 805716e:	4829      	ldr	r0, [pc, #164]	; (8057214 <__lshift+0xd4>)
 8057170:	f240 11d9 	movw	r1, #473	; 0x1d9
 8057174:	f001 f8b0 	bl	80582d8 <__assert_func>
 8057178:	3101      	adds	r1, #1
 805717a:	005b      	lsls	r3, r3, #1
 805717c:	e7ee      	b.n	805715c <__lshift+0x1c>
 805717e:	2300      	movs	r3, #0
 8057180:	f100 0114 	add.w	r1, r0, #20
 8057184:	f100 0210 	add.w	r2, r0, #16
 8057188:	4618      	mov	r0, r3
 805718a:	4553      	cmp	r3, sl
 805718c:	db33      	blt.n	80571f6 <__lshift+0xb6>
 805718e:	6920      	ldr	r0, [r4, #16]
 8057190:	ea2a 7aea 	bic.w	sl, sl, sl, asr #31
 8057194:	f104 0314 	add.w	r3, r4, #20
 8057198:	f019 091f 	ands.w	r9, r9, #31
 805719c:	eb01 018a 	add.w	r1, r1, sl, lsl #2
 80571a0:	eb03 0c80 	add.w	ip, r3, r0, lsl #2
 80571a4:	d02b      	beq.n	80571fe <__lshift+0xbe>
 80571a6:	f1c9 0e20 	rsb	lr, r9, #32
 80571aa:	468a      	mov	sl, r1
 80571ac:	2200      	movs	r2, #0
 80571ae:	6818      	ldr	r0, [r3, #0]
 80571b0:	fa00 f009 	lsl.w	r0, r0, r9
 80571b4:	4302      	orrs	r2, r0
 80571b6:	f84a 2b04 	str.w	r2, [sl], #4
 80571ba:	f853 2b04 	ldr.w	r2, [r3], #4
 80571be:	459c      	cmp	ip, r3
 80571c0:	fa22 f20e 	lsr.w	r2, r2, lr
 80571c4:	d8f3      	bhi.n	80571ae <__lshift+0x6e>
 80571c6:	ebac 0304 	sub.w	r3, ip, r4
 80571ca:	3b15      	subs	r3, #21
 80571cc:	f023 0303 	bic.w	r3, r3, #3
 80571d0:	3304      	adds	r3, #4
 80571d2:	f104 0015 	add.w	r0, r4, #21
 80571d6:	4584      	cmp	ip, r0
 80571d8:	bf38      	it	cc
 80571da:	2304      	movcc	r3, #4
 80571dc:	50ca      	str	r2, [r1, r3]
 80571de:	b10a      	cbz	r2, 80571e4 <__lshift+0xa4>
 80571e0:	f108 0602 	add.w	r6, r8, #2
 80571e4:	3e01      	subs	r6, #1
 80571e6:	4638      	mov	r0, r7
 80571e8:	612e      	str	r6, [r5, #16]
 80571ea:	4621      	mov	r1, r4
 80571ec:	f7ff fdbf 	bl	8056d6e <_Bfree>
 80571f0:	4628      	mov	r0, r5
 80571f2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80571f6:	f842 0f04 	str.w	r0, [r2, #4]!
 80571fa:	3301      	adds	r3, #1
 80571fc:	e7c5      	b.n	805718a <__lshift+0x4a>
 80571fe:	3904      	subs	r1, #4
 8057200:	f853 2b04 	ldr.w	r2, [r3], #4
 8057204:	f841 2f04 	str.w	r2, [r1, #4]!
 8057208:	459c      	cmp	ip, r3
 805720a:	d8f9      	bhi.n	8057200 <__lshift+0xc0>
 805720c:	e7ea      	b.n	80571e4 <__lshift+0xa4>
 805720e:	bf00      	nop
 8057210:	0805acf7 	.word	0x0805acf7
 8057214:	0805ade4 	.word	0x0805ade4

08057218 <__mcmp>:
 8057218:	b530      	push	{r4, r5, lr}
 805721a:	6902      	ldr	r2, [r0, #16]
 805721c:	690c      	ldr	r4, [r1, #16]
 805721e:	1b12      	subs	r2, r2, r4
 8057220:	d10e      	bne.n	8057240 <__mcmp+0x28>
 8057222:	f100 0314 	add.w	r3, r0, #20
 8057226:	3114      	adds	r1, #20
 8057228:	eb03 0084 	add.w	r0, r3, r4, lsl #2
 805722c:	eb01 0184 	add.w	r1, r1, r4, lsl #2
 8057230:	f850 5d04 	ldr.w	r5, [r0, #-4]!
 8057234:	f851 4d04 	ldr.w	r4, [r1, #-4]!
 8057238:	42a5      	cmp	r5, r4
 805723a:	d003      	beq.n	8057244 <__mcmp+0x2c>
 805723c:	d305      	bcc.n	805724a <__mcmp+0x32>
 805723e:	2201      	movs	r2, #1
 8057240:	4610      	mov	r0, r2
 8057242:	bd30      	pop	{r4, r5, pc}
 8057244:	4283      	cmp	r3, r0
 8057246:	d3f3      	bcc.n	8057230 <__mcmp+0x18>
 8057248:	e7fa      	b.n	8057240 <__mcmp+0x28>
 805724a:	f04f 32ff 	mov.w	r2, #4294967295
 805724e:	e7f7      	b.n	8057240 <__mcmp+0x28>

08057250 <__mdiff>:
 8057250:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8057254:	460c      	mov	r4, r1
 8057256:	4606      	mov	r6, r0
 8057258:	4611      	mov	r1, r2
 805725a:	4620      	mov	r0, r4
 805725c:	4617      	mov	r7, r2
 805725e:	f7ff ffdb 	bl	8057218 <__mcmp>
 8057262:	1e05      	subs	r5, r0, #0
 8057264:	d110      	bne.n	8057288 <__mdiff+0x38>
 8057266:	4629      	mov	r1, r5
 8057268:	4630      	mov	r0, r6
 805726a:	f7ff fd5b 	bl	8056d24 <_Balloc>
 805726e:	b930      	cbnz	r0, 805727e <__mdiff+0x2e>
 8057270:	4b39      	ldr	r3, [pc, #228]	; (8057358 <__mdiff+0x108>)
 8057272:	4602      	mov	r2, r0
 8057274:	f240 2132 	movw	r1, #562	; 0x232
 8057278:	4838      	ldr	r0, [pc, #224]	; (805735c <__mdiff+0x10c>)
 805727a:	f001 f82d 	bl	80582d8 <__assert_func>
 805727e:	2301      	movs	r3, #1
 8057280:	e9c0 3504 	strd	r3, r5, [r0, #16]
 8057284:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8057288:	bfa4      	itt	ge
 805728a:	463b      	movge	r3, r7
 805728c:	4627      	movge	r7, r4
 805728e:	4630      	mov	r0, r6
 8057290:	6879      	ldr	r1, [r7, #4]
 8057292:	bfa6      	itte	ge
 8057294:	461c      	movge	r4, r3
 8057296:	2500      	movge	r5, #0
 8057298:	2501      	movlt	r5, #1
 805729a:	f7ff fd43 	bl	8056d24 <_Balloc>
 805729e:	b920      	cbnz	r0, 80572aa <__mdiff+0x5a>
 80572a0:	4b2d      	ldr	r3, [pc, #180]	; (8057358 <__mdiff+0x108>)
 80572a2:	4602      	mov	r2, r0
 80572a4:	f44f 7110 	mov.w	r1, #576	; 0x240
 80572a8:	e7e6      	b.n	8057278 <__mdiff+0x28>
 80572aa:	693e      	ldr	r6, [r7, #16]
 80572ac:	60c5      	str	r5, [r0, #12]
 80572ae:	6925      	ldr	r5, [r4, #16]
 80572b0:	f107 0114 	add.w	r1, r7, #20
 80572b4:	f104 0914 	add.w	r9, r4, #20
 80572b8:	f100 0e14 	add.w	lr, r0, #20
 80572bc:	f107 0210 	add.w	r2, r7, #16
 80572c0:	eb01 0c86 	add.w	ip, r1, r6, lsl #2
 80572c4:	eb09 0585 	add.w	r5, r9, r5, lsl #2
 80572c8:	46f2      	mov	sl, lr
 80572ca:	2700      	movs	r7, #0
 80572cc:	f859 3b04 	ldr.w	r3, [r9], #4
 80572d0:	f852 bf04 	ldr.w	fp, [r2, #4]!
 80572d4:	fa1f f883 	uxth.w	r8, r3
 80572d8:	fa17 f78b 	uxtah	r7, r7, fp
 80572dc:	0c1b      	lsrs	r3, r3, #16
 80572de:	eba7 0808 	sub.w	r8, r7, r8
 80572e2:	ebc3 431b 	rsb	r3, r3, fp, lsr #16
 80572e6:	eb03 4328 	add.w	r3, r3, r8, asr #16
 80572ea:	fa1f f888 	uxth.w	r8, r8
 80572ee:	141f      	asrs	r7, r3, #16
 80572f0:	454d      	cmp	r5, r9
 80572f2:	ea48 4303 	orr.w	r3, r8, r3, lsl #16
 80572f6:	f84a 3b04 	str.w	r3, [sl], #4
 80572fa:	d8e7      	bhi.n	80572cc <__mdiff+0x7c>
 80572fc:	1b2b      	subs	r3, r5, r4
 80572fe:	3b15      	subs	r3, #21
 8057300:	f023 0303 	bic.w	r3, r3, #3
 8057304:	3304      	adds	r3, #4
 8057306:	3415      	adds	r4, #21
 8057308:	42a5      	cmp	r5, r4
 805730a:	bf38      	it	cc
 805730c:	2304      	movcc	r3, #4
 805730e:	4419      	add	r1, r3
 8057310:	4473      	add	r3, lr
 8057312:	469e      	mov	lr, r3
 8057314:	460d      	mov	r5, r1
 8057316:	4565      	cmp	r5, ip
 8057318:	d30e      	bcc.n	8057338 <__mdiff+0xe8>
 805731a:	f10c 0203 	add.w	r2, ip, #3
 805731e:	1a52      	subs	r2, r2, r1
 8057320:	f022 0203 	bic.w	r2, r2, #3
 8057324:	3903      	subs	r1, #3
 8057326:	458c      	cmp	ip, r1
 8057328:	bf38      	it	cc
 805732a:	2200      	movcc	r2, #0
 805732c:	441a      	add	r2, r3
 805732e:	f852 3d04 	ldr.w	r3, [r2, #-4]!
 8057332:	b17b      	cbz	r3, 8057354 <__mdiff+0x104>
 8057334:	6106      	str	r6, [r0, #16]
 8057336:	e7a5      	b.n	8057284 <__mdiff+0x34>
 8057338:	f855 8b04 	ldr.w	r8, [r5], #4
 805733c:	fa17 f488 	uxtah	r4, r7, r8
 8057340:	1422      	asrs	r2, r4, #16
 8057342:	eb02 4218 	add.w	r2, r2, r8, lsr #16
 8057346:	b2a4      	uxth	r4, r4
 8057348:	ea44 4402 	orr.w	r4, r4, r2, lsl #16
 805734c:	f84e 4b04 	str.w	r4, [lr], #4
 8057350:	1417      	asrs	r7, r2, #16
 8057352:	e7e0      	b.n	8057316 <__mdiff+0xc6>
 8057354:	3e01      	subs	r6, #1
 8057356:	e7ea      	b.n	805732e <__mdiff+0xde>
 8057358:	0805acf7 	.word	0x0805acf7
 805735c:	0805ade4 	.word	0x0805ade4

08057360 <__ulp>:
 8057360:	b082      	sub	sp, #8
 8057362:	ed8d 0b00 	vstr	d0, [sp]
 8057366:	9b01      	ldr	r3, [sp, #4]
 8057368:	4912      	ldr	r1, [pc, #72]	; (80573b4 <__ulp+0x54>)
 805736a:	4019      	ands	r1, r3
 805736c:	f1a1 7150 	sub.w	r1, r1, #54525952	; 0x3400000
 8057370:	2900      	cmp	r1, #0
 8057372:	dd05      	ble.n	8057380 <__ulp+0x20>
 8057374:	2200      	movs	r2, #0
 8057376:	460b      	mov	r3, r1
 8057378:	ec43 2b10 	vmov	d0, r2, r3
 805737c:	b002      	add	sp, #8
 805737e:	4770      	bx	lr
 8057380:	4249      	negs	r1, r1
 8057382:	f1b1 7fa0 	cmp.w	r1, #20971520	; 0x1400000
 8057386:	ea4f 5021 	mov.w	r0, r1, asr #20
 805738a:	f04f 0200 	mov.w	r2, #0
 805738e:	f04f 0300 	mov.w	r3, #0
 8057392:	da04      	bge.n	805739e <__ulp+0x3e>
 8057394:	f44f 2100 	mov.w	r1, #524288	; 0x80000
 8057398:	fa41 f300 	asr.w	r3, r1, r0
 805739c:	e7ec      	b.n	8057378 <__ulp+0x18>
 805739e:	f1a0 0114 	sub.w	r1, r0, #20
 80573a2:	291e      	cmp	r1, #30
 80573a4:	bfda      	itte	le
 80573a6:	f04f 4000 	movle.w	r0, #2147483648	; 0x80000000
 80573aa:	fa20 f101 	lsrle.w	r1, r0, r1
 80573ae:	2101      	movgt	r1, #1
 80573b0:	460a      	mov	r2, r1
 80573b2:	e7e1      	b.n	8057378 <__ulp+0x18>
 80573b4:	7ff00000 	.word	0x7ff00000

080573b8 <__b2d>:
 80573b8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80573ba:	6905      	ldr	r5, [r0, #16]
 80573bc:	f100 0714 	add.w	r7, r0, #20
 80573c0:	eb07 0585 	add.w	r5, r7, r5, lsl #2
 80573c4:	1f2e      	subs	r6, r5, #4
 80573c6:	f855 4c04 	ldr.w	r4, [r5, #-4]
 80573ca:	4620      	mov	r0, r4
 80573cc:	f7ff fd6c 	bl	8056ea8 <__hi0bits>
 80573d0:	f1c0 0320 	rsb	r3, r0, #32
 80573d4:	280a      	cmp	r0, #10
 80573d6:	f8df c07c 	ldr.w	ip, [pc, #124]	; 8057454 <__b2d+0x9c>
 80573da:	600b      	str	r3, [r1, #0]
 80573dc:	dc14      	bgt.n	8057408 <__b2d+0x50>
 80573de:	f1c0 0e0b 	rsb	lr, r0, #11
 80573e2:	fa24 f10e 	lsr.w	r1, r4, lr
 80573e6:	42b7      	cmp	r7, r6
 80573e8:	ea41 030c 	orr.w	r3, r1, ip
 80573ec:	bf34      	ite	cc
 80573ee:	f855 1c08 	ldrcc.w	r1, [r5, #-8]
 80573f2:	2100      	movcs	r1, #0
 80573f4:	3015      	adds	r0, #21
 80573f6:	fa04 f000 	lsl.w	r0, r4, r0
 80573fa:	fa21 f10e 	lsr.w	r1, r1, lr
 80573fe:	ea40 0201 	orr.w	r2, r0, r1
 8057402:	ec43 2b10 	vmov	d0, r2, r3
 8057406:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8057408:	42b7      	cmp	r7, r6
 805740a:	bf3a      	itte	cc
 805740c:	f855 1c08 	ldrcc.w	r1, [r5, #-8]
 8057410:	f1a5 0608 	subcc.w	r6, r5, #8
 8057414:	2100      	movcs	r1, #0
 8057416:	380b      	subs	r0, #11
 8057418:	d017      	beq.n	805744a <__b2d+0x92>
 805741a:	f1c0 0c20 	rsb	ip, r0, #32
 805741e:	fa04 f500 	lsl.w	r5, r4, r0
 8057422:	42be      	cmp	r6, r7
 8057424:	fa21 f40c 	lsr.w	r4, r1, ip
 8057428:	ea45 0504 	orr.w	r5, r5, r4
 805742c:	bf8c      	ite	hi
 805742e:	f856 4c04 	ldrhi.w	r4, [r6, #-4]
 8057432:	2400      	movls	r4, #0
 8057434:	f045 537f 	orr.w	r3, r5, #1069547520	; 0x3fc00000
 8057438:	fa01 f000 	lsl.w	r0, r1, r0
 805743c:	fa24 f40c 	lsr.w	r4, r4, ip
 8057440:	f443 1340 	orr.w	r3, r3, #3145728	; 0x300000
 8057444:	ea40 0204 	orr.w	r2, r0, r4
 8057448:	e7db      	b.n	8057402 <__b2d+0x4a>
 805744a:	ea44 030c 	orr.w	r3, r4, ip
 805744e:	460a      	mov	r2, r1
 8057450:	e7d7      	b.n	8057402 <__b2d+0x4a>
 8057452:	bf00      	nop
 8057454:	3ff00000 	.word	0x3ff00000

08057458 <__d2b>:
 8057458:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
 805745c:	4689      	mov	r9, r1
 805745e:	2101      	movs	r1, #1
 8057460:	ec57 6b10 	vmov	r6, r7, d0
 8057464:	4690      	mov	r8, r2
 8057466:	f7ff fc5d 	bl	8056d24 <_Balloc>
 805746a:	4604      	mov	r4, r0
 805746c:	b930      	cbnz	r0, 805747c <__d2b+0x24>
 805746e:	4602      	mov	r2, r0
 8057470:	4b25      	ldr	r3, [pc, #148]	; (8057508 <__d2b+0xb0>)
 8057472:	4826      	ldr	r0, [pc, #152]	; (805750c <__d2b+0xb4>)
 8057474:	f240 310a 	movw	r1, #778	; 0x30a
 8057478:	f000 ff2e 	bl	80582d8 <__assert_func>
 805747c:	f3c7 550a 	ubfx	r5, r7, #20, #11
 8057480:	f3c7 0313 	ubfx	r3, r7, #0, #20
 8057484:	bb35      	cbnz	r5, 80574d4 <__d2b+0x7c>
 8057486:	2e00      	cmp	r6, #0
 8057488:	9301      	str	r3, [sp, #4]
 805748a:	d028      	beq.n	80574de <__d2b+0x86>
 805748c:	4668      	mov	r0, sp
 805748e:	9600      	str	r6, [sp, #0]
 8057490:	f7ff fd2a 	bl	8056ee8 <__lo0bits>
 8057494:	9900      	ldr	r1, [sp, #0]
 8057496:	b300      	cbz	r0, 80574da <__d2b+0x82>
 8057498:	9a01      	ldr	r2, [sp, #4]
 805749a:	f1c0 0320 	rsb	r3, r0, #32
 805749e:	fa02 f303 	lsl.w	r3, r2, r3
 80574a2:	430b      	orrs	r3, r1
 80574a4:	40c2      	lsrs	r2, r0
 80574a6:	6163      	str	r3, [r4, #20]
 80574a8:	9201      	str	r2, [sp, #4]
 80574aa:	9b01      	ldr	r3, [sp, #4]
 80574ac:	61a3      	str	r3, [r4, #24]
 80574ae:	2b00      	cmp	r3, #0
 80574b0:	bf14      	ite	ne
 80574b2:	2202      	movne	r2, #2
 80574b4:	2201      	moveq	r2, #1
 80574b6:	6122      	str	r2, [r4, #16]
 80574b8:	b1d5      	cbz	r5, 80574f0 <__d2b+0x98>
 80574ba:	f2a5 4533 	subw	r5, r5, #1075	; 0x433
 80574be:	4405      	add	r5, r0
 80574c0:	f8c9 5000 	str.w	r5, [r9]
 80574c4:	f1c0 0035 	rsb	r0, r0, #53	; 0x35
 80574c8:	f8c8 0000 	str.w	r0, [r8]
 80574cc:	4620      	mov	r0, r4
 80574ce:	b003      	add	sp, #12
 80574d0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 80574d4:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 80574d8:	e7d5      	b.n	8057486 <__d2b+0x2e>
 80574da:	6161      	str	r1, [r4, #20]
 80574dc:	e7e5      	b.n	80574aa <__d2b+0x52>
 80574de:	a801      	add	r0, sp, #4
 80574e0:	f7ff fd02 	bl	8056ee8 <__lo0bits>
 80574e4:	9b01      	ldr	r3, [sp, #4]
 80574e6:	6163      	str	r3, [r4, #20]
 80574e8:	2201      	movs	r2, #1
 80574ea:	6122      	str	r2, [r4, #16]
 80574ec:	3020      	adds	r0, #32
 80574ee:	e7e3      	b.n	80574b8 <__d2b+0x60>
 80574f0:	eb04 0382 	add.w	r3, r4, r2, lsl #2
 80574f4:	f2a0 4032 	subw	r0, r0, #1074	; 0x432
 80574f8:	f8c9 0000 	str.w	r0, [r9]
 80574fc:	6918      	ldr	r0, [r3, #16]
 80574fe:	f7ff fcd3 	bl	8056ea8 <__hi0bits>
 8057502:	ebc0 1042 	rsb	r0, r0, r2, lsl #5
 8057506:	e7df      	b.n	80574c8 <__d2b+0x70>
 8057508:	0805acf7 	.word	0x0805acf7
 805750c:	0805ade4 	.word	0x0805ade4

08057510 <__ratio>:
 8057510:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8057514:	4688      	mov	r8, r1
 8057516:	4669      	mov	r1, sp
 8057518:	4681      	mov	r9, r0
 805751a:	f7ff ff4d 	bl	80573b8 <__b2d>
 805751e:	a901      	add	r1, sp, #4
 8057520:	4640      	mov	r0, r8
 8057522:	ec55 4b10 	vmov	r4, r5, d0
 8057526:	f7ff ff47 	bl	80573b8 <__b2d>
 805752a:	f8d9 3010 	ldr.w	r3, [r9, #16]
 805752e:	f8d8 2010 	ldr.w	r2, [r8, #16]
 8057532:	eba3 0c02 	sub.w	ip, r3, r2
 8057536:	e9dd 3200 	ldrd	r3, r2, [sp]
 805753a:	1a9b      	subs	r3, r3, r2
 805753c:	eb03 134c 	add.w	r3, r3, ip, lsl #5
 8057540:	ec51 0b10 	vmov	r0, r1, d0
 8057544:	2b00      	cmp	r3, #0
 8057546:	bfd6      	itet	le
 8057548:	460a      	movle	r2, r1
 805754a:	462a      	movgt	r2, r5
 805754c:	ebc3 3303 	rsble	r3, r3, r3, lsl #12
 8057550:	468b      	mov	fp, r1
 8057552:	462f      	mov	r7, r5
 8057554:	bfd4      	ite	le
 8057556:	eb02 5b03 	addle.w	fp, r2, r3, lsl #20
 805755a:	eb02 5703 	addgt.w	r7, r2, r3, lsl #20
 805755e:	4620      	mov	r0, r4
 8057560:	ee10 2a10 	vmov	r2, s0
 8057564:	465b      	mov	r3, fp
 8057566:	4639      	mov	r1, r7
 8057568:	f7e9 f990 	bl	804088c <__aeabi_ddiv>
 805756c:	ec41 0b10 	vmov	d0, r0, r1
 8057570:	b003      	add	sp, #12
 8057572:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08057576 <__copybits>:
 8057576:	3901      	subs	r1, #1
 8057578:	b570      	push	{r4, r5, r6, lr}
 805757a:	1149      	asrs	r1, r1, #5
 805757c:	6914      	ldr	r4, [r2, #16]
 805757e:	3101      	adds	r1, #1
 8057580:	f102 0314 	add.w	r3, r2, #20
 8057584:	eb00 0181 	add.w	r1, r0, r1, lsl #2
 8057588:	eb03 0484 	add.w	r4, r3, r4, lsl #2
 805758c:	1f05      	subs	r5, r0, #4
 805758e:	42a3      	cmp	r3, r4
 8057590:	d30c      	bcc.n	80575ac <__copybits+0x36>
 8057592:	1aa3      	subs	r3, r4, r2
 8057594:	3b11      	subs	r3, #17
 8057596:	f023 0303 	bic.w	r3, r3, #3
 805759a:	3211      	adds	r2, #17
 805759c:	42a2      	cmp	r2, r4
 805759e:	bf88      	it	hi
 80575a0:	2300      	movhi	r3, #0
 80575a2:	4418      	add	r0, r3
 80575a4:	2300      	movs	r3, #0
 80575a6:	4288      	cmp	r0, r1
 80575a8:	d305      	bcc.n	80575b6 <__copybits+0x40>
 80575aa:	bd70      	pop	{r4, r5, r6, pc}
 80575ac:	f853 6b04 	ldr.w	r6, [r3], #4
 80575b0:	f845 6f04 	str.w	r6, [r5, #4]!
 80575b4:	e7eb      	b.n	805758e <__copybits+0x18>
 80575b6:	f840 3b04 	str.w	r3, [r0], #4
 80575ba:	e7f4      	b.n	80575a6 <__copybits+0x30>

080575bc <__any_on>:
 80575bc:	f100 0214 	add.w	r2, r0, #20
 80575c0:	6900      	ldr	r0, [r0, #16]
 80575c2:	114b      	asrs	r3, r1, #5
 80575c4:	4298      	cmp	r0, r3
 80575c6:	b510      	push	{r4, lr}
 80575c8:	db11      	blt.n	80575ee <__any_on+0x32>
 80575ca:	dd0a      	ble.n	80575e2 <__any_on+0x26>
 80575cc:	f011 011f 	ands.w	r1, r1, #31
 80575d0:	d007      	beq.n	80575e2 <__any_on+0x26>
 80575d2:	f852 4023 	ldr.w	r4, [r2, r3, lsl #2]
 80575d6:	fa24 f001 	lsr.w	r0, r4, r1
 80575da:	fa00 f101 	lsl.w	r1, r0, r1
 80575de:	428c      	cmp	r4, r1
 80575e0:	d10b      	bne.n	80575fa <__any_on+0x3e>
 80575e2:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 80575e6:	4293      	cmp	r3, r2
 80575e8:	d803      	bhi.n	80575f2 <__any_on+0x36>
 80575ea:	2000      	movs	r0, #0
 80575ec:	bd10      	pop	{r4, pc}
 80575ee:	4603      	mov	r3, r0
 80575f0:	e7f7      	b.n	80575e2 <__any_on+0x26>
 80575f2:	f853 1d04 	ldr.w	r1, [r3, #-4]!
 80575f6:	2900      	cmp	r1, #0
 80575f8:	d0f5      	beq.n	80575e6 <__any_on+0x2a>
 80575fa:	2001      	movs	r0, #1
 80575fc:	e7f6      	b.n	80575ec <__any_on+0x30>
	...

08057600 <frexp>:
 8057600:	b570      	push	{r4, r5, r6, lr}
 8057602:	2100      	movs	r1, #0
 8057604:	ec55 4b10 	vmov	r4, r5, d0
 8057608:	6001      	str	r1, [r0, #0]
 805760a:	4916      	ldr	r1, [pc, #88]	; (8057664 <frexp+0x64>)
 805760c:	f025 4200 	bic.w	r2, r5, #2147483648	; 0x80000000
 8057610:	428a      	cmp	r2, r1
 8057612:	4606      	mov	r6, r0
 8057614:	462b      	mov	r3, r5
 8057616:	dc22      	bgt.n	805765e <frexp+0x5e>
 8057618:	ee10 1a10 	vmov	r1, s0
 805761c:	4311      	orrs	r1, r2
 805761e:	d01e      	beq.n	805765e <frexp+0x5e>
 8057620:	4911      	ldr	r1, [pc, #68]	; (8057668 <frexp+0x68>)
 8057622:	4029      	ands	r1, r5
 8057624:	b969      	cbnz	r1, 8057642 <frexp+0x42>
 8057626:	4b11      	ldr	r3, [pc, #68]	; (805766c <frexp+0x6c>)
 8057628:	2200      	movs	r2, #0
 805762a:	ee10 0a10 	vmov	r0, s0
 805762e:	4629      	mov	r1, r5
 8057630:	f7e9 f802 	bl	8040638 <__aeabi_dmul>
 8057634:	460b      	mov	r3, r1
 8057636:	f021 4200 	bic.w	r2, r1, #2147483648	; 0x80000000
 805763a:	f06f 0135 	mvn.w	r1, #53	; 0x35
 805763e:	4604      	mov	r4, r0
 8057640:	6031      	str	r1, [r6, #0]
 8057642:	6831      	ldr	r1, [r6, #0]
 8057644:	1512      	asrs	r2, r2, #20
 8057646:	f023 43ff 	bic.w	r3, r3, #2139095040	; 0x7f800000
 805764a:	f2a2 32fe 	subw	r2, r2, #1022	; 0x3fe
 805764e:	f423 03e0 	bic.w	r3, r3, #7340032	; 0x700000
 8057652:	440a      	add	r2, r1
 8057654:	f043 557f 	orr.w	r5, r3, #1069547520	; 0x3fc00000
 8057658:	6032      	str	r2, [r6, #0]
 805765a:	f445 1500 	orr.w	r5, r5, #2097152	; 0x200000
 805765e:	ec45 4b10 	vmov	d0, r4, r5
 8057662:	bd70      	pop	{r4, r5, r6, pc}
 8057664:	7fefffff 	.word	0x7fefffff
 8057668:	7ff00000 	.word	0x7ff00000
 805766c:	43500000 	.word	0x43500000

08057670 <nan>:
 8057670:	ed9f 0b01 	vldr	d0, [pc, #4]	; 8057678 <nan+0x8>
 8057674:	4770      	bx	lr
 8057676:	bf00      	nop
 8057678:	00000000 	.word	0x00000000
 805767c:	7ff80000 	.word	0x7ff80000

08057680 <__sread>:
 8057680:	b510      	push	{r4, lr}
 8057682:	460c      	mov	r4, r1
 8057684:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8057688:	f001 f8f0 	bl	805886c <_read_r>
 805768c:	2800      	cmp	r0, #0
 805768e:	bfab      	itete	ge
 8057690:	6d23      	ldrge	r3, [r4, #80]	; 0x50
 8057692:	89a3      	ldrhlt	r3, [r4, #12]
 8057694:	181b      	addge	r3, r3, r0
 8057696:	f423 5380 	biclt.w	r3, r3, #4096	; 0x1000
 805769a:	bfac      	ite	ge
 805769c:	6523      	strge	r3, [r4, #80]	; 0x50
 805769e:	81a3      	strhlt	r3, [r4, #12]
 80576a0:	bd10      	pop	{r4, pc}

080576a2 <__swrite>:
 80576a2:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80576a6:	461f      	mov	r7, r3
 80576a8:	898b      	ldrh	r3, [r1, #12]
 80576aa:	05db      	lsls	r3, r3, #23
 80576ac:	4605      	mov	r5, r0
 80576ae:	460c      	mov	r4, r1
 80576b0:	4616      	mov	r6, r2
 80576b2:	d505      	bpl.n	80576c0 <__swrite+0x1e>
 80576b4:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 80576b8:	2302      	movs	r3, #2
 80576ba:	2200      	movs	r2, #0
 80576bc:	f001 f8aa 	bl	8058814 <_lseek_r>
 80576c0:	89a3      	ldrh	r3, [r4, #12]
 80576c2:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 80576c6:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 80576ca:	81a3      	strh	r3, [r4, #12]
 80576cc:	4632      	mov	r2, r6
 80576ce:	463b      	mov	r3, r7
 80576d0:	4628      	mov	r0, r5
 80576d2:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 80576d6:	f000 bdad 	b.w	8058234 <_write_r>

080576da <__sseek>:
 80576da:	b510      	push	{r4, lr}
 80576dc:	460c      	mov	r4, r1
 80576de:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 80576e2:	f001 f897 	bl	8058814 <_lseek_r>
 80576e6:	1c43      	adds	r3, r0, #1
 80576e8:	89a3      	ldrh	r3, [r4, #12]
 80576ea:	bf15      	itete	ne
 80576ec:	6520      	strne	r0, [r4, #80]	; 0x50
 80576ee:	f423 5380 	biceq.w	r3, r3, #4096	; 0x1000
 80576f2:	f443 5380 	orrne.w	r3, r3, #4096	; 0x1000
 80576f6:	81a3      	strheq	r3, [r4, #12]
 80576f8:	bf18      	it	ne
 80576fa:	81a3      	strhne	r3, [r4, #12]
 80576fc:	bd10      	pop	{r4, pc}

080576fe <__sclose>:
 80576fe:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8057702:	f000 be35 	b.w	8058370 <_close_r>

08057706 <strncpy>:
 8057706:	b510      	push	{r4, lr}
 8057708:	3901      	subs	r1, #1
 805770a:	4603      	mov	r3, r0
 805770c:	b132      	cbz	r2, 805771c <strncpy+0x16>
 805770e:	f811 4f01 	ldrb.w	r4, [r1, #1]!
 8057712:	f803 4b01 	strb.w	r4, [r3], #1
 8057716:	3a01      	subs	r2, #1
 8057718:	2c00      	cmp	r4, #0
 805771a:	d1f7      	bne.n	805770c <strncpy+0x6>
 805771c:	441a      	add	r2, r3
 805771e:	2100      	movs	r1, #0
 8057720:	4293      	cmp	r3, r2
 8057722:	d100      	bne.n	8057726 <strncpy+0x20>
 8057724:	bd10      	pop	{r4, pc}
 8057726:	f803 1b01 	strb.w	r1, [r3], #1
 805772a:	e7f9      	b.n	8057720 <strncpy+0x1a>

0805772c <__ssprint_r>:
 805772c:	6893      	ldr	r3, [r2, #8]
 805772e:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8057732:	4680      	mov	r8, r0
 8057734:	460c      	mov	r4, r1
 8057736:	4617      	mov	r7, r2
 8057738:	2b00      	cmp	r3, #0
 805773a:	d061      	beq.n	8057800 <__ssprint_r+0xd4>
 805773c:	2300      	movs	r3, #0
 805773e:	f8d2 a000 	ldr.w	sl, [r2]
 8057742:	9301      	str	r3, [sp, #4]
 8057744:	469b      	mov	fp, r3
 8057746:	f1bb 0f00 	cmp.w	fp, #0
 805774a:	d02b      	beq.n	80577a4 <__ssprint_r+0x78>
 805774c:	68a6      	ldr	r6, [r4, #8]
 805774e:	45b3      	cmp	fp, r6
 8057750:	d342      	bcc.n	80577d8 <__ssprint_r+0xac>
 8057752:	89a2      	ldrh	r2, [r4, #12]
 8057754:	f412 6f90 	tst.w	r2, #1152	; 0x480
 8057758:	d03e      	beq.n	80577d8 <__ssprint_r+0xac>
 805775a:	6825      	ldr	r5, [r4, #0]
 805775c:	6921      	ldr	r1, [r4, #16]
 805775e:	eba5 0901 	sub.w	r9, r5, r1
 8057762:	6965      	ldr	r5, [r4, #20]
 8057764:	eb05 0545 	add.w	r5, r5, r5, lsl #1
 8057768:	eb05 75d5 	add.w	r5, r5, r5, lsr #31
 805776c:	f109 0001 	add.w	r0, r9, #1
 8057770:	106d      	asrs	r5, r5, #1
 8057772:	4458      	add	r0, fp
 8057774:	4285      	cmp	r5, r0
 8057776:	bf38      	it	cc
 8057778:	4605      	movcc	r5, r0
 805777a:	0553      	lsls	r3, r2, #21
 805777c:	d545      	bpl.n	805780a <__ssprint_r+0xde>
 805777e:	4629      	mov	r1, r5
 8057780:	4640      	mov	r0, r8
 8057782:	f7f9 feef 	bl	8051564 <_malloc_r>
 8057786:	4606      	mov	r6, r0
 8057788:	b9a0      	cbnz	r0, 80577b4 <__ssprint_r+0x88>
 805778a:	230c      	movs	r3, #12
 805778c:	f8c8 3000 	str.w	r3, [r8]
 8057790:	89a3      	ldrh	r3, [r4, #12]
 8057792:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8057796:	81a3      	strh	r3, [r4, #12]
 8057798:	2300      	movs	r3, #0
 805779a:	e9c7 3301 	strd	r3, r3, [r7, #4]
 805779e:	f04f 30ff 	mov.w	r0, #4294967295
 80577a2:	e02f      	b.n	8057804 <__ssprint_r+0xd8>
 80577a4:	f8da 3000 	ldr.w	r3, [sl]
 80577a8:	f8da b004 	ldr.w	fp, [sl, #4]
 80577ac:	9301      	str	r3, [sp, #4]
 80577ae:	f10a 0a08 	add.w	sl, sl, #8
 80577b2:	e7c8      	b.n	8057746 <__ssprint_r+0x1a>
 80577b4:	464a      	mov	r2, r9
 80577b6:	6921      	ldr	r1, [r4, #16]
 80577b8:	f7fa f924 	bl	8051a04 <memcpy>
 80577bc:	89a2      	ldrh	r2, [r4, #12]
 80577be:	f422 6290 	bic.w	r2, r2, #1152	; 0x480
 80577c2:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 80577c6:	81a2      	strh	r2, [r4, #12]
 80577c8:	6126      	str	r6, [r4, #16]
 80577ca:	6165      	str	r5, [r4, #20]
 80577cc:	444e      	add	r6, r9
 80577ce:	eba5 0509 	sub.w	r5, r5, r9
 80577d2:	6026      	str	r6, [r4, #0]
 80577d4:	60a5      	str	r5, [r4, #8]
 80577d6:	465e      	mov	r6, fp
 80577d8:	455e      	cmp	r6, fp
 80577da:	bf28      	it	cs
 80577dc:	465e      	movcs	r6, fp
 80577de:	4632      	mov	r2, r6
 80577e0:	9901      	ldr	r1, [sp, #4]
 80577e2:	6820      	ldr	r0, [r4, #0]
 80577e4:	f001 f828 	bl	8058838 <memmove>
 80577e8:	68a2      	ldr	r2, [r4, #8]
 80577ea:	1b92      	subs	r2, r2, r6
 80577ec:	60a2      	str	r2, [r4, #8]
 80577ee:	6822      	ldr	r2, [r4, #0]
 80577f0:	4432      	add	r2, r6
 80577f2:	6022      	str	r2, [r4, #0]
 80577f4:	68ba      	ldr	r2, [r7, #8]
 80577f6:	eba2 030b 	sub.w	r3, r2, fp
 80577fa:	60bb      	str	r3, [r7, #8]
 80577fc:	2b00      	cmp	r3, #0
 80577fe:	d1d1      	bne.n	80577a4 <__ssprint_r+0x78>
 8057800:	2000      	movs	r0, #0
 8057802:	6078      	str	r0, [r7, #4]
 8057804:	b003      	add	sp, #12
 8057806:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 805780a:	462a      	mov	r2, r5
 805780c:	4640      	mov	r0, r8
 805780e:	f001 f83f 	bl	8058890 <_realloc_r>
 8057812:	4606      	mov	r6, r0
 8057814:	2800      	cmp	r0, #0
 8057816:	d1d7      	bne.n	80577c8 <__ssprint_r+0x9c>
 8057818:	6921      	ldr	r1, [r4, #16]
 805781a:	4640      	mov	r0, r8
 805781c:	f7fe fda8 	bl	8056370 <_free_r>
 8057820:	e7b3      	b.n	805778a <__ssprint_r+0x5e>

08057822 <__sprint_r>:
 8057822:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8057826:	6893      	ldr	r3, [r2, #8]
 8057828:	4680      	mov	r8, r0
 805782a:	460f      	mov	r7, r1
 805782c:	4614      	mov	r4, r2
 805782e:	b91b      	cbnz	r3, 8057838 <__sprint_r+0x16>
 8057830:	6053      	str	r3, [r2, #4]
 8057832:	4618      	mov	r0, r3
 8057834:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8057838:	6e4b      	ldr	r3, [r1, #100]	; 0x64
 805783a:	049d      	lsls	r5, r3, #18
 805783c:	d520      	bpl.n	8057880 <__sprint_r+0x5e>
 805783e:	6815      	ldr	r5, [r2, #0]
 8057840:	3508      	adds	r5, #8
 8057842:	e955 b602 	ldrd	fp, r6, [r5, #-8]
 8057846:	f04f 0900 	mov.w	r9, #0
 805784a:	ea4f 0a96 	mov.w	sl, r6, lsr #2
 805784e:	45ca      	cmp	sl, r9
 8057850:	dc0b      	bgt.n	805786a <__sprint_r+0x48>
 8057852:	68a3      	ldr	r3, [r4, #8]
 8057854:	f026 0003 	bic.w	r0, r6, #3
 8057858:	1a18      	subs	r0, r3, r0
 805785a:	60a0      	str	r0, [r4, #8]
 805785c:	3508      	adds	r5, #8
 805785e:	2800      	cmp	r0, #0
 8057860:	d1ef      	bne.n	8057842 <__sprint_r+0x20>
 8057862:	2300      	movs	r3, #0
 8057864:	e9c4 3301 	strd	r3, r3, [r4, #4]
 8057868:	e7e4      	b.n	8057834 <__sprint_r+0x12>
 805786a:	f85b 1029 	ldr.w	r1, [fp, r9, lsl #2]
 805786e:	463a      	mov	r2, r7
 8057870:	4640      	mov	r0, r8
 8057872:	f000 fe38 	bl	80584e6 <_fputwc_r>
 8057876:	1c43      	adds	r3, r0, #1
 8057878:	d0f3      	beq.n	8057862 <__sprint_r+0x40>
 805787a:	f109 0901 	add.w	r9, r9, #1
 805787e:	e7e6      	b.n	805784e <__sprint_r+0x2c>
 8057880:	f000 fe6e 	bl	8058560 <__sfvwrite_r>
 8057884:	e7ed      	b.n	8057862 <__sprint_r+0x40>
	...

08057888 <_vfiprintf_r>:
 8057888:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 805788c:	ed2d 8b02 	vpush	{d8}
 8057890:	b0b9      	sub	sp, #228	; 0xe4
 8057892:	460f      	mov	r7, r1
 8057894:	9201      	str	r2, [sp, #4]
 8057896:	461d      	mov	r5, r3
 8057898:	461c      	mov	r4, r3
 805789a:	4681      	mov	r9, r0
 805789c:	b118      	cbz	r0, 80578a6 <_vfiprintf_r+0x1e>
 805789e:	6b83      	ldr	r3, [r0, #56]	; 0x38
 80578a0:	b90b      	cbnz	r3, 80578a6 <_vfiprintf_r+0x1e>
 80578a2:	f7fe fcd5 	bl	8056250 <__sinit>
 80578a6:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 80578a8:	07d8      	lsls	r0, r3, #31
 80578aa:	d405      	bmi.n	80578b8 <_vfiprintf_r+0x30>
 80578ac:	89bb      	ldrh	r3, [r7, #12]
 80578ae:	0599      	lsls	r1, r3, #22
 80578b0:	d402      	bmi.n	80578b8 <_vfiprintf_r+0x30>
 80578b2:	6db8      	ldr	r0, [r7, #88]	; 0x58
 80578b4:	f7ff f9b6 	bl	8056c24 <__retarget_lock_acquire_recursive>
 80578b8:	f9b7 300c 	ldrsh.w	r3, [r7, #12]
 80578bc:	049a      	lsls	r2, r3, #18
 80578be:	d406      	bmi.n	80578ce <_vfiprintf_r+0x46>
 80578c0:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 80578c4:	81bb      	strh	r3, [r7, #12]
 80578c6:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 80578c8:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 80578cc:	667b      	str	r3, [r7, #100]	; 0x64
 80578ce:	89bb      	ldrh	r3, [r7, #12]
 80578d0:	071e      	lsls	r6, r3, #28
 80578d2:	d501      	bpl.n	80578d8 <_vfiprintf_r+0x50>
 80578d4:	693b      	ldr	r3, [r7, #16]
 80578d6:	b9bb      	cbnz	r3, 8057908 <_vfiprintf_r+0x80>
 80578d8:	4639      	mov	r1, r7
 80578da:	4648      	mov	r0, r9
 80578dc:	f7fd fcee 	bl	80552bc <__swsetup_r>
 80578e0:	b190      	cbz	r0, 8057908 <_vfiprintf_r+0x80>
 80578e2:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 80578e4:	07d8      	lsls	r0, r3, #31
 80578e6:	d508      	bpl.n	80578fa <_vfiprintf_r+0x72>
 80578e8:	f04f 33ff 	mov.w	r3, #4294967295
 80578ec:	9302      	str	r3, [sp, #8]
 80578ee:	9802      	ldr	r0, [sp, #8]
 80578f0:	b039      	add	sp, #228	; 0xe4
 80578f2:	ecbd 8b02 	vpop	{d8}
 80578f6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80578fa:	89bb      	ldrh	r3, [r7, #12]
 80578fc:	0599      	lsls	r1, r3, #22
 80578fe:	d4f3      	bmi.n	80578e8 <_vfiprintf_r+0x60>
 8057900:	6db8      	ldr	r0, [r7, #88]	; 0x58
 8057902:	f7ff f990 	bl	8056c26 <__retarget_lock_release_recursive>
 8057906:	e7ef      	b.n	80578e8 <_vfiprintf_r+0x60>
 8057908:	89bb      	ldrh	r3, [r7, #12]
 805790a:	f003 021a 	and.w	r2, r3, #26
 805790e:	2a0a      	cmp	r2, #10
 8057910:	d113      	bne.n	805793a <_vfiprintf_r+0xb2>
 8057912:	f9b7 200e 	ldrsh.w	r2, [r7, #14]
 8057916:	2a00      	cmp	r2, #0
 8057918:	db0f      	blt.n	805793a <_vfiprintf_r+0xb2>
 805791a:	6e7a      	ldr	r2, [r7, #100]	; 0x64
 805791c:	07d2      	lsls	r2, r2, #31
 805791e:	d404      	bmi.n	805792a <_vfiprintf_r+0xa2>
 8057920:	059e      	lsls	r6, r3, #22
 8057922:	d402      	bmi.n	805792a <_vfiprintf_r+0xa2>
 8057924:	6db8      	ldr	r0, [r7, #88]	; 0x58
 8057926:	f7ff f97e 	bl	8056c26 <__retarget_lock_release_recursive>
 805792a:	9a01      	ldr	r2, [sp, #4]
 805792c:	462b      	mov	r3, r5
 805792e:	4639      	mov	r1, r7
 8057930:	4648      	mov	r0, r9
 8057932:	f000 fc31 	bl	8058198 <__sbprintf>
 8057936:	9002      	str	r0, [sp, #8]
 8057938:	e7d9      	b.n	80578ee <_vfiprintf_r+0x66>
 805793a:	2300      	movs	r3, #0
 805793c:	e9cd 330d 	strd	r3, r3, [sp, #52]	; 0x34
 8057940:	e9cd 3305 	strd	r3, r3, [sp, #20]
 8057944:	ae0f      	add	r6, sp, #60	; 0x3c
 8057946:	ee08 3a10 	vmov	s16, r3
 805794a:	960c      	str	r6, [sp, #48]	; 0x30
 805794c:	9307      	str	r3, [sp, #28]
 805794e:	9302      	str	r3, [sp, #8]
 8057950:	9b01      	ldr	r3, [sp, #4]
 8057952:	461d      	mov	r5, r3
 8057954:	f813 2b01 	ldrb.w	r2, [r3], #1
 8057958:	b10a      	cbz	r2, 805795e <_vfiprintf_r+0xd6>
 805795a:	2a25      	cmp	r2, #37	; 0x25
 805795c:	d1f9      	bne.n	8057952 <_vfiprintf_r+0xca>
 805795e:	9b01      	ldr	r3, [sp, #4]
 8057960:	ebb5 0803 	subs.w	r8, r5, r3
 8057964:	d00d      	beq.n	8057982 <_vfiprintf_r+0xfa>
 8057966:	e9c6 3800 	strd	r3, r8, [r6]
 805796a:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 805796c:	4443      	add	r3, r8
 805796e:	930e      	str	r3, [sp, #56]	; 0x38
 8057970:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8057972:	3301      	adds	r3, #1
 8057974:	2b07      	cmp	r3, #7
 8057976:	930d      	str	r3, [sp, #52]	; 0x34
 8057978:	dc75      	bgt.n	8057a66 <_vfiprintf_r+0x1de>
 805797a:	3608      	adds	r6, #8
 805797c:	9b02      	ldr	r3, [sp, #8]
 805797e:	4443      	add	r3, r8
 8057980:	9302      	str	r3, [sp, #8]
 8057982:	782b      	ldrb	r3, [r5, #0]
 8057984:	2b00      	cmp	r3, #0
 8057986:	f000 83c8 	beq.w	805811a <_vfiprintf_r+0x892>
 805798a:	2300      	movs	r3, #0
 805798c:	f04f 31ff 	mov.w	r1, #4294967295
 8057990:	1c6a      	adds	r2, r5, #1
 8057992:	f88d 302b 	strb.w	r3, [sp, #43]	; 0x2b
 8057996:	9100      	str	r1, [sp, #0]
 8057998:	9303      	str	r3, [sp, #12]
 805799a:	469a      	mov	sl, r3
 805799c:	f812 3b01 	ldrb.w	r3, [r2], #1
 80579a0:	9201      	str	r2, [sp, #4]
 80579a2:	f1a3 0220 	sub.w	r2, r3, #32
 80579a6:	2a5a      	cmp	r2, #90	; 0x5a
 80579a8:	f200 8310 	bhi.w	8057fcc <_vfiprintf_r+0x744>
 80579ac:	e8df f012 	tbh	[pc, r2, lsl #1]
 80579b0:	030e0099 	.word	0x030e0099
 80579b4:	00a1030e 	.word	0x00a1030e
 80579b8:	030e030e 	.word	0x030e030e
 80579bc:	0080030e 	.word	0x0080030e
 80579c0:	030e030e 	.word	0x030e030e
 80579c4:	00ae00a4 	.word	0x00ae00a4
 80579c8:	00ab030e 	.word	0x00ab030e
 80579cc:	030e00b0 	.word	0x030e00b0
 80579d0:	00ce00cb 	.word	0x00ce00cb
 80579d4:	00ce00ce 	.word	0x00ce00ce
 80579d8:	00ce00ce 	.word	0x00ce00ce
 80579dc:	00ce00ce 	.word	0x00ce00ce
 80579e0:	00ce00ce 	.word	0x00ce00ce
 80579e4:	030e030e 	.word	0x030e030e
 80579e8:	030e030e 	.word	0x030e030e
 80579ec:	030e030e 	.word	0x030e030e
 80579f0:	030e030e 	.word	0x030e030e
 80579f4:	00f8030e 	.word	0x00f8030e
 80579f8:	030e0106 	.word	0x030e0106
 80579fc:	030e030e 	.word	0x030e030e
 8057a00:	030e030e 	.word	0x030e030e
 8057a04:	030e030e 	.word	0x030e030e
 8057a08:	030e030e 	.word	0x030e030e
 8057a0c:	014d030e 	.word	0x014d030e
 8057a10:	030e030e 	.word	0x030e030e
 8057a14:	0192030e 	.word	0x0192030e
 8057a18:	0270030e 	.word	0x0270030e
 8057a1c:	030e030e 	.word	0x030e030e
 8057a20:	030e028e 	.word	0x030e028e
 8057a24:	030e030e 	.word	0x030e030e
 8057a28:	030e030e 	.word	0x030e030e
 8057a2c:	030e030e 	.word	0x030e030e
 8057a30:	030e030e 	.word	0x030e030e
 8057a34:	00f8030e 	.word	0x00f8030e
 8057a38:	030e0108 	.word	0x030e0108
 8057a3c:	030e030e 	.word	0x030e030e
 8057a40:	010800de 	.word	0x010800de
 8057a44:	030e00f2 	.word	0x030e00f2
 8057a48:	030e00eb 	.word	0x030e00eb
 8057a4c:	014f0130 	.word	0x014f0130
 8057a50:	00f20182 	.word	0x00f20182
 8057a54:	0192030e 	.word	0x0192030e
 8057a58:	02720097 	.word	0x02720097
 8057a5c:	030e030e 	.word	0x030e030e
 8057a60:	030e0065 	.word	0x030e0065
 8057a64:	0097      	.short	0x0097
 8057a66:	aa0c      	add	r2, sp, #48	; 0x30
 8057a68:	4639      	mov	r1, r7
 8057a6a:	4648      	mov	r0, r9
 8057a6c:	f7ff fed9 	bl	8057822 <__sprint_r>
 8057a70:	2800      	cmp	r0, #0
 8057a72:	f040 8331 	bne.w	80580d8 <_vfiprintf_r+0x850>
 8057a76:	ae0f      	add	r6, sp, #60	; 0x3c
 8057a78:	e780      	b.n	805797c <_vfiprintf_r+0xf4>
 8057a7a:	4a95      	ldr	r2, [pc, #596]	; (8057cd0 <_vfiprintf_r+0x448>)
 8057a7c:	9205      	str	r2, [sp, #20]
 8057a7e:	f01a 0f20 	tst.w	sl, #32
 8057a82:	f000 8225 	beq.w	8057ed0 <_vfiprintf_r+0x648>
 8057a86:	3407      	adds	r4, #7
 8057a88:	f024 0b07 	bic.w	fp, r4, #7
 8057a8c:	e8fb 4502 	ldrd	r4, r5, [fp], #8
 8057a90:	f01a 0f01 	tst.w	sl, #1
 8057a94:	d009      	beq.n	8057aaa <_vfiprintf_r+0x222>
 8057a96:	ea54 0205 	orrs.w	r2, r4, r5
 8057a9a:	bf1f      	itttt	ne
 8057a9c:	2230      	movne	r2, #48	; 0x30
 8057a9e:	f88d 202c 	strbne.w	r2, [sp, #44]	; 0x2c
 8057aa2:	f88d 302d 	strbne.w	r3, [sp, #45]	; 0x2d
 8057aa6:	f04a 0a02 	orrne.w	sl, sl, #2
 8057aaa:	f42a 6a80 	bic.w	sl, sl, #1024	; 0x400
 8057aae:	e10d      	b.n	8057ccc <_vfiprintf_r+0x444>
 8057ab0:	4648      	mov	r0, r9
 8057ab2:	f7ff f8b1 	bl	8056c18 <_localeconv_r>
 8057ab6:	6843      	ldr	r3, [r0, #4]
 8057ab8:	4618      	mov	r0, r3
 8057aba:	ee08 3a10 	vmov	s16, r3
 8057abe:	f7e8 fba1 	bl	8040204 <strlen>
 8057ac2:	9007      	str	r0, [sp, #28]
 8057ac4:	4648      	mov	r0, r9
 8057ac6:	f7ff f8a7 	bl	8056c18 <_localeconv_r>
 8057aca:	6883      	ldr	r3, [r0, #8]
 8057acc:	9306      	str	r3, [sp, #24]
 8057ace:	9b07      	ldr	r3, [sp, #28]
 8057ad0:	b12b      	cbz	r3, 8057ade <_vfiprintf_r+0x256>
 8057ad2:	9b06      	ldr	r3, [sp, #24]
 8057ad4:	b11b      	cbz	r3, 8057ade <_vfiprintf_r+0x256>
 8057ad6:	781b      	ldrb	r3, [r3, #0]
 8057ad8:	b10b      	cbz	r3, 8057ade <_vfiprintf_r+0x256>
 8057ada:	f44a 6a80 	orr.w	sl, sl, #1024	; 0x400
 8057ade:	9a01      	ldr	r2, [sp, #4]
 8057ae0:	e75c      	b.n	805799c <_vfiprintf_r+0x114>
 8057ae2:	f89d 302b 	ldrb.w	r3, [sp, #43]	; 0x2b
 8057ae6:	2b00      	cmp	r3, #0
 8057ae8:	d1f9      	bne.n	8057ade <_vfiprintf_r+0x256>
 8057aea:	2320      	movs	r3, #32
 8057aec:	f88d 302b 	strb.w	r3, [sp, #43]	; 0x2b
 8057af0:	e7f5      	b.n	8057ade <_vfiprintf_r+0x256>
 8057af2:	f04a 0a01 	orr.w	sl, sl, #1
 8057af6:	e7f2      	b.n	8057ade <_vfiprintf_r+0x256>
 8057af8:	f854 3b04 	ldr.w	r3, [r4], #4
 8057afc:	9303      	str	r3, [sp, #12]
 8057afe:	2b00      	cmp	r3, #0
 8057b00:	daed      	bge.n	8057ade <_vfiprintf_r+0x256>
 8057b02:	425b      	negs	r3, r3
 8057b04:	9303      	str	r3, [sp, #12]
 8057b06:	f04a 0a04 	orr.w	sl, sl, #4
 8057b0a:	e7e8      	b.n	8057ade <_vfiprintf_r+0x256>
 8057b0c:	232b      	movs	r3, #43	; 0x2b
 8057b0e:	e7ed      	b.n	8057aec <_vfiprintf_r+0x264>
 8057b10:	9a01      	ldr	r2, [sp, #4]
 8057b12:	f812 3b01 	ldrb.w	r3, [r2], #1
 8057b16:	2b2a      	cmp	r3, #42	; 0x2a
 8057b18:	d112      	bne.n	8057b40 <_vfiprintf_r+0x2b8>
 8057b1a:	f854 0b04 	ldr.w	r0, [r4], #4
 8057b1e:	ea40 73e0 	orr.w	r3, r0, r0, asr #31
 8057b22:	e9cd 3200 	strd	r3, r2, [sp]
 8057b26:	e7da      	b.n	8057ade <_vfiprintf_r+0x256>
 8057b28:	9b00      	ldr	r3, [sp, #0]
 8057b2a:	200a      	movs	r0, #10
 8057b2c:	fb00 1303 	mla	r3, r0, r3, r1
 8057b30:	9300      	str	r3, [sp, #0]
 8057b32:	f812 3b01 	ldrb.w	r3, [r2], #1
 8057b36:	f1a3 0130 	sub.w	r1, r3, #48	; 0x30
 8057b3a:	2909      	cmp	r1, #9
 8057b3c:	d9f4      	bls.n	8057b28 <_vfiprintf_r+0x2a0>
 8057b3e:	e72f      	b.n	80579a0 <_vfiprintf_r+0x118>
 8057b40:	2100      	movs	r1, #0
 8057b42:	9100      	str	r1, [sp, #0]
 8057b44:	e7f7      	b.n	8057b36 <_vfiprintf_r+0x2ae>
 8057b46:	f04a 0a80 	orr.w	sl, sl, #128	; 0x80
 8057b4a:	e7c8      	b.n	8057ade <_vfiprintf_r+0x256>
 8057b4c:	2100      	movs	r1, #0
 8057b4e:	9a01      	ldr	r2, [sp, #4]
 8057b50:	9103      	str	r1, [sp, #12]
 8057b52:	9903      	ldr	r1, [sp, #12]
 8057b54:	3b30      	subs	r3, #48	; 0x30
 8057b56:	200a      	movs	r0, #10
 8057b58:	fb00 3301 	mla	r3, r0, r1, r3
 8057b5c:	9303      	str	r3, [sp, #12]
 8057b5e:	f812 3b01 	ldrb.w	r3, [r2], #1
 8057b62:	f1a3 0130 	sub.w	r1, r3, #48	; 0x30
 8057b66:	2909      	cmp	r1, #9
 8057b68:	d9f3      	bls.n	8057b52 <_vfiprintf_r+0x2ca>
 8057b6a:	e719      	b.n	80579a0 <_vfiprintf_r+0x118>
 8057b6c:	9b01      	ldr	r3, [sp, #4]
 8057b6e:	781b      	ldrb	r3, [r3, #0]
 8057b70:	2b68      	cmp	r3, #104	; 0x68
 8057b72:	bf01      	itttt	eq
 8057b74:	9b01      	ldreq	r3, [sp, #4]
 8057b76:	3301      	addeq	r3, #1
 8057b78:	9301      	streq	r3, [sp, #4]
 8057b7a:	f44a 7a00 	orreq.w	sl, sl, #512	; 0x200
 8057b7e:	bf18      	it	ne
 8057b80:	f04a 0a40 	orrne.w	sl, sl, #64	; 0x40
 8057b84:	e7ab      	b.n	8057ade <_vfiprintf_r+0x256>
 8057b86:	9b01      	ldr	r3, [sp, #4]
 8057b88:	781b      	ldrb	r3, [r3, #0]
 8057b8a:	2b6c      	cmp	r3, #108	; 0x6c
 8057b8c:	d105      	bne.n	8057b9a <_vfiprintf_r+0x312>
 8057b8e:	9b01      	ldr	r3, [sp, #4]
 8057b90:	3301      	adds	r3, #1
 8057b92:	9301      	str	r3, [sp, #4]
 8057b94:	f04a 0a20 	orr.w	sl, sl, #32
 8057b98:	e7a1      	b.n	8057ade <_vfiprintf_r+0x256>
 8057b9a:	f04a 0a10 	orr.w	sl, sl, #16
 8057b9e:	e79e      	b.n	8057ade <_vfiprintf_r+0x256>
 8057ba0:	46a3      	mov	fp, r4
 8057ba2:	2100      	movs	r1, #0
 8057ba4:	f85b 3b04 	ldr.w	r3, [fp], #4
 8057ba8:	f88d 307c 	strb.w	r3, [sp, #124]	; 0x7c
 8057bac:	f88d 102b 	strb.w	r1, [sp, #43]	; 0x2b
 8057bb0:	2301      	movs	r3, #1
 8057bb2:	9300      	str	r3, [sp, #0]
 8057bb4:	460d      	mov	r5, r1
 8057bb6:	f10d 087c 	add.w	r8, sp, #124	; 0x7c
 8057bba:	e0a0      	b.n	8057cfe <_vfiprintf_r+0x476>
 8057bbc:	f04a 0a10 	orr.w	sl, sl, #16
 8057bc0:	f01a 0f20 	tst.w	sl, #32
 8057bc4:	d011      	beq.n	8057bea <_vfiprintf_r+0x362>
 8057bc6:	3407      	adds	r4, #7
 8057bc8:	f024 0b07 	bic.w	fp, r4, #7
 8057bcc:	e8fb 4502 	ldrd	r4, r5, [fp], #8
 8057bd0:	2c00      	cmp	r4, #0
 8057bd2:	f175 0300 	sbcs.w	r3, r5, #0
 8057bd6:	da06      	bge.n	8057be6 <_vfiprintf_r+0x35e>
 8057bd8:	4264      	negs	r4, r4
 8057bda:	f04f 032d 	mov.w	r3, #45	; 0x2d
 8057bde:	eb65 0545 	sbc.w	r5, r5, r5, lsl #1
 8057be2:	f88d 302b 	strb.w	r3, [sp, #43]	; 0x2b
 8057be6:	2301      	movs	r3, #1
 8057be8:	e03f      	b.n	8057c6a <_vfiprintf_r+0x3e2>
 8057bea:	f01a 0f10 	tst.w	sl, #16
 8057bee:	f104 0b04 	add.w	fp, r4, #4
 8057bf2:	d002      	beq.n	8057bfa <_vfiprintf_r+0x372>
 8057bf4:	6824      	ldr	r4, [r4, #0]
 8057bf6:	17e5      	asrs	r5, r4, #31
 8057bf8:	e7ea      	b.n	8057bd0 <_vfiprintf_r+0x348>
 8057bfa:	f01a 0f40 	tst.w	sl, #64	; 0x40
 8057bfe:	6824      	ldr	r4, [r4, #0]
 8057c00:	d001      	beq.n	8057c06 <_vfiprintf_r+0x37e>
 8057c02:	b224      	sxth	r4, r4
 8057c04:	e7f7      	b.n	8057bf6 <_vfiprintf_r+0x36e>
 8057c06:	f41a 7f00 	tst.w	sl, #512	; 0x200
 8057c0a:	bf18      	it	ne
 8057c0c:	b264      	sxtbne	r4, r4
 8057c0e:	e7f2      	b.n	8057bf6 <_vfiprintf_r+0x36e>
 8057c10:	f01a 0f20 	tst.w	sl, #32
 8057c14:	f854 3b04 	ldr.w	r3, [r4], #4
 8057c18:	d005      	beq.n	8057c26 <_vfiprintf_r+0x39e>
 8057c1a:	9a02      	ldr	r2, [sp, #8]
 8057c1c:	4610      	mov	r0, r2
 8057c1e:	17d1      	asrs	r1, r2, #31
 8057c20:	e9c3 0100 	strd	r0, r1, [r3]
 8057c24:	e694      	b.n	8057950 <_vfiprintf_r+0xc8>
 8057c26:	f01a 0f10 	tst.w	sl, #16
 8057c2a:	d002      	beq.n	8057c32 <_vfiprintf_r+0x3aa>
 8057c2c:	9a02      	ldr	r2, [sp, #8]
 8057c2e:	601a      	str	r2, [r3, #0]
 8057c30:	e68e      	b.n	8057950 <_vfiprintf_r+0xc8>
 8057c32:	f01a 0f40 	tst.w	sl, #64	; 0x40
 8057c36:	d002      	beq.n	8057c3e <_vfiprintf_r+0x3b6>
 8057c38:	9a02      	ldr	r2, [sp, #8]
 8057c3a:	801a      	strh	r2, [r3, #0]
 8057c3c:	e688      	b.n	8057950 <_vfiprintf_r+0xc8>
 8057c3e:	f41a 7f00 	tst.w	sl, #512	; 0x200
 8057c42:	d0f3      	beq.n	8057c2c <_vfiprintf_r+0x3a4>
 8057c44:	9a02      	ldr	r2, [sp, #8]
 8057c46:	701a      	strb	r2, [r3, #0]
 8057c48:	e682      	b.n	8057950 <_vfiprintf_r+0xc8>
 8057c4a:	f04a 0a10 	orr.w	sl, sl, #16
 8057c4e:	f01a 0f20 	tst.w	sl, #32
 8057c52:	d01d      	beq.n	8057c90 <_vfiprintf_r+0x408>
 8057c54:	3407      	adds	r4, #7
 8057c56:	f024 0b07 	bic.w	fp, r4, #7
 8057c5a:	e8fb 4502 	ldrd	r4, r5, [fp], #8
 8057c5e:	f42a 6a80 	bic.w	sl, sl, #1024	; 0x400
 8057c62:	2300      	movs	r3, #0
 8057c64:	2200      	movs	r2, #0
 8057c66:	f88d 202b 	strb.w	r2, [sp, #43]	; 0x2b
 8057c6a:	9a00      	ldr	r2, [sp, #0]
 8057c6c:	3201      	adds	r2, #1
 8057c6e:	f000 8261 	beq.w	8058134 <_vfiprintf_r+0x8ac>
 8057c72:	f02a 0280 	bic.w	r2, sl, #128	; 0x80
 8057c76:	9204      	str	r2, [sp, #16]
 8057c78:	ea54 0205 	orrs.w	r2, r4, r5
 8057c7c:	f040 8260 	bne.w	8058140 <_vfiprintf_r+0x8b8>
 8057c80:	9a00      	ldr	r2, [sp, #0]
 8057c82:	2a00      	cmp	r2, #0
 8057c84:	f000 8197 	beq.w	8057fb6 <_vfiprintf_r+0x72e>
 8057c88:	2b01      	cmp	r3, #1
 8057c8a:	f040 825c 	bne.w	8058146 <_vfiprintf_r+0x8be>
 8057c8e:	e135      	b.n	8057efc <_vfiprintf_r+0x674>
 8057c90:	f01a 0f10 	tst.w	sl, #16
 8057c94:	f104 0b04 	add.w	fp, r4, #4
 8057c98:	d001      	beq.n	8057c9e <_vfiprintf_r+0x416>
 8057c9a:	6824      	ldr	r4, [r4, #0]
 8057c9c:	e003      	b.n	8057ca6 <_vfiprintf_r+0x41e>
 8057c9e:	f01a 0f40 	tst.w	sl, #64	; 0x40
 8057ca2:	d002      	beq.n	8057caa <_vfiprintf_r+0x422>
 8057ca4:	8824      	ldrh	r4, [r4, #0]
 8057ca6:	2500      	movs	r5, #0
 8057ca8:	e7d9      	b.n	8057c5e <_vfiprintf_r+0x3d6>
 8057caa:	f41a 7f00 	tst.w	sl, #512	; 0x200
 8057cae:	d0f4      	beq.n	8057c9a <_vfiprintf_r+0x412>
 8057cb0:	7824      	ldrb	r4, [r4, #0]
 8057cb2:	e7f8      	b.n	8057ca6 <_vfiprintf_r+0x41e>
 8057cb4:	46a3      	mov	fp, r4
 8057cb6:	f647 0330 	movw	r3, #30768	; 0x7830
 8057cba:	f8ad 302c 	strh.w	r3, [sp, #44]	; 0x2c
 8057cbe:	f85b 4b04 	ldr.w	r4, [fp], #4
 8057cc2:	4b03      	ldr	r3, [pc, #12]	; (8057cd0 <_vfiprintf_r+0x448>)
 8057cc4:	9305      	str	r3, [sp, #20]
 8057cc6:	2500      	movs	r5, #0
 8057cc8:	f04a 0a02 	orr.w	sl, sl, #2
 8057ccc:	2302      	movs	r3, #2
 8057cce:	e7c9      	b.n	8057c64 <_vfiprintf_r+0x3dc>
 8057cd0:	0805ab60 	.word	0x0805ab60
 8057cd4:	9b00      	ldr	r3, [sp, #0]
 8057cd6:	46a3      	mov	fp, r4
 8057cd8:	2500      	movs	r5, #0
 8057cda:	1c5c      	adds	r4, r3, #1
 8057cdc:	f85b 8b04 	ldr.w	r8, [fp], #4
 8057ce0:	f88d 502b 	strb.w	r5, [sp, #43]	; 0x2b
 8057ce4:	f000 80cf 	beq.w	8057e86 <_vfiprintf_r+0x5fe>
 8057ce8:	461a      	mov	r2, r3
 8057cea:	4629      	mov	r1, r5
 8057cec:	4640      	mov	r0, r8
 8057cee:	f7e8 fa97 	bl	8040220 <memchr>
 8057cf2:	2800      	cmp	r0, #0
 8057cf4:	f000 8174 	beq.w	8057fe0 <_vfiprintf_r+0x758>
 8057cf8:	eba0 0308 	sub.w	r3, r0, r8
 8057cfc:	9300      	str	r3, [sp, #0]
 8057cfe:	9b00      	ldr	r3, [sp, #0]
 8057d00:	42ab      	cmp	r3, r5
 8057d02:	bfb8      	it	lt
 8057d04:	462b      	movlt	r3, r5
 8057d06:	9304      	str	r3, [sp, #16]
 8057d08:	f89d 302b 	ldrb.w	r3, [sp, #43]	; 0x2b
 8057d0c:	b113      	cbz	r3, 8057d14 <_vfiprintf_r+0x48c>
 8057d0e:	9b04      	ldr	r3, [sp, #16]
 8057d10:	3301      	adds	r3, #1
 8057d12:	9304      	str	r3, [sp, #16]
 8057d14:	f01a 0302 	ands.w	r3, sl, #2
 8057d18:	9308      	str	r3, [sp, #32]
 8057d1a:	bf1e      	ittt	ne
 8057d1c:	9b04      	ldrne	r3, [sp, #16]
 8057d1e:	3302      	addne	r3, #2
 8057d20:	9304      	strne	r3, [sp, #16]
 8057d22:	f01a 0384 	ands.w	r3, sl, #132	; 0x84
 8057d26:	9309      	str	r3, [sp, #36]	; 0x24
 8057d28:	d11f      	bne.n	8057d6a <_vfiprintf_r+0x4e2>
 8057d2a:	e9dd 3203 	ldrd	r3, r2, [sp, #12]
 8057d2e:	1a9c      	subs	r4, r3, r2
 8057d30:	2c00      	cmp	r4, #0
 8057d32:	dd1a      	ble.n	8057d6a <_vfiprintf_r+0x4e2>
 8057d34:	e9dd 320d 	ldrd	r3, r2, [sp, #52]	; 0x34
 8057d38:	48b9      	ldr	r0, [pc, #740]	; (8058020 <_vfiprintf_r+0x798>)
 8057d3a:	6030      	str	r0, [r6, #0]
 8057d3c:	2c10      	cmp	r4, #16
 8057d3e:	f103 0301 	add.w	r3, r3, #1
 8057d42:	f106 0108 	add.w	r1, r6, #8
 8057d46:	f300 814d 	bgt.w	8057fe4 <_vfiprintf_r+0x75c>
 8057d4a:	6074      	str	r4, [r6, #4]
 8057d4c:	2b07      	cmp	r3, #7
 8057d4e:	4414      	add	r4, r2
 8057d50:	e9cd 340d 	strd	r3, r4, [sp, #52]	; 0x34
 8057d54:	f340 8158 	ble.w	8058008 <_vfiprintf_r+0x780>
 8057d58:	aa0c      	add	r2, sp, #48	; 0x30
 8057d5a:	4639      	mov	r1, r7
 8057d5c:	4648      	mov	r0, r9
 8057d5e:	f7ff fd60 	bl	8057822 <__sprint_r>
 8057d62:	2800      	cmp	r0, #0
 8057d64:	f040 81b8 	bne.w	80580d8 <_vfiprintf_r+0x850>
 8057d68:	ae0f      	add	r6, sp, #60	; 0x3c
 8057d6a:	f89d 302b 	ldrb.w	r3, [sp, #43]	; 0x2b
 8057d6e:	b173      	cbz	r3, 8057d8e <_vfiprintf_r+0x506>
 8057d70:	f10d 022b 	add.w	r2, sp, #43	; 0x2b
 8057d74:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8057d76:	6032      	str	r2, [r6, #0]
 8057d78:	2201      	movs	r2, #1
 8057d7a:	6072      	str	r2, [r6, #4]
 8057d7c:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 8057d7e:	3301      	adds	r3, #1
 8057d80:	3201      	adds	r2, #1
 8057d82:	2b07      	cmp	r3, #7
 8057d84:	e9cd 320d 	strd	r3, r2, [sp, #52]	; 0x34
 8057d88:	f300 8140 	bgt.w	805800c <_vfiprintf_r+0x784>
 8057d8c:	3608      	adds	r6, #8
 8057d8e:	9b08      	ldr	r3, [sp, #32]
 8057d90:	b16b      	cbz	r3, 8057dae <_vfiprintf_r+0x526>
 8057d92:	aa0b      	add	r2, sp, #44	; 0x2c
 8057d94:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8057d96:	6032      	str	r2, [r6, #0]
 8057d98:	2202      	movs	r2, #2
 8057d9a:	6072      	str	r2, [r6, #4]
 8057d9c:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 8057d9e:	3301      	adds	r3, #1
 8057da0:	3202      	adds	r2, #2
 8057da2:	2b07      	cmp	r3, #7
 8057da4:	e9cd 320d 	strd	r3, r2, [sp, #52]	; 0x34
 8057da8:	f300 8140 	bgt.w	805802c <_vfiprintf_r+0x7a4>
 8057dac:	3608      	adds	r6, #8
 8057dae:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8057db0:	2b80      	cmp	r3, #128	; 0x80
 8057db2:	d11f      	bne.n	8057df4 <_vfiprintf_r+0x56c>
 8057db4:	e9dd 3203 	ldrd	r3, r2, [sp, #12]
 8057db8:	1a9c      	subs	r4, r3, r2
 8057dba:	2c00      	cmp	r4, #0
 8057dbc:	dd1a      	ble.n	8057df4 <_vfiprintf_r+0x56c>
 8057dbe:	e9dd 320d 	ldrd	r3, r2, [sp, #52]	; 0x34
 8057dc2:	4898      	ldr	r0, [pc, #608]	; (8058024 <_vfiprintf_r+0x79c>)
 8057dc4:	6030      	str	r0, [r6, #0]
 8057dc6:	2c10      	cmp	r4, #16
 8057dc8:	f103 0301 	add.w	r3, r3, #1
 8057dcc:	f106 0108 	add.w	r1, r6, #8
 8057dd0:	f300 8135 	bgt.w	805803e <_vfiprintf_r+0x7b6>
 8057dd4:	6074      	str	r4, [r6, #4]
 8057dd6:	2b07      	cmp	r3, #7
 8057dd8:	4414      	add	r4, r2
 8057dda:	e9cd 340d 	strd	r3, r4, [sp, #52]	; 0x34
 8057dde:	f340 8140 	ble.w	8058062 <_vfiprintf_r+0x7da>
 8057de2:	aa0c      	add	r2, sp, #48	; 0x30
 8057de4:	4639      	mov	r1, r7
 8057de6:	4648      	mov	r0, r9
 8057de8:	f7ff fd1b 	bl	8057822 <__sprint_r>
 8057dec:	2800      	cmp	r0, #0
 8057dee:	f040 8173 	bne.w	80580d8 <_vfiprintf_r+0x850>
 8057df2:	ae0f      	add	r6, sp, #60	; 0x3c
 8057df4:	9b00      	ldr	r3, [sp, #0]
 8057df6:	1aec      	subs	r4, r5, r3
 8057df8:	2c00      	cmp	r4, #0
 8057dfa:	dd1a      	ble.n	8057e32 <_vfiprintf_r+0x5aa>
 8057dfc:	4d89      	ldr	r5, [pc, #548]	; (8058024 <_vfiprintf_r+0x79c>)
 8057dfe:	6035      	str	r5, [r6, #0]
 8057e00:	e9dd 310d 	ldrd	r3, r1, [sp, #52]	; 0x34
 8057e04:	2c10      	cmp	r4, #16
 8057e06:	f103 0301 	add.w	r3, r3, #1
 8057e0a:	f106 0208 	add.w	r2, r6, #8
 8057e0e:	f300 812a 	bgt.w	8058066 <_vfiprintf_r+0x7de>
 8057e12:	6074      	str	r4, [r6, #4]
 8057e14:	2b07      	cmp	r3, #7
 8057e16:	440c      	add	r4, r1
 8057e18:	e9cd 340d 	strd	r3, r4, [sp, #52]	; 0x34
 8057e1c:	f340 8134 	ble.w	8058088 <_vfiprintf_r+0x800>
 8057e20:	aa0c      	add	r2, sp, #48	; 0x30
 8057e22:	4639      	mov	r1, r7
 8057e24:	4648      	mov	r0, r9
 8057e26:	f7ff fcfc 	bl	8057822 <__sprint_r>
 8057e2a:	2800      	cmp	r0, #0
 8057e2c:	f040 8154 	bne.w	80580d8 <_vfiprintf_r+0x850>
 8057e30:	ae0f      	add	r6, sp, #60	; 0x3c
 8057e32:	9b00      	ldr	r3, [sp, #0]
 8057e34:	980e      	ldr	r0, [sp, #56]	; 0x38
 8057e36:	6073      	str	r3, [r6, #4]
 8057e38:	4418      	add	r0, r3
 8057e3a:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8057e3c:	f8c6 8000 	str.w	r8, [r6]
 8057e40:	3301      	adds	r3, #1
 8057e42:	2b07      	cmp	r3, #7
 8057e44:	900e      	str	r0, [sp, #56]	; 0x38
 8057e46:	930d      	str	r3, [sp, #52]	; 0x34
 8057e48:	f300 8120 	bgt.w	805808c <_vfiprintf_r+0x804>
 8057e4c:	f106 0308 	add.w	r3, r6, #8
 8057e50:	f01a 0f04 	tst.w	sl, #4
 8057e54:	f040 8122 	bne.w	805809c <_vfiprintf_r+0x814>
 8057e58:	e9dd 3202 	ldrd	r3, r2, [sp, #8]
 8057e5c:	9904      	ldr	r1, [sp, #16]
 8057e5e:	428a      	cmp	r2, r1
 8057e60:	bfac      	ite	ge
 8057e62:	189b      	addge	r3, r3, r2
 8057e64:	185b      	addlt	r3, r3, r1
 8057e66:	9302      	str	r3, [sp, #8]
 8057e68:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8057e6a:	b13b      	cbz	r3, 8057e7c <_vfiprintf_r+0x5f4>
 8057e6c:	aa0c      	add	r2, sp, #48	; 0x30
 8057e6e:	4639      	mov	r1, r7
 8057e70:	4648      	mov	r0, r9
 8057e72:	f7ff fcd6 	bl	8057822 <__sprint_r>
 8057e76:	2800      	cmp	r0, #0
 8057e78:	f040 812e 	bne.w	80580d8 <_vfiprintf_r+0x850>
 8057e7c:	2300      	movs	r3, #0
 8057e7e:	930d      	str	r3, [sp, #52]	; 0x34
 8057e80:	465c      	mov	r4, fp
 8057e82:	ae0f      	add	r6, sp, #60	; 0x3c
 8057e84:	e564      	b.n	8057950 <_vfiprintf_r+0xc8>
 8057e86:	4640      	mov	r0, r8
 8057e88:	f7e8 f9bc 	bl	8040204 <strlen>
 8057e8c:	9000      	str	r0, [sp, #0]
 8057e8e:	e736      	b.n	8057cfe <_vfiprintf_r+0x476>
 8057e90:	f04a 0a10 	orr.w	sl, sl, #16
 8057e94:	f01a 0f20 	tst.w	sl, #32
 8057e98:	d006      	beq.n	8057ea8 <_vfiprintf_r+0x620>
 8057e9a:	3407      	adds	r4, #7
 8057e9c:	f024 0b07 	bic.w	fp, r4, #7
 8057ea0:	e8fb 4502 	ldrd	r4, r5, [fp], #8
 8057ea4:	2301      	movs	r3, #1
 8057ea6:	e6dd      	b.n	8057c64 <_vfiprintf_r+0x3dc>
 8057ea8:	f01a 0f10 	tst.w	sl, #16
 8057eac:	f104 0b04 	add.w	fp, r4, #4
 8057eb0:	d001      	beq.n	8057eb6 <_vfiprintf_r+0x62e>
 8057eb2:	6824      	ldr	r4, [r4, #0]
 8057eb4:	e003      	b.n	8057ebe <_vfiprintf_r+0x636>
 8057eb6:	f01a 0f40 	tst.w	sl, #64	; 0x40
 8057eba:	d002      	beq.n	8057ec2 <_vfiprintf_r+0x63a>
 8057ebc:	8824      	ldrh	r4, [r4, #0]
 8057ebe:	2500      	movs	r5, #0
 8057ec0:	e7f0      	b.n	8057ea4 <_vfiprintf_r+0x61c>
 8057ec2:	f41a 7f00 	tst.w	sl, #512	; 0x200
 8057ec6:	d0f4      	beq.n	8057eb2 <_vfiprintf_r+0x62a>
 8057ec8:	7824      	ldrb	r4, [r4, #0]
 8057eca:	e7f8      	b.n	8057ebe <_vfiprintf_r+0x636>
 8057ecc:	4a56      	ldr	r2, [pc, #344]	; (8058028 <_vfiprintf_r+0x7a0>)
 8057ece:	e5d5      	b.n	8057a7c <_vfiprintf_r+0x1f4>
 8057ed0:	f01a 0f10 	tst.w	sl, #16
 8057ed4:	f104 0b04 	add.w	fp, r4, #4
 8057ed8:	d001      	beq.n	8057ede <_vfiprintf_r+0x656>
 8057eda:	6824      	ldr	r4, [r4, #0]
 8057edc:	e003      	b.n	8057ee6 <_vfiprintf_r+0x65e>
 8057ede:	f01a 0f40 	tst.w	sl, #64	; 0x40
 8057ee2:	d002      	beq.n	8057eea <_vfiprintf_r+0x662>
 8057ee4:	8824      	ldrh	r4, [r4, #0]
 8057ee6:	2500      	movs	r5, #0
 8057ee8:	e5d2      	b.n	8057a90 <_vfiprintf_r+0x208>
 8057eea:	f41a 7f00 	tst.w	sl, #512	; 0x200
 8057eee:	d0f4      	beq.n	8057eda <_vfiprintf_r+0x652>
 8057ef0:	7824      	ldrb	r4, [r4, #0]
 8057ef2:	e7f8      	b.n	8057ee6 <_vfiprintf_r+0x65e>
 8057ef4:	2d00      	cmp	r5, #0
 8057ef6:	bf08      	it	eq
 8057ef8:	2c0a      	cmpeq	r4, #10
 8057efa:	d205      	bcs.n	8057f08 <_vfiprintf_r+0x680>
 8057efc:	3430      	adds	r4, #48	; 0x30
 8057efe:	f88d 40df 	strb.w	r4, [sp, #223]	; 0xdf
 8057f02:	f10d 08df 	add.w	r8, sp, #223	; 0xdf
 8057f06:	e13c      	b.n	8058182 <_vfiprintf_r+0x8fa>
 8057f08:	ab38      	add	r3, sp, #224	; 0xe0
 8057f0a:	9308      	str	r3, [sp, #32]
 8057f0c:	9b04      	ldr	r3, [sp, #16]
 8057f0e:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8057f12:	f04f 0a00 	mov.w	sl, #0
 8057f16:	9309      	str	r3, [sp, #36]	; 0x24
 8057f18:	9b08      	ldr	r3, [sp, #32]
 8057f1a:	220a      	movs	r2, #10
 8057f1c:	f103 38ff 	add.w	r8, r3, #4294967295
 8057f20:	4620      	mov	r0, r4
 8057f22:	2300      	movs	r3, #0
 8057f24:	4629      	mov	r1, r5
 8057f26:	f7e8 fecf 	bl	8040cc8 <__aeabi_uldivmod>
 8057f2a:	9b08      	ldr	r3, [sp, #32]
 8057f2c:	3230      	adds	r2, #48	; 0x30
 8057f2e:	f803 2c01 	strb.w	r2, [r3, #-1]
 8057f32:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8057f34:	f10a 0a01 	add.w	sl, sl, #1
 8057f38:	b1db      	cbz	r3, 8057f72 <_vfiprintf_r+0x6ea>
 8057f3a:	9b06      	ldr	r3, [sp, #24]
 8057f3c:	781b      	ldrb	r3, [r3, #0]
 8057f3e:	4553      	cmp	r3, sl
 8057f40:	d117      	bne.n	8057f72 <_vfiprintf_r+0x6ea>
 8057f42:	f1ba 0fff 	cmp.w	sl, #255	; 0xff
 8057f46:	d014      	beq.n	8057f72 <_vfiprintf_r+0x6ea>
 8057f48:	2d00      	cmp	r5, #0
 8057f4a:	bf08      	it	eq
 8057f4c:	2c0a      	cmpeq	r4, #10
 8057f4e:	d310      	bcc.n	8057f72 <_vfiprintf_r+0x6ea>
 8057f50:	9b07      	ldr	r3, [sp, #28]
 8057f52:	eba8 0803 	sub.w	r8, r8, r3
 8057f56:	461a      	mov	r2, r3
 8057f58:	ee18 1a10 	vmov	r1, s16
 8057f5c:	4640      	mov	r0, r8
 8057f5e:	f7ff fbd2 	bl	8057706 <strncpy>
 8057f62:	9b06      	ldr	r3, [sp, #24]
 8057f64:	785b      	ldrb	r3, [r3, #1]
 8057f66:	b1a3      	cbz	r3, 8057f92 <_vfiprintf_r+0x70a>
 8057f68:	9b06      	ldr	r3, [sp, #24]
 8057f6a:	3301      	adds	r3, #1
 8057f6c:	9306      	str	r3, [sp, #24]
 8057f6e:	f04f 0a00 	mov.w	sl, #0
 8057f72:	220a      	movs	r2, #10
 8057f74:	2300      	movs	r3, #0
 8057f76:	4620      	mov	r0, r4
 8057f78:	4629      	mov	r1, r5
 8057f7a:	f7e8 fea5 	bl	8040cc8 <__aeabi_uldivmod>
 8057f7e:	2d00      	cmp	r5, #0
 8057f80:	bf08      	it	eq
 8057f82:	2c0a      	cmpeq	r4, #10
 8057f84:	f0c0 80fd 	bcc.w	8058182 <_vfiprintf_r+0x8fa>
 8057f88:	4604      	mov	r4, r0
 8057f8a:	460d      	mov	r5, r1
 8057f8c:	f8cd 8020 	str.w	r8, [sp, #32]
 8057f90:	e7c2      	b.n	8057f18 <_vfiprintf_r+0x690>
 8057f92:	469a      	mov	sl, r3
 8057f94:	e7ed      	b.n	8057f72 <_vfiprintf_r+0x6ea>
 8057f96:	9a05      	ldr	r2, [sp, #20]
 8057f98:	f004 030f 	and.w	r3, r4, #15
 8057f9c:	5cd3      	ldrb	r3, [r2, r3]
 8057f9e:	f808 3d01 	strb.w	r3, [r8, #-1]!
 8057fa2:	0923      	lsrs	r3, r4, #4
 8057fa4:	ea43 7305 	orr.w	r3, r3, r5, lsl #28
 8057fa8:	092a      	lsrs	r2, r5, #4
 8057faa:	461c      	mov	r4, r3
 8057fac:	4615      	mov	r5, r2
 8057fae:	ea54 0305 	orrs.w	r3, r4, r5
 8057fb2:	d1f0      	bne.n	8057f96 <_vfiprintf_r+0x70e>
 8057fb4:	e0e5      	b.n	8058182 <_vfiprintf_r+0x8fa>
 8057fb6:	b933      	cbnz	r3, 8057fc6 <_vfiprintf_r+0x73e>
 8057fb8:	f01a 0f01 	tst.w	sl, #1
 8057fbc:	d003      	beq.n	8057fc6 <_vfiprintf_r+0x73e>
 8057fbe:	2330      	movs	r3, #48	; 0x30
 8057fc0:	f88d 30df 	strb.w	r3, [sp, #223]	; 0xdf
 8057fc4:	e79d      	b.n	8057f02 <_vfiprintf_r+0x67a>
 8057fc6:	f10d 08e0 	add.w	r8, sp, #224	; 0xe0
 8057fca:	e0da      	b.n	8058182 <_vfiprintf_r+0x8fa>
 8057fcc:	2b00      	cmp	r3, #0
 8057fce:	f000 80a4 	beq.w	805811a <_vfiprintf_r+0x892>
 8057fd2:	2100      	movs	r1, #0
 8057fd4:	f88d 307c 	strb.w	r3, [sp, #124]	; 0x7c
 8057fd8:	f88d 102b 	strb.w	r1, [sp, #43]	; 0x2b
 8057fdc:	46a3      	mov	fp, r4
 8057fde:	e5e7      	b.n	8057bb0 <_vfiprintf_r+0x328>
 8057fe0:	4605      	mov	r5, r0
 8057fe2:	e68c      	b.n	8057cfe <_vfiprintf_r+0x476>
 8057fe4:	2010      	movs	r0, #16
 8057fe6:	4402      	add	r2, r0
 8057fe8:	2b07      	cmp	r3, #7
 8057fea:	e9cd 320d 	strd	r3, r2, [sp, #52]	; 0x34
 8057fee:	6070      	str	r0, [r6, #4]
 8057ff0:	dd07      	ble.n	8058002 <_vfiprintf_r+0x77a>
 8057ff2:	aa0c      	add	r2, sp, #48	; 0x30
 8057ff4:	4639      	mov	r1, r7
 8057ff6:	4648      	mov	r0, r9
 8057ff8:	f7ff fc13 	bl	8057822 <__sprint_r>
 8057ffc:	2800      	cmp	r0, #0
 8057ffe:	d16b      	bne.n	80580d8 <_vfiprintf_r+0x850>
 8058000:	a90f      	add	r1, sp, #60	; 0x3c
 8058002:	3c10      	subs	r4, #16
 8058004:	460e      	mov	r6, r1
 8058006:	e695      	b.n	8057d34 <_vfiprintf_r+0x4ac>
 8058008:	460e      	mov	r6, r1
 805800a:	e6ae      	b.n	8057d6a <_vfiprintf_r+0x4e2>
 805800c:	aa0c      	add	r2, sp, #48	; 0x30
 805800e:	4639      	mov	r1, r7
 8058010:	4648      	mov	r0, r9
 8058012:	f7ff fc06 	bl	8057822 <__sprint_r>
 8058016:	2800      	cmp	r0, #0
 8058018:	d15e      	bne.n	80580d8 <_vfiprintf_r+0x850>
 805801a:	ae0f      	add	r6, sp, #60	; 0x3c
 805801c:	e6b7      	b.n	8057d8e <_vfiprintf_r+0x506>
 805801e:	bf00      	nop
 8058020:	0805af44 	.word	0x0805af44
 8058024:	0805af54 	.word	0x0805af54
 8058028:	0805ab71 	.word	0x0805ab71
 805802c:	aa0c      	add	r2, sp, #48	; 0x30
 805802e:	4639      	mov	r1, r7
 8058030:	4648      	mov	r0, r9
 8058032:	f7ff fbf6 	bl	8057822 <__sprint_r>
 8058036:	2800      	cmp	r0, #0
 8058038:	d14e      	bne.n	80580d8 <_vfiprintf_r+0x850>
 805803a:	ae0f      	add	r6, sp, #60	; 0x3c
 805803c:	e6b7      	b.n	8057dae <_vfiprintf_r+0x526>
 805803e:	2010      	movs	r0, #16
 8058040:	4402      	add	r2, r0
 8058042:	2b07      	cmp	r3, #7
 8058044:	e9cd 320d 	strd	r3, r2, [sp, #52]	; 0x34
 8058048:	6070      	str	r0, [r6, #4]
 805804a:	dd07      	ble.n	805805c <_vfiprintf_r+0x7d4>
 805804c:	aa0c      	add	r2, sp, #48	; 0x30
 805804e:	4639      	mov	r1, r7
 8058050:	4648      	mov	r0, r9
 8058052:	f7ff fbe6 	bl	8057822 <__sprint_r>
 8058056:	2800      	cmp	r0, #0
 8058058:	d13e      	bne.n	80580d8 <_vfiprintf_r+0x850>
 805805a:	a90f      	add	r1, sp, #60	; 0x3c
 805805c:	3c10      	subs	r4, #16
 805805e:	460e      	mov	r6, r1
 8058060:	e6ad      	b.n	8057dbe <_vfiprintf_r+0x536>
 8058062:	460e      	mov	r6, r1
 8058064:	e6c6      	b.n	8057df4 <_vfiprintf_r+0x56c>
 8058066:	2010      	movs	r0, #16
 8058068:	4401      	add	r1, r0
 805806a:	2b07      	cmp	r3, #7
 805806c:	e9cd 310d 	strd	r3, r1, [sp, #52]	; 0x34
 8058070:	6070      	str	r0, [r6, #4]
 8058072:	dd06      	ble.n	8058082 <_vfiprintf_r+0x7fa>
 8058074:	aa0c      	add	r2, sp, #48	; 0x30
 8058076:	4639      	mov	r1, r7
 8058078:	4648      	mov	r0, r9
 805807a:	f7ff fbd2 	bl	8057822 <__sprint_r>
 805807e:	bb58      	cbnz	r0, 80580d8 <_vfiprintf_r+0x850>
 8058080:	aa0f      	add	r2, sp, #60	; 0x3c
 8058082:	3c10      	subs	r4, #16
 8058084:	4616      	mov	r6, r2
 8058086:	e6ba      	b.n	8057dfe <_vfiprintf_r+0x576>
 8058088:	4616      	mov	r6, r2
 805808a:	e6d2      	b.n	8057e32 <_vfiprintf_r+0x5aa>
 805808c:	aa0c      	add	r2, sp, #48	; 0x30
 805808e:	4639      	mov	r1, r7
 8058090:	4648      	mov	r0, r9
 8058092:	f7ff fbc6 	bl	8057822 <__sprint_r>
 8058096:	b9f8      	cbnz	r0, 80580d8 <_vfiprintf_r+0x850>
 8058098:	ab0f      	add	r3, sp, #60	; 0x3c
 805809a:	e6d9      	b.n	8057e50 <_vfiprintf_r+0x5c8>
 805809c:	e9dd 2103 	ldrd	r2, r1, [sp, #12]
 80580a0:	1a54      	subs	r4, r2, r1
 80580a2:	2c00      	cmp	r4, #0
 80580a4:	f77f aed8 	ble.w	8057e58 <_vfiprintf_r+0x5d0>
 80580a8:	4d3a      	ldr	r5, [pc, #232]	; (8058194 <_vfiprintf_r+0x90c>)
 80580aa:	2610      	movs	r6, #16
 80580ac:	e9dd 210d 	ldrd	r2, r1, [sp, #52]	; 0x34
 80580b0:	2c10      	cmp	r4, #16
 80580b2:	f102 0201 	add.w	r2, r2, #1
 80580b6:	601d      	str	r5, [r3, #0]
 80580b8:	dc1d      	bgt.n	80580f6 <_vfiprintf_r+0x86e>
 80580ba:	605c      	str	r4, [r3, #4]
 80580bc:	2a07      	cmp	r2, #7
 80580be:	440c      	add	r4, r1
 80580c0:	e9cd 240d 	strd	r2, r4, [sp, #52]	; 0x34
 80580c4:	f77f aec8 	ble.w	8057e58 <_vfiprintf_r+0x5d0>
 80580c8:	aa0c      	add	r2, sp, #48	; 0x30
 80580ca:	4639      	mov	r1, r7
 80580cc:	4648      	mov	r0, r9
 80580ce:	f7ff fba8 	bl	8057822 <__sprint_r>
 80580d2:	2800      	cmp	r0, #0
 80580d4:	f43f aec0 	beq.w	8057e58 <_vfiprintf_r+0x5d0>
 80580d8:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 80580da:	07d9      	lsls	r1, r3, #31
 80580dc:	d405      	bmi.n	80580ea <_vfiprintf_r+0x862>
 80580de:	89bb      	ldrh	r3, [r7, #12]
 80580e0:	059a      	lsls	r2, r3, #22
 80580e2:	d402      	bmi.n	80580ea <_vfiprintf_r+0x862>
 80580e4:	6db8      	ldr	r0, [r7, #88]	; 0x58
 80580e6:	f7fe fd9e 	bl	8056c26 <__retarget_lock_release_recursive>
 80580ea:	89bb      	ldrh	r3, [r7, #12]
 80580ec:	065b      	lsls	r3, r3, #25
 80580ee:	f57f abfe 	bpl.w	80578ee <_vfiprintf_r+0x66>
 80580f2:	f7ff bbf9 	b.w	80578e8 <_vfiprintf_r+0x60>
 80580f6:	3110      	adds	r1, #16
 80580f8:	2a07      	cmp	r2, #7
 80580fa:	e9cd 210d 	strd	r2, r1, [sp, #52]	; 0x34
 80580fe:	605e      	str	r6, [r3, #4]
 8058100:	dc02      	bgt.n	8058108 <_vfiprintf_r+0x880>
 8058102:	3308      	adds	r3, #8
 8058104:	3c10      	subs	r4, #16
 8058106:	e7d1      	b.n	80580ac <_vfiprintf_r+0x824>
 8058108:	aa0c      	add	r2, sp, #48	; 0x30
 805810a:	4639      	mov	r1, r7
 805810c:	4648      	mov	r0, r9
 805810e:	f7ff fb88 	bl	8057822 <__sprint_r>
 8058112:	2800      	cmp	r0, #0
 8058114:	d1e0      	bne.n	80580d8 <_vfiprintf_r+0x850>
 8058116:	ab0f      	add	r3, sp, #60	; 0x3c
 8058118:	e7f4      	b.n	8058104 <_vfiprintf_r+0x87c>
 805811a:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 805811c:	b913      	cbnz	r3, 8058124 <_vfiprintf_r+0x89c>
 805811e:	2300      	movs	r3, #0
 8058120:	930d      	str	r3, [sp, #52]	; 0x34
 8058122:	e7d9      	b.n	80580d8 <_vfiprintf_r+0x850>
 8058124:	aa0c      	add	r2, sp, #48	; 0x30
 8058126:	4639      	mov	r1, r7
 8058128:	4648      	mov	r0, r9
 805812a:	f7ff fb7a 	bl	8057822 <__sprint_r>
 805812e:	2800      	cmp	r0, #0
 8058130:	d0f5      	beq.n	805811e <_vfiprintf_r+0x896>
 8058132:	e7d1      	b.n	80580d8 <_vfiprintf_r+0x850>
 8058134:	ea54 0205 	orrs.w	r2, r4, r5
 8058138:	f8cd a010 	str.w	sl, [sp, #16]
 805813c:	f43f ada4 	beq.w	8057c88 <_vfiprintf_r+0x400>
 8058140:	2b01      	cmp	r3, #1
 8058142:	f43f aed7 	beq.w	8057ef4 <_vfiprintf_r+0x66c>
 8058146:	2b02      	cmp	r3, #2
 8058148:	f10d 08e0 	add.w	r8, sp, #224	; 0xe0
 805814c:	f43f af23 	beq.w	8057f96 <_vfiprintf_r+0x70e>
 8058150:	08e2      	lsrs	r2, r4, #3
 8058152:	ea42 7245 	orr.w	r2, r2, r5, lsl #29
 8058156:	08e8      	lsrs	r0, r5, #3
 8058158:	f004 0307 	and.w	r3, r4, #7
 805815c:	4605      	mov	r5, r0
 805815e:	4614      	mov	r4, r2
 8058160:	3330      	adds	r3, #48	; 0x30
 8058162:	ea54 0205 	orrs.w	r2, r4, r5
 8058166:	4641      	mov	r1, r8
 8058168:	f808 3d01 	strb.w	r3, [r8, #-1]!
 805816c:	d1f0      	bne.n	8058150 <_vfiprintf_r+0x8c8>
 805816e:	9a04      	ldr	r2, [sp, #16]
 8058170:	07d0      	lsls	r0, r2, #31
 8058172:	d506      	bpl.n	8058182 <_vfiprintf_r+0x8fa>
 8058174:	2b30      	cmp	r3, #48	; 0x30
 8058176:	d004      	beq.n	8058182 <_vfiprintf_r+0x8fa>
 8058178:	2330      	movs	r3, #48	; 0x30
 805817a:	f808 3c01 	strb.w	r3, [r8, #-1]
 805817e:	f1a1 0802 	sub.w	r8, r1, #2
 8058182:	ab38      	add	r3, sp, #224	; 0xe0
 8058184:	eba3 0308 	sub.w	r3, r3, r8
 8058188:	9d00      	ldr	r5, [sp, #0]
 805818a:	f8dd a010 	ldr.w	sl, [sp, #16]
 805818e:	9300      	str	r3, [sp, #0]
 8058190:	e5b5      	b.n	8057cfe <_vfiprintf_r+0x476>
 8058192:	bf00      	nop
 8058194:	0805af44 	.word	0x0805af44

08058198 <__sbprintf>:
 8058198:	b570      	push	{r4, r5, r6, lr}
 805819a:	460c      	mov	r4, r1
 805819c:	8989      	ldrh	r1, [r1, #12]
 805819e:	f5ad 6d8e 	sub.w	sp, sp, #1136	; 0x470
 80581a2:	f021 0102 	bic.w	r1, r1, #2
 80581a6:	f8ad 1014 	strh.w	r1, [sp, #20]
 80581aa:	6e61      	ldr	r1, [r4, #100]	; 0x64
 80581ac:	911b      	str	r1, [sp, #108]	; 0x6c
 80581ae:	89e1      	ldrh	r1, [r4, #14]
 80581b0:	f8ad 1016 	strh.w	r1, [sp, #22]
 80581b4:	69e1      	ldr	r1, [r4, #28]
 80581b6:	9109      	str	r1, [sp, #36]	; 0x24
 80581b8:	6a61      	ldr	r1, [r4, #36]	; 0x24
 80581ba:	910b      	str	r1, [sp, #44]	; 0x2c
 80581bc:	a91c      	add	r1, sp, #112	; 0x70
 80581be:	9102      	str	r1, [sp, #8]
 80581c0:	9106      	str	r1, [sp, #24]
 80581c2:	f44f 6180 	mov.w	r1, #1024	; 0x400
 80581c6:	4606      	mov	r6, r0
 80581c8:	9104      	str	r1, [sp, #16]
 80581ca:	9107      	str	r1, [sp, #28]
 80581cc:	a818      	add	r0, sp, #96	; 0x60
 80581ce:	2100      	movs	r1, #0
 80581d0:	e9cd 3200 	strd	r3, r2, [sp]
 80581d4:	9108      	str	r1, [sp, #32]
 80581d6:	f7fe fd23 	bl	8056c20 <__retarget_lock_init_recursive>
 80581da:	e9dd 3200 	ldrd	r3, r2, [sp]
 80581de:	a902      	add	r1, sp, #8
 80581e0:	4630      	mov	r0, r6
 80581e2:	f7ff fb51 	bl	8057888 <_vfiprintf_r>
 80581e6:	1e05      	subs	r5, r0, #0
 80581e8:	db07      	blt.n	80581fa <__sbprintf+0x62>
 80581ea:	a902      	add	r1, sp, #8
 80581ec:	4630      	mov	r0, r6
 80581ee:	f7fd ffc3 	bl	8056178 <_fflush_r>
 80581f2:	2800      	cmp	r0, #0
 80581f4:	bf18      	it	ne
 80581f6:	f04f 35ff 	movne.w	r5, #4294967295
 80581fa:	f8bd 3014 	ldrh.w	r3, [sp, #20]
 80581fe:	9818      	ldr	r0, [sp, #96]	; 0x60
 8058200:	065b      	lsls	r3, r3, #25
 8058202:	bf42      	ittt	mi
 8058204:	89a3      	ldrhmi	r3, [r4, #12]
 8058206:	f043 0340 	orrmi.w	r3, r3, #64	; 0x40
 805820a:	81a3      	strhmi	r3, [r4, #12]
 805820c:	f7fe fd09 	bl	8056c22 <__retarget_lock_close_recursive>
 8058210:	4628      	mov	r0, r5
 8058212:	f50d 6d8e 	add.w	sp, sp, #1136	; 0x470
 8058216:	bd70      	pop	{r4, r5, r6, pc}

08058218 <__ascii_wctomb>:
 8058218:	b149      	cbz	r1, 805822e <__ascii_wctomb+0x16>
 805821a:	2aff      	cmp	r2, #255	; 0xff
 805821c:	bf85      	ittet	hi
 805821e:	238a      	movhi	r3, #138	; 0x8a
 8058220:	6003      	strhi	r3, [r0, #0]
 8058222:	700a      	strbls	r2, [r1, #0]
 8058224:	f04f 30ff 	movhi.w	r0, #4294967295
 8058228:	bf98      	it	ls
 805822a:	2001      	movls	r0, #1
 805822c:	4770      	bx	lr
 805822e:	4608      	mov	r0, r1
 8058230:	4770      	bx	lr
	...

08058234 <_write_r>:
 8058234:	b538      	push	{r3, r4, r5, lr}
 8058236:	4d07      	ldr	r5, [pc, #28]	; (8058254 <_write_r+0x20>)
 8058238:	4604      	mov	r4, r0
 805823a:	4608      	mov	r0, r1
 805823c:	4611      	mov	r1, r2
 805823e:	2200      	movs	r2, #0
 8058240:	602a      	str	r2, [r5, #0]
 8058242:	461a      	mov	r2, r3
 8058244:	f7f8 f9ee 	bl	8050624 <_write>
 8058248:	1c43      	adds	r3, r0, #1
 805824a:	d102      	bne.n	8058252 <_write_r+0x1e>
 805824c:	682b      	ldr	r3, [r5, #0]
 805824e:	b103      	cbz	r3, 8058252 <_write_r+0x1e>
 8058250:	6023      	str	r3, [r4, #0]
 8058252:	bd38      	pop	{r3, r4, r5, pc}
 8058254:	200100a8 	.word	0x200100a8

08058258 <__register_exitproc>:
 8058258:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 805825c:	4d1c      	ldr	r5, [pc, #112]	; (80582d0 <__register_exitproc+0x78>)
 805825e:	4606      	mov	r6, r0
 8058260:	6828      	ldr	r0, [r5, #0]
 8058262:	4698      	mov	r8, r3
 8058264:	460f      	mov	r7, r1
 8058266:	4691      	mov	r9, r2
 8058268:	f7fe fcdc 	bl	8056c24 <__retarget_lock_acquire_recursive>
 805826c:	4b19      	ldr	r3, [pc, #100]	; (80582d4 <__register_exitproc+0x7c>)
 805826e:	681b      	ldr	r3, [r3, #0]
 8058270:	f8d3 4148 	ldr.w	r4, [r3, #328]	; 0x148
 8058274:	4628      	mov	r0, r5
 8058276:	b91c      	cbnz	r4, 8058280 <__register_exitproc+0x28>
 8058278:	f503 74a6 	add.w	r4, r3, #332	; 0x14c
 805827c:	f8c3 4148 	str.w	r4, [r3, #328]	; 0x148
 8058280:	6865      	ldr	r5, [r4, #4]
 8058282:	6800      	ldr	r0, [r0, #0]
 8058284:	2d1f      	cmp	r5, #31
 8058286:	dd05      	ble.n	8058294 <__register_exitproc+0x3c>
 8058288:	f7fe fccd 	bl	8056c26 <__retarget_lock_release_recursive>
 805828c:	f04f 30ff 	mov.w	r0, #4294967295
 8058290:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8058294:	b19e      	cbz	r6, 80582be <__register_exitproc+0x66>
 8058296:	eb04 0185 	add.w	r1, r4, r5, lsl #2
 805829a:	2201      	movs	r2, #1
 805829c:	f8c1 9088 	str.w	r9, [r1, #136]	; 0x88
 80582a0:	f8d4 3188 	ldr.w	r3, [r4, #392]	; 0x188
 80582a4:	40aa      	lsls	r2, r5
 80582a6:	4313      	orrs	r3, r2
 80582a8:	2e02      	cmp	r6, #2
 80582aa:	f8c4 3188 	str.w	r3, [r4, #392]	; 0x188
 80582ae:	f8c1 8108 	str.w	r8, [r1, #264]	; 0x108
 80582b2:	bf02      	ittt	eq
 80582b4:	f8d4 318c 	ldreq.w	r3, [r4, #396]	; 0x18c
 80582b8:	431a      	orreq	r2, r3
 80582ba:	f8c4 218c 	streq.w	r2, [r4, #396]	; 0x18c
 80582be:	1c6b      	adds	r3, r5, #1
 80582c0:	3502      	adds	r5, #2
 80582c2:	6063      	str	r3, [r4, #4]
 80582c4:	f844 7025 	str.w	r7, [r4, r5, lsl #2]
 80582c8:	f7fe fcad 	bl	8056c26 <__retarget_lock_release_recursive>
 80582cc:	2000      	movs	r0, #0
 80582ce:	e7df      	b.n	8058290 <__register_exitproc+0x38>
 80582d0:	20003f10 	.word	0x20003f10
 80582d4:	0805aafc 	.word	0x0805aafc

080582d8 <__assert_func>:
 80582d8:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 80582da:	4614      	mov	r4, r2
 80582dc:	461a      	mov	r2, r3
 80582de:	4b09      	ldr	r3, [pc, #36]	; (8058304 <__assert_func+0x2c>)
 80582e0:	681b      	ldr	r3, [r3, #0]
 80582e2:	4605      	mov	r5, r0
 80582e4:	68d8      	ldr	r0, [r3, #12]
 80582e6:	b14c      	cbz	r4, 80582fc <__assert_func+0x24>
 80582e8:	4b07      	ldr	r3, [pc, #28]	; (8058308 <__assert_func+0x30>)
 80582ea:	9100      	str	r1, [sp, #0]
 80582ec:	e9cd 3401 	strd	r3, r4, [sp, #4]
 80582f0:	4906      	ldr	r1, [pc, #24]	; (805830c <__assert_func+0x34>)
 80582f2:	462b      	mov	r3, r5
 80582f4:	f000 f8a4 	bl	8058440 <fiprintf>
 80582f8:	f000 fcd0 	bl	8058c9c <abort>
 80582fc:	4b04      	ldr	r3, [pc, #16]	; (8058310 <__assert_func+0x38>)
 80582fe:	461c      	mov	r4, r3
 8058300:	e7f3      	b.n	80582ea <__assert_func+0x12>
 8058302:	bf00      	nop
 8058304:	200036d0 	.word	0x200036d0
 8058308:	0805af64 	.word	0x0805af64
 805830c:	0805af71 	.word	0x0805af71
 8058310:	0805af9f 	.word	0x0805af9f

08058314 <_calloc_r>:
 8058314:	b510      	push	{r4, lr}
 8058316:	4351      	muls	r1, r2
 8058318:	f7f9 f924 	bl	8051564 <_malloc_r>
 805831c:	4604      	mov	r4, r0
 805831e:	b198      	cbz	r0, 8058348 <_calloc_r+0x34>
 8058320:	f850 2c04 	ldr.w	r2, [r0, #-4]
 8058324:	f022 0203 	bic.w	r2, r2, #3
 8058328:	3a04      	subs	r2, #4
 805832a:	2a24      	cmp	r2, #36	; 0x24
 805832c:	d81b      	bhi.n	8058366 <_calloc_r+0x52>
 805832e:	2a13      	cmp	r2, #19
 8058330:	d917      	bls.n	8058362 <_calloc_r+0x4e>
 8058332:	2100      	movs	r1, #0
 8058334:	2a1b      	cmp	r2, #27
 8058336:	e9c0 1100 	strd	r1, r1, [r0]
 805833a:	d807      	bhi.n	805834c <_calloc_r+0x38>
 805833c:	f100 0308 	add.w	r3, r0, #8
 8058340:	2200      	movs	r2, #0
 8058342:	e9c3 2200 	strd	r2, r2, [r3]
 8058346:	609a      	str	r2, [r3, #8]
 8058348:	4620      	mov	r0, r4
 805834a:	bd10      	pop	{r4, pc}
 805834c:	2a24      	cmp	r2, #36	; 0x24
 805834e:	e9c0 1102 	strd	r1, r1, [r0, #8]
 8058352:	bf11      	iteee	ne
 8058354:	f100 0310 	addne.w	r3, r0, #16
 8058358:	6101      	streq	r1, [r0, #16]
 805835a:	f100 0318 	addeq.w	r3, r0, #24
 805835e:	6141      	streq	r1, [r0, #20]
 8058360:	e7ee      	b.n	8058340 <_calloc_r+0x2c>
 8058362:	4603      	mov	r3, r0
 8058364:	e7ec      	b.n	8058340 <_calloc_r+0x2c>
 8058366:	2100      	movs	r1, #0
 8058368:	f7f9 fb5a 	bl	8051a20 <memset>
 805836c:	e7ec      	b.n	8058348 <_calloc_r+0x34>
	...

08058370 <_close_r>:
 8058370:	b538      	push	{r3, r4, r5, lr}
 8058372:	4d06      	ldr	r5, [pc, #24]	; (805838c <_close_r+0x1c>)
 8058374:	2300      	movs	r3, #0
 8058376:	4604      	mov	r4, r0
 8058378:	4608      	mov	r0, r1
 805837a:	602b      	str	r3, [r5, #0]
 805837c:	f7f8 f97e 	bl	805067c <_close>
 8058380:	1c43      	adds	r3, r0, #1
 8058382:	d102      	bne.n	805838a <_close_r+0x1a>
 8058384:	682b      	ldr	r3, [r5, #0]
 8058386:	b103      	cbz	r3, 805838a <_close_r+0x1a>
 8058388:	6023      	str	r3, [r4, #0]
 805838a:	bd38      	pop	{r3, r4, r5, pc}
 805838c:	200100a8 	.word	0x200100a8

08058390 <_fclose_r>:
 8058390:	b570      	push	{r4, r5, r6, lr}
 8058392:	4606      	mov	r6, r0
 8058394:	460c      	mov	r4, r1
 8058396:	b911      	cbnz	r1, 805839e <_fclose_r+0xe>
 8058398:	2500      	movs	r5, #0
 805839a:	4628      	mov	r0, r5
 805839c:	bd70      	pop	{r4, r5, r6, pc}
 805839e:	b118      	cbz	r0, 80583a8 <_fclose_r+0x18>
 80583a0:	6b83      	ldr	r3, [r0, #56]	; 0x38
 80583a2:	b90b      	cbnz	r3, 80583a8 <_fclose_r+0x18>
 80583a4:	f7fd ff54 	bl	8056250 <__sinit>
 80583a8:	6e63      	ldr	r3, [r4, #100]	; 0x64
 80583aa:	07d8      	lsls	r0, r3, #31
 80583ac:	d405      	bmi.n	80583ba <_fclose_r+0x2a>
 80583ae:	89a3      	ldrh	r3, [r4, #12]
 80583b0:	0599      	lsls	r1, r3, #22
 80583b2:	d402      	bmi.n	80583ba <_fclose_r+0x2a>
 80583b4:	6da0      	ldr	r0, [r4, #88]	; 0x58
 80583b6:	f7fe fc35 	bl	8056c24 <__retarget_lock_acquire_recursive>
 80583ba:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 80583be:	b93b      	cbnz	r3, 80583d0 <_fclose_r+0x40>
 80583c0:	6e65      	ldr	r5, [r4, #100]	; 0x64
 80583c2:	f015 0501 	ands.w	r5, r5, #1
 80583c6:	d1e7      	bne.n	8058398 <_fclose_r+0x8>
 80583c8:	6da0      	ldr	r0, [r4, #88]	; 0x58
 80583ca:	f7fe fc2c 	bl	8056c26 <__retarget_lock_release_recursive>
 80583ce:	e7e4      	b.n	805839a <_fclose_r+0xa>
 80583d0:	4621      	mov	r1, r4
 80583d2:	4630      	mov	r0, r6
 80583d4:	f7fd fe42 	bl	805605c <__sflush_r>
 80583d8:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 80583da:	4605      	mov	r5, r0
 80583dc:	b133      	cbz	r3, 80583ec <_fclose_r+0x5c>
 80583de:	69e1      	ldr	r1, [r4, #28]
 80583e0:	4630      	mov	r0, r6
 80583e2:	4798      	blx	r3
 80583e4:	2800      	cmp	r0, #0
 80583e6:	bfb8      	it	lt
 80583e8:	f04f 35ff 	movlt.w	r5, #4294967295
 80583ec:	89a3      	ldrh	r3, [r4, #12]
 80583ee:	061a      	lsls	r2, r3, #24
 80583f0:	d503      	bpl.n	80583fa <_fclose_r+0x6a>
 80583f2:	6921      	ldr	r1, [r4, #16]
 80583f4:	4630      	mov	r0, r6
 80583f6:	f7fd ffbb 	bl	8056370 <_free_r>
 80583fa:	6b21      	ldr	r1, [r4, #48]	; 0x30
 80583fc:	b141      	cbz	r1, 8058410 <_fclose_r+0x80>
 80583fe:	f104 0340 	add.w	r3, r4, #64	; 0x40
 8058402:	4299      	cmp	r1, r3
 8058404:	d002      	beq.n	805840c <_fclose_r+0x7c>
 8058406:	4630      	mov	r0, r6
 8058408:	f7fd ffb2 	bl	8056370 <_free_r>
 805840c:	2300      	movs	r3, #0
 805840e:	6323      	str	r3, [r4, #48]	; 0x30
 8058410:	6c61      	ldr	r1, [r4, #68]	; 0x44
 8058412:	b121      	cbz	r1, 805841e <_fclose_r+0x8e>
 8058414:	4630      	mov	r0, r6
 8058416:	f7fd ffab 	bl	8056370 <_free_r>
 805841a:	2300      	movs	r3, #0
 805841c:	6463      	str	r3, [r4, #68]	; 0x44
 805841e:	f7fd feff 	bl	8056220 <__sfp_lock_acquire>
 8058422:	2300      	movs	r3, #0
 8058424:	81a3      	strh	r3, [r4, #12]
 8058426:	6e63      	ldr	r3, [r4, #100]	; 0x64
 8058428:	07db      	lsls	r3, r3, #31
 805842a:	d402      	bmi.n	8058432 <_fclose_r+0xa2>
 805842c:	6da0      	ldr	r0, [r4, #88]	; 0x58
 805842e:	f7fe fbfa 	bl	8056c26 <__retarget_lock_release_recursive>
 8058432:	6da0      	ldr	r0, [r4, #88]	; 0x58
 8058434:	f7fe fbf5 	bl	8056c22 <__retarget_lock_close_recursive>
 8058438:	f7fd fef8 	bl	805622c <__sfp_lock_release>
 805843c:	e7ad      	b.n	805839a <_fclose_r+0xa>
	...

08058440 <fiprintf>:
 8058440:	b40e      	push	{r1, r2, r3}
 8058442:	b503      	push	{r0, r1, lr}
 8058444:	4601      	mov	r1, r0
 8058446:	ab03      	add	r3, sp, #12
 8058448:	4805      	ldr	r0, [pc, #20]	; (8058460 <fiprintf+0x20>)
 805844a:	f853 2b04 	ldr.w	r2, [r3], #4
 805844e:	6800      	ldr	r0, [r0, #0]
 8058450:	9301      	str	r3, [sp, #4]
 8058452:	f7ff fa19 	bl	8057888 <_vfiprintf_r>
 8058456:	b002      	add	sp, #8
 8058458:	f85d eb04 	ldr.w	lr, [sp], #4
 805845c:	b003      	add	sp, #12
 805845e:	4770      	bx	lr
 8058460:	200036d0 	.word	0x200036d0

08058464 <__fputwc>:
 8058464:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
 8058468:	4680      	mov	r8, r0
 805846a:	460e      	mov	r6, r1
 805846c:	4615      	mov	r5, r2
 805846e:	f7fe fbcd 	bl	8056c0c <__locale_mb_cur_max>
 8058472:	2801      	cmp	r0, #1
 8058474:	d11c      	bne.n	80584b0 <__fputwc+0x4c>
 8058476:	1e73      	subs	r3, r6, #1
 8058478:	2bfe      	cmp	r3, #254	; 0xfe
 805847a:	d819      	bhi.n	80584b0 <__fputwc+0x4c>
 805847c:	f88d 6004 	strb.w	r6, [sp, #4]
 8058480:	4604      	mov	r4, r0
 8058482:	2700      	movs	r7, #0
 8058484:	f10d 0904 	add.w	r9, sp, #4
 8058488:	42a7      	cmp	r7, r4
 805848a:	d020      	beq.n	80584ce <__fputwc+0x6a>
 805848c:	68ab      	ldr	r3, [r5, #8]
 805848e:	f817 1009 	ldrb.w	r1, [r7, r9]
 8058492:	3b01      	subs	r3, #1
 8058494:	2b00      	cmp	r3, #0
 8058496:	60ab      	str	r3, [r5, #8]
 8058498:	da04      	bge.n	80584a4 <__fputwc+0x40>
 805849a:	69aa      	ldr	r2, [r5, #24]
 805849c:	4293      	cmp	r3, r2
 805849e:	db1a      	blt.n	80584d6 <__fputwc+0x72>
 80584a0:	290a      	cmp	r1, #10
 80584a2:	d018      	beq.n	80584d6 <__fputwc+0x72>
 80584a4:	682b      	ldr	r3, [r5, #0]
 80584a6:	1c5a      	adds	r2, r3, #1
 80584a8:	602a      	str	r2, [r5, #0]
 80584aa:	7019      	strb	r1, [r3, #0]
 80584ac:	3701      	adds	r7, #1
 80584ae:	e7eb      	b.n	8058488 <__fputwc+0x24>
 80584b0:	4632      	mov	r2, r6
 80584b2:	f105 035c 	add.w	r3, r5, #92	; 0x5c
 80584b6:	a901      	add	r1, sp, #4
 80584b8:	4640      	mov	r0, r8
 80584ba:	f000 fbd9 	bl	8058c70 <_wcrtomb_r>
 80584be:	1c42      	adds	r2, r0, #1
 80584c0:	4604      	mov	r4, r0
 80584c2:	d1de      	bne.n	8058482 <__fputwc+0x1e>
 80584c4:	89ab      	ldrh	r3, [r5, #12]
 80584c6:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80584ca:	81ab      	strh	r3, [r5, #12]
 80584cc:	4606      	mov	r6, r0
 80584ce:	4630      	mov	r0, r6
 80584d0:	b003      	add	sp, #12
 80584d2:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 80584d6:	462a      	mov	r2, r5
 80584d8:	4640      	mov	r0, r8
 80584da:	f000 fb7f 	bl	8058bdc <__swbuf_r>
 80584de:	1c43      	adds	r3, r0, #1
 80584e0:	d1e4      	bne.n	80584ac <__fputwc+0x48>
 80584e2:	4606      	mov	r6, r0
 80584e4:	e7f3      	b.n	80584ce <__fputwc+0x6a>

080584e6 <_fputwc_r>:
 80584e6:	6e53      	ldr	r3, [r2, #100]	; 0x64
 80584e8:	b537      	push	{r0, r1, r2, r4, r5, lr}
 80584ea:	4614      	mov	r4, r2
 80584ec:	07da      	lsls	r2, r3, #31
 80584ee:	4605      	mov	r5, r0
 80584f0:	d407      	bmi.n	8058502 <_fputwc_r+0x1c>
 80584f2:	89a3      	ldrh	r3, [r4, #12]
 80584f4:	059b      	lsls	r3, r3, #22
 80584f6:	d404      	bmi.n	8058502 <_fputwc_r+0x1c>
 80584f8:	6da0      	ldr	r0, [r4, #88]	; 0x58
 80584fa:	9101      	str	r1, [sp, #4]
 80584fc:	f7fe fb92 	bl	8056c24 <__retarget_lock_acquire_recursive>
 8058500:	9901      	ldr	r1, [sp, #4]
 8058502:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8058506:	0498      	lsls	r0, r3, #18
 8058508:	d406      	bmi.n	8058518 <_fputwc_r+0x32>
 805850a:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 805850e:	81a3      	strh	r3, [r4, #12]
 8058510:	6e63      	ldr	r3, [r4, #100]	; 0x64
 8058512:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8058516:	6663      	str	r3, [r4, #100]	; 0x64
 8058518:	4622      	mov	r2, r4
 805851a:	4628      	mov	r0, r5
 805851c:	f7ff ffa2 	bl	8058464 <__fputwc>
 8058520:	6e63      	ldr	r3, [r4, #100]	; 0x64
 8058522:	07da      	lsls	r2, r3, #31
 8058524:	4605      	mov	r5, r0
 8058526:	d405      	bmi.n	8058534 <_fputwc_r+0x4e>
 8058528:	89a3      	ldrh	r3, [r4, #12]
 805852a:	059b      	lsls	r3, r3, #22
 805852c:	d402      	bmi.n	8058534 <_fputwc_r+0x4e>
 805852e:	6da0      	ldr	r0, [r4, #88]	; 0x58
 8058530:	f7fe fb79 	bl	8056c26 <__retarget_lock_release_recursive>
 8058534:	4628      	mov	r0, r5
 8058536:	b003      	add	sp, #12
 8058538:	bd30      	pop	{r4, r5, pc}
	...

0805853c <_fstat_r>:
 805853c:	b538      	push	{r3, r4, r5, lr}
 805853e:	4d07      	ldr	r5, [pc, #28]	; (805855c <_fstat_r+0x20>)
 8058540:	2300      	movs	r3, #0
 8058542:	4604      	mov	r4, r0
 8058544:	4608      	mov	r0, r1
 8058546:	4611      	mov	r1, r2
 8058548:	602b      	str	r3, [r5, #0]
 805854a:	f7f8 f89a 	bl	8050682 <_fstat>
 805854e:	1c43      	adds	r3, r0, #1
 8058550:	d102      	bne.n	8058558 <_fstat_r+0x1c>
 8058552:	682b      	ldr	r3, [r5, #0]
 8058554:	b103      	cbz	r3, 8058558 <_fstat_r+0x1c>
 8058556:	6023      	str	r3, [r4, #0]
 8058558:	bd38      	pop	{r3, r4, r5, pc}
 805855a:	bf00      	nop
 805855c:	200100a8 	.word	0x200100a8

08058560 <__sfvwrite_r>:
 8058560:	6893      	ldr	r3, [r2, #8]
 8058562:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8058566:	4606      	mov	r6, r0
 8058568:	460c      	mov	r4, r1
 805856a:	4690      	mov	r8, r2
 805856c:	b91b      	cbnz	r3, 8058576 <__sfvwrite_r+0x16>
 805856e:	2000      	movs	r0, #0
 8058570:	b003      	add	sp, #12
 8058572:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8058576:	898b      	ldrh	r3, [r1, #12]
 8058578:	0718      	lsls	r0, r3, #28
 805857a:	d550      	bpl.n	805861e <__sfvwrite_r+0xbe>
 805857c:	690b      	ldr	r3, [r1, #16]
 805857e:	2b00      	cmp	r3, #0
 8058580:	d04d      	beq.n	805861e <__sfvwrite_r+0xbe>
 8058582:	89a3      	ldrh	r3, [r4, #12]
 8058584:	f8d8 7000 	ldr.w	r7, [r8]
 8058588:	f013 0902 	ands.w	r9, r3, #2
 805858c:	d16c      	bne.n	8058668 <__sfvwrite_r+0x108>
 805858e:	f013 0301 	ands.w	r3, r3, #1
 8058592:	f000 809c 	beq.w	80586ce <__sfvwrite_r+0x16e>
 8058596:	4648      	mov	r0, r9
 8058598:	46ca      	mov	sl, r9
 805859a:	46cb      	mov	fp, r9
 805859c:	f1bb 0f00 	cmp.w	fp, #0
 80585a0:	f000 8103 	beq.w	80587aa <__sfvwrite_r+0x24a>
 80585a4:	b950      	cbnz	r0, 80585bc <__sfvwrite_r+0x5c>
 80585a6:	465a      	mov	r2, fp
 80585a8:	210a      	movs	r1, #10
 80585aa:	4650      	mov	r0, sl
 80585ac:	f7e7 fe38 	bl	8040220 <memchr>
 80585b0:	2800      	cmp	r0, #0
 80585b2:	f000 80ff 	beq.w	80587b4 <__sfvwrite_r+0x254>
 80585b6:	3001      	adds	r0, #1
 80585b8:	eba0 090a 	sub.w	r9, r0, sl
 80585bc:	6820      	ldr	r0, [r4, #0]
 80585be:	6921      	ldr	r1, [r4, #16]
 80585c0:	6963      	ldr	r3, [r4, #20]
 80585c2:	45d9      	cmp	r9, fp
 80585c4:	464a      	mov	r2, r9
 80585c6:	bf28      	it	cs
 80585c8:	465a      	movcs	r2, fp
 80585ca:	4288      	cmp	r0, r1
 80585cc:	f240 80f5 	bls.w	80587ba <__sfvwrite_r+0x25a>
 80585d0:	68a5      	ldr	r5, [r4, #8]
 80585d2:	441d      	add	r5, r3
 80585d4:	42aa      	cmp	r2, r5
 80585d6:	f340 80f0 	ble.w	80587ba <__sfvwrite_r+0x25a>
 80585da:	4651      	mov	r1, sl
 80585dc:	462a      	mov	r2, r5
 80585de:	f000 f92b 	bl	8058838 <memmove>
 80585e2:	6823      	ldr	r3, [r4, #0]
 80585e4:	442b      	add	r3, r5
 80585e6:	6023      	str	r3, [r4, #0]
 80585e8:	4621      	mov	r1, r4
 80585ea:	4630      	mov	r0, r6
 80585ec:	f7fd fdc4 	bl	8056178 <_fflush_r>
 80585f0:	2800      	cmp	r0, #0
 80585f2:	d167      	bne.n	80586c4 <__sfvwrite_r+0x164>
 80585f4:	ebb9 0905 	subs.w	r9, r9, r5
 80585f8:	f040 80f7 	bne.w	80587ea <__sfvwrite_r+0x28a>
 80585fc:	4621      	mov	r1, r4
 80585fe:	4630      	mov	r0, r6
 8058600:	f7fd fdba 	bl	8056178 <_fflush_r>
 8058604:	2800      	cmp	r0, #0
 8058606:	d15d      	bne.n	80586c4 <__sfvwrite_r+0x164>
 8058608:	f8d8 2008 	ldr.w	r2, [r8, #8]
 805860c:	44aa      	add	sl, r5
 805860e:	ebab 0b05 	sub.w	fp, fp, r5
 8058612:	1b55      	subs	r5, r2, r5
 8058614:	f8c8 5008 	str.w	r5, [r8, #8]
 8058618:	2d00      	cmp	r5, #0
 805861a:	d1bf      	bne.n	805859c <__sfvwrite_r+0x3c>
 805861c:	e7a7      	b.n	805856e <__sfvwrite_r+0xe>
 805861e:	4621      	mov	r1, r4
 8058620:	4630      	mov	r0, r6
 8058622:	f7fc fe4b 	bl	80552bc <__swsetup_r>
 8058626:	2800      	cmp	r0, #0
 8058628:	d0ab      	beq.n	8058582 <__sfvwrite_r+0x22>
 805862a:	f04f 30ff 	mov.w	r0, #4294967295
 805862e:	e79f      	b.n	8058570 <__sfvwrite_r+0x10>
 8058630:	e9d7 b900 	ldrd	fp, r9, [r7]
 8058634:	3708      	adds	r7, #8
 8058636:	f1b9 0f00 	cmp.w	r9, #0
 805863a:	d0f9      	beq.n	8058630 <__sfvwrite_r+0xd0>
 805863c:	45d1      	cmp	r9, sl
 805863e:	464b      	mov	r3, r9
 8058640:	69e1      	ldr	r1, [r4, #28]
 8058642:	6a65      	ldr	r5, [r4, #36]	; 0x24
 8058644:	bf28      	it	cs
 8058646:	4653      	movcs	r3, sl
 8058648:	465a      	mov	r2, fp
 805864a:	4630      	mov	r0, r6
 805864c:	47a8      	blx	r5
 805864e:	2800      	cmp	r0, #0
 8058650:	dd38      	ble.n	80586c4 <__sfvwrite_r+0x164>
 8058652:	f8d8 3008 	ldr.w	r3, [r8, #8]
 8058656:	4483      	add	fp, r0
 8058658:	eba9 0900 	sub.w	r9, r9, r0
 805865c:	1a18      	subs	r0, r3, r0
 805865e:	f8c8 0008 	str.w	r0, [r8, #8]
 8058662:	2800      	cmp	r0, #0
 8058664:	d1e7      	bne.n	8058636 <__sfvwrite_r+0xd6>
 8058666:	e782      	b.n	805856e <__sfvwrite_r+0xe>
 8058668:	f04f 0b00 	mov.w	fp, #0
 805866c:	f8df a180 	ldr.w	sl, [pc, #384]	; 80587f0 <__sfvwrite_r+0x290>
 8058670:	46d9      	mov	r9, fp
 8058672:	e7e0      	b.n	8058636 <__sfvwrite_r+0xd6>
 8058674:	e9d7 9a00 	ldrd	r9, sl, [r7]
 8058678:	3708      	adds	r7, #8
 805867a:	f1ba 0f00 	cmp.w	sl, #0
 805867e:	d0f9      	beq.n	8058674 <__sfvwrite_r+0x114>
 8058680:	89a3      	ldrh	r3, [r4, #12]
 8058682:	68a2      	ldr	r2, [r4, #8]
 8058684:	6820      	ldr	r0, [r4, #0]
 8058686:	0599      	lsls	r1, r3, #22
 8058688:	d563      	bpl.n	8058752 <__sfvwrite_r+0x1f2>
 805868a:	4552      	cmp	r2, sl
 805868c:	d836      	bhi.n	80586fc <__sfvwrite_r+0x19c>
 805868e:	f413 6f90 	tst.w	r3, #1152	; 0x480
 8058692:	d033      	beq.n	80586fc <__sfvwrite_r+0x19c>
 8058694:	6921      	ldr	r1, [r4, #16]
 8058696:	6965      	ldr	r5, [r4, #20]
 8058698:	eba0 0b01 	sub.w	fp, r0, r1
 805869c:	eb05 0545 	add.w	r5, r5, r5, lsl #1
 80586a0:	eb05 75d5 	add.w	r5, r5, r5, lsr #31
 80586a4:	f10b 0201 	add.w	r2, fp, #1
 80586a8:	106d      	asrs	r5, r5, #1
 80586aa:	4452      	add	r2, sl
 80586ac:	4295      	cmp	r5, r2
 80586ae:	bf38      	it	cc
 80586b0:	4615      	movcc	r5, r2
 80586b2:	055b      	lsls	r3, r3, #21
 80586b4:	d53d      	bpl.n	8058732 <__sfvwrite_r+0x1d2>
 80586b6:	4629      	mov	r1, r5
 80586b8:	4630      	mov	r0, r6
 80586ba:	f7f8 ff53 	bl	8051564 <_malloc_r>
 80586be:	b948      	cbnz	r0, 80586d4 <__sfvwrite_r+0x174>
 80586c0:	230c      	movs	r3, #12
 80586c2:	6033      	str	r3, [r6, #0]
 80586c4:	89a3      	ldrh	r3, [r4, #12]
 80586c6:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80586ca:	81a3      	strh	r3, [r4, #12]
 80586cc:	e7ad      	b.n	805862a <__sfvwrite_r+0xca>
 80586ce:	4699      	mov	r9, r3
 80586d0:	469a      	mov	sl, r3
 80586d2:	e7d2      	b.n	805867a <__sfvwrite_r+0x11a>
 80586d4:	465a      	mov	r2, fp
 80586d6:	6921      	ldr	r1, [r4, #16]
 80586d8:	9001      	str	r0, [sp, #4]
 80586da:	f7f9 f993 	bl	8051a04 <memcpy>
 80586de:	89a2      	ldrh	r2, [r4, #12]
 80586e0:	9b01      	ldr	r3, [sp, #4]
 80586e2:	f422 6290 	bic.w	r2, r2, #1152	; 0x480
 80586e6:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 80586ea:	81a2      	strh	r2, [r4, #12]
 80586ec:	6123      	str	r3, [r4, #16]
 80586ee:	6165      	str	r5, [r4, #20]
 80586f0:	445b      	add	r3, fp
 80586f2:	eba5 050b 	sub.w	r5, r5, fp
 80586f6:	6023      	str	r3, [r4, #0]
 80586f8:	4652      	mov	r2, sl
 80586fa:	60a5      	str	r5, [r4, #8]
 80586fc:	4552      	cmp	r2, sl
 80586fe:	bf28      	it	cs
 8058700:	4652      	movcs	r2, sl
 8058702:	6820      	ldr	r0, [r4, #0]
 8058704:	9201      	str	r2, [sp, #4]
 8058706:	4649      	mov	r1, r9
 8058708:	f000 f896 	bl	8058838 <memmove>
 805870c:	68a3      	ldr	r3, [r4, #8]
 805870e:	9a01      	ldr	r2, [sp, #4]
 8058710:	1a9b      	subs	r3, r3, r2
 8058712:	60a3      	str	r3, [r4, #8]
 8058714:	6823      	ldr	r3, [r4, #0]
 8058716:	441a      	add	r2, r3
 8058718:	4655      	mov	r5, sl
 805871a:	6022      	str	r2, [r4, #0]
 805871c:	f8d8 0008 	ldr.w	r0, [r8, #8]
 8058720:	44a9      	add	r9, r5
 8058722:	ebaa 0a05 	sub.w	sl, sl, r5
 8058726:	1b45      	subs	r5, r0, r5
 8058728:	f8c8 5008 	str.w	r5, [r8, #8]
 805872c:	2d00      	cmp	r5, #0
 805872e:	d1a4      	bne.n	805867a <__sfvwrite_r+0x11a>
 8058730:	e71d      	b.n	805856e <__sfvwrite_r+0xe>
 8058732:	462a      	mov	r2, r5
 8058734:	4630      	mov	r0, r6
 8058736:	f000 f8ab 	bl	8058890 <_realloc_r>
 805873a:	4603      	mov	r3, r0
 805873c:	2800      	cmp	r0, #0
 805873e:	d1d5      	bne.n	80586ec <__sfvwrite_r+0x18c>
 8058740:	6921      	ldr	r1, [r4, #16]
 8058742:	4630      	mov	r0, r6
 8058744:	f7fd fe14 	bl	8056370 <_free_r>
 8058748:	89a3      	ldrh	r3, [r4, #12]
 805874a:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 805874e:	81a3      	strh	r3, [r4, #12]
 8058750:	e7b6      	b.n	80586c0 <__sfvwrite_r+0x160>
 8058752:	6923      	ldr	r3, [r4, #16]
 8058754:	4283      	cmp	r3, r0
 8058756:	d302      	bcc.n	805875e <__sfvwrite_r+0x1fe>
 8058758:	6961      	ldr	r1, [r4, #20]
 805875a:	4551      	cmp	r1, sl
 805875c:	d915      	bls.n	805878a <__sfvwrite_r+0x22a>
 805875e:	4552      	cmp	r2, sl
 8058760:	bf28      	it	cs
 8058762:	4652      	movcs	r2, sl
 8058764:	4649      	mov	r1, r9
 8058766:	4615      	mov	r5, r2
 8058768:	f000 f866 	bl	8058838 <memmove>
 805876c:	68a3      	ldr	r3, [r4, #8]
 805876e:	6822      	ldr	r2, [r4, #0]
 8058770:	1b5b      	subs	r3, r3, r5
 8058772:	442a      	add	r2, r5
 8058774:	60a3      	str	r3, [r4, #8]
 8058776:	6022      	str	r2, [r4, #0]
 8058778:	2b00      	cmp	r3, #0
 805877a:	d1cf      	bne.n	805871c <__sfvwrite_r+0x1bc>
 805877c:	4621      	mov	r1, r4
 805877e:	4630      	mov	r0, r6
 8058780:	f7fd fcfa 	bl	8056178 <_fflush_r>
 8058784:	2800      	cmp	r0, #0
 8058786:	d0c9      	beq.n	805871c <__sfvwrite_r+0x1bc>
 8058788:	e79c      	b.n	80586c4 <__sfvwrite_r+0x164>
 805878a:	f06f 4300 	mvn.w	r3, #2147483648	; 0x80000000
 805878e:	459a      	cmp	sl, r3
 8058790:	bf38      	it	cc
 8058792:	4653      	movcc	r3, sl
 8058794:	6a65      	ldr	r5, [r4, #36]	; 0x24
 8058796:	fb93 f3f1 	sdiv	r3, r3, r1
 805879a:	464a      	mov	r2, r9
 805879c:	434b      	muls	r3, r1
 805879e:	4630      	mov	r0, r6
 80587a0:	69e1      	ldr	r1, [r4, #28]
 80587a2:	47a8      	blx	r5
 80587a4:	1e05      	subs	r5, r0, #0
 80587a6:	dcb9      	bgt.n	805871c <__sfvwrite_r+0x1bc>
 80587a8:	e78c      	b.n	80586c4 <__sfvwrite_r+0x164>
 80587aa:	e9d7 ab00 	ldrd	sl, fp, [r7]
 80587ae:	2000      	movs	r0, #0
 80587b0:	3708      	adds	r7, #8
 80587b2:	e6f3      	b.n	805859c <__sfvwrite_r+0x3c>
 80587b4:	f10b 0901 	add.w	r9, fp, #1
 80587b8:	e700      	b.n	80585bc <__sfvwrite_r+0x5c>
 80587ba:	4293      	cmp	r3, r2
 80587bc:	dc08      	bgt.n	80587d0 <__sfvwrite_r+0x270>
 80587be:	6a65      	ldr	r5, [r4, #36]	; 0x24
 80587c0:	69e1      	ldr	r1, [r4, #28]
 80587c2:	4652      	mov	r2, sl
 80587c4:	4630      	mov	r0, r6
 80587c6:	47a8      	blx	r5
 80587c8:	1e05      	subs	r5, r0, #0
 80587ca:	f73f af13 	bgt.w	80585f4 <__sfvwrite_r+0x94>
 80587ce:	e779      	b.n	80586c4 <__sfvwrite_r+0x164>
 80587d0:	4651      	mov	r1, sl
 80587d2:	9201      	str	r2, [sp, #4]
 80587d4:	f000 f830 	bl	8058838 <memmove>
 80587d8:	9a01      	ldr	r2, [sp, #4]
 80587da:	68a3      	ldr	r3, [r4, #8]
 80587dc:	1a9b      	subs	r3, r3, r2
 80587de:	60a3      	str	r3, [r4, #8]
 80587e0:	6823      	ldr	r3, [r4, #0]
 80587e2:	4413      	add	r3, r2
 80587e4:	6023      	str	r3, [r4, #0]
 80587e6:	4615      	mov	r5, r2
 80587e8:	e704      	b.n	80585f4 <__sfvwrite_r+0x94>
 80587ea:	2001      	movs	r0, #1
 80587ec:	e70c      	b.n	8058608 <__sfvwrite_r+0xa8>
 80587ee:	bf00      	nop
 80587f0:	7ffffc00 	.word	0x7ffffc00

080587f4 <_isatty_r>:
 80587f4:	b538      	push	{r3, r4, r5, lr}
 80587f6:	4d06      	ldr	r5, [pc, #24]	; (8058810 <_isatty_r+0x1c>)
 80587f8:	2300      	movs	r3, #0
 80587fa:	4604      	mov	r4, r0
 80587fc:	4608      	mov	r0, r1
 80587fe:	602b      	str	r3, [r5, #0]
 8058800:	f7f7 ff44 	bl	805068c <_isatty>
 8058804:	1c43      	adds	r3, r0, #1
 8058806:	d102      	bne.n	805880e <_isatty_r+0x1a>
 8058808:	682b      	ldr	r3, [r5, #0]
 805880a:	b103      	cbz	r3, 805880e <_isatty_r+0x1a>
 805880c:	6023      	str	r3, [r4, #0]
 805880e:	bd38      	pop	{r3, r4, r5, pc}
 8058810:	200100a8 	.word	0x200100a8

08058814 <_lseek_r>:
 8058814:	b538      	push	{r3, r4, r5, lr}
 8058816:	4d07      	ldr	r5, [pc, #28]	; (8058834 <_lseek_r+0x20>)
 8058818:	4604      	mov	r4, r0
 805881a:	4608      	mov	r0, r1
 805881c:	4611      	mov	r1, r2
 805881e:	2200      	movs	r2, #0
 8058820:	602a      	str	r2, [r5, #0]
 8058822:	461a      	mov	r2, r3
 8058824:	f7f7 ff34 	bl	8050690 <_lseek>
 8058828:	1c43      	adds	r3, r0, #1
 805882a:	d102      	bne.n	8058832 <_lseek_r+0x1e>
 805882c:	682b      	ldr	r3, [r5, #0]
 805882e:	b103      	cbz	r3, 8058832 <_lseek_r+0x1e>
 8058830:	6023      	str	r3, [r4, #0]
 8058832:	bd38      	pop	{r3, r4, r5, pc}
 8058834:	200100a8 	.word	0x200100a8

08058838 <memmove>:
 8058838:	4288      	cmp	r0, r1
 805883a:	b510      	push	{r4, lr}
 805883c:	eb01 0402 	add.w	r4, r1, r2
 8058840:	d902      	bls.n	8058848 <memmove+0x10>
 8058842:	4284      	cmp	r4, r0
 8058844:	4623      	mov	r3, r4
 8058846:	d807      	bhi.n	8058858 <memmove+0x20>
 8058848:	1e43      	subs	r3, r0, #1
 805884a:	42a1      	cmp	r1, r4
 805884c:	d008      	beq.n	8058860 <memmove+0x28>
 805884e:	f811 2b01 	ldrb.w	r2, [r1], #1
 8058852:	f803 2f01 	strb.w	r2, [r3, #1]!
 8058856:	e7f8      	b.n	805884a <memmove+0x12>
 8058858:	4402      	add	r2, r0
 805885a:	4601      	mov	r1, r0
 805885c:	428a      	cmp	r2, r1
 805885e:	d100      	bne.n	8058862 <memmove+0x2a>
 8058860:	bd10      	pop	{r4, pc}
 8058862:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
 8058866:	f802 4d01 	strb.w	r4, [r2, #-1]!
 805886a:	e7f7      	b.n	805885c <memmove+0x24>

0805886c <_read_r>:
 805886c:	b538      	push	{r3, r4, r5, lr}
 805886e:	4d07      	ldr	r5, [pc, #28]	; (805888c <_read_r+0x20>)
 8058870:	4604      	mov	r4, r0
 8058872:	4608      	mov	r0, r1
 8058874:	4611      	mov	r1, r2
 8058876:	2200      	movs	r2, #0
 8058878:	602a      	str	r2, [r5, #0]
 805887a:	461a      	mov	r2, r3
 805887c:	f7f7 fec2 	bl	8050604 <_read>
 8058880:	1c43      	adds	r3, r0, #1
 8058882:	d102      	bne.n	805888a <_read_r+0x1e>
 8058884:	682b      	ldr	r3, [r5, #0]
 8058886:	b103      	cbz	r3, 805888a <_read_r+0x1e>
 8058888:	6023      	str	r3, [r4, #0]
 805888a:	bd38      	pop	{r3, r4, r5, pc}
 805888c:	200100a8 	.word	0x200100a8

08058890 <_realloc_r>:
 8058890:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8058894:	4681      	mov	r9, r0
 8058896:	460c      	mov	r4, r1
 8058898:	b929      	cbnz	r1, 80588a6 <_realloc_r+0x16>
 805889a:	4611      	mov	r1, r2
 805889c:	b003      	add	sp, #12
 805889e:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80588a2:	f7f8 be5f 	b.w	8051564 <_malloc_r>
 80588a6:	9201      	str	r2, [sp, #4]
 80588a8:	f7f9 f8c2 	bl	8051a30 <__malloc_lock>
 80588ac:	9a01      	ldr	r2, [sp, #4]
 80588ae:	f102 080b 	add.w	r8, r2, #11
 80588b2:	f1b8 0f16 	cmp.w	r8, #22
 80588b6:	d90b      	bls.n	80588d0 <_realloc_r+0x40>
 80588b8:	f038 0807 	bics.w	r8, r8, #7
 80588bc:	d50a      	bpl.n	80588d4 <_realloc_r+0x44>
 80588be:	230c      	movs	r3, #12
 80588c0:	f8c9 3000 	str.w	r3, [r9]
 80588c4:	f04f 0b00 	mov.w	fp, #0
 80588c8:	4658      	mov	r0, fp
 80588ca:	b003      	add	sp, #12
 80588cc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80588d0:	f04f 0810 	mov.w	r8, #16
 80588d4:	4590      	cmp	r8, r2
 80588d6:	d3f2      	bcc.n	80588be <_realloc_r+0x2e>
 80588d8:	f854 5c04 	ldr.w	r5, [r4, #-4]
 80588dc:	f025 0603 	bic.w	r6, r5, #3
 80588e0:	45b0      	cmp	r8, r6
 80588e2:	f1a4 0a08 	sub.w	sl, r4, #8
 80588e6:	f340 8170 	ble.w	8058bca <_realloc_r+0x33a>
 80588ea:	48a9      	ldr	r0, [pc, #676]	; (8058b90 <_realloc_r+0x300>)
 80588ec:	9001      	str	r0, [sp, #4]
 80588ee:	f8d0 c008 	ldr.w	ip, [r0, #8]
 80588f2:	eb0a 0306 	add.w	r3, sl, r6
 80588f6:	459c      	cmp	ip, r3
 80588f8:	6859      	ldr	r1, [r3, #4]
 80588fa:	d005      	beq.n	8058908 <_realloc_r+0x78>
 80588fc:	f021 0001 	bic.w	r0, r1, #1
 8058900:	4418      	add	r0, r3
 8058902:	6840      	ldr	r0, [r0, #4]
 8058904:	07c7      	lsls	r7, r0, #31
 8058906:	d427      	bmi.n	8058958 <_realloc_r+0xc8>
 8058908:	f021 0103 	bic.w	r1, r1, #3
 805890c:	459c      	cmp	ip, r3
 805890e:	eb06 0701 	add.w	r7, r6, r1
 8058912:	d119      	bne.n	8058948 <_realloc_r+0xb8>
 8058914:	f108 0010 	add.w	r0, r8, #16
 8058918:	42b8      	cmp	r0, r7
 805891a:	dc1f      	bgt.n	805895c <_realloc_r+0xcc>
 805891c:	eb0a 0308 	add.w	r3, sl, r8
 8058920:	9a01      	ldr	r2, [sp, #4]
 8058922:	eba7 0708 	sub.w	r7, r7, r8
 8058926:	f047 0701 	orr.w	r7, r7, #1
 805892a:	6093      	str	r3, [r2, #8]
 805892c:	605f      	str	r7, [r3, #4]
 805892e:	f854 3c04 	ldr.w	r3, [r4, #-4]
 8058932:	f003 0301 	and.w	r3, r3, #1
 8058936:	ea43 0308 	orr.w	r3, r3, r8
 805893a:	f844 3c04 	str.w	r3, [r4, #-4]
 805893e:	4648      	mov	r0, r9
 8058940:	f7f9 f87c 	bl	8051a3c <__malloc_unlock>
 8058944:	46a3      	mov	fp, r4
 8058946:	e7bf      	b.n	80588c8 <_realloc_r+0x38>
 8058948:	45b8      	cmp	r8, r7
 805894a:	dc07      	bgt.n	805895c <_realloc_r+0xcc>
 805894c:	e9d3 3202 	ldrd	r3, r2, [r3, #8]
 8058950:	60da      	str	r2, [r3, #12]
 8058952:	6093      	str	r3, [r2, #8]
 8058954:	4655      	mov	r5, sl
 8058956:	e07f      	b.n	8058a58 <_realloc_r+0x1c8>
 8058958:	2100      	movs	r1, #0
 805895a:	460b      	mov	r3, r1
 805895c:	07e8      	lsls	r0, r5, #31
 805895e:	f100 80e5 	bmi.w	8058b2c <_realloc_r+0x29c>
 8058962:	f854 5c08 	ldr.w	r5, [r4, #-8]
 8058966:	ebaa 0505 	sub.w	r5, sl, r5
 805896a:	6868      	ldr	r0, [r5, #4]
 805896c:	f020 0003 	bic.w	r0, r0, #3
 8058970:	eb00 0b06 	add.w	fp, r0, r6
 8058974:	2b00      	cmp	r3, #0
 8058976:	f000 80a5 	beq.w	8058ac4 <_realloc_r+0x234>
 805897a:	459c      	cmp	ip, r3
 805897c:	eb01 070b 	add.w	r7, r1, fp
 8058980:	d14a      	bne.n	8058a18 <_realloc_r+0x188>
 8058982:	f108 0310 	add.w	r3, r8, #16
 8058986:	42bb      	cmp	r3, r7
 8058988:	f300 809c 	bgt.w	8058ac4 <_realloc_r+0x234>
 805898c:	46ab      	mov	fp, r5
 805898e:	68eb      	ldr	r3, [r5, #12]
 8058990:	f85b 2f08 	ldr.w	r2, [fp, #8]!
 8058994:	60d3      	str	r3, [r2, #12]
 8058996:	609a      	str	r2, [r3, #8]
 8058998:	1f32      	subs	r2, r6, #4
 805899a:	2a24      	cmp	r2, #36	; 0x24
 805899c:	d837      	bhi.n	8058a0e <_realloc_r+0x17e>
 805899e:	2a13      	cmp	r2, #19
 80589a0:	d933      	bls.n	8058a0a <_realloc_r+0x17a>
 80589a2:	6823      	ldr	r3, [r4, #0]
 80589a4:	60ab      	str	r3, [r5, #8]
 80589a6:	6863      	ldr	r3, [r4, #4]
 80589a8:	60eb      	str	r3, [r5, #12]
 80589aa:	2a1b      	cmp	r2, #27
 80589ac:	d81b      	bhi.n	80589e6 <_realloc_r+0x156>
 80589ae:	3408      	adds	r4, #8
 80589b0:	f105 0310 	add.w	r3, r5, #16
 80589b4:	6822      	ldr	r2, [r4, #0]
 80589b6:	601a      	str	r2, [r3, #0]
 80589b8:	6862      	ldr	r2, [r4, #4]
 80589ba:	605a      	str	r2, [r3, #4]
 80589bc:	68a2      	ldr	r2, [r4, #8]
 80589be:	609a      	str	r2, [r3, #8]
 80589c0:	eb05 0308 	add.w	r3, r5, r8
 80589c4:	9a01      	ldr	r2, [sp, #4]
 80589c6:	eba7 0708 	sub.w	r7, r7, r8
 80589ca:	f047 0701 	orr.w	r7, r7, #1
 80589ce:	6093      	str	r3, [r2, #8]
 80589d0:	605f      	str	r7, [r3, #4]
 80589d2:	686b      	ldr	r3, [r5, #4]
 80589d4:	f003 0301 	and.w	r3, r3, #1
 80589d8:	ea43 0308 	orr.w	r3, r3, r8
 80589dc:	606b      	str	r3, [r5, #4]
 80589de:	4648      	mov	r0, r9
 80589e0:	f7f9 f82c 	bl	8051a3c <__malloc_unlock>
 80589e4:	e770      	b.n	80588c8 <_realloc_r+0x38>
 80589e6:	68a3      	ldr	r3, [r4, #8]
 80589e8:	612b      	str	r3, [r5, #16]
 80589ea:	68e3      	ldr	r3, [r4, #12]
 80589ec:	616b      	str	r3, [r5, #20]
 80589ee:	2a24      	cmp	r2, #36	; 0x24
 80589f0:	bf01      	itttt	eq
 80589f2:	6923      	ldreq	r3, [r4, #16]
 80589f4:	61ab      	streq	r3, [r5, #24]
 80589f6:	6962      	ldreq	r2, [r4, #20]
 80589f8:	61ea      	streq	r2, [r5, #28]
 80589fa:	bf19      	ittee	ne
 80589fc:	3410      	addne	r4, #16
 80589fe:	f105 0318 	addne.w	r3, r5, #24
 8058a02:	f105 0320 	addeq.w	r3, r5, #32
 8058a06:	3418      	addeq	r4, #24
 8058a08:	e7d4      	b.n	80589b4 <_realloc_r+0x124>
 8058a0a:	465b      	mov	r3, fp
 8058a0c:	e7d2      	b.n	80589b4 <_realloc_r+0x124>
 8058a0e:	4621      	mov	r1, r4
 8058a10:	4658      	mov	r0, fp
 8058a12:	f7ff ff11 	bl	8058838 <memmove>
 8058a16:	e7d3      	b.n	80589c0 <_realloc_r+0x130>
 8058a18:	45b8      	cmp	r8, r7
 8058a1a:	dc53      	bgt.n	8058ac4 <_realloc_r+0x234>
 8058a1c:	e9d3 3202 	ldrd	r3, r2, [r3, #8]
 8058a20:	4628      	mov	r0, r5
 8058a22:	60da      	str	r2, [r3, #12]
 8058a24:	6093      	str	r3, [r2, #8]
 8058a26:	f850 2f08 	ldr.w	r2, [r0, #8]!
 8058a2a:	68eb      	ldr	r3, [r5, #12]
 8058a2c:	60d3      	str	r3, [r2, #12]
 8058a2e:	609a      	str	r2, [r3, #8]
 8058a30:	1f32      	subs	r2, r6, #4
 8058a32:	2a24      	cmp	r2, #36	; 0x24
 8058a34:	d842      	bhi.n	8058abc <_realloc_r+0x22c>
 8058a36:	2a13      	cmp	r2, #19
 8058a38:	d908      	bls.n	8058a4c <_realloc_r+0x1bc>
 8058a3a:	6823      	ldr	r3, [r4, #0]
 8058a3c:	60ab      	str	r3, [r5, #8]
 8058a3e:	6863      	ldr	r3, [r4, #4]
 8058a40:	60eb      	str	r3, [r5, #12]
 8058a42:	2a1b      	cmp	r2, #27
 8058a44:	d828      	bhi.n	8058a98 <_realloc_r+0x208>
 8058a46:	3408      	adds	r4, #8
 8058a48:	f105 0010 	add.w	r0, r5, #16
 8058a4c:	6823      	ldr	r3, [r4, #0]
 8058a4e:	6003      	str	r3, [r0, #0]
 8058a50:	6863      	ldr	r3, [r4, #4]
 8058a52:	6043      	str	r3, [r0, #4]
 8058a54:	68a3      	ldr	r3, [r4, #8]
 8058a56:	6083      	str	r3, [r0, #8]
 8058a58:	686a      	ldr	r2, [r5, #4]
 8058a5a:	eba7 0008 	sub.w	r0, r7, r8
 8058a5e:	280f      	cmp	r0, #15
 8058a60:	f002 0201 	and.w	r2, r2, #1
 8058a64:	eb05 0307 	add.w	r3, r5, r7
 8058a68:	f240 80b1 	bls.w	8058bce <_realloc_r+0x33e>
 8058a6c:	eb05 0108 	add.w	r1, r5, r8
 8058a70:	ea48 0202 	orr.w	r2, r8, r2
 8058a74:	f040 0001 	orr.w	r0, r0, #1
 8058a78:	606a      	str	r2, [r5, #4]
 8058a7a:	6048      	str	r0, [r1, #4]
 8058a7c:	685a      	ldr	r2, [r3, #4]
 8058a7e:	f042 0201 	orr.w	r2, r2, #1
 8058a82:	605a      	str	r2, [r3, #4]
 8058a84:	3108      	adds	r1, #8
 8058a86:	4648      	mov	r0, r9
 8058a88:	f7fd fc72 	bl	8056370 <_free_r>
 8058a8c:	4648      	mov	r0, r9
 8058a8e:	f7f8 ffd5 	bl	8051a3c <__malloc_unlock>
 8058a92:	f105 0b08 	add.w	fp, r5, #8
 8058a96:	e717      	b.n	80588c8 <_realloc_r+0x38>
 8058a98:	68a3      	ldr	r3, [r4, #8]
 8058a9a:	612b      	str	r3, [r5, #16]
 8058a9c:	68e3      	ldr	r3, [r4, #12]
 8058a9e:	616b      	str	r3, [r5, #20]
 8058aa0:	2a24      	cmp	r2, #36	; 0x24
 8058aa2:	bf01      	itttt	eq
 8058aa4:	6923      	ldreq	r3, [r4, #16]
 8058aa6:	61ab      	streq	r3, [r5, #24]
 8058aa8:	6963      	ldreq	r3, [r4, #20]
 8058aaa:	61eb      	streq	r3, [r5, #28]
 8058aac:	bf19      	ittee	ne
 8058aae:	3410      	addne	r4, #16
 8058ab0:	f105 0018 	addne.w	r0, r5, #24
 8058ab4:	f105 0020 	addeq.w	r0, r5, #32
 8058ab8:	3418      	addeq	r4, #24
 8058aba:	e7c7      	b.n	8058a4c <_realloc_r+0x1bc>
 8058abc:	4621      	mov	r1, r4
 8058abe:	f7ff febb 	bl	8058838 <memmove>
 8058ac2:	e7c9      	b.n	8058a58 <_realloc_r+0x1c8>
 8058ac4:	45d8      	cmp	r8, fp
 8058ac6:	dc31      	bgt.n	8058b2c <_realloc_r+0x29c>
 8058ac8:	4628      	mov	r0, r5
 8058aca:	68eb      	ldr	r3, [r5, #12]
 8058acc:	f850 2f08 	ldr.w	r2, [r0, #8]!
 8058ad0:	60d3      	str	r3, [r2, #12]
 8058ad2:	609a      	str	r2, [r3, #8]
 8058ad4:	1f32      	subs	r2, r6, #4
 8058ad6:	2a24      	cmp	r2, #36	; 0x24
 8058ad8:	d824      	bhi.n	8058b24 <_realloc_r+0x294>
 8058ada:	2a13      	cmp	r2, #19
 8058adc:	d908      	bls.n	8058af0 <_realloc_r+0x260>
 8058ade:	6823      	ldr	r3, [r4, #0]
 8058ae0:	60ab      	str	r3, [r5, #8]
 8058ae2:	6863      	ldr	r3, [r4, #4]
 8058ae4:	60eb      	str	r3, [r5, #12]
 8058ae6:	2a1b      	cmp	r2, #27
 8058ae8:	d80a      	bhi.n	8058b00 <_realloc_r+0x270>
 8058aea:	3408      	adds	r4, #8
 8058aec:	f105 0010 	add.w	r0, r5, #16
 8058af0:	6823      	ldr	r3, [r4, #0]
 8058af2:	6003      	str	r3, [r0, #0]
 8058af4:	6863      	ldr	r3, [r4, #4]
 8058af6:	6043      	str	r3, [r0, #4]
 8058af8:	68a3      	ldr	r3, [r4, #8]
 8058afa:	6083      	str	r3, [r0, #8]
 8058afc:	465f      	mov	r7, fp
 8058afe:	e7ab      	b.n	8058a58 <_realloc_r+0x1c8>
 8058b00:	68a3      	ldr	r3, [r4, #8]
 8058b02:	612b      	str	r3, [r5, #16]
 8058b04:	68e3      	ldr	r3, [r4, #12]
 8058b06:	616b      	str	r3, [r5, #20]
 8058b08:	2a24      	cmp	r2, #36	; 0x24
 8058b0a:	bf01      	itttt	eq
 8058b0c:	6923      	ldreq	r3, [r4, #16]
 8058b0e:	61ab      	streq	r3, [r5, #24]
 8058b10:	6963      	ldreq	r3, [r4, #20]
 8058b12:	61eb      	streq	r3, [r5, #28]
 8058b14:	bf19      	ittee	ne
 8058b16:	3410      	addne	r4, #16
 8058b18:	f105 0018 	addne.w	r0, r5, #24
 8058b1c:	f105 0020 	addeq.w	r0, r5, #32
 8058b20:	3418      	addeq	r4, #24
 8058b22:	e7e5      	b.n	8058af0 <_realloc_r+0x260>
 8058b24:	4621      	mov	r1, r4
 8058b26:	f7ff fe87 	bl	8058838 <memmove>
 8058b2a:	e7e7      	b.n	8058afc <_realloc_r+0x26c>
 8058b2c:	4611      	mov	r1, r2
 8058b2e:	4648      	mov	r0, r9
 8058b30:	f7f8 fd18 	bl	8051564 <_malloc_r>
 8058b34:	4683      	mov	fp, r0
 8058b36:	2800      	cmp	r0, #0
 8058b38:	f43f af51 	beq.w	80589de <_realloc_r+0x14e>
 8058b3c:	f854 3c04 	ldr.w	r3, [r4, #-4]
 8058b40:	f023 0301 	bic.w	r3, r3, #1
 8058b44:	4453      	add	r3, sl
 8058b46:	f1a0 0208 	sub.w	r2, r0, #8
 8058b4a:	4293      	cmp	r3, r2
 8058b4c:	d105      	bne.n	8058b5a <_realloc_r+0x2ca>
 8058b4e:	f850 7c04 	ldr.w	r7, [r0, #-4]
 8058b52:	f027 0703 	bic.w	r7, r7, #3
 8058b56:	4437      	add	r7, r6
 8058b58:	e6fc      	b.n	8058954 <_realloc_r+0xc4>
 8058b5a:	1f32      	subs	r2, r6, #4
 8058b5c:	2a24      	cmp	r2, #36	; 0x24
 8058b5e:	d830      	bhi.n	8058bc2 <_realloc_r+0x332>
 8058b60:	2a13      	cmp	r2, #19
 8058b62:	d92b      	bls.n	8058bbc <_realloc_r+0x32c>
 8058b64:	6823      	ldr	r3, [r4, #0]
 8058b66:	6003      	str	r3, [r0, #0]
 8058b68:	6863      	ldr	r3, [r4, #4]
 8058b6a:	6043      	str	r3, [r0, #4]
 8058b6c:	2a1b      	cmp	r2, #27
 8058b6e:	d811      	bhi.n	8058b94 <_realloc_r+0x304>
 8058b70:	f104 0208 	add.w	r2, r4, #8
 8058b74:	f100 0308 	add.w	r3, r0, #8
 8058b78:	6811      	ldr	r1, [r2, #0]
 8058b7a:	6019      	str	r1, [r3, #0]
 8058b7c:	6851      	ldr	r1, [r2, #4]
 8058b7e:	6059      	str	r1, [r3, #4]
 8058b80:	6892      	ldr	r2, [r2, #8]
 8058b82:	609a      	str	r2, [r3, #8]
 8058b84:	4621      	mov	r1, r4
 8058b86:	4648      	mov	r0, r9
 8058b88:	f7fd fbf2 	bl	8056370 <_free_r>
 8058b8c:	e727      	b.n	80589de <_realloc_r+0x14e>
 8058b8e:	bf00      	nop
 8058b90:	20003b00 	.word	0x20003b00
 8058b94:	68a3      	ldr	r3, [r4, #8]
 8058b96:	6083      	str	r3, [r0, #8]
 8058b98:	68e3      	ldr	r3, [r4, #12]
 8058b9a:	60c3      	str	r3, [r0, #12]
 8058b9c:	2a24      	cmp	r2, #36	; 0x24
 8058b9e:	bf01      	itttt	eq
 8058ba0:	6923      	ldreq	r3, [r4, #16]
 8058ba2:	6103      	streq	r3, [r0, #16]
 8058ba4:	6961      	ldreq	r1, [r4, #20]
 8058ba6:	6141      	streq	r1, [r0, #20]
 8058ba8:	bf19      	ittee	ne
 8058baa:	f104 0210 	addne.w	r2, r4, #16
 8058bae:	f100 0310 	addne.w	r3, r0, #16
 8058bb2:	f104 0218 	addeq.w	r2, r4, #24
 8058bb6:	f100 0318 	addeq.w	r3, r0, #24
 8058bba:	e7dd      	b.n	8058b78 <_realloc_r+0x2e8>
 8058bbc:	4603      	mov	r3, r0
 8058bbe:	4622      	mov	r2, r4
 8058bc0:	e7da      	b.n	8058b78 <_realloc_r+0x2e8>
 8058bc2:	4621      	mov	r1, r4
 8058bc4:	f7ff fe38 	bl	8058838 <memmove>
 8058bc8:	e7dc      	b.n	8058b84 <_realloc_r+0x2f4>
 8058bca:	4637      	mov	r7, r6
 8058bcc:	e6c2      	b.n	8058954 <_realloc_r+0xc4>
 8058bce:	4317      	orrs	r7, r2
 8058bd0:	606f      	str	r7, [r5, #4]
 8058bd2:	685a      	ldr	r2, [r3, #4]
 8058bd4:	f042 0201 	orr.w	r2, r2, #1
 8058bd8:	605a      	str	r2, [r3, #4]
 8058bda:	e757      	b.n	8058a8c <_realloc_r+0x1fc>

08058bdc <__swbuf_r>:
 8058bdc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8058bde:	460e      	mov	r6, r1
 8058be0:	4614      	mov	r4, r2
 8058be2:	4605      	mov	r5, r0
 8058be4:	b118      	cbz	r0, 8058bee <__swbuf_r+0x12>
 8058be6:	6b83      	ldr	r3, [r0, #56]	; 0x38
 8058be8:	b90b      	cbnz	r3, 8058bee <__swbuf_r+0x12>
 8058bea:	f7fd fb31 	bl	8056250 <__sinit>
 8058bee:	69a3      	ldr	r3, [r4, #24]
 8058bf0:	60a3      	str	r3, [r4, #8]
 8058bf2:	89a3      	ldrh	r3, [r4, #12]
 8058bf4:	0719      	lsls	r1, r3, #28
 8058bf6:	d529      	bpl.n	8058c4c <__swbuf_r+0x70>
 8058bf8:	6923      	ldr	r3, [r4, #16]
 8058bfa:	b33b      	cbz	r3, 8058c4c <__swbuf_r+0x70>
 8058bfc:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8058c00:	b2f6      	uxtb	r6, r6
 8058c02:	049a      	lsls	r2, r3, #18
 8058c04:	4637      	mov	r7, r6
 8058c06:	d52a      	bpl.n	8058c5e <__swbuf_r+0x82>
 8058c08:	6823      	ldr	r3, [r4, #0]
 8058c0a:	6920      	ldr	r0, [r4, #16]
 8058c0c:	1a18      	subs	r0, r3, r0
 8058c0e:	6963      	ldr	r3, [r4, #20]
 8058c10:	4283      	cmp	r3, r0
 8058c12:	dc04      	bgt.n	8058c1e <__swbuf_r+0x42>
 8058c14:	4621      	mov	r1, r4
 8058c16:	4628      	mov	r0, r5
 8058c18:	f7fd faae 	bl	8056178 <_fflush_r>
 8058c1c:	b9e0      	cbnz	r0, 8058c58 <__swbuf_r+0x7c>
 8058c1e:	68a3      	ldr	r3, [r4, #8]
 8058c20:	3b01      	subs	r3, #1
 8058c22:	60a3      	str	r3, [r4, #8]
 8058c24:	6823      	ldr	r3, [r4, #0]
 8058c26:	1c5a      	adds	r2, r3, #1
 8058c28:	6022      	str	r2, [r4, #0]
 8058c2a:	701e      	strb	r6, [r3, #0]
 8058c2c:	6962      	ldr	r2, [r4, #20]
 8058c2e:	1c43      	adds	r3, r0, #1
 8058c30:	429a      	cmp	r2, r3
 8058c32:	d004      	beq.n	8058c3e <__swbuf_r+0x62>
 8058c34:	89a3      	ldrh	r3, [r4, #12]
 8058c36:	07db      	lsls	r3, r3, #31
 8058c38:	d506      	bpl.n	8058c48 <__swbuf_r+0x6c>
 8058c3a:	2e0a      	cmp	r6, #10
 8058c3c:	d104      	bne.n	8058c48 <__swbuf_r+0x6c>
 8058c3e:	4621      	mov	r1, r4
 8058c40:	4628      	mov	r0, r5
 8058c42:	f7fd fa99 	bl	8056178 <_fflush_r>
 8058c46:	b938      	cbnz	r0, 8058c58 <__swbuf_r+0x7c>
 8058c48:	4638      	mov	r0, r7
 8058c4a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8058c4c:	4621      	mov	r1, r4
 8058c4e:	4628      	mov	r0, r5
 8058c50:	f7fc fb34 	bl	80552bc <__swsetup_r>
 8058c54:	2800      	cmp	r0, #0
 8058c56:	d0d1      	beq.n	8058bfc <__swbuf_r+0x20>
 8058c58:	f04f 37ff 	mov.w	r7, #4294967295
 8058c5c:	e7f4      	b.n	8058c48 <__swbuf_r+0x6c>
 8058c5e:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8058c62:	81a3      	strh	r3, [r4, #12]
 8058c64:	6e63      	ldr	r3, [r4, #100]	; 0x64
 8058c66:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 8058c6a:	6663      	str	r3, [r4, #100]	; 0x64
 8058c6c:	e7cc      	b.n	8058c08 <__swbuf_r+0x2c>
	...

08058c70 <_wcrtomb_r>:
 8058c70:	b5f0      	push	{r4, r5, r6, r7, lr}
 8058c72:	4c09      	ldr	r4, [pc, #36]	; (8058c98 <_wcrtomb_r+0x28>)
 8058c74:	b085      	sub	sp, #20
 8058c76:	f8d4 70e0 	ldr.w	r7, [r4, #224]	; 0xe0
 8058c7a:	4605      	mov	r5, r0
 8058c7c:	461e      	mov	r6, r3
 8058c7e:	b909      	cbnz	r1, 8058c84 <_wcrtomb_r+0x14>
 8058c80:	460a      	mov	r2, r1
 8058c82:	a901      	add	r1, sp, #4
 8058c84:	47b8      	blx	r7
 8058c86:	1c43      	adds	r3, r0, #1
 8058c88:	bf01      	itttt	eq
 8058c8a:	2300      	moveq	r3, #0
 8058c8c:	6033      	streq	r3, [r6, #0]
 8058c8e:	238a      	moveq	r3, #138	; 0x8a
 8058c90:	602b      	streq	r3, [r5, #0]
 8058c92:	b005      	add	sp, #20
 8058c94:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8058c96:	bf00      	nop
 8058c98:	20003f18 	.word	0x20003f18

08058c9c <abort>:
 8058c9c:	b508      	push	{r3, lr}
 8058c9e:	2006      	movs	r0, #6
 8058ca0:	f000 f82c 	bl	8058cfc <raise>
 8058ca4:	2001      	movs	r0, #1
 8058ca6:	f7f7 fca7 	bl	80505f8 <_exit>

08058caa <_raise_r>:
 8058caa:	291f      	cmp	r1, #31
 8058cac:	b538      	push	{r3, r4, r5, lr}
 8058cae:	4604      	mov	r4, r0
 8058cb0:	460d      	mov	r5, r1
 8058cb2:	d904      	bls.n	8058cbe <_raise_r+0x14>
 8058cb4:	2316      	movs	r3, #22
 8058cb6:	6003      	str	r3, [r0, #0]
 8058cb8:	f04f 30ff 	mov.w	r0, #4294967295
 8058cbc:	bd38      	pop	{r3, r4, r5, pc}
 8058cbe:	f8d0 22dc 	ldr.w	r2, [r0, #732]	; 0x2dc
 8058cc2:	b112      	cbz	r2, 8058cca <_raise_r+0x20>
 8058cc4:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
 8058cc8:	b94b      	cbnz	r3, 8058cde <_raise_r+0x34>
 8058cca:	4620      	mov	r0, r4
 8058ccc:	f000 f830 	bl	8058d30 <_getpid_r>
 8058cd0:	462a      	mov	r2, r5
 8058cd2:	4601      	mov	r1, r0
 8058cd4:	4620      	mov	r0, r4
 8058cd6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 8058cda:	f000 b817 	b.w	8058d0c <_kill_r>
 8058cde:	2b01      	cmp	r3, #1
 8058ce0:	d00a      	beq.n	8058cf8 <_raise_r+0x4e>
 8058ce2:	1c59      	adds	r1, r3, #1
 8058ce4:	d103      	bne.n	8058cee <_raise_r+0x44>
 8058ce6:	2316      	movs	r3, #22
 8058ce8:	6003      	str	r3, [r0, #0]
 8058cea:	2001      	movs	r0, #1
 8058cec:	e7e6      	b.n	8058cbc <_raise_r+0x12>
 8058cee:	2400      	movs	r4, #0
 8058cf0:	f842 4025 	str.w	r4, [r2, r5, lsl #2]
 8058cf4:	4628      	mov	r0, r5
 8058cf6:	4798      	blx	r3
 8058cf8:	2000      	movs	r0, #0
 8058cfa:	e7df      	b.n	8058cbc <_raise_r+0x12>

08058cfc <raise>:
 8058cfc:	4b02      	ldr	r3, [pc, #8]	; (8058d08 <raise+0xc>)
 8058cfe:	4601      	mov	r1, r0
 8058d00:	6818      	ldr	r0, [r3, #0]
 8058d02:	f7ff bfd2 	b.w	8058caa <_raise_r>
 8058d06:	bf00      	nop
 8058d08:	200036d0 	.word	0x200036d0

08058d0c <_kill_r>:
 8058d0c:	b538      	push	{r3, r4, r5, lr}
 8058d0e:	4d07      	ldr	r5, [pc, #28]	; (8058d2c <_kill_r+0x20>)
 8058d10:	2300      	movs	r3, #0
 8058d12:	4604      	mov	r4, r0
 8058d14:	4608      	mov	r0, r1
 8058d16:	4611      	mov	r1, r2
 8058d18:	602b      	str	r3, [r5, #0]
 8058d1a:	f7f7 fc65 	bl	80505e8 <_kill>
 8058d1e:	1c43      	adds	r3, r0, #1
 8058d20:	d102      	bne.n	8058d28 <_kill_r+0x1c>
 8058d22:	682b      	ldr	r3, [r5, #0]
 8058d24:	b103      	cbz	r3, 8058d28 <_kill_r+0x1c>
 8058d26:	6023      	str	r3, [r4, #0]
 8058d28:	bd38      	pop	{r3, r4, r5, pc}
 8058d2a:	bf00      	nop
 8058d2c:	200100a8 	.word	0x200100a8

08058d30 <_getpid_r>:
 8058d30:	f7f7 bc58 	b.w	80505e4 <_getpid>

08058d34 <_init>:
 8058d34:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8058d36:	bf00      	nop
 8058d38:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8058d3a:	bc08      	pop	{r3}
 8058d3c:	469e      	mov	lr, r3
 8058d3e:	4770      	bx	lr

08058d40 <_fini>:
 8058d40:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8058d42:	bf00      	nop
 8058d44:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8058d46:	bc08      	pop	{r3}
 8058d48:	469e      	mov	lr, r3
 8058d4a:	4770      	bx	lr
